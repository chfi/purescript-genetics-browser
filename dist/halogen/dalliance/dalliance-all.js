(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bam.js: indexed binary alignments
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var bin = require('./bin');
    var readInt = bin.readInt;
    var readShort = bin.readShort;
    var readByte = bin.readByte;
    var readInt64 = bin.readInt64;
    var readFloat = bin.readFloat;

    var lh3utils = require('./lh3utils');
    var readVob = lh3utils.readVob;
    var unbgzf = lh3utils.unbgzf;
    var reg2bins = lh3utils.reg2bins;
    var Chunk = lh3utils.Chunk;
}

var BAM_MAGIC = 0x14d4142;
var BAI_MAGIC = 0x1494142;

var BamFlags = {
    MULTIPLE_SEGMENTS: 0x1,
    ALL_SEGMENTS_ALIGN: 0x2,
    SEGMENT_UNMAPPED: 0x4,
    NEXT_SEGMENT_UNMAPPED: 0x8,
    REVERSE_COMPLEMENT: 0x10,
    NEXT_REVERSE_COMPLEMENT: 0x20,
    FIRST_SEGMENT: 0x40,
    LAST_SEGMENT: 0x80,
    SECONDARY_ALIGNMENT: 0x100,
    QC_FAIL: 0x200,
    DUPLICATE: 0x400,
    SUPPLEMENTARY: 0x800
};

function BamFile() {}

// Calculate the length (in bytes) of the BAI ref starting at offset.
// Returns {nbin, length, minBlockIndex}
function _getBaiRefLength(uncba, offset) {
    var p = offset;
    var nbin = readInt(uncba, p);p += 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(uncba, p);
        var nchnk = readInt(uncba, p + 4);
        p += 8 + nchnk * 16;
    }
    var nintv = readInt(uncba, p);p += 4;

    var minBlockIndex = 1000000000;
    var q = p;
    for (var i = 0; i < nintv; ++i) {
        var v = readVob(uncba, q);q += 8;
        if (v) {
            var bi = v.block;
            if (v.offset > 0) bi += 65536;

            if (bi < minBlockIndex) minBlockIndex = bi;
            break;
        }
    }
    p += nintv * 8;

    return {
        minBlockIndex: minBlockIndex,
        nbin: nbin,
        length: p - offset
    };
}

function makeBam(data, bai, indexChunks, callback, attempted) {
    // Do an initial probe on the BAM file to catch any mixed-content errors.
    data.slice(0, 10).fetch(function (header) {
        if (header) {
            return makeBam2(data, bai, indexChunks, callback, attempted);
        } else {
            return callback(null, "Couldn't access BAM.");
        }
    }, { timeout: 5000 });
}

function makeBam2(data, bai, indexChunks, callback, attempted) {
    var bam = new BamFile();
    bam.data = data;
    bam.bai = bai;
    bam.indexChunks = indexChunks;

    var minBlockIndex = bam.indexChunks ? bam.indexChunks.minBlockIndex : 1000000000;

    // Fills out bam.chrToIndex and bam.indexToChr based on the first few bytes of the BAM.
    function parseBamHeader(r) {
        if (!r) {
            return callback(null, "Couldn't access BAM");
        }

        var unc = unbgzf(r, r.byteLength);
        var uncba = new Uint8Array(unc);

        var magic = readInt(uncba, 0);
        if (magic != BAM_MAGIC) {
            return callback(null, "Not a BAM file, magic=0x" + magic.toString(16));
        }
        var headLen = readInt(uncba, 4);
        var header = '';
        for (var i = 0; i < headLen; ++i) {
            header += String.fromCharCode(uncba[i + 8]);
        }

        var nRef = readInt(uncba, headLen + 8);
        var p = headLen + 12;

        bam.chrToIndex = {};
        bam.indexToChr = [];
        for (var i = 0; i < nRef; ++i) {
            var lName = readInt(uncba, p);
            var name = '';
            for (var j = 0; j < lName - 1; ++j) {
                name += String.fromCharCode(uncba[p + 4 + j]);
            }
            var lRef = readInt(uncba, p + lName + 4);
            bam.chrToIndex[name] = i;
            if (name.indexOf('chr') == 0) {
                bam.chrToIndex[name.substring(3)] = i;
            } else {
                bam.chrToIndex['chr' + name] = i;
            }
            bam.indexToChr.push(name);

            p = p + 8 + lName;
        }

        if (bam.indices) {
            return callback(bam);
        }
    }

    function parseBai(header) {
        if (!header) {
            return "Couldn't access BAI";
        }

        var uncba = new Uint8Array(header);
        var baiMagic = readInt(uncba, 0);
        if (baiMagic != BAI_MAGIC) {
            return callback(null, 'Not a BAI file, magic=0x' + baiMagic.toString(16));
        }

        var nref = readInt(uncba, 4);

        bam.indices = [];

        var p = 8;
        for (var ref = 0; ref < nref; ++ref) {
            var blockStart = p;
            var o = _getBaiRefLength(uncba, blockStart);
            p += o.length;

            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);

            var nbin = o.nbin;

            if (nbin > 0) {
                bam.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);
            }
        }

        return true;
    }

    if (!bam.indexChunks) {
        bam.bai.fetch(function (header) {
            // Do we really need to fetch the whole thing? :-(
            var result = parseBai(header);
            if (result !== true) {
                if (bam.bai.url && typeof attempted === "undefined") {
                    // Already attempted x.bam.bai not there so now trying x.bai
                    bam.bai.url = bam.data.url.replace(new RegExp('.bam$'), '.bai');

                    // True lets us know we are making a second attempt
                    makeBam2(data, bam.bai, indexChunks, callback, true);
                } else {
                    // We've attempted x.bam.bai & x.bai and nothing worked
                    callback(null, result);
                }
            } else {
                bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);
            }
        }); // Timeout on first request to catch Chrome mixed-content error.
    } else {
        var chunks = bam.indexChunks.chunks;
        bam.indices = [];
        for (var i = 0; i < chunks.length; i++) {
            bam.indices[i] = null; // To be filled out lazily as needed
        }
        bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);
    }
}

BamFile.prototype.blocksForRange = function (refId, min, max) {
    var index = this.indices[refId];
    if (!index) {
        return [];
    }

    var intBinsL = reg2bins(min, max);
    var intBins = [];
    for (var i = 0; i < intBinsL.length; ++i) {
        intBins[intBinsL[i]] = true;
    }
    var leafChunks = [],
        otherChunks = [];

    var nbin = readInt(index, 0);
    var p = 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(index, p);
        var nchnk = readInt(index, p + 4);
        //        dlog('bin=' + bin + '; nchnk=' + nchnk);
        p += 8;
        if (intBins[bin]) {
            for (var c = 0; c < nchnk; ++c) {
                var cs = readVob(index, p);
                var ce = readVob(index, p + 8);
                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));
                p += 16;
            }
        } else {
            p += nchnk * 16;
        }
    }
    // console.log('leafChunks = ' + JSON.stringify(leafChunks));
    // console.log('otherChunks = ' + JSON.stringify(otherChunks));

    var nintv = readInt(index, p);
    // console.log('nintv=' + nintv);
    var lowest = null;
    var minLin = Math.min(min >> 14, nintv - 1),
        maxLin = Math.min(max >> 14, nintv - 1);
    for (var i = minLin; i <= maxLin; ++i) {
        var lb = readVob(index, p + 4 + i * 8);
        if (!lb) {
            continue;
        }
        if (!lowest || lb.block < lowest.block || lb.block == lowest.block && lb.offset < lowest.offset) {
            lowest = lb;
        }
    }
    // console.log('Lowest LB = ' + lowest);

    var prunedOtherChunks = [];
    if (lowest != null) {
        for (var i = 0; i < otherChunks.length; ++i) {
            var chnk = otherChunks[i];
            if (chnk.maxv.block > lowest.block || chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset) {
                prunedOtherChunks.push(chnk);
            }
        }
    }
    // console.log('prunedOtherChunks = ' + JSON.stringify(prunedOtherChunks));
    otherChunks = prunedOtherChunks;

    var intChunks = [];
    for (var i = 0; i < otherChunks.length; ++i) {
        intChunks.push(otherChunks[i]);
    }
    for (var i = 0; i < leafChunks.length; ++i) {
        intChunks.push(leafChunks[i]);
    }

    intChunks.sort(function (c0, c1) {
        var dif = c0.minv.block - c1.minv.block;
        if (dif != 0) {
            return dif;
        } else {
            return c0.minv.offset - c1.minv.offset;
        }
    });
    var mergedChunks = [];
    if (intChunks.length > 0) {
        var cur = intChunks[0];
        for (var i = 1; i < intChunks.length; ++i) {
            var nc = intChunks[i];
            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) {
                    // no point splitting mid-block
                    cur = new Chunk(cur.minv, nc.maxv);
                } else {
                mergedChunks.push(cur);
                cur = nc;
            }
        }
        mergedChunks.push(cur);
    }
    // console.log('mergedChunks = ' + JSON.stringify(mergedChunks));

    return mergedChunks;
};

BamFile.prototype.fetch = function (chr, min, max, callback, opts) {
    var thisB = this;
    opts = opts || {};

    var chrId = this.chrToIndex[chr];
    var chunks;
    if (chrId === undefined) {
        chunks = [];
    } else {
        // Fetch this portion of the BAI if it hasn't been loaded yet.
        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {
            var start_stop = this.indexChunks.chunks[chrId];
            return this.bai.slice(start_stop[0], start_stop[1]).fetch(function (data) {
                var buffer = new Uint8Array(data);
                this.indices[chrId] = buffer;
                return this.fetch(chr, min, max, callback, opts);
            }.bind(this));
        }

        chunks = this.blocksForRange(chrId, min, max);
        if (!chunks) {
            callback(null, 'Error in index fetch');
        }
    }

    var records = [];
    var index = 0;
    var data;

    function tramp() {
        if (index >= chunks.length) {
            return callback(records);
        } else if (!data) {
            var c = chunks[index];
            var fetchMin = c.minv.block;
            var fetchMax = c.maxv.block + (1 << 16); // *sigh*
            // console.log('fetching ' + fetchMin + ':' + fetchMax);
            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function (r) {
                data = unbgzf(r, c.maxv.block - c.minv.block + 1);
                return tramp();
            });
        } else {
            var ba = new Uint8Array(data);
            var finished = thisB.readBamRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);
            data = null;
            ++index;
            if (finished) return callback(records);else return tramp();
        }
    }
    tramp();
};

var SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];
var CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];

function BamRecord() {}

BamFile.prototype.readBamRecords = function (ba, offset, sink, min, max, chrId, opts) {
    while (true) {
        var blockSize = readInt(ba, offset);
        var blockEnd = offset + blockSize + 4;
        if (blockEnd > ba.length) {
            return false;
        }

        var record = new BamRecord();

        var refID = readInt(ba, offset + 4);
        var pos = readInt(ba, offset + 8);

        var bmn = readInt(ba, offset + 12);
        var bin = (bmn & 0xffff0000) >> 16;
        var mq = (bmn & 0xff00) >> 8;
        var nl = bmn & 0xff;

        var flag_nc = readInt(ba, offset + 16);
        var flag = (flag_nc & 0xffff0000) >> 16;
        var nc = flag_nc & 0xffff;

        var lseq = readInt(ba, offset + 20);

        var nextRef = readInt(ba, offset + 24);
        var nextPos = readInt(ba, offset + 28);

        var tlen = readInt(ba, offset + 32);

        record.segment = this.indexToChr[refID];
        record.flag = flag;
        record.pos = pos;
        record.mq = mq;
        if (opts.light) record.seqLength = lseq;

        if (!opts.light || opts.includeName) {
            var readName = '';
            for (var j = 0; j < nl - 1; ++j) {
                readName += String.fromCharCode(ba[offset + 36 + j]);
            }
            record.readName = readName;
        }

        if (!opts.light) {
            if (nextRef >= 0) {
                record.nextSegment = this.indexToChr[nextRef];
                record.nextPos = nextPos;
            }

            var p = offset + 36 + nl;

            var cigar = '';
            for (var c = 0; c < nc; ++c) {
                var cigop = readInt(ba, p);
                cigar = cigar + (cigop >> 4) + CIGAR_DECODER[cigop & 0xf];
                p += 4;
            }
            record.cigar = cigar;

            var seq = '';
            var seqBytes = lseq + 1 >> 1;
            for (var j = 0; j < seqBytes; ++j) {
                var sb = ba[p + j];
                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];
                if (seq.length < lseq) seq += SEQRET_DECODER[sb & 0x0f];
            }
            p += seqBytes;
            record.seq = seq;

            var qseq = '';
            for (var j = 0; j < lseq; ++j) {
                qseq += String.fromCharCode(ba[p + j] + 33);
            }
            p += lseq;
            record.quals = qseq;

            while (p < blockEnd) {
                var tag = String.fromCharCode(ba[p], ba[p + 1]);
                var type = String.fromCharCode(ba[p + 2]);
                var value;

                if (type == 'A') {
                    value = String.fromCharCode(ba[p + 3]);
                    p += 4;
                } else if (type == 'i' || type == 'I') {
                    value = readInt(ba, p + 3);
                    p += 7;
                } else if (type == 'c' || type == 'C') {
                    value = ba[p + 3];
                    p += 4;
                } else if (type == 's' || type == 'S') {
                    value = readShort(ba, p + 3);
                    p += 5;
                } else if (type == 'f') {
                    value = readFloat(ba, p + 3);
                    p += 7;
                } else if (type == 'Z' || type == 'H') {
                    p += 3;
                    value = '';
                    for (;;) {
                        var cc = ba[p++];
                        if (cc == 0) {
                            break;
                        } else {
                            value += String.fromCharCode(cc);
                        }
                    }
                } else if (type == 'B') {
                    var atype = String.fromCharCode(ba[p + 3]);
                    var alen = readInt(ba, p + 4);
                    var elen;
                    var reader;
                    if (atype == 'i' || atype == 'I' || atype == 'f') {
                        elen = 4;
                        if (atype == 'f') reader = readFloat;else reader = readInt;
                    } else if (atype == 's' || atype == 'S') {
                        elen = 2;
                        reader = readShort;
                    } else if (atype == 'c' || atype == 'C') {
                        elen = 1;
                        reader = readByte;
                    } else {
                        throw 'Unknown array type ' + atype;
                    }

                    p += 8;
                    value = [];
                    for (var i = 0; i < alen; ++i) {
                        value.push(reader(ba, p));
                        p += elen;
                    }
                } else {
                    throw 'Unknown type ' + type;
                }
                record[tag] = value;
            }
        }

        if (!min || record.pos <= max && record.pos + lseq >= min) {
            if (chrId === undefined || refID == chrId) {
                sink.push(record);
            }
        }
        if (record.pos > max) {
            return true;
        }
        offset = blockEnd;
    }

    // Exits via top of loop.
};

if (typeof module !== 'undefined') {
    module.exports = {
        makeBam: makeBam,
        BAM_MAGIC: BAM_MAGIC,
        BAI_MAGIC: BAI_MAGIC,
        BamFlags: BamFlags
    };
}

},{"./bin":4,"./lh3utils":27,"./spans":43}],2:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// bedwig.js
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var sa = require('./sourceadapters');
    var dalliance_registerParserFactory = sa.registerParserFactory;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
}

function BedWigParser(type) {
    this.type = type;
}

BedWigParser.prototype.createSession = function (sink) {
    if (this.type == 'wig') return new WigParseSession(this, sink);else return new BedParseSession(this, sink);
};

var __KV_REGEXP = /([^=]+)=(.+)/;
var __SPACE_REGEXP = /\s/;
var BED_COLOR_REGEXP = new RegExp("^[0-9]+,[0-9]+,[0-9]+");

function BedParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
}

BedParseSession.prototype.parse = function (line) {
    var toks = line.split(__SPACE_REGEXP);
    if (toks.length < 3) return;

    var start = parseInt(toks[1]) + 1;
    var end = parseInt(toks[2]);

    var f = { segment: toks[0],
        min: start,
        max: end };

    if (toks.length > 3 && toks[3] !== '.') {
        f.label = toks[3];
    }

    if (toks.length > 4) {
        f.score = parseFloat(toks[4]);
    }

    if (toks.length > 5) {
        f.orientation = toks[5];
    }

    if (toks.length > 8) {
        var color = toks[8];
        if (BED_COLOR_REGEXP.test(color)) {
            f.itemRgb = 'rgb(' + color + ')';
        }
    }

    if (toks.length >= 12) {
        var thickStart = parseInt(toks[6]);
        var thickEnd = parseInt(toks[7]);
        var blockCount = parseInt(toks[9]);
        var blockSizes = toks[10].split(',').map(function (x) {
            return parseInt(x);
        });
        var blockStarts = toks[11].split(',').map(function (x) {
            return parseInt(x);
        });

        f.type = 'transcript';
        var grp = new DASGroup();
        grp.id = toks[3];
        grp.type = 'transcript';
        grp.notes = [];
        f.groups = [grp];

        if (toks.length > 12) {
            var geneId = toks[12];
            var geneName = geneId;
            if (toks.length > 13) {
                geneName = toks[13];
            }
            var gg = new DASGroup();
            gg.id = geneId;
            gg.label = geneName;
            gg.type = 'gene';
            f.groups.push(gg);
        }

        var spans = null;
        for (var b = 0; b < blockCount; ++b) {
            var bmin = blockStarts[b] + start;
            var bmax = bmin + blockSizes[b];
            var span = new Range(bmin, bmax);
            if (spans) {
                spans = union(spans, span);
            } else {
                spans = span;
            }
        }

        var tsList = spans.ranges();
        for (var s = 0; s < tsList.length; ++s) {
            var ts = tsList[s];
            var bf = shallowCopy(f);
            bf.min = ts.min();
            bf.max = ts.max();
            this.sink(bf);
        }

        if (thickEnd > thickStart) {
            var codingRegion = f.orientation == '+' ? new Range(thickStart, thickEnd + 3) : new Range(thickStart - 3, thickEnd);
            // +/- 3 to account for stop codon

            var tl = intersection(spans, codingRegion);
            if (tl) {
                f.type = 'translation';
                var tlList = tl.ranges();
                var readingFrame = 0;
                for (var s = 0; s < tlList.length; ++s) {
                    // Record reading frame for every exon
                    var index = s;
                    if (f.orientation == '-') index = tlList.length - s - 1;
                    var ts = tlList[index];
                    var bf = shallowCopy(f);
                    bf.min = ts.min();
                    bf.max = ts.max();
                    f.readframe = readingFrame;
                    var length = ts.max() - ts.min();
                    readingFrame = (readingFrame + length) % 3;
                    this.sink(bf);
                }
            }
        }
    } else {
        this.sink(f);
    }
};

BedParseSession.prototype.flush = function () {};

function WigParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
    this.wigState = null;
}

WigParseSession.prototype.parse = function (line) {
    var toks = line.split(__SPACE_REGEXP);

    if (toks[0] == 'fixedStep') {
        this.wigState = 'fixedStep';
        this.chr = this.pos = this.step = null;
        this.span = 1;

        for (var ti = 1; ti < toks.length; ++ti) {
            var m = __KV_REGEXP.exec(toks[ti]);
            if (m) {
                if (m[1] == 'chrom') {
                    this.chr = m[2];
                } else if (m[1] == 'start') {
                    this.pos = parseInt(m[2]);
                } else if (m[1] == 'step') {
                    this.step = parseInt(m[2]);
                } else if (m[1] == 'span') {
                    this.span = parseInt(m[2]);
                }
            }
        }
    } else if (toks[0] == 'variableStep') {
        this.wigState = 'variableStep';
        this.chr = null;
        this.span = 1;

        for (var ti = 1; ti < toks.length; ++ti) {
            var m = __KV_REGEXP.exec(toks[ti]);
            if (m[1] == 'chrom') {
                this.chr = m[2];
            } else if (m[1] == 'span') {
                this.span = parseInt(m[2]);
            }
        }
    } else {
        if (!this.wigState) {
            if (toks.length < 4) return;

            var f = { segment: toks[0],
                min: parseInt(toks[1]) + 1,
                max: parseInt(toks[2]),
                score: parseFloat(toks[3]) };

            this.sink(f);
        } else if (this.wigState == 'fixedStep') {
            if (toks.length != 1) return;
            var score = parseFloat(toks[0]);
            var f = { segment: this.chr, min: this.pos, max: this.pos + this.span - 1, score: score };
            this.pos += this.step;
            this.sink(f);
        } else if (this.wigState == 'variableStep') {
            if (toks.length != 2) return;
            var pos = parseInt(toks[0]);
            var score = parseFloat(toks[1]);
            var f = { segment: this.chr, min: pos, max: pos + this.span - 1, score: score };
            this.sink(f);
        }
    }
};

WigParseSession.prototype.flush = function () {};

BedWigParser.prototype.getStyleSheet = function (callback) {
    var thisB = this;
    var stylesheet = new DASStylesheet();

    if (this.type == 'wig') {
        var wigStyle = new DASStyle();
        wigStyle.glyph = 'HISTOGRAM';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
    } else {
        var wigStyle = new DASStyle();
        wigStyle.glyph = 'BOX';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = true;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'default' }, null, wigStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = 'BOX';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'red';
        wigStyle.HEIGHT = 10;
        wigStyle.BUMP = true;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'translation' }, null, wigStyle);

        var tsStyle = new DASStyle();
        tsStyle.glyph = 'BOX';
        tsStyle.FGCOLOR = 'black';
        tsStyle.BGCOLOR = 'white';
        tsStyle.HEIGHT = 10;
        tsStyle.ZINDEX = 10;
        tsStyle.BUMP = true;
        tsStyle.LABEL = true;
        stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'white';
        densStyle.COLOR2 = 'black';
        densStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'density' }, null, densStyle);
    }

    return callback(stylesheet);
};

dalliance_registerParserFactory('bed', function (t) {
    return new BedWigParser(t);
});
dalliance_registerParserFactory('wig', function (t) {
    return new BedWigParser(t);
});

},{"./das":11,"./sourceadapters":41,"./spans":43,"./utils":58}],3:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// bigwig.js: indexed binary WIG (and BED) files
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var das = require('./das');
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var bin = require('./bin');
    var readInt = bin.readInt;

    var jszlib = require('jszlib');
    var jszlib_inflate_buffer = jszlib.inflateBuffer;
    var arrayCopy = jszlib.arrayCopy;
}

var BIG_WIG_MAGIC = 0x888FFC26;
var BIG_WIG_MAGIC_BE = 0x26FC8F88;
var BIG_BED_MAGIC = 0x8789F2EB;
var BIG_BED_MAGIC_BE = 0xEBF28987;

var BIG_WIG_TYPE_GRAPH = 1;
var BIG_WIG_TYPE_VSTEP = 2;
var BIG_WIG_TYPE_FSTEP = 3;

var M1 = 256;
var M2 = 256 * 256;
var M3 = 256 * 256 * 256;
var M4 = 256 * 256 * 256 * 256;

var BED_COLOR_REGEXP = new RegExp("^[0-9]+,[0-9]+,[0-9]+");

function bwg_readOffset(ba, o) {
    var offset = ba[o] + ba[o + 1] * M1 + ba[o + 2] * M2 + ba[o + 3] * M3 + ba[o + 4] * M4;
    return offset;
}

function BigWig() {}

BigWig.prototype.readChromTree = function (callback) {
    var thisB = this;
    this.chromsToIDs = {};
    this.idsToChroms = {};
    this.maxID = 0;

    var udo = this.unzoomedDataOffset;
    var eb = udo - this.chromTreeOffset & 3;
    udo = udo + 4 - eb;

    this.data.slice(this.chromTreeOffset, udo - this.chromTreeOffset).fetch(function (bpt) {
        var ba = new Uint8Array(bpt);
        var sa = new Int16Array(bpt);
        var la = new Int32Array(bpt);
        var bptMagic = la[0];
        var blockSize = la[1];
        var keySize = la[2];
        var valSize = la[3];
        var itemCount = bwg_readOffset(ba, 16);
        var rootNodeOffset = 32;

        var bptReadNode = function bptReadNode(offset) {
            var nodeType = ba[offset];
            var cnt = sa[offset / 2 + 1];
            offset += 4;
            for (var n = 0; n < cnt; ++n) {
                if (nodeType == 0) {
                    offset += keySize;
                    var childOffset = bwg_readOffset(ba, offset);
                    offset += 8;
                    childOffset -= thisB.chromTreeOffset;
                    bptReadNode(childOffset);
                } else {
                    var key = '';
                    for (var ki = 0; ki < keySize; ++ki) {
                        var charCode = ba[offset++];
                        if (charCode != 0) {
                            key += String.fromCharCode(charCode);
                        }
                    }
                    var chromId = ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset + 0];
                    var chromSize = ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];
                    offset += 8;

                    thisB.chromsToIDs[key] = chromId;
                    if (key.indexOf('chr') == 0) {
                        thisB.chromsToIDs[key.substr(3)] = chromId;
                    }
                    thisB.idsToChroms[chromId] = key;
                    thisB.maxID = Math.max(thisB.maxID, chromId);
                }
            }
        };
        bptReadNode(rootNodeOffset);

        callback(thisB);
    });
};

function BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {
    this.bwg = bwg;
    this.cirTreeOffset = cirTreeOffset;
    this.cirTreeLength = cirTreeLength;
    this.isSummary = isSummary;
}

BigWigView.prototype.readWigData = function (chrName, min, max, callback) {
    var chr = this.bwg.chromsToIDs[chrName];
    if (chr === undefined) {
        // Not an error because some .bwgs won't have data for all chromosomes.
        return callback([]);
    } else {
        this.readWigDataById(chr, min, max, callback);
    }
};

BigWigView.prototype.readWigDataById = function (chr, min, max, callback) {
    var thisB = this;
    if (!this.cirHeader) {
        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function (result) {
            thisB.cirHeader = result;
            var la = new Int32Array(thisB.cirHeader);
            thisB.cirBlockSize = la[1];
            thisB.readWigDataById(chr, min, max, callback);
        });
        return;
    }

    var blocksToFetch = [];
    var outstanding = 0;

    var beforeBWG = Date.now();

    var filter = function filter(chromId, fmin, fmax, toks) {
        return (chr < 0 || chromId == chr) && fmin <= max && fmax >= min;
    };

    var cirFobRecur = function cirFobRecur(offset, level) {
        if (thisB.bwg.instrument) console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now() | 0));

        outstanding += offset.length;

        if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {
            cirFobRecur2(thisB.cachedCirRoot, 0, level);
            --outstanding;
            if (outstanding == 0) {
                thisB.fetchFeatures(filter, blocksToFetch, callback);
            }
            return;
        }

        var maxCirBlockSpan = 4 + thisB.cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.
        var spans;
        for (var i = 0; i < offset.length; ++i) {
            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans ? union(spans, blockSpan) : blockSpan;
        }

        var fetchRanges = spans.ranges();
        for (var r = 0; r < fetchRanges.length; ++r) {
            var fr = fetchRanges[r];
            cirFobStartFetch(offset, fr, level);
        }
    };

    var cirFobStartFetch = function cirFobStartFetch(offset, fr, level, attempts) {
        var length = fr.max() - fr.min();
        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function (resultBuffer) {
            for (var i = 0; i < offset.length; ++i) {
                if (fr.contains(offset[i])) {
                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);

                    if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() == 0) thisB.cachedCirRoot = resultBuffer;

                    --outstanding;
                    if (outstanding == 0) {
                        thisB.fetchFeatures(filter, blocksToFetch, callback);
                    }
                }
            }
        });
    };

    var cirFobRecur2 = function cirFobRecur2(cirBlockData, offset, level) {
        var ba = new Uint8Array(cirBlockData);
        var sa = new Int16Array(cirBlockData);
        var la = new Int32Array(cirBlockData);

        var isLeaf = ba[offset];
        var cnt = sa[offset / 2 + 1];
        offset += 4;

        if (isLeaf != 0) {
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset + 16);
                var blockSize = bwg_readOffset(ba, offset + 24);
                if ((chr < 0 || startChrom < chr || startChrom == chr && startBase <= max) && (chr < 0 || endChrom > chr || endChrom == chr && endBase >= min)) {
                    blocksToFetch.push({ offset: blockOffset, size: blockSize });
                }
                offset += 32;
            }
        } else {
            var recurOffsets = [];
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset + 16);
                if ((chr < 0 || startChrom < chr || startChrom == chr && startBase <= max) && (chr < 0 || endChrom > chr || endChrom == chr && endBase >= min)) {
                    recurOffsets.push(blockOffset);
                }
                offset += 24;
            }
            if (recurOffsets.length > 0) {
                cirFobRecur(recurOffsets, level + 1);
            }
        }
    };

    cirFobRecur([thisB.cirTreeOffset + 48], 1);
};

BigWigView.prototype.fetchFeatures = function (filter, blocksToFetch, callback) {
    var thisB = this;

    blocksToFetch.sort(function (b0, b1) {
        return (b0.offset | 0) - (b1.offset | 0);
    });

    if (blocksToFetch.length == 0) {
        callback([]);
    } else {
        var features = [];
        var createFeature = function createFeature(chr, fmin, fmax, opts) {
            if (!opts) {
                opts = {};
            }

            var f = new DASFeature();
            f._chromId = chr;
            f.segment = thisB.bwg.idsToChroms[chr];
            f.min = fmin;
            f.max = fmax;
            f.type = thisB.bwg.type;

            for (var k in opts) {
                f[k] = opts[k];
            }

            features.push(f);
        };

        var tramp = function tramp() {
            if (blocksToFetch.length == 0) {
                var afterBWG = Date.now();
                // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');
                callback(features);
                return; // just in case...
            } else {
                var block = blocksToFetch[0];
                if (block.data) {
                    thisB.parseFeatures(block.data, createFeature, filter);
                    blocksToFetch.splice(0, 1);
                    tramp();
                } else {
                    var fetchStart = block.offset;
                    var fetchSize = block.size;
                    var bi = 1;
                    while (bi < blocksToFetch.length && blocksToFetch[bi].offset == fetchStart + fetchSize) {
                        fetchSize += blocksToFetch[bi].size;
                        ++bi;
                    }

                    thisB.bwg.data.slice(fetchStart, fetchSize).fetch(function (result) {
                        var offset = 0;
                        var bi = 0;
                        while (offset < fetchSize) {
                            var fb = blocksToFetch[bi];

                            var data;
                            if (thisB.bwg.uncompressBufSize > 0) {
                                data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);
                            } else {
                                var tmp = new Uint8Array(fb.size); // FIXME is this really the best we can do?
                                arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);
                                data = tmp.buffer;
                            }
                            fb.data = data;

                            offset += fb.size;
                            ++bi;
                        }
                        tramp();
                    });
                }
            }
        };
        tramp();
    }
};

BigWigView.prototype.parseFeatures = function (data, createFeature, filter) {
    var ba = new Uint8Array(data);

    if (this.isSummary) {
        var sa = new Int16Array(data);
        var la = new Int32Array(data);
        var fa = new Float32Array(data);

        var itemCount = data.byteLength / 32;
        for (var i = 0; i < itemCount; ++i) {
            var chromId = la[i * 8];
            var start = la[i * 8 + 1];
            var end = la[i * 8 + 2];
            var validCnt = la[i * 8 + 3];
            var minVal = fa[i * 8 + 4];
            var maxVal = fa[i * 8 + 5];
            var sumData = fa[i * 8 + 6];
            var sumSqData = fa[i * 8 + 7];

            if (filter(chromId, start + 1, end)) {
                var summaryOpts = { type: 'bigwig', score: sumData / validCnt, maxScore: maxVal };
                if (this.bwg.type == 'bigbed') {
                    summaryOpts.type = 'density';
                }
                createFeature(chromId, start + 1, end, summaryOpts);
            }
        }
    } else if (this.bwg.type == 'bigwig') {
        var sa = new Int16Array(data);
        var la = new Int32Array(data);
        var fa = new Float32Array(data);

        var chromId = la[0];
        var blockStart = la[1];
        var blockEnd = la[2];
        var itemStep = la[3];
        var itemSpan = la[4];
        var blockType = ba[20];
        var itemCount = sa[11];

        if (blockType == BIG_WIG_TYPE_FSTEP) {
            for (var i = 0; i < itemCount; ++i) {
                var score = fa[i + 6];
                var fmin = blockStart + i * itemStep + 1,
                    fmax = blockStart + i * itemStep + itemSpan;
                if (filter(chromId, fmin, fmax)) createFeature(chromId, fmin, fmax, { score: score });
            }
        } else if (blockType == BIG_WIG_TYPE_VSTEP) {
            for (var i = 0; i < itemCount; ++i) {
                var start = la[i * 2 + 6] + 1;
                var end = start + itemSpan - 1;
                var score = fa[i * 2 + 7];
                if (filter(chromId, start, end)) createFeature(chromId, start, end, { score: score });
            }
        } else if (blockType == BIG_WIG_TYPE_GRAPH) {
            for (var i = 0; i < itemCount; ++i) {
                var start = la[i * 3 + 6] + 1;
                var end = la[i * 3 + 7];
                var score = fa[i * 3 + 8];
                if (start > end) {
                    start = end;
                }
                if (filter(chromId, start, end)) createFeature(chromId, start, end, { score: score });
            }
        } else {
            console.log('Currently not handling bwgType=' + blockType);
        }
    } else if (this.bwg.type == 'bigbed') {
        var offset = 0;
        var dfc = this.bwg.definedFieldCount;
        var schema = this.bwg.schema;

        while (offset < ba.length) {
            var chromId = ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset + 0];
            var start = ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];
            var end = ba[offset + 11] << 24 | ba[offset + 10] << 16 | ba[offset + 9] << 8 | ba[offset + 8];
            offset += 12;
            var rest = '';
            while (true) {
                var ch = ba[offset++];
                if (ch != 0) {
                    rest += String.fromCharCode(ch);
                } else {
                    break;
                }
            }

            var featureOpts = {};

            var bedColumns;
            if (rest.length > 0) {
                bedColumns = rest.split('\t');
            } else {
                bedColumns = [];
            }
            if (bedColumns.length > 0 && dfc > 3) {
                featureOpts.label = bedColumns[0];
            }
            if (bedColumns.length > 1 && dfc > 4) {
                var score = parseInt(bedColumns[1]);
                if (!isNaN(score)) featureOpts.score = score;
            }
            if (bedColumns.length > 2 && dfc > 5) {
                featureOpts.orientation = bedColumns[2];
            }
            if (bedColumns.length > 5 && dfc > 8) {
                var color = bedColumns[5];
                if (BED_COLOR_REGEXP.test(color)) {
                    featureOpts.itemRgb = 'rgb(' + color + ')';
                }
            }

            if (bedColumns.length > dfc - 3 && schema) {
                for (var col = dfc - 3; col < bedColumns.length; ++col) {
                    featureOpts[schema.fields[col + 3].name] = bedColumns[col];
                }
            }

            if (filter(chromId, start + 1, end, bedColumns)) {
                if (dfc < 12) {
                    createFeature(chromId, start + 1, end, featureOpts);
                } else {
                    var thickStart = bedColumns[3] | 0;
                    var thickEnd = bedColumns[4] | 0;
                    var blockCount = bedColumns[6] | 0;
                    var blockSizes = bedColumns[7].split(',');
                    var blockStarts = bedColumns[8].split(',');

                    if (featureOpts.exonFrames) {
                        var exonFrames = featureOpts.exonFrames.split(',');
                        featureOpts.exonFrames = undefined;
                    }

                    featureOpts.type = 'transcript';
                    var grp = new DASGroup();
                    for (var k in featureOpts) {
                        grp[k] = featureOpts[k];
                    }
                    grp.id = bedColumns[0];
                    grp.segment = this.bwg.idsToChroms[chromId];
                    grp.min = start + 1;
                    grp.max = end;
                    grp.notes = [];
                    featureOpts.groups = [grp];

                    // Moving towards using bigGenePred model, but will
                    // still support old Dalliance-style BED12+gene-name for the
                    // foreseeable future.
                    if (bedColumns.length > 9) {
                        var geneId = featureOpts.geneName || bedColumns[9];
                        var geneName = geneId;
                        if (bedColumns.length > 10) {
                            geneName = bedColumns[10];
                        }
                        if (featureOpts.geneName2) geneName = featureOpts.geneName2;

                        var gg = shallowCopy(grp);
                        gg.id = geneId;
                        gg.label = geneName;
                        gg.type = 'gene';
                        featureOpts.groups.push(gg);
                    }

                    var spanList = [];
                    for (var b = 0; b < blockCount; ++b) {
                        var bmin = (blockStarts[b] | 0) + start;
                        var bmax = bmin + (blockSizes[b] | 0);
                        var span = new Range(bmin, bmax);
                        spanList.push(span);
                    }
                    var spans = union(spanList);

                    var tsList = spans.ranges();
                    for (var s = 0; s < tsList.length; ++s) {
                        var ts = tsList[s];
                        createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);
                    }

                    if (thickEnd > thickStart) {
                        var codingRegion = featureOpts.orientation == '+' ? new Range(thickStart, thickEnd + 3) : new Range(thickStart - 3, thickEnd);
                        // +/- 3 to account for stop codon

                        var tl = intersection(spans, codingRegion);
                        if (tl) {
                            featureOpts.type = 'translation';
                            var tlList = tl.ranges();
                            var readingFrame = 0;

                            var tlOffset = 0;
                            while (tlList[0].min() > tsList[tlOffset].max()) {
                                tlOffset++;
                            }for (var s = 0; s < tlList.length; ++s) {
                                // Record reading frame for every exon
                                var index = s;
                                if (featureOpts.orientation == '-') index = tlList.length - s - 1;
                                var ts = tlList[index];
                                featureOpts.readframe = readingFrame;
                                if (exonFrames) {
                                    var brf = parseInt(exonFrames[index + tlOffset]);
                                    if (typeof brf === 'number' && brf >= 0 && brf <= 2) {
                                        featureOpts.readframe = brf;
                                        featureOpts.readframeExplicit = true;
                                    }
                                }
                                var length = ts.max() - ts.min();
                                readingFrame = (readingFrame + length) % 3;
                                createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);
                            }
                        }
                    }
                }
            }
        }
    } else {
        throw Error("Don't know what to do with " + this.bwg.type);
    }
};

//
// nasty cut/paste, should roll back in!
//

BigWigView.prototype.getFirstAdjacent = function (chrName, pos, dir, callback) {
    var chr = this.bwg.chromsToIDs[chrName];
    if (chr === undefined) {
        // Not an error because some .bwgs won't have data for all chromosomes.
        return callback([]);
    } else {
        this.getFirstAdjacentById(chr, pos, dir, callback);
    }
};

BigWigView.prototype.getFirstAdjacentById = function (chr, pos, dir, callback) {
    var thisB = this;
    if (!this.cirHeader) {
        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function (result) {
            thisB.cirHeader = result;
            var la = new Int32Array(thisB.cirHeader);
            thisB.cirBlockSize = la[1];
            thisB.getFirstAdjacentById(chr, pos, dir, callback);
        });
        return;
    }

    var blockToFetch = null;
    var bestBlockChr = -1;
    var bestBlockOffset = -1;

    var outstanding = 0;

    var beforeBWG = Date.now();

    var cirFobRecur = function cirFobRecur(offset, level) {
        outstanding += offset.length;

        var maxCirBlockSpan = 4 + thisB.cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.
        var spans;
        for (var i = 0; i < offset.length; ++i) {
            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans ? union(spans, blockSpan) : blockSpan;
        }

        var fetchRanges = spans.ranges();
        for (var r = 0; r < fetchRanges.length; ++r) {
            var fr = fetchRanges[r];
            cirFobStartFetch(offset, fr, level);
        }
    };

    var cirFobStartFetch = function cirFobStartFetch(offset, fr, level, attempts) {
        var length = fr.max() - fr.min();
        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function (resultBuffer) {
            for (var i = 0; i < offset.length; ++i) {
                if (fr.contains(offset[i])) {
                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);
                    --outstanding;
                    if (outstanding == 0) {
                        if (!blockToFetch) {
                            if (dir > 0 && (chr != 0 || pos > 0)) {
                                return thisB.getFirstAdjacentById(0, 0, dir, callback);
                            } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {
                                return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);
                            }
                            return callback([]);
                        }

                        thisB.fetchFeatures(function (chrx, fmin, fmax, toks) {
                            return dir < 0 && (chrx < chr || fmax < pos) || dir > 0 && (chrx > chr || fmin > pos);
                        }, [blockToFetch], function (features) {
                            var bestFeature = null;
                            var bestChr = -1;
                            var bestPos = -1;
                            for (var fi = 0; fi < features.length; ++fi) {
                                var f = features[fi];
                                var chrx = f._chromId,
                                    fmin = f.min,
                                    fmax = f.max;
                                if (bestFeature == null || dir < 0 && (chrx > bestChr || fmax > bestPos) || dir > 0 && (chrx < bestChr || fmin < bestPos)) {
                                    bestFeature = f;
                                    bestPos = dir < 0 ? fmax : fmin;
                                    bestChr = chrx;
                                }
                            }

                            if (bestFeature != null) return callback([bestFeature]);else return callback([]);
                        });
                    }
                }
            }
        });
    };

    var cirFobRecur2 = function cirFobRecur2(cirBlockData, offset, level) {
        var ba = new Uint8Array(cirBlockData);
        var sa = new Int16Array(cirBlockData);
        var la = new Int32Array(cirBlockData);

        var isLeaf = ba[offset];
        var cnt = sa[offset / 2 + 1];
        offset += 4;

        if (isLeaf != 0) {
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset + 16);
                var blockSize = bwg_readOffset(ba, offset + 24);
                if (dir < 0 && (startChrom < chr || startChrom == chr && startBase <= pos) || dir > 0 && (endChrom > chr || endChrom == chr && endBase >= pos)) {
                    // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);
                    if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {
                        // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);
                    } else if (blockToFetch == null || dir < 0 && (endChrom > bestBlockChr || endChrom == bestBlockChr && endBase > bestBlockOffset) || dir > 0 && (startChrom < bestBlockChr || startChrom == bestBlockChr && startBase < bestBlockOffset)) {
                        //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);
                        blockToFetch = { offset: blockOffset, size: blockSize };
                        bestBlockOffset = dir < 0 ? endBase : startBase;
                        bestBlockChr = dir < 0 ? endChrom : startChrom;
                    }
                }
                offset += 32;
            }
        } else {
            var bestRecur = -1;
            var bestPos = -1;
            var bestChr = -1;
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = la[lo + 4] << 32 | la[lo + 5];
                if (dir < 0 && (startChrom < chr || startChrom == chr && startBase <= pos) && endChrom >= chr || dir > 0 && (endChrom > chr || endChrom == chr && endBase >= pos) && startChrom <= chr) {
                    if (bestRecur < 0 || endBase > bestPos) {
                        bestRecur = blockOffset;
                        bestPos = dir < 0 ? endBase : startBase;
                        bestChr = dir < 0 ? endChrom : startChrom;
                    }
                }
                offset += 24;
            }
            if (bestRecur >= 0) {
                cirFobRecur([bestRecur], level + 1);
            }
        }
    };

    cirFobRecur([thisB.cirTreeOffset + 48], 1);
};

BigWig.prototype.readWigData = function (chrName, min, max, callback) {
    this.getUnzoomedView().readWigData(chrName, min, max, callback);
};

BigWig.prototype.getUnzoomedView = function () {
    if (!this.unzoomedView) {
        var cirLen = 4000;
        var nzl = this.zoomLevels[0];
        if (nzl) {
            cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;
        }
        this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);
    }
    return this.unzoomedView;
};

BigWig.prototype.getZoomedView = function (z) {
    var zh = this.zoomLevels[z];
    if (!zh.view) {
        zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */4000, true);
    }
    return zh.view;
};

function makeBwg(data, callback, name) {
    var bwg = new BigWig();
    bwg.data = data;
    bwg.name = name;
    bwg.data.slice(0, 512).salted().fetch(function (result) {
        if (!result) {
            return callback(null, "Couldn't fetch file");
        }

        var header = result;
        var ba = new Uint8Array(header);
        var sa = new Int16Array(header);
        var la = new Int32Array(header);
        var magic = ba[0] + M1 * ba[1] + M2 * ba[2] + M3 * ba[3];
        if (magic == BIG_WIG_MAGIC) {
            bwg.type = 'bigwig';
        } else if (magic == BIG_BED_MAGIC) {
            bwg.type = 'bigbed';
        } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {
            return callback(null, "Currently don't support big-endian BBI files");
        } else {
            return callback(null, "Not a supported format, magic=0x" + magic.toString(16));
        }

        bwg.version = sa[2]; // 4
        bwg.numZoomLevels = sa[3]; // 6
        bwg.chromTreeOffset = bwg_readOffset(ba, 8);
        bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);
        bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);
        bwg.fieldCount = sa[16]; // 32
        bwg.definedFieldCount = sa[17]; // 34
        bwg.asOffset = bwg_readOffset(ba, 36);
        bwg.totalSummaryOffset = bwg_readOffset(ba, 44);
        bwg.uncompressBufSize = la[13]; // 52
        bwg.extHeaderOffset = bwg_readOffset(ba, 56);

        bwg.zoomLevels = [];
        for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {
            var zlReduction = la[zl * 6 + 16];
            var zlData = bwg_readOffset(ba, zl * 24 + 72);
            var zlIndex = bwg_readOffset(ba, zl * 24 + 80);
            bwg.zoomLevels.push({ reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex });
        }

        bwg.readChromTree(function () {
            bwg.getAutoSQL(function (as) {
                bwg.schema = as;
                return callback(bwg);
            });
        });
    }, { timeout: 5000 }); // Potential timeout on first request to catch mixed-content errors on
    // Chromium.
}

BigWig.prototype._tsFetch = function (zoom, chr, min, max, callback) {
    var bwg = this;
    if (zoom >= this.zoomLevels.length - 1) {
        if (!this.topLevelReductionCache) {
            this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function (feats) {
                bwg.topLevelReductionCache = feats;
                return bwg._tsFetch(zoom, chr, min, max, callback);
            });
        } else {
            var f = [];
            var c = this.topLevelReductionCache;
            for (var fi = 0; fi < c.length; ++fi) {
                if (c[fi]._chromId == chr) {
                    f.push(c[fi]);
                }
            }
            return callback(f);
        }
    } else {
        var view;
        if (zoom < 0) {
            view = this.getUnzoomedView();
        } else {
            view = this.getZoomedView(zoom);
        }
        return view.readWigDataById(chr, min, max, callback);
    }
};

BigWig.prototype.thresholdSearch = function (chrName, referencePoint, dir, threshold, callback) {
    dir = dir < 0 ? -1 : 1;
    var bwg = this;
    var initialChr = this.chromsToIDs[chrName];
    var candidates = [{ chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true }];
    for (var i = 1; i <= this.maxID + 1; ++i) {
        var chrId = (initialChr + dir * i) % (this.maxID + 1);
        if (chrId < 0) chrId += this.maxID + 1;
        candidates.push({ chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000 });
    }

    function fbThresholdSearchRecur() {
        if (candidates.length == 0) {
            return callback(null);
        }
        candidates.sort(function (c1, c2) {
            var d = c1.zoom - c2.zoom;
            if (d != 0) return d;

            d = c1.chrOrd - c2.chrOrd;
            if (d != 0) return d;else return c1.min - c2.min * dir;
        });

        var candidate = candidates.splice(0, 1)[0];
        bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function (feats) {
            var rp = dir > 0 ? 0 : 300000000;
            if (candidate.fromRef) rp = referencePoint;

            for (var fi = 0; fi < feats.length; ++fi) {
                var f = feats[fi];
                var score;
                if (f.maxScore != undefined) score = f.maxScore;else score = f.score;

                if (dir > 0) {
                    if (score > threshold) {
                        if (candidate.zoom < 0) {
                            if (f.min > rp) return callback(f);
                        } else if (f.max > rp) {
                            candidates.push({ chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef });
                        }
                    }
                } else {
                    if (score > threshold) {
                        if (candidate.zoom < 0) {
                            if (f.max < rp) return callback(f);
                        } else if (f.min < rp) {
                            candidates.push({ chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef });
                        }
                    }
                }
            }
            fbThresholdSearchRecur();
        });
    }

    fbThresholdSearchRecur();
};

BigWig.prototype.getAutoSQL = function (callback) {
    var thisB = this;
    if (!this.asOffset) return callback(null);

    this.data.slice(this.asOffset, 2048).fetch(function (result) {
        var ba = new Uint8Array(result);
        var s = '';
        for (var i = 0; i < ba.length; ++i) {
            if (ba[i] == 0) break;
            s += String.fromCharCode(ba[i]);
        }

        /* 
         * Quick'n'dirty attempt to parse autoSql format.
         * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html
         */

        var header_re = /(\w+)\s+(\w+)\s+("([^"]+)")?\s+\(\s*/;
        var field_re = /([\w\[\]]+)\s+(\w+)\s*;\s*("([^"]+)")?\s*/g;

        var headerMatch = header_re.exec(s);
        if (headerMatch) {
            var as = {
                declType: headerMatch[1],
                name: headerMatch[2],
                comment: headerMatch[4],

                fields: []
            };

            s = s.substring(headerMatch[0]);
            for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {
                as.fields.push({ type: m[1],
                    name: m[2],
                    comment: m[4] });
            }

            return callback(as);
        }
    });
};

BigWig.prototype.getExtraIndices = function (callback) {
    var thisB = this;
    if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {
        return callback(null);
    } else {
        this.data.slice(this.extHeaderOffset, 64).fetch(function (result) {
            if (!result) {
                return callback(null, "Couldn't fetch extension header");
            }

            var ba = new Uint8Array(result);
            var sa = new Int16Array(result);
            var la = new Int32Array(result);

            var extHeaderSize = sa[0];
            var extraIndexCount = sa[1];
            var extraIndexListOffset = bwg_readOffset(ba, 4);

            if (extraIndexCount == 0) {
                return callback(null);
            }

            // FIXME 20byte records only make sense for single-field indices.
            // Right now, these seem to be the only things around, but the format
            // is actually more general.
            thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function (eil) {
                if (!eil) {
                    return callback(null, "Couldn't fetch index info");
                }

                var ba = new Uint8Array(eil);
                var sa = new Int16Array(eil);
                var la = new Int32Array(eil);

                var indices = [];
                for (var ii = 0; ii < extraIndexCount; ++ii) {
                    var eiType = sa[ii * 10];
                    var eiFieldCount = sa[ii * 10 + 1];
                    var eiOffset = bwg_readOffset(ba, ii * 20 + 4);
                    var eiField = sa[ii * 10 + 8];
                    var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);
                    indices.push(index);
                }
                callback(indices);
            });
        });
    }
};

function BBIExtraIndex(bbi, type, fieldCount, offset, field) {
    this.bbi = bbi;
    this.type = type;
    this.fieldCount = fieldCount;
    this.offset = offset;
    this.field = field;
}

BBIExtraIndex.prototype.lookup = function (name, callback) {
    var thisB = this;

    this.bbi.data.slice(this.offset, 32).fetch(function (bpt) {
        var ba = new Uint8Array(bpt);
        var sa = new Int16Array(bpt);
        var la = new Int32Array(bpt);
        var bptMagic = la[0];
        var blockSize = la[1];
        var keySize = la[2];
        var valSize = la[3];
        var itemCount = bwg_readOffset(ba, 16);
        var rootNodeOffset = 32;

        function bptReadNode(nodeOffset) {
            thisB.bbi.data.slice(nodeOffset, 4 + blockSize * (keySize + valSize)).fetch(function (node) {
                var ba = new Uint8Array(node);
                var sa = new Uint16Array(node);
                var la = new Uint32Array(node);

                var nodeType = ba[0];
                var cnt = sa[1];

                var offset = 4;
                if (nodeType == 0) {
                    var lastChildOffset = null;
                    for (var n = 0; n < cnt; ++n) {
                        var key = '';
                        for (var ki = 0; ki < keySize; ++ki) {
                            var charCode = ba[offset++];
                            if (charCode != 0) {
                                key += String.fromCharCode(charCode);
                            }
                        }

                        var childOffset = bwg_readOffset(ba, offset);
                        offset += 8;

                        if (name.localeCompare(key) < 0 && lastChildOffset) {
                            bptReadNode(lastChildOffset);
                            return;
                        }
                        lastChildOffset = childOffset;
                    }
                    bptReadNode(lastChildOffset);
                } else {
                    for (var n = 0; n < cnt; ++n) {
                        var key = '';
                        for (var ki = 0; ki < keySize; ++ki) {
                            var charCode = ba[offset++];
                            if (charCode != 0) {
                                key += String.fromCharCode(charCode);
                            }
                        }

                        // Specific for EI case.
                        if (key == name) {
                            var start = bwg_readOffset(ba, offset);
                            var length = readInt(ba, offset + 8);

                            return thisB.bbi.getUnzoomedView().fetchFeatures(function (chr, min, max, toks) {
                                if (toks && toks.length > thisB.field - 3) return toks[thisB.field - 3] == name;
                            }, [{ offset: start, size: length }], callback);
                        }
                        offset += valSize;
                    }
                    return callback([]);
                }
            });
        }

        bptReadNode(thisB.offset + rootNodeOffset);
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        makeBwg: makeBwg,
        BIG_BED_MAGIC: BIG_BED_MAGIC,
        BIG_WIG_MAGIC: BIG_WIG_MAGIC
    };
}

},{"./bin":4,"./das":11,"./spans":43,"./utils":58,"jszlib":64}],4:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bin.js general binary data support
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;

    var Promise = require('es6-promise').Promise;
}

function BlobFetchable(b) {
    this.blob = b;
}

BlobFetchable.prototype.slice = function (start, length) {
    var b;

    if (this.blob.slice) {
        if (length) {
            b = this.blob.slice(start, start + length);
        } else {
            b = this.blob.slice(start);
        }
    } else {
        if (length) {
            b = this.blob.webkitSlice(start, start + length);
        } else {
            b = this.blob.webkitSlice(start);
        }
    }
    return new BlobFetchable(b);
};

BlobFetchable.prototype.salted = function () {
    return this;
};

if (typeof FileReader !== 'undefined') {
    // console.log('defining async BlobFetchable.fetch');

    BlobFetchable.prototype.fetch = function (callback) {
        var reader = new FileReader();
        reader.onloadend = function (ev) {
            callback(bstringToBuffer(reader.result));
        };
        reader.readAsBinaryString(this.blob);
    };
} else {
    // if (console && console.log)
    //    console.log('defining sync BlobFetchable.fetch');

    BlobFetchable.prototype.fetch = function (callback) {
        var reader = new FileReaderSync();
        try {
            var res = reader.readAsArrayBuffer(this.blob);
            callback(res);
        } catch (e) {
            callback(null, e);
        }
    };
}

function URLFetchable(url, start, end, opts) {
    if (!opts) {
        if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object') {
            opts = start;
            start = undefined;
        } else {
            opts = {};
        }
    }

    this.url = url;
    this.start = start || 0;
    if (end) {
        this.end = end;
    }
    this.opts = opts;
}

URLFetchable.prototype.slice = function (s, l) {
    if (s < 0) {
        throw 'Bad slice ' + s;
    }

    var ns = this.start,
        ne = this.end;
    if (ns && s) {
        ns = ns + s;
    } else {
        ns = s || ns;
    }
    if (l && ns) {
        ne = ns + l - 1;
    } else {
        ne = ne || l - 1;
    }
    return new URLFetchable(this.url, ns, ne, this.opts);
};

var seed = 0;
var isSafari = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') >= 0 && navigator.userAgent.indexOf('Chrome') < 0;

URLFetchable.prototype.fetchAsText = function (callback) {
    var thisB = this;

    this.getURL().then(function (url) {
        try {
            var req = new XMLHttpRequest();
            var length;
            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {
                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++seed);
            }
            req.open('GET', url, true);

            if (thisB.end) {
                if (thisB.end - thisB.start > 100000000) {
                    throw 'Monster fetch!';
                }
                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);
                length = thisB.end - thisB.start + 1;
            }

            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200 || req.status == 206) {
                        return callback(req.responseText);
                    } else {
                        return callback(null);
                    }
                }
            };
            if (thisB.opts.credentials) {
                req.withCredentials = true;
            }
            req.send();
        } catch (e) {
            return callback(null);
        }
    }).catch(function (err) {
        console.log(err);
        return callback(null, err);
    });
};

URLFetchable.prototype.salted = function () {
    var o = shallowCopy(this.opts);
    o.salt = true;
    return new URLFetchable(this.url, this.start, this.end, o);
};

URLFetchable.prototype.getURL = function () {
    if (this.opts.resolver) {
        return this.opts.resolver(this.url).then(function (urlOrObj) {
            if (typeof urlOrObj === 'string') {
                return urlOrObj;
            } else {
                return urlOrObj.url;
            }
        });
    } else {
        return Promise.resolve(this.url);
    }
};

URLFetchable.prototype.fetch = function (callback, opts) {
    var thisB = this;

    opts = opts || {};
    var attempt = opts.attempt || 1;
    var truncatedLength = opts.truncatedLength;
    if (attempt > 3) {
        return callback(null);
    }

    this.getURL().then(function (url) {
        try {
            var timeout;
            if (opts.timeout && !thisB.opts.credentials) {
                timeout = setTimeout(function () {
                    console.log('timing out ' + url);
                    req.abort();
                    return callback(null, 'Timeout');
                }, opts.timeout);
            }

            var req = new XMLHttpRequest();
            var length;
            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {
                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++seed);
            }
            req.open('GET', url, true);
            req.overrideMimeType('text/plain; charset=x-user-defined');
            if (thisB.end) {
                if (thisB.end - thisB.start > 100000000) {
                    throw 'Monster fetch!';
                }
                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);
                length = thisB.end - thisB.start + 1;
            }
            req.responseType = 'arraybuffer';
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (timeout) clearTimeout(timeout);
                    if (req.status == 200 || req.status == 206) {
                        if (req.response) {
                            var bl = req.response.byteLength;
                            if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {
                                return thisB.fetch(callback, { attempt: attempt + 1, truncatedLength: bl });
                            } else {
                                return callback(req.response);
                            }
                        } else if (req.mozResponseArrayBuffer) {
                            return callback(req.mozResponseArrayBuffer);
                        } else {
                            var r = req.responseText;
                            if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {
                                return thisB.fetch(callback, { attempt: attempt + 1, truncatedLength: r.length });
                            } else {
                                return callback(bstringToBuffer(req.responseText));
                            }
                        }
                    } else {
                        return thisB.fetch(callback, { attempt: attempt + 1 });
                    }
                }
            };
            if (thisB.opts.credentials) {
                req.withCredentials = true;
            }
            req.send();
        } catch (e) {
            return callback(null);
        }
    }).catch(function (err) {
        console.log(err);
        return callback(null, err);
    });
};

function bstringToBuffer(result) {
    if (!result) {
        return null;
    }

    var ba = new Uint8Array(result.length);
    for (var i = 0; i < ba.length; ++i) {
        ba[i] = result.charCodeAt(i);
    }
    return ba.buffer;
}

// Read from Uint8Array

var convertBuffer = new ArrayBuffer(8);
var ba = new Uint8Array(convertBuffer);
var fa = new Float32Array(convertBuffer);

function readFloat(buf, offset) {
    ba[0] = buf[offset];
    ba[1] = buf[offset + 1];
    ba[2] = buf[offset + 2];
    ba[3] = buf[offset + 3];
    return fa[0];
}

function readInt64(ba, offset) {
    return ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];
}

function readInt(ba, offset) {
    return ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset];
}

function readShort(ba, offset) {
    return ba[offset + 1] << 8 | ba[offset];
}

function readByte(ba, offset) {
    return ba[offset];
}

function readIntBE(ba, offset) {
    return ba[offset] << 24 | ba[offset + 1] << 16 | ba[offset + 2] << 8 | ba[offset + 3];
}

// Exports if we are being used as a module

if (typeof module !== 'undefined') {
    module.exports = {
        BlobFetchable: BlobFetchable,
        URLFetchable: URLFetchable,

        readInt: readInt,
        readIntBE: readIntBE,
        readInt64: readInt64,
        readShort: readShort,
        readByte: readByte,
        readFloat: readFloat
    };
}

},{"./sha1":40,"./utils":58,"es6-promise":63}],5:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// browser-us.js: standard UI wiring
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;

    var nf = require('./numformats');
    var formatLongInt = nf.formatLongInt;

    var makeZoomSlider = require('./zoomslider');

    // For side effects

    require('./tier-edit');
    require('./export-config');
    require('./export-ui');
    require('./export-image');
    require('./svg-export');
    require('./session');
}

/*
 * Quite a bit of this ought to be done using a templating system, but
 * since web-components isn't quite ready for prime time yet we'll stick
 * with constructing it all in Javascript for now...
 */

Browser.prototype.initUI = function (holder, genomePanel) {
    if (!this.noSourceCSS) {
        ['bootstrap-scoped.css', 'dalliance-scoped.css', 'font-awesome.min.css'].forEach(function (path) {
            document.head.appendChild(makeElement('link', '', {
                rel: 'stylesheet',
                href: this.resolveURL('$$css/' + path)
            }));
        }.bind(this));
    }

    var b = this;

    if (!b.disableDefaultFeaturePopup) {
        this.addFeatureListener(function (ev, feature, hit, tier) {
            b.featurePopup(ev, feature, hit, tier);
        });
    }

    holder.classList.add('dalliance');
    var toolbar = b.toolbar = makeElement('div', null, { className: 'btn-toolbar toolbar' });

    var title = b.coordSystem.speciesName + ' ' + b.nameForCoordSystem(b.coordSystem);
    if (this.setDocumentTitle) {
        document.title = title + ' :: dalliance';
    }

    var locField = makeElement('input', '', { className: 'loc-field' });
    b.makeTooltip(locField, 'Enter a genomic location or gene name');
    var locStatusField = makeElement('p', '', { className: 'loc-status' });

    var zoomInBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-search-plus' })], { className: 'btn' });
    var zoomSlider = new makeZoomSlider({ width: b.zoomSliderWidth });
    b.makeTooltip(zoomSlider, "Highlighted button shows current zoom level, gray button shows inactive zoom level (click or tap SPACE to toggle).");

    var zoomOutBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-search-minus' })], { className: 'btn' });

    var clearHighlightsButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-eraser' })], { className: 'btn' });

    var addTrackBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-plus' })], { className: 'btn' });
    var favBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-bookmark' })], { className: 'btn' });
    var svgBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-print' })], { className: 'btn' });
    var resetBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-refresh' })], { className: 'btn' });
    var optsButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-cogs' })], { className: 'btn' });
    var helpButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-question' })], { className: 'btn' });

    var tierEditButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-road' })], { className: 'btn' });
    b.makeTooltip(tierEditButton, 'Configure currently selected track(s) (E)');

    var leapLeftButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-angle-left' })], { className: 'btn pull-right' }, { width: '5px' });
    var leapRightButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-angle-right' })], { className: 'btn pull-right' }, { width: '5px' });

    var modeButtons = makeElement('div', null, { className: 'btn-group pull-right' });
    if (!this.noTrackAdder) modeButtons.appendChild(addTrackBtn);
    if (!this.noTrackEditor) modeButtons.appendChild(tierEditButton);
    if (!this.noExport) modeButtons.appendChild(svgBtn);
    if (!this.noOptions) modeButtons.appendChild(optsButton);
    if (!this.noHelp) modeButtons.appendChild(helpButton);

    this.setUiMode = function (m) {
        this.uiMode = m;
        var mb = { help: helpButton, add: addTrackBtn, opts: optsButton, 'export': svgBtn, tier: tierEditButton };
        for (var x in mb) {
            if (x == m) mb[x].classList.add('active');else mb[x].classList.remove('active');
        }
    };

    if (modeButtons.firstChild) toolbar.appendChild(modeButtons);

    if (!this.noLeapButtons) toolbar.appendChild(leapRightButton);
    if (!this.noLeapButtons) toolbar.appendChild(leapLeftButton);
    if (!this.noTitle) {
        toolbar.appendChild(makeElement('div', makeElement('h4', title, {}, { margin: '0px' }), { className: 'btn-group title' }));
    }
    if (!this.noLocationField) toolbar.appendChild(makeElement('div', [locField, locStatusField], { className: 'btn-group loc-group' }));
    if (!this.noClearHighlightsButton) toolbar.appendChild(clearHighlightsButton);

    if (!this.noZoomSlider) {
        toolbar.appendChild(makeElement('div', [zoomInBtn, makeElement('span', zoomSlider, { className: 'btn' }), zoomOutBtn], { className: 'btn-group' }));
    }

    if (this.toolbarBelow) {
        holder.appendChild(genomePanel);
        holder.appendChild(toolbar);
    } else {
        holder.appendChild(toolbar);
        holder.appendChild(genomePanel);
    }

    var lt2 = Math.log(2) / Math.log(10);
    var lt5 = Math.log(5) / Math.log(10);
    var roundSliderValue = function roundSliderValue(x) {
        var ltx = (x / b.zoomExpt + Math.log(b.zoomBase)) / Math.log(10);

        var whole = ltx | 0;
        var frac = ltx - whole;
        var rounded;

        if (frac < 0.01) rounded = whole;else if (frac <= lt2 + 0.01) rounded = whole + lt2;else if (frac <= lt5 + 0.01) rounded = whole + lt5;else {
            rounded = whole + 1;
        }

        return (rounded * Math.log(10) - Math.log(b.zoomBase)) * b.zoomExpt;
    };

    var markSlider = function markSlider(x) {
        zoomSlider.addLabel(x, humanReadableScale(Math.exp(x / b.zoomExpt) * b.zoomBase));
    };

    this.addViewListener(function (chr, min, max, _oldZoom, zoom) {
        locField.value = chr + ':' + formatLongInt(min) + '..' + formatLongInt(max);
        zoomSlider.min = zoom.min | 0;
        zoomSlider.max = zoom.max | 0;
        if (zoom.isSnapZooming) {
            zoomSlider.value = zoom.alternate;
            zoomSlider.value2 = zoom.current;
            zoomSlider.active = 2;
        } else {
            zoomSlider.value = zoom.current;
            zoomSlider.value2 = zoom.alternate;
            zoomSlider.active = 1;
        }

        if (zoom.current == zoom.min) zoomInBtn.classList.add('disabled');else zoomInBtn.classList.remove('disabled');

        if (zoom.current == zoom.max) zoomOutBtn.classList.add('disabled');else zoomOutBtn.classList.remove('disabled');

        zoomSlider.removeLabels();
        var zmin = zoom.min;
        var zmax = zoom.max;
        var zrange = zmax - zmin;

        var numSliderTicks = 4;
        if (b.zoomSliderWidth && b.zoomSliderWidth < 150) numSliderTicks = 3;
        markSlider(roundSliderValue(zmin));
        for (var sti = 1; sti < numSliderTicks - 1; ++sti) {
            markSlider(roundSliderValue(zmin + 1.0 * sti * zrange / (numSliderTicks - 1)));
        }
        markSlider(roundSliderValue(zmax));

        if (b.storeStatus) {
            b.storeViewStatus();
        }

        if (b.highlights.length > 0) {
            clearHighlightsButton.style.display = 'inline-block';
        } else {
            clearHighlightsButton.style.display = 'none';
        }
    });

    this.addTierListener(function () {
        if (b.storeStatus) {
            b.storeTierStatus();
        }
    });

    locField.addEventListener('keydown', function (ev) {
        if (ev.keyCode == 40) {
            ev.preventDefault();ev.stopPropagation();
            b.setSelectedTier(0);
        }if (ev.keyCode == 10 || ev.keyCode == 13) {
            ev.preventDefault();

            var g = locField.value;
            b.search(g, function (err) {
                if (err) {
                    locStatusField.textContent = '' + err;
                } else {
                    locStatusField.textContent = '';
                }
            });
        }
    }, false);

    var trackAddPopup;
    addTrackBtn.addEventListener('click', function (ev) {
        if (trackAddPopup && trackAddPopup.displayed) {
            b.removeAllPopups();
        } else {
            trackAddPopup = b.showTrackAdder(ev);
        }
    }, false);
    b.makeTooltip(addTrackBtn, 'Add a new track from the registry or an indexed file. (A)');

    zoomInBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        b.zoomStep(-10);
    }, false);
    b.makeTooltip(zoomInBtn, 'Zoom in (+)');

    zoomOutBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        b.zoomStep(10);
    }, false);
    b.makeTooltip(zoomOutBtn, 'Zoom out (-)');

    zoomSlider.addEventListener('change', function (ev) {
        var wantSnap = zoomSlider.active == 2;
        if (wantSnap != b.isSnapZooming) {
            b.savedZoom = b.zoomSliderValue - b.zoomMin;
            b.isSnapZooming = wantSnap;
        }
        var activeZSV = zoomSlider.active == 1 ? zoomSlider.value : zoomSlider.value2;

        b.zoomSliderValue = 1.0 * activeZSV;
        b.zoom(Math.exp(1.0 * activeZSV / b.zoomExpt));
    }, false);

    favBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
    }, false);
    b.makeTooltip(favBtn, 'Favourite regions');

    svgBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        b.openExportPanel();
    }, false);
    b.makeTooltip(svgBtn, 'Export publication-quality SVG. (X)');

    var optsPopup;
    optsButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        b.toggleOptsPopup(ev);
    }, false);
    b.makeTooltip(optsButton, 'Configure options.');

    helpButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        b.toggleHelpPopup(ev);
    });
    b.makeTooltip(helpButton, 'Help; Keyboard shortcuts. (H)');

    tierEditButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        if (b.selectedTiers.length == 1) {
            b.openTierPanel(b.tiers[b.selectedTiers[0]]);
        }
    }, false);

    leapLeftButton.addEventListener('click', function (ev) {
        b.leap(b.reverseKeyScrolling ? -1 : 1, false);
    }, false);
    b.makeTooltip(leapLeftButton, function (ev) {
        var st = b.getSelectedTier();
        var tier;
        if (st >= 0) tier = b.tiers[st];

        if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof tier.quantLeapThreshold == 'number') {
            return 'Jump to the next region with a score above the threshold in the selected track "' + (tier.config.name || tier.dasSource.name) + '"" (ctrl+LEFT)';
        } else if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'leap')) {
            return 'Jump to the next feature in the selected track "' + (tier.config.name || tier.dasSource.name) + '" (ctrl+LEFT)';
        } else {
            return 'Jump left (shift+LEFT)';
        }
    });

    leapRightButton.addEventListener('click', function (ev) {
        b.leap(b.reverseKeyScrolling ? 1 : -1, false);
    }, false);
    b.makeTooltip(leapRightButton, function (ev) {
        var st = b.getSelectedTier();
        var tier;
        if (st >= 0) tier = b.tiers[st];

        if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof tier.quantLeapThreshold == 'number') {
            return 'Jump to the next region with a score above the threshold in the selected track "' + (tier.config.name || tier.dasSource.name) + '"" (ctrl+RIGHT)';
        } else if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'leap')) {
            return 'Jump to the next feature in the selected track "' + (tier.config.name || tier.dasSource.name) + '" (ctrl+RIGHT)';
        } else {
            return 'Jump right (shift+RIGHT)';
        }
    });
    b.addTierSelectionListener(function () {
        var st = b.getSelectedTier();
        var tier;
        if (st >= 0) tier = b.tiers[st];

        var canLeap = false;
        if (tier && tier.featureSource) {
            if (b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof tier.quantLeapThreshold == 'number') canLeap = true;else if (b.sourceAdapterIsCapable(tier.featureSource, 'leap')) canLeap = true;
        }

        leapLeftButton.firstChild.className = canLeap ? 'fa fa-angle-double-left' : 'fa fa-angle-left';
        leapRightButton.firstChild.className = canLeap ? 'fa fa-angle-double-right' : 'fa fa-angle-right';
    });

    clearHighlightsButton.addEventListener('click', function (ev) {
        b.clearHighlights();
    }, false);
    b.makeTooltip(clearHighlightsButton, 'Clear highlights (C)');

    b.addTierSelectionWrapListener(function (dir) {
        if (dir < 0) {
            b.setSelectedTier(null);
            locField.focus();
        }
    });

    b.addTierSelectionListener(function (sel) {
        if (b.uiMode === 'tier') {
            if (sel.length == 0) {
                b.hideToolPanel();
                b.manipulatingTier = null;
                b.uiMode = 'none';
            } else {
                var ft = b.tiers[sel[0]];
                if (ft != b.manipulatingTier) {
                    b.openTierPanel(ft);
                }
            }
        }
    });

    var uiKeyHandler = function uiKeyHandler(ev) {
        // console.log('bukh: ' + ev.keyCode);
        if (ev.keyCode == 65 || ev.keyCode == 97) {
            // a
            ev.preventDefault();ev.stopPropagation();
            b.showTrackAdder();
        } else if (ev.keyCode == 72 || ev.keyCode == 104) {
            // h
            ev.stopPropagation();ev.preventDefault();
            b.toggleHelpPopup(ev);
        } else if (ev.keyCode == 69 || ev.keyCode == 101) {
            //e
            ev.stopPropagation();ev.preventDefault();
            if (b.selectedTiers.length == 1) {
                b.openTierPanel(b.tiers[b.selectedTiers[0]]);
            }
        } else if (ev.keyCode == 88 || ev.keyCode == 120) {
            // x
            ev.stopPropagation();ev.preventDefault();
            b.openExportPanel();
        } else if (ev.keyCode == 67 || ev.keyCode == 99) {
            // c
            ev.stopPropagation();ev.preventDefault();
            b.clearHighlights();
        }
    };

    holder.addEventListener('focus', function (ev) {
        holder.addEventListener('keydown', uiKeyHandler, false);
    }, false);
    holder.addEventListener('blur', function (ev) {
        holder.removeEventListener('keydown', uiKeyHandler, false);
    }, false);

    holder.addEventListener('keydown', function (ev) {
        if (ev.keyCode === 27) {
            if (b.uiMode !== 'none') {
                // Only consume event if tool panel is open.
                ev.preventDefault();
                ev.stopPropagation();
                b.setUiMode('none');
                b.hideToolPanel();

                if (b.selectedTiers && b.selectedTiers.length > 0) {
                    b.browserHolder.focus();
                }
            }
        }
    }, false);
};

Browser.prototype.showToolPanel = function (panel, nowrap) {
    var thisB = this;

    if (this.activeToolPanel) {
        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);
    }

    var content;
    if (nowrap) content = panel;else content = makeElement('div', panel, {}, { overflowY: 'auto', width: '100%' });

    var divider = makeElement('div', makeElement('i', null, { className: 'fa fa-caret-right' }), { className: 'tool-divider' });
    divider.addEventListener('click', function (ev) {
        thisB.hideToolPanel();
        thisB.setUiMode('none');
    }, false);
    this.makeTooltip(divider, 'Close tool panel (ESC)');
    this.activeToolPanel = makeElement('div', [divider, content], { className: 'tool-holder' });
    this.svgHolder.appendChild(this.activeToolPanel);
    this.resizeViewer();

    var thisB = this;
};

Browser.prototype.hideToolPanel = function () {
    if (this.activeToolPanel) {
        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);
    }
    this.svgHolder.style.width = '100%';
    this.activeToolPanel = null;
    this.resizeViewer();
};

Browser.prototype.toggleHelpPopup = function (ev) {
    if (this.uiMode === 'help') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var helpFrame = makeElement('iframe', null, { scrolling: 'yes', seamless: 'seamless', src: this.resolveURL('$$help/index.html'), className: 'help-panel' });
        this.showToolPanel(helpFrame, false);
        this.setUiMode('help');
    }
};

Browser.prototype.toggleOptsPopup = function (ev) {
    var b = this;

    if (this.uiMode === 'opts') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var optsForm = makeElement('div', null, { className: 'form-horizontal' }, { boxSizing: 'border-box', MozBoxSizing: 'border-box', display: 'inline-block', verticalAlign: 'top' });
        var optsTable = makeElement('table');
        optsTable.cellPadding = 5;

        var scrollModeButton = makeElement('input', '', { type: 'checkbox', checked: b.reverseScrolling });
        scrollModeButton.addEventListener('change', function (ev) {
            b.reverseScrolling = scrollModeButton.checked;
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse trackpad scrolling', { align: 'right' }), makeElement('td', scrollModeButton)]));

        var scrollKeyButton = makeElement('input', '', { type: 'checkbox', checked: b.reverseKeyScrolling });
        scrollKeyButton.addEventListener('change', function (ev) {
            b.reverseKeyScrolling = scrollKeyButton.checked;
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse scrolling buttons and keys', { align: 'right' }), makeElement('td', scrollKeyButton)]));

        var rulerSelect = makeElement('select');
        rulerSelect.appendChild(makeElement('option', 'Left', { value: 'left' }));
        rulerSelect.appendChild(makeElement('option', 'Center', { value: 'center' }));
        rulerSelect.appendChild(makeElement('option', 'Right', { value: 'right' }));
        rulerSelect.appendChild(makeElement('option', 'None', { value: 'none' }));
        rulerSelect.value = b.rulerLocation;
        rulerSelect.addEventListener('change', function (ev) {
            b.rulerLocation = rulerSelect.value;
            b.positionRuler();
            for (var ti = 0; ti < b.tiers.length; ++ti) {
                b.tiers[ti].paintQuant();
            }
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Vertical guideline', { align: 'right' }), makeElement('td', rulerSelect)]));

        var singleBaseHighlightButton = makeElement('input', '', { type: 'checkbox', checked: b.singleBaseHighlight });
        singleBaseHighlightButton.addEventListener('change', function (ev) {
            b.singleBaseHighlight = singleBaseHighlightButton.checked;
            b.positionRuler();
            b.storeStatus();
        }, false);
        singleBaseHighlightButton.setAttribute('id', 'singleBaseHightlightButton'); // making this because access is required when the key 'u' is pressed and the options are visible
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Display and highlight current genome location', { align: 'right' }), makeElement('td', singleBaseHighlightButton)]));

        optsForm.appendChild(optsTable);

        var resetButton = makeElement('button', 'Reset browser', { className: 'btn' }, { marginLeft: 'auto', marginRight: 'auto', display: 'block' });
        resetButton.addEventListener('click', function (ev) {
            b.reset();
        }, false);
        optsForm.appendChild(resetButton);

        this.showToolPanel(optsForm);
        this.setUiMode('opts');
    }
};

function humanReadableScale(x) {
    var suffix = 'bp';
    if (x > 1000000000) {
        x /= 1000000000;
        suffix = 'Gb';
    } else if (x > 1000000) {
        x /= 1000000;
        suffix = 'Mb';
    } else if (x > 1000) {
        x /= 1000;
        suffix = 'kb';
    }
    return '' + Math.round(x) + suffix;
}

},{"./cbrowser":6,"./export-config":17,"./export-image":18,"./export-ui":19,"./numformats":30,"./session":39,"./svg-export":46,"./tier-edit":53,"./utils":58,"./zoomslider":62}],6:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// cbrowser.js: canvas browser container
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var Observed = utils.Observed;
    var Awaited = utils.Awaited;
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var miniJSONify = utils.miniJSONify;
    var shallowCopy = utils.shallowCopy;
    var textXHR = utils.textXHR;

    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;

    var thub = require('./thub');
    var connectTrackHub = thub.connectTrackHub;

    var VERSION = require('./version');

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
    var formatLongInt = nf.formatLongInt;

    var Chainset = require('./chainset').Chainset;

    var Promise = require('es6-promise').Promise;

    var sourcecompare = require('./sourcecompare');
    var sourcesAreEqual = sourcecompare.sourcesAreEqual;
    var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;
    var sourceDataURI = sourcecompare.sourceDataURI;
    var sourceStyleURI = sourcecompare.sourceStyleURI;

    var DefaultRenderer = require('./default-renderer');

    var MultiRenderer = require('./multi-renderer');
    var SubRenderer = require('./sub-renderer');

    var DummyRenderer = require('./dummy-renderer');
}

function Region(chr, min, max) {
    this.min = min;
    this.max = max;
    this.chr = chr;
}

function Browser(opts) {
    if (!opts) {
        opts = {};
    }

    this.renderers = { 'default': DefaultRenderer,
        'dummy': DummyRenderer,
        'multi': MultiRenderer,
        'sub': SubRenderer
    };

    if (opts.externalRenderers && _typeof(opts.externalRenderers) === "object") {
        for (var k in opts.externalRenderers) {
            this.renderers[k] = opts.externalRenderers[k];
        }
    }

    this.defaultRenderer = opts.renderer || DefaultRenderer;

    this.prefix = '//www.biodalliance.org/release-0.14/';
    this.workerPrefix = opts.workerPrefix || '';

    this.sources = [];
    this.tiers = [];
    this.tierGroups = {};

    this.featureListeners = [];
    this.featureHoverListeners = [];
    this.viewListeners = [];
    this.regionSelectListeners = [];
    this.tierListeners = [];
    this.tierSelectionListeners = [];
    this.tierSelectionWrapListeners = [];

    this.cookieKey = 'browser';

    this.chains = {};

    this.pageName = 'svgHolder';
    this.zoomFactor = 1.0;
    this.maxPixelsPerBase = 10;
    this.origin = 0;
    this.targetQuantRes = 1.0;
    this.featurePanelWidth = 750;
    this.zoomBase = 100;
    this.zoomExpt = 30.0; // Back to being fixed....
    this.zoomSliderValue = 100;
    this.entryPoints = null;
    this.currentSeqMax = -1; // init once EPs are fetched.

    this.highlights = [];
    this.selectedTiers = [1];

    this.maxViewWidth = 500000;
    this.defaultSubtierMax = 100;

    this.highZoomThreshold = 0.2;
    this.mediumZoomThreshold = 0.01;

    this.minExtraWidth = 100.0;
    this.maxExtraWidth = 1000.0;

    // Options.

    this.reverseScrolling = false;
    this.rulerLocation = 'center';
    this.defaultHighlightFill = 'red';
    this.defaultHighlightAlpha = 0.3;
    this.exportHighlights = true;
    this.exportRuler = true;
    this.exportBanner = true;
    this.exportRegion = true;
    this.singleBaseHighlight = true;

    // Visual config.

    // this.tierBackgroundColors = ["rgb(245,245,245)", "rgb(230,230,250)" /* 'white' */];
    this.tierBackgroundColors = ["rgb(245,245,245)", 'white'];
    this.minTierHeight = 20;
    this.noDefaultLabels = false;

    // Registry

    this.availableSources = new Observed();
    this.defaultSources = [];
    this.mappableSources = {};

    // Central DAS Registry no longer available 2015-05

    this.registry = null; // '//www.dasregistry.org/das/sources';
    this.noRegistryTabs = true;

    this.hubs = [];
    this.hubObjects = [];

    this.sourceCache = new SourceCache();

    this.retina = true;

    this.useFetchWorkers = true;
    this.maxWorkers = 2;
    this.workerPath = '$$' + this.workerPrefix + 'worker-all.js';
    this.resolvers = {};
    this.resolverSeed = 1;

    this.assemblyNamePrimary = true;
    this.assemblyNameUcsc = true;

    this.defaultSearchRegionPadding = 10000;

    // HTTP warning support

    this.httpCanaryURL = 'http://www.biodalliance.org/http-canary.txt';
    this.httpWarningURL = '//www.biodalliance.org/https.html';

    this.initListeners = [];

    if (opts.baseColors) {
        this.baseColors = opts.baseColors;
    } else {
        this.baseColors = {
            A: 'green',
            C: 'blue',
            G: 'orange',
            T: 'red',
            '-': 'hotpink', // deletion
            'I': 'red' // insertion
        };
    }

    if (opts.viewStart !== undefined && typeof opts.viewStart !== 'number') {
        throw Error('viewStart must be an integer');
    }
    if (opts.viewEnd !== undefined && typeof opts.viewEnd !== 'number') {
        throw Error('viewEnd must be an integer');
    }
    if (opts.offscreenInitWidth !== undefined && typeof opts.offscreenInitWidth !== 'number') {
        throw Error('offscreenInitWidth must be an integer');
    }

    for (var k in opts) {
        this[k] = opts[k];
    }

    if (typeof opts.uiPrefix === 'string' && typeof opts.prefix !== 'string') {
        this.prefix = opts.uiPrefix;
    }
    // If the prefix only starts with a single '/' this is relative to the current
    // site, so we need to prefix the prefix with //{hostname}
    if (this.prefix.indexOf('//') < 0 && this.prefix.indexOf('/') === 0) {
        var location = window.location.hostname;
        if (window.location.port) {
            location += ':' + window.location.port;
        };
        this.prefix = '//' + location + this.prefix;
    }
    if (this.prefix.indexOf('//') === 0) {
        var proto = window.location.protocol;
        if (proto == 'http:' || proto == 'https:') {
            // Protocol-relative URLs okay.
        } else {
            console.log(window.location.protocol);
            console.log('WARNING: prefix is set to a protocol-relative URL (' + this.prefix + ' when loading from a non-HTTP source');
            this.prefix = 'http:' + this.prefix;
        }
    }

    if (!this.coordSystem) {
        throw Error('Coordinate system must be configured');
    }

    if (this.chr === undefined || this.viewStart === undefined || this.viewEnd === undefined) {
        throw Error('Viewed region (chr:start..end) must be defined');
    }

    var thisB = this;

    if (document.readyState === 'complete') {
        thisB.realInit();
    } else {
        var loadListener = function loadListener(ev) {
            window.removeEventListener('load', loadListener, false);
            thisB.realInit();
        };
        window.addEventListener('load', loadListener, false);
    }
}

Browser.prototype.resolveURL = function (url) {
    return url.replace('$$', this.prefix);
};

Browser.prototype.destroy = function () {
    window.removeEventListener('resize', this.resizeListener, false);
    if (this.fetchWorkers) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.fetchWorkers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var worker = _step.value;

                worker.terminate();
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
};

Browser.prototype.realInit = function () {
    var self = this;
    var thisB = this;

    if (this.wasInitialized) {
        console.log('Attemping to call realInit on an already-initialized Dalliance instance');
        return;
    }

    this.wasInitialized = true;

    if (typeof navigator !== 'undefined') {
        var ua = navigator.userAgent || 'dummy';
        if (ua.indexOf('Trident') >= 0 && ua.indexOf('rv:11') >= 0) {
            // console.log('Detected IE11, disabling tier pinning.');
            this.disablePinning = true;
        }
    }

    this.defaultChr = this.chr;
    this.defaultStart = this.viewStart;
    this.defaultEnd = this.viewEnd;
    this.defaultSources = [];
    for (var i = 0; i < this.sources.length; ++i) {
        var s = this.sources[i];
        if (s) this.defaultSources.push(s);
    }

    if (this.restoreStatus) {
        this.statusRestored = this.restoreStatus();
    }

    if (this.injectionPoint && this.injectionPoint instanceof Element) {
        this.browserHolderHolder = this.injectionPoint;
    } else if (this.injectionPoint) {
        this.browserHolderHolder = document.getElementById(this.injectionPoint);
        if (!this.browserHolderHolder) {
            throw Error('injectionPoint must point to a valid DOM element of element ID');
        }
    } else {
        this.browserHolderHolder = document.getElementById(this.pageName);
        if (!this.browserHolderHolder) {
            throw Error('pageName must be a valid element ID (or use the injectionPoint option instead)');
        }
    }

    this.browserHolderHolder.classList.add('dalliance-injection-point');
    this.browserHolder = makeElement('div', null, { className: 'dalliance dalliance-root', tabIndex: -1 });
    if (this.maxHeight) {
        this.browserHolder.style.maxHeight = this.maxHeight + 'px';
    } else if (this.maxHeight != undefined) {
        this.browserHolder.style.maxHeight = null;
    }
    removeChildren(this.browserHolderHolder);
    this.browserHolderHolder.appendChild(this.browserHolder);
    this.svgHolder = makeElement('div', null, { className: 'main-holder' });

    this.initUI(this.browserHolder, this.svgHolder);

    this.pinnedTierHolder = makeElement('div', null, { className: 'tier-holder tier-holder-pinned' });
    this.tierHolder = makeElement('div', this.makeLoader(24), { className: 'tier-holder tier-holder-rest' });

    this.locSingleBase = makeElement('span', '', { className: 'loc-single-base' });
    var locSingleBaseHolder = makeElement('div', this.locSingleBase, { className: 'loc-single-base-holder' });
    // Add listener to update single base location
    this.addViewListener(function (chr, minFloor, maxFloor, zoomSliderValue, zoomSliderDict, min, max) {
        // Just setting textContent causes layout flickering in Blink.
        // This approach means that the element is never empty.
        var loc = Math.round((max + min) / 2);
        self.locSingleBase.appendChild(document.createTextNode(chr + ':' + formatLongInt(loc)));
        self.locSingleBase.removeChild(self.locSingleBase.firstChild);
    });

    if (this.disablePinning) {
        this.tierHolderHolder = this.tierHolder;
    } else {
        this.tierHolderHolder = makeElement('div', [locSingleBaseHolder, this.pinnedTierHolder, this.tierHolder], { className: 'tier-holder-holder' });
        this.svgHolder.appendChild(this.tierHolderHolder);
    }
    this.svgHolder.appendChild(this.tierHolderHolder);

    this.bhtmlRoot = makeElement('div');
    if (!this.disablePoweredBy) {
        this.bhtmlRoot.appendChild(makeElement('span', ['Powered by ', makeElement('a', 'Biodalliance', { href: 'http://www.biodalliance.org/' }), ' ' + VERSION], { className: 'powered-by' }));
    }
    this.browserHolder.appendChild(this.bhtmlRoot);

    this.resizeListener = function (ev) {
        thisB.resizeViewer();
    };

    this.ruler = makeElement('div', null, { className: 'guideline' });
    this.ruler2 = makeElement('div', null, { className: 'single-base-guideline' });
    this.tierHolderHolder.appendChild(this.ruler);
    this.tierHolderHolder.appendChild(this.ruler2);
    this.chainConfigs = this.chains || {};
    this.chains = {};
    for (var k in this.chainConfigs) {
        var cc = this.chainConfigs[k];
        if (cc instanceof Chainset) {
            console.log('WARNING: Should no longer use "new Chainset" in Biodalliance configurations.');
        }
        this.chains[k] = new Chainset(cc);
    }

    var promisedWorkers;
    if (this.maxWorkers > 0) {
        var pw = [];
        for (var fi = 0; fi < this.maxWorkers; ++fi) {
            pw.push(makeFetchWorker(this));
        }promisedWorkers = Promise.all(pw);
    } else {
        promisedWorkers = Promise.resolve([]);
    }

    this.fetchWorkers = null;
    this.nextWorker = 0;
    promisedWorkers.then(function (v) {
        console.log('Booted ' + v.length + ' workers');
        thisB.fetchWorkers = v;
    }, function (v) {
        console.log('Failed to boot workers', v);
    }).then(function () {
        if (self.offscreenInitWidth || window.getComputedStyle(thisB.browserHolderHolder).display != 'none' && thisB.tierHolder.getBoundingClientRect().width > 0) {
            setTimeout(function () {
                thisB.realInit2();
            }, 1);
        } else {
            var pollInterval = setInterval(function () {
                if (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' && thisB.tierHolder.getBoundingClientRect().width > 0) {
                    clearInterval(pollInterval);
                    thisB.realInit2();
                }
            }, 300);
        }
    });
};

Browser.prototype.realInit2 = function () {
    var _this = this;

    var thisB = this;

    // Remove the loader icon, if needed
    removeChildren(this.tierHolder);
    removeChildren(this.pinnedTierHolder);

    this.featurePanelWidth = this.tierHolder.getBoundingClientRect().width | thisB.offscreenInitWidth | 0;
    window.addEventListener('resize', this.resizeListener, false);

    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);
    if (!this.zoomMax) {
        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);
        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase);
    }
    this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

    // Event handlers

    this.tierHolderHolder.addEventListener('mousewheel', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        if (ev.wheelDeltaX) {
            var delta = ev.wheelDeltaX / 5;
            if (!thisB.reverseScrolling) {
                delta = -delta;
            }
            thisB.move(delta);
        }

        if (ev.wheelDeltaY) {
            var delta = ev.wheelDeltaY;
            if (thisB.reverseScrolling) {
                delta = -delta;
            }
            thisB.tierHolder.scrollTop += delta;
        }
    }, false);

    this.tierHolderHolder.addEventListener('MozMousePixelScroll', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        if (ev.axis == 1) {
            if (ev.detail != 0) {
                var delta = ev.detail / 4;
                if (thisB.reverseScrolling) {
                    delta = -delta;
                }
                thisB.move(delta);
            }
        } else {
            var delta = ev.detail;
            if (!thisB.reverseScrolling) {
                delta = -delta;
            }

            thisB.tierHolder.scrollTop += delta;
        }
    }, false);

    this.tierHolderHolder.addEventListener('touchstart', function (ev) {
        return thisB.touchStartHandler(ev);
    }, false);
    this.tierHolderHolder.addEventListener('touchmove', function (ev) {
        return thisB.touchMoveHandler(ev);
    }, false);
    this.tierHolderHolder.addEventListener('touchend', function (ev) {
        return thisB.touchEndHandler(ev);
    }, false);
    this.tierHolderHolder.addEventListener('touchcancel', function (ev) {
        return thisB.touchCancelHandler(ev);
    }, false);

    var keyHandler = function keyHandler(ev) {
        // console.log('cbkh: ' + ev.keyCode);
        if (ev.keyCode == 13) {
            // enter
            var layoutsChanged = false;
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                var t = thisB.tiers[ti];
                if (t.wantedLayoutHeight && t.wantedLayoutHeight != t.layoutHeight) {
                    t.layoutHeight = t.wantedLayoutHeight;
                    t.clipTier();
                    layoutsChanged = true;
                }
            }
            if (layoutsChanged) {
                thisB.arrangeTiers();
            }
        } else if (ev.keyCode == 32 || ev.charCode == 32) {
            // space
            if (!thisB.isSnapZooming) {
                thisB.isSnapZooming = true;
                var newZoom = (thisB.savedZoom || 0.0) + thisB.zoomMin;
                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;
                thisB.zoomSliderValue = newZoom;
                thisB.zoom(Math.exp(1.0 * newZoom / thisB.zoomExpt));
            } else {
                thisB.isSnapZooming = false;
                var newZoom = (thisB.savedZoom || 20.0) + thisB.zoomMin;
                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;
                thisB.zoomSliderValue = newZoom;
                thisB.zoom(Math.exp(1.0 * newZoom / thisB.zoomExpt));
            }
            ev.stopPropagation();ev.preventDefault();
        } else if (ev.keyCode == 85) {
            // u
            if (thisB.uiMode === 'opts') {
                // if the options are visible, toggle the checkbox too
                var check = document.getElementById("singleBaseHightlightButton").checked;
                document.getElementById("singleBaseHightlightButton").checked = !check;
            }
            thisB.singleBaseHighlight = !thisB.singleBaseHighlight;
            thisB.positionRuler();
            ev.stopPropagation();ev.preventDefault();
        } else if (ev.keyCode == 39) {
            // right arrow
            ev.stopPropagation();ev.preventDefault();
            thisB.scrollArrowKey(ev, -1);
        } else if (ev.keyCode == 37) {
            // left arrow
            ev.stopPropagation();ev.preventDefault();
            thisB.scrollArrowKey(ev, 1);
        } else if (ev.keyCode == 38 || ev.keyCode == 87) {
            // up arrow | w
            ev.stopPropagation();ev.preventDefault();

            if (ev.shiftKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];
                var ch = tt.forceHeight || tt.subtiers[0].height;
                if (ch >= 40) {
                    tt.mergeConfig({ height: ch - 10 });
                }
            } else if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];

                if (tt.quantLeapThreshold) {
                    var th = tt.subtiers[0].height;
                    var tq = tt.subtiers[0].quant;
                    if (!tq) return;

                    var qmin = 1.0 * tq.min;
                    var qmax = 1.0 * tq.max;

                    var qscale = (qmax - qmin) / th;
                    tt.mergeConfig({ quantLeapThreshold: qmin + ((Math.round((tt.quantLeapThreshold - qmin) / qscale) | 0) + 1) * qscale });

                    tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));
                }
            } else if (ev.altKey) {
                var cnt = thisB.selectedTiers.length;
                if (cnt == 0) return;

                var st = thisB.selectedTiers[0];
                var contiguous = true;
                var mt = [];
                for (var si = 0; si < thisB.selectedTiers.length; ++si) {
                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);
                    if (si > 0 && thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] != 1) contiguous = false;
                }

                if (contiguous && st <= 0) return;

                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si) {
                    thisB.tiers.splice(thisB.selectedTiers[si], 1);
                }thisB.selectedTiers.splice(0, cnt);

                var ip = contiguous ? st - 1 : st;
                for (var si = 0; si < mt.length; ++si) {
                    thisB.tiers.splice(ip + si, 0, mt[si]);
                    thisB.selectedTiers.push(ip + si);
                }

                thisB.withPreservedSelection(thisB._ensureTiersGrouped);
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();
                thisB.reorderTiers();
                thisB.notifyTier("selected", st);
            } else {
                var st = thisB.getSelectedTier();
                if (st > 0) {
                    thisB.setSelectedTier(st - 1);
                    var nst = thisB.tiers[thisB.getSelectedTier()];
                    var top = nst.row.offsetTop,
                        bottom = top + nst.row.offsetHeight;
                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {
                        thisB.tierHolder.scrollTop = top;
                    }
                } else {
                    thisB.notifyTierSelectionWrap(-1);
                }
            }
        } else if (ev.keyCode == 40 || ev.keyCode == 83) {
            // down arrow | s
            ev.stopPropagation();ev.preventDefault();

            if (ev.shiftKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];
                var ch = tt.forceHeight || tt.subtiers[0].height;
                tt.mergeConfig({ height: ch + 10 });
            } else if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];

                if (tt.quantLeapThreshold) {
                    var th = tt.subtiers[0].height;
                    var tq = tt.subtiers[0].quant;
                    if (!tq) return;

                    var qmin = 1.0 * tq.min;
                    var qmax = 1.0 * tq.max;
                    var qscale = (qmax - qmin) / th;

                    var it = Math.round((tt.quantLeapThreshold - qmin) / qscale) | 0;
                    if (it > 1) {
                        tt.mergeConfig({ quantLeapThreshold: qmin + (it - 1) * qscale });
                        tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));
                    }
                }
            } else if (ev.altKey) {
                var cnt = thisB.selectedTiers.length;
                if (cnt == 0) return;

                var st = thisB.selectedTiers[0];
                var discontig = 0;
                var mt = [];
                for (var si = 0; si < thisB.selectedTiers.length; ++si) {
                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);
                    if (si > 0) discontig += thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] - 1;
                }
                var contiguous = discontig == 0;

                if (contiguous && st + cnt >= thisB.tiers.length) return;

                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si) {
                    thisB.tiers.splice(thisB.selectedTiers[si], 1);
                }thisB.selectedTiers.splice(0, cnt);

                var ip = contiguous ? st + 1 : st + discontig;
                for (var si = 0; si < mt.length; ++si) {
                    thisB.tiers.splice(ip + si, 0, mt[si]);
                    thisB.selectedTiers.push(ip + si);
                }

                thisB.withPreservedSelection(function () {
                    thisB._ensureTiersGrouped(true);
                });
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();
                thisB.reorderTiers();
                thisB.notifyTier("selected", st);
            } else {
                var st = thisB.getSelectedTier();
                if (st < thisB.tiers.length - 1) {
                    thisB.setSelectedTier(st + 1);
                    var nst = thisB.tiers[thisB.getSelectedTier()];
                    var top = nst.row.offsetTop,
                        bottom = top + nst.row.offsetHeight;
                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {
                        thisB.tierHolder.scrollTop = Math.min(top, bottom - thisB.tierHolder.offsetHeight);
                    }
                }
            }
        } else if (ev.keyCode == 187 || ev.keyCode == 61) {
            // +
            ev.stopPropagation();ev.preventDefault();
            thisB.zoomStep(-10);
        } else if (ev.keyCode == 189 || ev.keyCode == 173) {
            // -
            ev.stopPropagation();ev.preventDefault();
            thisB.zoomStep(10);
        } else if (ev.keyCode == 73 || ev.keyCode == 105) {
            // i
            ev.stopPropagation();ev.preventDefault();
            var st = thisB.getSelectedTier();
            if (st < 0) return;
            var t = thisB.tiers[st];
            if (!t.infoVisible) {
                t.infoElement.style.display = 'block';
                t.updateHeight();
                t.infoVisible = true;
            } else {
                t.infoElement.style.display = 'none';
                t.updateHeight();
                t.infoVisible = false;
            }
        } else if (ev.keyCode == 84 || ev.keyCode == 116) {
            // t
            var bumpStatus;
            if (ev.shiftKey) {
                ev.stopPropagation();ev.preventDefault();
                for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                    var t = thisB.tiers[ti];
                    if (t.dasSource.collapseSuperGroups) {
                        if (bumpStatus === undefined) {
                            bumpStatus = !t.bumped;
                        }
                        t.mergeConfig({ bumped: bumpStatus });
                    }
                }
            } else if (!ev.ctrlKey && !ev.metaKey) {
                ev.stopPropagation();ev.preventDefault();
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var t = thisB.tiers[st];

                if (t.dasSource.collapseSuperGroups) {
                    if (bumpStatus === undefined) {
                        bumpStatus = !t.bumped;
                    }
                    t.mergeConfig({ bumped: bumpStatus });
                }
            }
        } else if (ev.keyCode == 77 || ev.keyCode == 109) {
            // m
            ev.stopPropagation();ev.preventDefault();
            if ((ev.ctrlKey || ev.metaKey) && thisB.selectedTiers.length > 1) {
                thisB.mergeSelectedTiers();
            }
        } else if (ev.keyCode == 68 || ev.keyCode == 100) {
            // d
            ev.stopPropagation();ev.preventDefault();
            if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                thisB.addTier(thisB.tiers[st].dasSource);
            }
        } else if (ev.keyCode == 80 || ev.keyCode == 112) {
            // p
            if (ev.ctrlKey || ev.metaKey) {
                // Need to be careful because order of tiers could change
                // once we start updating pinning.
                var tt = [];
                for (var st = 0; st < thisB.selectedTiers.length; ++st) {
                    tt.push(thisB.tiers[thisB.selectedTiers[st]]);
                }
                for (var ti = 0; ti < tt.length; ++ti) {
                    tt[ti].mergeConfig({ pinned: !tt[ti].pinned });
                }
            }
        } else {
            // console.log('key: ' + ev.keyCode + '; char: ' + ev.charCode);
        }
    };

    this.browserHolder.addEventListener('focus', function (ev) {
        thisB.browserHolder.addEventListener('keydown', keyHandler, false);
    }, false);
    this.browserHolder.addEventListener('blur', function (ev) {
        thisB.browserHolder.removeEventListener('keydown', keyHandler, false);
    }, false);

    // Popup support (does this really belong here? FIXME)
    this.hPopupHolder = makeElement('div');
    this.hPopupHolder.style['font-family'] = 'helvetica';
    this.hPopupHolder.style['font-size'] = '12pt';
    this.hPopupHolder.classList.add('dalliance');
    document.body.appendChild(this.hPopupHolder);

    for (var t = 0; t < this.sources.length; ++t) {
        var source = this.sources[t];
        if (!source) continue;

        var config = {};
        if (this.restoredConfigs) {
            config = this.restoredConfigs[t];
        }

        if (!source.disabled) {
            this.makeTier(source, config).then(function (tier) {
                thisB.refreshTier(tier);
            });
        }
    }

    if (this.onFirstRender) {
        Promise.all(this.tiers.map(function (t) {
            return t.firstRenderPromise;
        })).then(function () {
            return _this.onFirstRender();
        }).catch(function (err) {
            return console.log(err);
        });
    }

    thisB._ensureTiersGrouped();
    thisB.arrangeTiers();
    thisB.reorderTiers();

    var ss = this.getSequenceSource();
    if (ss) {
        ss.getSeqInfo(this.chr, function (si) {
            if (si) thisB.currentSeqMax = si.length;else thisB.currentSeqMax = -1;
        });
    }

    this.queryRegistry();
    for (var m in this.chains) {
        this.queryRegistry(m, true);
    }

    if (this.hubs) {
        for (var hi = 0; hi < this.hubs.length; ++hi) {
            var hc = this.hubs[hi];
            if (typeof hc == 'string') {
                hc = { url: hc };
            };

            (function (hc) {
                connectTrackHub(hc.url, function (hub, err) {
                    if (err) {
                        console.log(err);
                    } else {
                        var tdb;
                        if (hc.genome) tdb = hub.genomes[hc.genome];else tdb = hub.genomes[thisB.coordSystem.ucscName];

                        if (tdb) {
                            if (hc.mapping) tdb.mapping = hc.mapping;
                            if (hc.label) tdb.hub.altLabel = hc.label;
                            thisB.hubObjects.push(tdb);
                        }
                    }
                }, hc);
            })(hc);
        }
    }

    if (this.fullScreen) {
        this.setFullScreenHeight();
    }

    if (!this.statusRestored && this.storeStatus) {
        this.storeStatus();
    }

    thisB.setLocation(this.chr, this.viewStart, this.viewEnd, function () {
        thisB.setSelectedTier(1);
        // Ping any init listeners.
        for (var ii = 0; ii < thisB.initListeners.length; ++ii) {
            try {
                thisB.initListeners[ii].call(thisB);
            } catch (e) {
                console.log(e);
            }
        }
    });
};

//
// Touch event support
//

Browser.prototype.touchStartHandler = function (ev) {
    // Events not consumed so they can be interpretted as clicks as well.

    this.touchOriginX = ev.touches[0].pageX;
    this.touchOriginY = ev.touches[0].pageY;
    if (ev.touches.length == 2) {
        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);
        this.zooming = true;
        this.zoomLastSep = this.zoomInitialSep = sep;
        this.zoomInitialScale = this.scale;
    }
};

Browser.prototype.touchMoveHandler = function (ev) {
    // These events *are* consumed to ensure we never get any dragging that
    // we don't manage ourselves.

    ev.stopPropagation();ev.preventDefault();

    if (ev.touches.length == 1) {
        var touchX = ev.touches[0].pageX;
        var touchY = ev.touches[0].pageY;
        if (this.touchOriginX && touchX != this.touchOriginX) {
            this.move(touchX - this.touchOriginX);
        }
        if (this.touchOriginY && touchY != this.touchOriginY) {
            this.tierHolder.scrollTop -= touchY - this.touchOriginY;
        }
        this.touchOriginX = touchX;
        this.touchOriginY = touchY;
    } else if (this.zooming && ev.touches.length == 2) {
        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);
        if (sep != this.zoomLastSep) {
            var cp = (ev.touches[0].pageX + ev.touches[1].pageX) / 2;
            var scp = this.viewStart + cp / this.scale | 0;
            this.scale = this.zoomInitialScale * (sep / this.zoomInitialSep);
            this.viewStart = scp - cp / this.scale | 0;
            for (var i = 0; i < this.tiers.length; ++i) {
                tiers[i].getRenderer().drawTier(tiers[i]);
            }
        }
        this.zoomLastSep = sep;
    }
};

Browser.prototype.touchEndHandler = function (ev) {};

Browser.prototype.touchCancelHandler = function (ev) {};

Browser.prototype.makeTier = function (source, config) {
    try {
        return this.realMakeTier(source, config);
    } catch (e) {
        console.log('Error initializing', source);
        console.log(e.stack || e);
    }
};

Browser.prototype.realMakeTier = function (source, config) {
    var thisB = this;
    var background = null;
    if (this.tierBackgroundColors) {
        background = this.tierBackgroundColors[this.tiers.length % this.tierBackgroundColors.length];
    }

    var tier = new DasTier(this, source, config, background);
    tier.oorigin = this.viewStart;

    var isDragging = false;
    var dragOrigin, dragMoveOrigin;
    var hoverTimeout;

    var featureLookup = function featureLookup(rx, ry) {
        var st = tier.subtiers;
        if (!st) {
            return;
        }

        var sti = 0;
        ry -= tier.padding;;
        while (sti < st.length && ry > st[sti].height && sti < st.length - 1) {
            ry = ry - st[sti].height - tier.padding;
            ++sti;
        }
        if (sti >= st.length) {
            return;
        }

        var glyphs = st[sti].glyphs;
        var viewCenter = (thisB.viewStart + thisB.viewEnd) / 2;
        var offset = (tier.glyphCacheOrigin - thisB.viewStart) * thisB.scale;
        rx -= offset;

        return glyphLookup(glyphs, rx, ry);
    };

    var dragMoveHandler = function dragMoveHandler(ev) {
        ev.preventDefault();ev.stopPropagation();
        var rx = ev.clientX;
        if (rx != dragMoveOrigin) {
            thisB.move(rx - dragMoveOrigin, true);
            dragMoveOrigin = rx;
        }
        thisB.isDragging = true;
    };

    var dragUpHandler = function dragUpHandler(ev) {
        window.removeEventListener('mousemove', dragMoveHandler, true);
        window.removeEventListener('mouseup', dragUpHandler, true);
        thisB.move(ev.clientX - dragMoveOrigin); // Snap back (FIXME: consider animation)
    };

    tier.viewport.addEventListener('mousedown', function (ev) {
        thisB.browserHolder.focus();
        ev.preventDefault();
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX,
            ry = ev.clientY;

        window.addEventListener('mousemove', dragMoveHandler, true);
        window.addEventListener('mouseup', dragUpHandler, true);
        dragOrigin = dragMoveOrigin = rx;
        thisB.isDragging = false; // Not dragging until a movement event arrives.
    }, false);

    tier.viewport.addEventListener('mousemove', function (ev) {
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX - br.left,
            ry = ev.clientY - br.top;

        var hit = featureLookup(rx, ry);
        if (hit && hit.length > 0) {
            tier.row.style.cursor = 'pointer';
        } else {
            tier.row.style.cursor = 'default';
        }

        if (hoverTimeout) {
            clearTimeout(hoverTimeout);
        }

        if (isDragging) {
            // if (tier.dasSource.tier_type !== 'sequence' && rx != dragMoveOrigin) {
            //    thisB.move((rx - dragMoveOrigin));
            //    dragMoveOrigin = rx;
            // }
        } else {
            hoverTimeout = setTimeout(function () {
                var hit = featureLookup(rx, ry);
                if (hit && hit.length > 0) {
                    thisB.notifyFeatureHover(ev, hit[hit.length - 1], hit, tier);
                }
            }, 1000);
        }
    });

    var doubleClickTimeout = null;
    tier.viewport.addEventListener('mouseup', function (ev) {
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX - br.left,
            ry = ev.clientY - br.top;

        var hit = featureLookup(rx, ry);
        if (hit && hit.length > 0 && !thisB.isDragging) {
            if (doubleClickTimeout) {
                clearTimeout(doubleClickTimeout);
                doubleClickTimeout = null;
                thisB.featureDoubleClick(hit, rx, ry);
            } else {
                doubleClickTimeout = setTimeout(function () {
                    doubleClickTimeout = null;
                    thisB.notifyFeature(ev, hit[hit.length - 1], hit, tier);
                }, 500);
            }
        }

        if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
            var a = thisB.viewStart + rx / thisB.scale;
            var b = thisB.viewStart + dragOrigin / thisB.scale;

            var min, max;
            if (a < b) {
                min = a | 0;max = b | 0;
            } else {
                min = b | 0;max = a | 0;
            }

            thisB.notifyRegionSelect(thisB.chr, min, max);
        }
        thisB.isDragging = false;
    }, false);

    tier.viewport.addEventListener('mouseout', function (ev) {
        isDragging = false;
    });

    tier.removeButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        for (var ti = 0; ti < thisB.tiers.length; ++ti) {
            if (thisB.tiers[ti] === tier) {
                thisB.removeTier({ index: ti });
                break;
            }
        }
    }, false);
    tier.nameButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        if (ev.shiftKey) {
            var hitTier = -1;
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    hitTier = ti;
                    break;
                }
            }
            if (hitTier >= 0) {
                var i = thisB.selectedTiers.indexOf(hitTier);
                if (i >= 0) {
                    thisB.selectedTiers.splice(i, 1);
                } else {
                    thisB.selectedTiers.push(hitTier);
                    thisB.selectedTiers.sort();
                }
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();

                if (thisB.selectedTiers.length > 0) {
                    thisB.browserHolder.focus();
                } else {
                    thisB.notifyTierSelectionWrap(-1);
                }
            }
        } else {
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    thisB.browserHolder.focus();
                    if (thisB.selectedTiers.length != 1 || thisB.selectedTiers[0] != ti) {
                        thisB.setSelectedTier(ti);
                        return;
                    }
                }
            }

            if (!tier.infoVisible) {
                tier.infoElement.style.display = 'block';
                tier.updateHeight();
                tier.infoVisible = true;
            } else {
                tier.infoElement.style.display = 'none';
                tier.updateHeight();
                tier.infoVisible = false;
            }
        }
    }, false);
    tier.bumpButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        var bumpStatus;
        var t = tier;
        if (t.dasSource.collapseSuperGroups) {
            if (bumpStatus === undefined) {
                bumpStatus = !t.bumped;
            }
            t.mergeConfig({ bumped: bumpStatus });
        }
    }, false);

    var dragLabel;
    var dragTierHolder;
    var dragTierHolderScrollLimit;
    var tierOrdinal;
    var yAtLastReorder;
    var tiersWereReordered = false;

    var labelDragHandler = function labelDragHandler(ev) {
        var label = tier.label;

        ev.stopPropagation();ev.preventDefault();
        if (!dragLabel) {
            if (tier.pinned) {
                dragTierHolder = thisB.pinnedTierHolder;
            } else {
                dragTierHolder = thisB.tierHolder;
            }
            dragTierHolderScrollLimit = dragTierHolder.scrollHeight - dragTierHolder.offsetHeight;

            dragLabel = label.cloneNode(true);
            dragLabel.style.cursor = 'pointer';
            dragTierHolder.appendChild(dragLabel);
            label.style.visibility = 'hidden';

            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    tierOrdinal = ti;
                    break;
                }
            }

            yAtLastReorder = ev.clientY;
        }

        var holderBCR = dragTierHolder.getBoundingClientRect();
        dragLabel.style.left = label.getBoundingClientRect().left - holderBCR.left + 'px';
        dragLabel.style.top = ev.clientY - holderBCR.top + dragTierHolder.scrollTop - 10 + 'px';

        var pty = ev.clientY - holderBCR.top + dragTierHolder.scrollTop;
        for (var ti = 0; ti < thisB.tiers.length; ++ti) {
            var tt = thisB.tiers[ti];
            if (tt.pinned ^ tier.pinned) continue;

            var ttr = tt.row.getBoundingClientRect();
            pty -= ttr.bottom - ttr.top;
            if (pty < 0) {
                if (ti < tierOrdinal && ev.clientY < yAtLastReorder || ti > tierOrdinal && ev.clientY > yAtLastReorder) {
                    thisB.withPreservedSelection(function () {
                        thisB.tiers.splice(tierOrdinal, 1);
                        thisB.tiers.splice(ti, 0, tier);
                        thisB._ensureTiersGrouped(ti > tierOrdinal);
                    });

                    for (var tix = 0; tix < thisB.tiers.length; ++tix) {
                        if (thisB.tiers[tix] == tier) tierOrdinal = tix;
                    }yAtLastReorder = ev.clientY;
                    thisB.reorderTiers();
                    dragTierHolder.appendChild(dragLabel); // Because reorderTiers removes all children.
                    tiersWereReordered = true;
                }
                break;
            }
        }

        if (dragLabel.offsetTop < dragTierHolder.scrollTop) {
            dragTierHolder.scrollTop -= dragTierHolder.scrollTop - dragLabel.offsetTop;
        } else if (dragLabel.offsetTop + dragLabel.offsetHeight > dragTierHolder.scrollTop + dragTierHolder.offsetHeight) {
            dragTierHolder.scrollTop = Math.min(dragTierHolder.scrollTop + (dragLabel.offsetTop + dragLabel.offsetHeight) - (dragTierHolder.scrollTop + dragTierHolder.offsetHeight), dragTierHolderScrollLimit);
        }
    };

    var labelReleaseHandler = function labelReleaseHandler(ev) {
        var label = tier.label;

        ev.stopPropagation();ev.preventDefault();
        if (dragLabel) {
            dragLabel.style.cursor = 'auto';
            dragTierHolder.removeChild(dragLabel);
            dragLabel = null;
            label.style.visibility = 'visible';
        }
        document.removeEventListener('mousemove', labelDragHandler, false);
        document.removeEventListener('mouseup', labelReleaseHandler, false);

        if (tiersWereReordered) {
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] == tier) {
                    thisB.setSelectedTier(ti);
                    break;
                }
            }
            thisB.notifyTier("reordered", tier);
        }
    };

    tier.label.addEventListener('mousedown', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        tiersWereReordered = false;
        document.addEventListener('mousemove', labelDragHandler, false);
        document.addEventListener('mouseup', labelReleaseHandler, false);
    }, false);

    this.tiers.push(tier); // NB this currently tells any extant knownSpace about the new tier.

    // fetches stylesheet
    return tier.init().then(function (updatedTier) {
        updatedTier.currentlyHeight = 50;
        thisB.updateHeight();
        updatedTier.updateLabel();

        thisB.withPreservedSelection(thisB._ensureTiersGrouped);
        updatedTier._updateFromConfig();
        thisB.reorderTiers();

        return updatedTier;
    });
};

Browser.prototype.reorderTiers = function () {
    removeChildren(this.tierHolder);
    removeChildren(this.pinnedTierHolder);
    if (this.disablePinning) {
        this.tierHolder.appendChild(this.ruler);
        this.tierHolder.appendChild(this.ruler2);
    }
    var hasPinned = false;
    var pinnedTiers = [],
        unpinnedTiers = [];
    for (var i = 0; i < this.tiers.length; ++i) {
        var t = this.tiers[i];
        var hasHiddenRenderer = ['sub', 'dummy'].indexOf(this.tiers[i].dasSource.renderer) !== -1;
        if (t.pinned && !this.disablePinning) {
            pinnedTiers.push(t);
            if (!hasHiddenRenderer || !this.tiers[i].dasSource.hidden) this.pinnedTierHolder.appendChild(this.tiers[i].row);
            hasPinned = true;
        } else {
            unpinnedTiers.push(t);
            if (!hasHiddenRenderer || !this.tiers[i].dasSource.hidden) this.tierHolder.appendChild(this.tiers[i].row);
        }
    }

    this.withPreservedSelection(function () {
        this.tiers.splice(0, this.tiers.length);
        for (var i = 0; i < pinnedTiers.length; ++i) {
            this.tiers.push(pinnedTiers[i]);
        }for (var i = 0; i < unpinnedTiers.length; ++i) {
            this.tiers.push(unpinnedTiers[i]);
        }
    });

    if (hasPinned) this.pinnedTierHolder.classList.add('tier-holder-pinned-full');else this.pinnedTierHolder.classList.remove('tier-holder-pinned-full');

    this.arrangeTiers();
};

Browser.prototype.withPreservedSelection = function (f) {
    var st = [];
    for (var xi = 0; xi < this.selectedTiers.length; ++xi) {
        st.push(this.tiers[this.selectedTiers[xi]]);
    }

    f.call(this);

    this.selectedTiers = [];
    for (var sti = 0; sti < this.tiers.length; ++sti) {
        if (st.indexOf(this.tiers[sti]) >= 0) this.selectedTiers.push(sti);
    }
};

Browser.prototype.refreshTier = function (tier, tierCallback) {
    var renderer = this.getTierRenderer(tier);
    if (tier.dasSource.renderer === 'multi') {
        renderer.drawTier(tier);
    } else {
        var renderCallback = tierCallback || renderer.renderTier;
        if (this.knownSpace) {
            this.knownSpace.invalidate(tier, renderCallback);
        }
    }
};

Browser.prototype.getTierRenderer = function (tier) {
    var renderer = tier.dasSource.renderer || this.defaultRenderer;
    if (typeof renderer === 'string') {
        return this.renderers[renderer];
    } else if (typeof renderer.renderTier === 'function' && typeof renderer.drawTier === 'function') {
        return renderer;
    } else {
        console.log("Tier doesn't have a renderer");
    }
};

/* Internal use only, assumes selection is being managed elsewhere... */

Browser.prototype._ensureTiersGrouped = function (down) {
    var groupedTiers = {};
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.dasSource.tierGroup) {
            pusho(groupedTiers, t.dasSource.tierGroup, t);
        }
    }

    var newTiers = [];
    if (down) this.tiers.reverse();
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.dasSource.tierGroup) {
            var nt = groupedTiers[t.dasSource.tierGroup];
            if (nt) {
                if (down) nt.reverse();
                for (var nti = 0; nti < nt.length; ++nti) {
                    newTiers.push(nt[nti]);
                }groupedTiers[t.dasSource.tierGroup] = null;
            }
        } else {
            newTiers.push(t);
        }
    }
    if (down) newTiers.reverse();
    this.tiers.splice(0, this.tiers.length);
    for (var nti = 0; nti < newTiers.length; ++nti) {
        this.tiers.push(newTiers[nti]);
    }
};

Browser.prototype.arrangeTiers = function () {
    var arrangedTiers = [];
    var groupedTiers = {};

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.pinned) {
            arrangedTiers.push(t);
            if (t.dasSource.tierGroup) {
                pusho(groupedTiers, t.dasSource.tierGroup, t);
            }
        }
    }
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (!t.pinned) {
            arrangedTiers.push(t);
            if (t.dasSource.tierGroup) {
                pusho(groupedTiers, t.dasSource.tierGroup, t);
            }
        }
    }

    for (var g in groupedTiers) {
        var tiers = groupedTiers[g];
        var tierGroup = this.tierGroups[g];
        if (!tierGroup) {
            tierGroup = {
                element: makeElement('div', makeElement('span', g, { className: 'tier-group-label' }), { className: "tier-group" })
            };
            this.tierGroups[g] = tierGroup;
        }

        if (tierGroup.element.parentNode) tierGroup.element.parentNode.removeChild(tierGroup.element);

        var holder = tiers[0].pinned ? this.pinnedTierHolder : this.tierHolder;
        var min = 10000000,
            max = 0;
        for (var ti = 0; ti < tiers.length; ++ti) {
            var row = tiers[ti].row;
            min = Math.min(min, row.offsetTop);
            max = Math.max(max, row.offsetTop + row.offsetHeight);
        }
        tierGroup.element.style.top = min + 'px';
        tierGroup.element.style.left = '0px';
        tierGroup.element.style.height = max - min + 'px';
        holder.appendChild(tierGroup.element);
    }

    if (this.tierBackgroundColors) {
        for (var ti = 0; ti < arrangedTiers.length; ++ti) {
            var t = arrangedTiers[ti];
            t.setBackground(this.tierBackgroundColors[ti % this.tierBackgroundColors.length]);
            if (t.dasSource.tierGroup) t.label.style.left = '18px';else t.label.style.left = '2px';
            t.background = this.tierBackgroundColors[ti % this.tierBackgroundColors.length];
        }
    }
};

Browser.prototype.refresh = function () {
    this.retrieveTierData(this.tiers);
    this.drawOverlays();
    this.positionRuler();
};

var defaultTierRenderer = function defaultTierRenderer(status, tier) {
    console.log("DEPRECATED!");
};

Browser.prototype.retrieveTierData = function (tiers) {
    this.notifyLocation();
    var width = this.viewEnd - this.viewStart + 1;
    var minExtraW = this.minExtraWidth / this.scale | 0;
    var maxExtraW = this.maxExtraWidth / this.scale | 0;

    var newOrigin = (this.viewStart + this.viewEnd) / 2;
    var oh = newOrigin - this.origin;
    this.origin = newOrigin;
    this.scaleAtLastRedraw = this.scale;
    for (var t = 0; t < tiers.length; ++t) {
        var od = oh;
        if (tiers[t].originHaxx) {
            od += tiers[t].originHaxx;
        }
        tiers[t].originHaxx = od;
    }

    var scaledQuantRes = this.targetQuantRes / this.scale;

    var innerDrawnStart = Math.max(1, (this.viewStart | 0) - minExtraW);
    var innerDrawnEnd = Math.min((this.viewEnd | 0) + minExtraW, (this.currentSeqMax | 0) > 0 ? this.currentSeqMax | 0 : 1000000000);
    var outerDrawnStart = Math.max(1, (this.viewStart | 0) - maxExtraW);
    var outerDrawnEnd = Math.min((this.viewEnd | 0) + maxExtraW, (this.currentSeqMax | 0) > 0 ? this.currentSeqMax | 0 : 1000000000);

    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {
        var ss = this.getSequenceSource();
        if (this.knownSpace) this.knownSpace.cancel();
        // known space is created based on the entire tier list, for future caching purposes, even if only a subset of the tiers are needed to be rendered now.
        this.knownSpace = new KnownSpace(this.tiers, this.chr, outerDrawnStart, outerDrawnEnd, scaledQuantRes, ss);
    }

    var seg = this.knownSpace.bestCacheOverlapping(this.chr, innerDrawnStart, innerDrawnEnd);
    if (seg && seg.min <= innerDrawnStart && seg.max >= innerDrawnEnd) {
        this.drawnStart = Math.max(seg.min, outerDrawnStart);
        this.drawnEnd = Math.min(seg.max, outerDrawnEnd);
    } else {
        this.drawnStart = outerDrawnStart;
        this.drawnEnd = outerDrawnEnd;
    }

    // send in the subset of tiers to retrieve.
    this.knownSpace.retrieveFeatures(tiers, this.chr, this.drawnStart, this.drawnEnd, scaledQuantRes);
};

function setSources(msh, availableSources, maybeMapping) {
    if (maybeMapping) {
        for (var s = 0; s < availableSources.length; ++s) {
            availableSources[s].mapping = maybeMapping;
        }
    }
    msh.set(availableSources);
}

Browser.prototype.queryRegistry = function (maybeMapping, tryCache) {
    if (!this.registry) return;

    var thisB = this;
    var coords, msh;
    if (maybeMapping) {
        coords = this.chains[maybeMapping].coords;
        if (!thisB.mappableSources[maybeMapping]) {
            thisB.mappableSources[maybeMapping] = new Observed();
        }
        msh = thisB.mappableSources[maybeMapping];
    } else {
        coords = this.coordSystem;
        msh = this.availableSources;
    }
    var cacheHash = hex_sha1(miniJSONify(coords));
    if (tryCache) {
        var cacheTime = localStorage['dalliance.registry.' + cacheHash + '.last_queried'];
        if (cacheTime) {
            try {
                setSources(msh, JSON.parse(localStorage['dalliance.registry.' + cacheHash + '.sources']), maybeMapping);
                var cacheAge = (Date.now() | 0) - (cacheTime | 0);
                if (cacheAge < 12 * 60 * 60 * 1000) {
                    return;
                }
            } catch (rex) {
                console.log('Bad registry cache: ' + rex);
            }
        }
    }

    var rurl = this.registry;
    if (rurl.indexOf('//') == 0) {
        var proto = window.location.protocol;
        if (proto != 'https:' && proto != 'http:') rurl = 'http:' + rurl;
    }
    new DASRegistry(rurl).sources(function (sources) {
        var availableSources = [];
        for (var s = 0; s < sources.length; ++s) {
            var source = sources[s];
            if (!source.coords || source.coords.length == 0) {
                continue;
            }
            var scoords = source.coords[0];
            if (scoords.taxon != coords.taxon || scoords.auth != coords.auth || scoords.version != coords.version) {
                continue;
            }
            availableSources.push(source);
        }

        localStorage['dalliance.registry.' + cacheHash + '.sources'] = JSON.stringify(availableSources);
        localStorage['dalliance.registry.' + cacheHash + '.last_queried'] = '' + Date.now();

        setSources(msh, availableSources, maybeMapping);
    }, function (error) {
        // msh.set(null);
    }, coords);
};

//
// Navigation
//

Browser.prototype.move = function (pos, soft) {
    var wid = this.viewEnd - this.viewStart;
    var nStart = this.viewStart - 1.0 * pos / this.scale;
    var nEnd = nStart + wid;

    if (!soft) {
        if (this.currentSeqMax > 0 && nEnd > this.currentSeqMax) {
            nEnd = this.currentSeqMax;
            nStart = this.viewEnd - wid;
        }
        if (nStart < 1) {
            nStart = 1;
            nEnd = nStart + wid;
        }
    }

    this.setLocation(null, nStart, nEnd, null, soft);
};

Browser.prototype.zoomStep = function (delta) {
    var oz = 1.0 * this.zoomSliderValue;
    var nz = oz + delta;
    if (nz < this.zoomMin) {
        nz = this.zoomMin;
    }
    if (nz > this.zoomMax) {
        nz = this.zoomMax;
    }

    if (nz != oz) {
        this.zoomSliderValue = nz; // FIXME maybe ought to set inside zoom!
        this.zoom(Math.exp(1.0 * nz / this.zoomExpt));
    }
};

Browser.prototype.zoom = function (factor) {
    this.zoomFactor = factor;
    var viewCenter = Math.round((this.viewStart + this.viewEnd) / 2.0) | 0;
    this.viewStart = viewCenter - this.zoomBase * this.zoomFactor / 2;
    this.viewEnd = viewCenter + this.zoomBase * this.zoomFactor / 2;
    if (this.currentSeqMax > 0 && this.viewEnd > this.currentSeqMax + 5) {
        var len = this.viewEnd - this.viewStart + 1;
        this.viewEnd = this.currentSeqMax;
        this.viewStart = this.viewEnd - len + 1;
    }
    if (this.viewStart < 1) {
        var len = this.viewEnd - this.viewStart + 1;
        this.viewStart = 1;
        this.viewEnd = this.viewStart + len - 1;
    }
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);
    var width = this.viewEnd - this.viewStart + 1;

    var scaleRat = this.scale / this.scaleAtLastRedraw;

    this.notifyLocation();
    this.refresh();
};

Browser.prototype.spaceCheck = function (dontRefresh) {
    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {
        this.refresh();
        return;
    }

    var width = (this.viewEnd - this.viewStart | 0) + 1;
    var minExtraW = this.minExtraWidth / this.scale | 0;
    var maxExtraW = this.maxExtraWidth / this.scale | 0;

    if ((this.drawnStart | 0) > Math.max(1, (this.viewStart | 0) - minExtraW | 0) || (this.drawnEnd | 0) < Math.min((this.viewEnd | 0) + minExtraW, (this.currentSeqMax | 0) > 0 ? this.currentSeqMax | 0 : 1000000000)) {
        this.refresh();
    }
};

Browser.prototype.resizeViewer = function (skipRefresh) {
    var width = this.tierHolder.getBoundingClientRect().width | 0;
    if (width == 0) return;

    var oldFPW = Math.max(this.featurePanelWidth, 300); // Can get silly values stored
    // when the browser is hidden.
    this.featurePanelWidth = width | 0;

    if (oldFPW != this.featurePanelWidth) {
        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);
        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase); // FIXME hard-coded minimum.
        this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

        var viewWidth = this.viewEnd - this.viewStart;
        var nve = this.viewStart + viewWidth * this.featurePanelWidth / oldFPW;

        this.viewEnd = nve;

        var wid = this.viewEnd - this.viewStart + 1;
        if (this.currentSeqMax > 0 && this.viewEnd > this.currentSeqMax) {
            this.viewEnd = this.currentSeqMax;
            this.viewStart = this.viewEnd - wid + 1;
        }
        if (this.viewStart < 1) {
            this.viewStart = 1;
            this.viewEnd = this.viewStart + wid - 1;
        }

        this.positionRuler();

        if (!skipRefresh) {
            this.spaceCheck();
        }
        this.notifyLocation();
    }

    if (this.fullScreen) {
        this.setFullScreenHeight();
    }
};

Browser.prototype.setFullScreenHeight = function () {
    var rest = document.body.offsetHeight - this.browserHolder.offsetHeight;
    this.browserHolder.style.maxHeight = Math.max(300, window.innerHeight - rest - 20) + 'px';
};

Browser.prototype.addTier = function (conf) {
    var thisB = this;
    conf = shallowCopy(conf);
    conf.disabled = false;

    return this.makeTier(conf).then(function (tier) {
        thisB.refreshTier(tier);
        thisB.markSelectedTiers();
        thisB.positionRuler();
        thisB.notifyTier("added", tier);
        return tier;
    });
};

Browser.prototype.removeTier = function (conf, force) {
    var target = -1;

    if (typeof conf.index !== 'undefined' && conf.index >= 0 && conf.index < this.tiers.length) {
        target = conf.index;
    } else {
        for (var ti = 0; ti < this.tiers.length; ++ti) {
            var ts = this.tiers[ti].dasSource;

            if (sourcesAreEqual(conf, ts)) {
                target = ti;break;
            }
        }
    }

    if (target < 0) {
        throw "Couldn't find requested tier";
    }

    var targetTier = this.tiers[target];
    this.tiers.splice(target, 1);

    var nst = [];
    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {
        var st = this.selectedTiers[sti];
        if (st < target) {
            nst.push(st);
        } else if (st > target) {
            nst.push(st - 1);
        }
    }
    this.selectedTiers = nst;
    this.markSelectedTiers();

    targetTier.destroy();
    if (this.knownSpace) {
        this.knownSpace.featureCache[targetTier] = null;
    }

    this.reorderTiers();
    this.notifyTier("removed", targetTier);
};

Browser.prototype.removeAllTiers = function () {
    var thisB = this;
    this.selectedTiers = [];
    this.markSelectedTiers();
    this.tiers.forEach(function (targetTier) {
        targetTier.destroy();
        if (thisB.knownSpace) {
            thisB.knownSpace.featureCache[targetTier] = null;
        }
    });
    this.tiers.length = 0;
    this.reorderTiers();
    this.notifyTier("removedAll", null);
};

Browser.prototype.getSequenceSource = function () {
    if (this._sequenceSource === undefined) this._sequenceSource = this._getSequenceSource();
    return this._sequenceSource;
};

Browser.prototype._getSequenceSource = function () {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (this.tiers[ti].sequenceSource) {
            return this.tiers[ti].sequenceSource;
        }
    }

    for (var si = 0; si < this.defaultSources.length; ++si) {
        var s = this.defaultSources[si];
        if (s.provides_entrypoints || s.tier_type == 'sequence' || s.twoBitURI || s.twoBitBlob) {
            if (s.twoBitURI || s.twoBitBlob) {
                return new TwoBitSequenceSource(s);
            } else if (s.ensemblURI) {
                return new EnsemblSequenceSource(s);
            } else {
                return new DASSequenceSource(s);
            }
        }
    }
};

Browser.prototype.setLocation = function (newChr, newMin, newMax, callback, soft) {
    if (typeof newMin !== 'number') {
        throw Error('minimum must be a number (got ' + JSON.stringify(newMin) + ')');
    }
    if (typeof newMax !== 'number') {
        throw Error('maximum must be a number (got ' + JSON.stringify(newMax) + ')');
    }

    if (newMin > newMax) {
        var oldNewMin = newMin;
        newMin = newMax;
        newMax = oldNewMin;
    } else if (newMin === newMax) {
        newMax += 1;
    }

    if (!callback) {
        callback = function callback(err) {
            if (err) {
                throw err;
            }
        };
    }
    var thisB = this;

    if ((!newChr || newChr == this.chr) && this.currentSeqMax > 0) {
        return this._setLocation(null, newMin, newMax, null, callback, soft);
    } else {
        var ss = this.getSequenceSource();
        if (!ss) {
            return callback('Need a sequence source');
        }

        var findChr = newChr || this.chr;
        ss.getSeqInfo(findChr, function (si) {
            if (!si) {
                var altChr;
                if (findChr.indexOf('chr') == 0) {
                    altChr = findChr.substr(3);
                } else {
                    altChr = 'chr' + findChr;
                }
                ss.getSeqInfo(altChr, function (si2) {
                    if (!si2 && newChr) {
                        return callback("Couldn't find sequence '" + newChr + "'");
                    } else if (!si2) {
                        return thisB._setLocation(null, newMin, newMax, null, callback, soft);
                    } else {
                        return thisB._setLocation(altChr, newMin, newMax, si2, callback, soft);
                    }
                });
            } else {
                return thisB._setLocation(newChr, newMin, newMax, si, callback, soft);
            }
        });
    }
};

Browser.prototype._setLocation = function (newChr, newMin, newMax, newChrInfo, callback, soft) {
    var chrChanged = false;
    if (newChr) {
        if (newChr.indexOf('chr') == 0) newChr = newChr.substring(3);

        if (this.chr != newChr) chrChanged = true;

        console.log("new chr: " + newChr);
        console.log("old chr: " + this.chr);
        this.chr = newChr;
        this.currentSeqMax = newChrInfo.length;
    }

    newMin = parseFloat(newMin);newMax = parseFloat(newMax);

    var newWidth = Math.max(10, newMax - newMin + 1);

    if (!soft) {
        var csm = this.currentSeqMax;
        if (csm <= 0) csm = 1000000000000;
        if (newMin < 1) {
            newMin = 1;newMax = newMin + newWidth - 1;
        }
        if (newMax > csm) {
            newMax = csm;
            newMin = Math.max(1, newMax - newWidth + 1);
        }
    }

    this.viewStart = newMin;
    this.viewEnd = newMax;
    var newScale = Math.max(this.featurePanelWidth || this.offscreenInitWidth, 50) / (this.viewEnd - this.viewStart);
    var oldScale = this.scale;
    var scaleChanged = Math.abs(newScale - oldScale) > 0.000001;
    this.scale = newScale;

    var newZS, oldZS;
    oldZS = this.zoomSliderValue;
    this.zoomSliderValue = newZS = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

    if (scaleChanged || chrChanged) {
        for (var i = 0; i < this.tiers.length; ++i) {
            this.tiers[i].viewportHolder.style.left = '5000px';
            this.tiers[i].overlay.style.left = '5000px';
        }

        this.refresh();

        if (this.savedZoom) {
            newZS -= this.zoomMin;
            oldZS -= this.zoomMin;
            var difToActive = newZS - oldZS;
            var difToSaved = newZS - this.savedZoom;
            if (Math.abs(difToActive) > Math.abs(difToSaved)) {
                this.isSnapZooming = !this.isSnapZooming;
                this.savedZoom = oldZS;
            }
        } else {
            this.isSnapZooming = false;
            this.savedZoom = null;
        }
    } else {
        var viewCenter = (this.viewStart + this.viewEnd) / 2;

        for (var i = 0; i < this.tiers.length; ++i) {
            var offset = (this.viewStart - this.tiers[i].norigin) * this.scale;
            this.tiers[i].viewportHolder.style.left = '' + ((-offset | 0) - 1000) + 'px';
            this.tiers[i].drawOverlay();
        }
    }

    this.notifyLocation();

    this.spaceCheck();
    if (this.instrumentActivity) this.activityStartTime = Date.now() | 0;

    // this.refresh();
    return callback();
};

Browser.prototype.setCenterLocation = function (newChr, newCenterLoc) {
    var halfWidth = (this.viewEnd - this.viewStart) / 2,
        newMin = newCenterLoc - halfWidth,
        newMax = newCenterLoc + halfWidth;
    this.setLocation(newChr, newMin, newMax);
};

Browser.prototype.pingActivity = function () {
    if (!this.instrumentActivity || !this.activityStartTime) return;

    var activity = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (this.tiers[ti].loaderButton.style.display !== 'none') ++activity;
    }

    if (activity == 0) {
        var now = Date.now() | 0;
        console.log('Loading took ' + (now - this.activityStartTime) + 'ms');
        this.activityStartTime = null;
    }
};

Browser.prototype.addInitListener = function (handler) {
    this.initListeners.push(handler);
};

Browser.prototype.addFeatureListener = function (handler, opts) {
    opts = opts || {};
    this.featureListeners.push(handler);
};

Browser.prototype.removeFeatureListener = function (handler, opts) {
    var idx = arrayIndexOf(this.featureListeners, handler);
    if (idx >= 0) {
        this.featureListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyFeature = function (ev, feature, hit, tier) {
    for (var fli = 0; fli < this.featureListeners.length; ++fli) {
        try {
            if (this.featureListeners[fli](ev, feature, hit, tier)) return;
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addFeatureHoverListener = function (handler, opts) {
    opts = opts || {};
    this.featureHoverListeners.push(handler);
};

Browser.prototype.removeFeatureHoverListener = function (handler, opts) {
    var idx = arrayIndexOf(this.featureHoverListeners, handler);
    if (idx >= 0) {
        this.featureHoverListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyFeatureHover = function (ev, feature, hit, tier) {
    for (var fli = 0; fli < this.featureHoverListeners.length; ++fli) {
        try {
            this.featureHoverListeners[fli](ev, feature, hit, tier);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addViewListener = function (handler, opts) {
    opts = opts || {};
    this.viewListeners.push(handler);
};

Browser.prototype.removeViewListener = function (handler, opts) {
    var idx = arrayIndexOf(this.viewListeners, handler);
    if (idx >= 0) {
        this.viewListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyLocation = function () {
    var nvs = Math.max(1, this.viewStart | 0);
    var nve = this.viewEnd | 0;
    if (this.currentSeqMax > 0 && nve > this.currentSeqMax) nve = this.currentSeqMax;

    for (var lli = 0; lli < this.viewListeners.length; ++lli) {
        try {
            this.viewListeners[lli](this.chr, nvs, nve, this.zoomSliderValue, { current: this.zoomSliderValue,
                alternate: this.savedZoom + this.zoomMin || this.zoomMin,
                isSnapZooming: this.isSnapZooming,
                min: this.zoomMin,
                max: this.zoomMax }, this.viewStart, this.viewEnd);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addTierListener = function (handler) {
    this.tierListeners.push(handler);
};

Browser.prototype.removeTierListener = function (handler) {
    var idx = arrayIndexOf(this.tierListeners, handler);
    if (idx >= 0) {
        this.tierListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyTier = function (status, tier) {
    for (var tli = 0; tli < this.tierListeners.length; ++tli) {
        try {
            this.tierListeners[tli](status, tier);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addRegionSelectListener = function (handler) {
    this.regionSelectListeners.push(handler);
};

Browser.prototype.removeRegionSelectListener = function (handler) {
    var idx = arrayIndexOf(this.regionSelectListeners, handler);
    if (idx >= 0) {
        this.regionSelectListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyRegionSelect = function (chr, min, max) {
    for (var rli = 0; rli < this.regionSelectListeners.length; ++rli) {
        try {
            this.regionSelectListeners[rli](chr, min, max);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.highlightRegion = function (chr, min, max) {
    var thisB = this;

    if (chr == this.chr) {
        return this._highlightRegion(chr, min, max);
    }

    var ss = this.getSequenceSource();
    if (!ss) {
        throw 'Need a sequence source';
    }

    ss.getSeqInfo(chr, function (si) {
        if (!si) {
            var altChr;
            if (chr.indexOf('chr') == 0) {
                altChr = chr.substr(3);
            } else {
                altChr = 'chr' + chr;
            }
            ss.getSeqInfo(altChr, function (si2) {
                if (!si2) {
                    // Fail silently.
                } else {
                    return thisB._highlightRegion(altChr, min, max);
                }
            });
        } else {
            return thisB._highlightRegion(chr, min, max);
        }
    });
};

Browser.prototype._highlightRegion = function (chr, min, max) {
    for (var hi = 0; hi < this.highlights.length; ++hi) {
        var h = this.highlights[hi];
        if (h.chr == chr && h.min == min && h.max == max) return;
    }

    this.highlights.push(new Region(chr, min, max));
    var visStart = this.viewStart - 1000 / this.scale;
    var visEnd = this.viewEnd + 1000 / this.scale;
    if ((chr == this.chr || chr == 'chr' + this.chr) && min < visEnd && max > visStart) {
        this.drawOverlays();
    }

    this.notifyLocation();
};

Browser.prototype.clearHighlights = function () {
    this.highlights = [];
    this.drawOverlays();
    this.notifyLocation();
};

Browser.prototype.drawOverlays = function () {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        this.tiers[ti].drawOverlay();
    }
};

Browser.prototype.featuresInRegion = function (chr, min, max) {
    var features = [];
    if (chr !== this.chr) {
        return [];
    }

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var fl = this.tiers[ti].currentFeatures || [];
        for (var fi = 0; fi < fl.length; ++fi) {
            var f = fl[fi];
            if (f.min <= max && f.max >= min) {
                features.push(f);
            }
        }
    }
    return features;
};

Browser.prototype.getSelectedTier = function () {
    if (this.selectedTiers.length > 0) return this.selectedTiers[0];else return -1;
};

Browser.prototype.setSelectedTier = function (t) {
    if (t == null) {
        this.selectedTiers = [];
    } else {
        this.selectedTiers = [t];
    }
    this.markSelectedTiers();
    this.notifyTierSelection();
};

Browser.prototype.markSelectedTiers = function () {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var button = this.tiers[ti].nameButton;

        if (this.selectedTiers.indexOf(ti) >= 0) {
            button.classList.add('active');
        } else {
            button.classList.remove('active');
        }
    }
    if (this.selectedTiers.length > 0) {
        var browserMid = this.browserHolder.offsetTop + this.browserHolder.offsetHeight / 2;
        if (browserMid > document.body.scrollTop && browserMid + 100 < document.body.scrollTop + window.innerHeight) this.browserHolder.focus();
    }
};

Browser.prototype.addTierSelectionListener = function (handler) {
    this.tierSelectionListeners.push(handler);
};

Browser.prototype.removeTierSelectionListener = function (handler) {
    var idx = arrayIndexOf(this.tierSelectionListeners, handler);
    if (idx >= 0) {
        this.tierSelectionListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyTierSelection = function () {
    for (var fli = 0; fli < this.tierSelectionListeners.length; ++fli) {
        try {
            this.tierSelectionListeners[fli](this.selectedTiers);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addTierSelectionWrapListener = function (f) {
    this.tierSelectionWrapListeners.push(f);
};

Browser.prototype.removeTierSelectionWrapListener = function (handler) {
    var idx = arrayIndexOf(this.tierSelectionWrapListeners, handler);
    if (idx >= 0) {
        this.tierSelectionWrapListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyTierSelectionWrap = function (i) {
    for (var fli = 0; fli < this.tierSelectionWrapListeners.length; ++fli) {
        try {
            this.tierSelectionWrapListeners[fli](i);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.positionRuler = function () {
    var display = 'none';
    var left = '';
    var right = '';

    if (this.rulerLocation == 'center') {
        display = 'block';
        left = '' + (this.featurePanelWidth / 2 | 0) + 'px';
    } else if (this.rulerLocation == 'left') {
        display = 'block';
        left = '0px';
    } else if (this.rulerLocation == 'right') {
        display = 'block';
        right = '0px';
    } else {
        display = 'none';
    }

    this.ruler.style.display = display;
    this.ruler.style.left = left;
    this.ruler.style.right = right;

    if (this.singleBaseHighlight) {
        this.ruler2.style.display = 'block';
        this.ruler2.style.borderWidth = '1px';
        if (this.scale < 1) {
            this.ruler2.style.width = '0px';
            this.ruler2.style.borderRightWidth = '0px';
        } else {
            this.ruler2.style.width = this.scale + 'px';
            this.ruler2.style.borderRightWidth = '1px';
        }
        // Position accompanying single base location text
        this.locSingleBase.style.visibility = 'visible';
        var centreOffset = this.featurePanelWidth / 2 - this.locSingleBase.offsetWidth / 2 + this.ruler2.offsetWidth / 2;
        this.locSingleBase.style.left = '' + (centreOffset | 0) + 'px';
    } else {
        this.locSingleBase.style.visibility = 'hidden';
        this.ruler2.style.width = '1px';
        this.ruler2.style.borderWidth = '0px';
        this.ruler2.style.display = this.rulerLocation == 'center' ? 'none' : 'block';
    }

    this.ruler2.style.left = '' + (this.featurePanelWidth / 2 | 0) + 'px';

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var q = tier.quantOverlay;

        var quant;
        if (tier.subtiers && tier.subtiers.length > 0) quant = tier.subtiers[0].quant;

        if (q) {
            q.style.display = quant ? display : 'none';
            q.style.left = left;
            q.style.right = right;
        }
    }
};

Browser.prototype.featureDoubleClick = function (hit, rx, ry) {
    if (!hit || hit.length == 0) return;

    var f = hit[hit.length - 1];

    if (!f.min || !f.max) {
        return;
    }

    var fstart = ((f.min | 0) - (this.viewStart | 0)) * this.scale;
    var fwidth = (f.max - f.min + 1) * this.scale;

    var newMid = ((f.min | 0) + (f.max | 0)) / 2;
    if (fwidth > 10) {
        var frac = 1.0 * (rx - fstart) / fwidth;
        if (frac < 0.3) {
            newMid = f.min | 0;
        } else if (frac > 0.7) {
            newMid = (f.max | 0) + 1;
        }
    }

    var width = this.viewEnd - this.viewStart;
    this.setLocation(null, newMid - width / 2, newMid + width / 2);
};

Browser.prototype.zoomForScale = function (scale) {
    var ssScale;
    if (scale > this.highZoomThreshold) {
        ssScale = 'high';
    } else if (scale > this.mediumZoomThreshold) {
        ssScale = 'medium';
    } else {
        ssScale = 'low';
    }
    return ssScale;
};

Browser.prototype.zoomForCurrentScale = function () {
    return this.zoomForScale(this.scale);
};

Browser.prototype.updateHeight = function () {
    var tierTotal = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        tierTotal += this.tiers[ti].currentHeight || 30;
    }this.ruler.style.height = '' + tierTotal + 'px';
    this.ruler2.style.height = '' + tierTotal + 'px';
    this.browserHolder.style.display = 'block';
    this.browserHolder.style.display = '-webkit-flex';
    this.browserHolder.style.display = 'flex';
    // this.svgHolder.style.maxHeight = '' + Math.max(tierTotal, 500) + 'px';
};

Browser.prototype.scrollArrowKey = function (ev, dir) {
    if (this.reverseKeyScrolling) dir = -dir;

    if (ev.ctrlKey || ev.metaKey) {
        var fedge = false;
        if (ev.shiftKey) {
            fedge = true;
        }

        this.leap(dir, fedge);
    } else if (this.scale > 1) {
        // per-base scrolling mode, tries to perfectly center.
        var mid = (this.viewStart + this.viewEnd) / 2;
        var err = mid - Math.round(mid);
        var n = 1;
        if (ev.shiftKey) n *= 10;
        if (dir > 0) {
            n = -n;
            n -= err;
            if (err > 0) n += 1;
        } else {
            n -= err;
            if (err < 0) n -= 1;
        }
        this.setLocation(null, this.viewStart + n, this.viewEnd + n);
    } else {
        this.move(ev.shiftKey ? 100 * dir : 25 * dir);
    }
};

Browser.prototype.leap = function (dir, fedge) {
    var thisB = this;
    var pos = (thisB.viewStart + thisB.viewEnd + 1) / 2 | 0;
    if (dir > 0 && thisB.viewStart <= 1) {
        pos -= 100000000;
    } else if (dir < 0 && thisB.viewEnd >= thisB.currentSeqMax) {
        pos += 100000000;
    }

    var st = thisB.getSelectedTier();
    if (st < 0) return;
    var tier = thisB.tiers[st];

    if (tier && (tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof tier.quantLeapThreshold == 'number' || tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'leap'))) {
        tier.findNextFeature(thisB.chr, pos, -dir, fedge, function (nxt) {
            if (nxt) {
                var nmin = nxt.min;
                var nmax = nxt.max;
                if (fedge) {
                    if (dir > 0) {
                        if (nmin > pos + 1) {
                            nmax = nmin;
                        } else {
                            nmax++;
                            nmin = nmax;
                        }
                    } else {
                        if (nmax < pos - 1) {
                            nmax++;
                            nmin = nmax;
                        } else {
                            nmax = nmin;
                        }
                    }
                }
                var wid = thisB.viewEnd - thisB.viewStart + 1;
                if (parseFloat(wid / 2) == parseInt(wid / 2)) {
                    wid--;
                }
                var newStart = (nmin + nmax - wid) / 2 + 1;
                var newEnd = newStart + wid - 1;
                var pos2 = pos;
                thisB.setLocation(nxt.segment, newStart, newEnd);
            } else {
                alert('no next feature'); // FIXME better reporting would be nice!
            }
        });
    } else {
        this.move(100 * dir);
    }
};

function glyphLookup(glyphs, rx, ry, matches) {
    matches = matches || [];

    for (var gi = glyphs.length - 1; gi >= 0; --gi) {
        var g = glyphs[gi];
        if (!g.notSelectable && g.min() <= rx && g.max() >= rx) {
            if (g.minY) {
                if (ry < g.minY() || ry > g.maxY()) continue;
            }

            if (g.feature) {
                matches.push(g.feature);
            } else if (g.group) {
                matches.push(g.group);
            }

            if (g.glyphs) {
                return glyphLookup(g.glyphs, rx, ry, matches);
            } else if (g.glyph) {
                return glyphLookup([g.glyph], rx, ry, matches);
            } else {
                return matches;
            }
        }
    }
    return matches;
}

Browser.prototype.nameForCoordSystem = function (cs) {
    var primary = null,
        ucsc = null;
    if (this.assemblyNamePrimary) {
        primary = '' + cs.auth;
        if (typeof cs.version !== 'undefined') primary += cs.version;
    }
    if (this.assemblyNameUcsc) {
        ucsc = cs.ucscName;
    }
    if (primary != null && ucsc != null) return primary + '/' + ucsc;else return primary || ucsc || 'unknown';
};

Browser.prototype.makeLoader = function (size) {
    size = size || 16;
    var retina = window.devicePixelRatio > 1;
    if (size < 20) {
        return makeElement('img', null, { src: this.resolveURL('$$img/spinner_' + (retina ? 16 : 32) + '.gif'), width: '16', height: '16' });
    } else {
        return makeElement('img', null, { src: this.resolveURL('$$img/spinner_' + (retina ? 24 : 48) + '.gif'), width: '24', height: '24' });
    }
};

Browser.prototype.canFetchPlainHTTP = function () {
    var self = this;
    if (!this._plainHTTPPromise) {
        var worker = this.getWorker();
        if (worker) {
            this._plainHTTPPromise = new Promise(function (resolve, reject) {
                worker.postCommand({ command: 'textxhr',
                    uri: self.httpCanaryURL }, function (result, err) {
                    if (result) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                });
            });
        } else {
            this._plainHTTPPromise = new Promise(function (resolve, reject) {
                textXHR(self.httpCanaryURL, function (result, err) {
                    if (result) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                }, { timeout: 2000 });
            });
        }
    }
    return this._plainHTTPPromise;
};

Browser.prototype.getWorker = function () {
    if (!this.useFetchWorkers || !this.fetchWorkers || this.fetchWorkers.length == 0) return null;

    if (this.nextWorker >= this.fetchWorkers.length) this.nextWorker = 0;
    return this.fetchWorkers[this.nextWorker++];
};

Browser.prototype.registerResolver = function (resolver) {
    var id = 'res' + ++this.resolverSeed;
    this.resolvers[id] = resolver;
    return id;
};

function FetchWorker(browser, worker) {
    var thisB = this;
    this.tagSeed = 0;
    this.callbacks = {};
    this.browser = browser;
    this.worker = worker;

    this.worker.onmessage = function (ev) {
        var data = ev.data;

        if (!data.cmd) {
            var cb = thisB.callbacks[data.tag];
            if (cb) {
                cb(data.result, data.error);
                delete thisB.callbacks[data.tag];
            }
        } else if (data.cmd == 'resolve') {
            var resolver = thisB.browser.resolvers[data.resolver];
            if (resolver) {
                resolver(data.url).then(function (url) {
                    thisB.worker.postMessage({
                        tag: data.tag,
                        url: url
                    });
                }).catch(function (err) {
                    console.log(err);
                    thisB.worker.postMessage({
                        tag: data.tag,
                        err: err.toString()
                    });
                });
            } else {
                console.log('No resolver ' + data.resolver);
            }
        } else {
            console.log('Bad worker callback ' + data.cmd);
        }
    };
}

function makeFetchWorker(browser) {
    var wurl = browser.resolveURL(browser.workerPath);
    if (wurl.indexOf('//') == 0) {
        var proto = window.location.protocol;
        if (proto == 'https:') wurl = 'https:' + wurl;else wurl = 'http:' + wurl;
    }

    var wscript = 'importScripts("' + wurl + '?version=' + VERSION + '");';
    var wblob = new Blob([wscript], { type: 'application/javascript' });

    return new Promise(function (resolve, reject) {
        var worker = new Worker(URL.createObjectURL(wblob));

        worker.onmessage = function (ev) {
            if (ev.data.tag === 'init') {
                console.log('Worker initialized');
                resolve(new FetchWorker(browser, worker));
            }
        };

        worker.onerror = function (ev) {
            reject(ev.message);
        };
    });
}

FetchWorker.prototype.postCommand = function (cmd, callback, transfer) {
    var tag = 'x' + ++this.tagSeed;
    cmd.tag = tag;
    this.callbacks[tag] = callback;
    this.worker.postMessage(cmd, transfer);
};

FetchWorker.prototype.terminate = function () {
    this.worker.terminate();
};

if (typeof module !== 'undefined') {
    module.exports = {
        Browser: Browser
    };

    // Required because they add stuff to Browser.prototype
    require('./browser-ui');
    require('./track-adder');
    require('./feature-popup');
    require('./tier-actions');
    require('./domui');
    require('./search');

    var sa = require('./sourceadapters');
    var TwoBitSequenceSource = sa.TwoBitSequenceSource;
    var EnsemblSequenceSource = sa.EnsemblSequenceSource;
    var DASSequenceSource = sa.DASSequenceSource;

    var KnownSpace = require('./kspace').KnownSpace;

    var DASRegistry = require('./das').DASRegistry;
}

function SourceCache() {
    this.sourcesByURI = {};
}

SourceCache.prototype.get = function (conf) {
    var scb = this.sourcesByURI[sourceDataURI(conf)];
    if (scb) {
        for (var si = 0; si < scb.configs.length; ++si) {
            if (sourcesAreEqualModuloStyle(scb.configs[si], conf)) {
                return scb.sources[si];
            }
        }
    }
};

SourceCache.prototype.put = function (conf, source) {
    var uri = sourceDataURI(conf);
    var scb = this.sourcesByURI[uri];
    if (!scb) {
        scb = { configs: [], sources: [] };
        this.sourcesByURI[uri] = scb;
    }
    scb.configs.push(conf);
    scb.sources.push(source);
};

},{"./browser-ui":5,"./chainset":7,"./das":11,"./default-renderer":12,"./domui":13,"./dummy-renderer":14,"./feature-popup":22,"./kspace":26,"./multi-renderer":29,"./numformats":30,"./search":37,"./sha1":40,"./sourceadapters":41,"./sourcecompare":42,"./sub-renderer":45,"./thub":51,"./tier":54,"./tier-actions":52,"./track-adder":55,"./utils":58,"./version":60,"es6-promise":63}],7:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// chainset.js: liftover support
//

"use strict";

if (typeof require !== 'undefined') {
    var das = require('./das');
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;

    var utils = require('./utils');
    var pusho = utils.pusho;
    var shallowCopy = utils.shallowCopy;

    var parseCigar = require('./cigar').parseCigar;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;

    var bbi = require('./bigwig');
    var makeBwg = bbi.makeBwg;

    var Promise = require('es6-promise').Promise;
}

function Chainset(conf, srcTag, destTag, coords) {
    if (typeof conf == 'string') {
        this.uri = conf;
        this.srcTag = srcTag;
        this.destTag = destTag;
        this.coords = coords;
    } else {
        this.uri = conf.uri;
        this.srcTag = conf.srcTag;
        this.destTag = conf.destTag;
        this.coords = shallowCopy(conf.coords);
        this.type = conf.type;
        this.credentials = conf.credentials;
    }

    this.chainsBySrc = {};
    this.chainsByDest = {};
    this.postFetchQueues = {};
    this.fetchedTiles = {};
    this.granularity = 1000000; // size in bases of tile to fetch

    if (this.type == 'bigbed') {
        this.chainFetcher = new BBIChainFetcher(this.uri, this.credentials);
    } else if (this.type == 'alias') {
        this.chainFetcher = new AliasChainFetcher(conf);
    } else {
        this.chainFetcher = new DASChainFetcher(this.uri, this.srcTag, this.destTag);
    }
};

Chainset.prototype.exportConfig = function () {
    return {
        uri: this.uri,
        srcTag: this.srcTag,
        destTag: this.destTag,
        coords: this.coords,
        type: this.type,
        credentials: this.credentials
    };
};

Chainset.prototype.mapPoint = function (chr, pos) {
    var chains = this.chainsBySrc[chr] || [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (pos >= c.srcMin && pos <= c.srcMax) {
            var cpos;
            if (c.srcOri == '-') {
                cpos = c.srcMax - pos;
            } else {
                cpos = pos - c.srcMin;
            }
            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];
                if (cpos >= bSrc && cpos <= bSrc + bSize) {
                    var apos = cpos - bSrc;

                    var dpos;
                    if (c.destOri == '-') {
                        dpos = c.destMax - bDest - apos;
                    } else {
                        dpos = apos + bDest + c.destMin;
                    }
                    return { seq: c.destChr, pos: dpos, flipped: c.srcOri != c.destOri };
                }
            }
        }
    }
    return null;
};

Chainset.prototype.mapSegment = function (chr, min, max) {
    var chains = this.chainsBySrc[chr] || [];
    var mappings = [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (max >= c.srcMin && min <= c.srcMax) {
            var cmin, cmax;
            if (c.srcOri == '-') {
                cmin = c.srcMax - max;
                cmax = c.srcMax - min;
            } else {
                cmin = min - c.srcMin;
                cmax = max - c.srcMin;
            }
            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];
                if (cmax >= bSrc && cmin <= bSrc + bSize) {
                    var m = {
                        segment: c.destChr,
                        flipped: c.srcOri == '-' ^ c.destOri == '-' };

                    if (c.destOri == '-') {
                        if (cmin >= bSrc) {
                            m.max = c.destMax - bDest - cmin + bSrc;
                        } else {
                            m.max = c.destMax - bDest;
                            m.partialMax = bSrc - cmin;
                        }
                        if (cmax <= bSrc + bSize) {
                            m.min = c.destMax - bDest - cmax + bSrc;
                        } else {
                            m.min = c.destMax - bDest - bSize;
                            m.partialMin = cmax - bSrc - bSize;
                        }
                    } else {
                        if (cmin >= bSrc) {
                            m.min = c.destMin + bDest + cmin - bSrc;
                        } else {
                            m.min = c.destMin + bDest;
                            m.partialMin = bSrc - cmin;
                        }
                        if (cmax <= bSrc + bSize) {
                            m.max = c.destMin + bDest + cmax - bSrc;
                        } else {
                            m.max = c.destMin + bDest + bSize;
                            m.partialMax = cmax - bSrc - bSize;
                        }
                    }
                    mappings.push(m);
                }
            }
        }
    }
    return mappings;
};

Chainset.prototype.unmapPoint = function (chr, pos) {
    var chains = this.chainsByDest[chr] || [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (pos >= c.destMin && pos <= c.destMax) {
            var cpos;
            if (c.srcOri == '-') {
                cpos = c.destMax - pos;
            } else {
                cpos = pos - c.destMin;
            }

            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];

                if (cpos >= bDest && cpos <= bDest + bSize) {
                    var apos = cpos - bDest;

                    var dpos = apos + bSrc + c.srcMin;
                    var dpos;
                    if (c.destOri == '-') {
                        dpos = c.srcMax - bSrc - apos;
                    } else {
                        dpos = apos + bSrc + c.srcMin;
                    }
                    return { seq: c.srcChr, pos: dpos, flipped: c.srcOri != c.destOri };
                }
            }
            // return null;
        }
    }
    return null;
};

Chainset.prototype.sourceBlocksForRange = function (chr, min, max, callback) {
    var STATE_PENDING = 1;
    var STATE_FETCHED = 2;

    var thisCS = this;
    var minTile = min / this.granularity | 0;
    var maxTile = max / this.granularity | 0;

    var needsNewOrPending = false;
    var needsNewFetch = false;
    for (var t = minTile; t <= maxTile; ++t) {
        var tn = chr + '_' + t;
        if (this.fetchedTiles[tn] != STATE_FETCHED) {
            needsNewOrPending = true;
            if (this.fetchedTiles[tn] != STATE_PENDING) {
                this.fetchedTiles[tn] = STATE_PENDING;
                needsNewFetch = true;
            }
        }
    }

    if (needsNewOrPending) {
        if (!this.postFetchQueues[chr]) {
            this.chainFetcher.fetchChains(chr, minTile * this.granularity, (maxTile + 1) * this.granularity - 1).then(function (chains) {
                if (!thisCS.chainsByDest) thisCS.chainsByDest[chr] = [];
                for (var ci = 0; ci < chains.length; ++ci) {
                    var chain = chains[ci];

                    {
                        var cbs = thisCS.chainsBySrc[chain.srcChr];
                        if (!cbs) {
                            thisCS.chainsBySrc[chain.srcChr] = [chain];
                        } else {
                            var present = false;
                            for (var oci = 0; oci < cbs.length; ++oci) {
                                var oc = cbs[oci];
                                if (oc.srcMin == chain.srcMin && oc.srcMax == chain.srcMax) {
                                    present = true;
                                    break;
                                }
                            }
                            if (!present) cbs.push(chain);
                        }
                    }

                    {
                        var cbd = thisCS.chainsByDest[chain.destChr];
                        if (!cbd) {
                            thisCS.chainsByDest[chain.destChr] = [chain];
                        } else {
                            var present = false;
                            for (var oci = 0; oci < cbd.length; ++oci) {
                                var oc = cbd[oci];
                                if (oc.destMin == chain.destMin && oc.destMax == chain.destMax) {
                                    present = true;
                                    break;
                                }
                            }
                            if (!present) cbd.push(chain);
                        }
                    }
                }
                for (var t = minTile; t <= maxTile; ++t) {
                    var tn = chr + '_' + t;
                    thisCS.fetchedTiles[tn] = STATE_FETCHED;
                }
                if (thisCS.postFetchQueues[chr]) {
                    var pfq = thisCS.postFetchQueues[chr];
                    for (var i = 0; i < pfq.length; ++i) {
                        pfq[i]();
                    }
                    thisCS.postFetchQueues[chr] = null;
                }
            }).catch(function (err) {
                console.log(err);
            });
        }

        pusho(this.postFetchQueues, chr, function () {
            // Will either succeed if the tiles that are needed have already been fetched,
            // or queue up a new fetch.

            thisCS.sourceBlocksForRange(chr, min, max, callback);
        });
    } else {
        var srcBlocks = [];
        var chains = this.chainsByDest[chr] || [];
        for (var ci = 0; ci < chains.length; ++ci) {
            var c = chains[ci];
            if (min <= c.destMax && max >= c.destMin) {
                var cmin, cmax;
                if (c.srcOri == '-') {
                    cmin = c.destMax - max;
                    cmax = c.destMax - min;
                } else {
                    cmin = min - c.destMin;
                    cmax = max - c.destMin;
                }

                var blocks = c.blocks;
                for (var bi = 0; bi < blocks.length; ++bi) {
                    var b = blocks[bi];
                    var bSrc = b[0];
                    var bDest = b[1];
                    var bSize = b[2];

                    if (cmax >= bDest && cmin <= bDest + bSize) {
                        var amin = Math.max(cmin, bDest) - bDest;
                        var amax = Math.min(cmax, bDest + bSize) - bDest;

                        if (c.destOri == '-') {
                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMax - bSrc - amax, c.srcMax - bSrc - amin));
                        } else {
                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMin + amin + bSrc, c.srcMin + amax + bSrc));
                        }
                    }
                }
            }
        }
        callback(srcBlocks);
    }
};

function DASChainFetcher(uri, srcTag, destTag) {
    this.source = new DASSource(uri);
    this.srcTag = srcTag;
    this.destTag = destTag;
}

DASChainFetcher.prototype.fetchChains = function (chr, _min, _max) {
    var thisCS = this;

    return new Promise(function (resolve, reject) {
        thisCS.source.alignments(chr, {}, function (aligns) {
            var chains = [];

            for (var ai = 0; ai < aligns.length; ++ai) {
                var aln = aligns[ai];
                for (var bi = 0; bi < aln.blocks.length; ++bi) {
                    var block = aln.blocks[bi];
                    var srcSeg, destSeg;
                    for (var si = 0; si < block.segments.length; ++si) {
                        var seg = block.segments[si];
                        var obj = aln.objects[seg.object];
                        if (obj.dbSource === thisCS.srcTag) {
                            srcSeg = seg;
                        } else if (obj.dbSource === thisCS.destTag) {
                            destSeg = seg;
                        }
                    }
                    if (srcSeg && destSeg) {
                        var chain = {
                            srcChr: aln.objects[srcSeg.object].accession,
                            srcMin: srcSeg.min | 0,
                            srcMax: srcSeg.max | 0,
                            srcOri: srcSeg.strand,
                            destChr: aln.objects[destSeg.object].accession,
                            destMin: destSeg.min | 0,
                            destMax: destSeg.max | 0,
                            destOri: destSeg.strand,
                            blocks: []
                        };

                        var srcops = parseCigar(srcSeg.cigar),
                            destops = parseCigar(destSeg.cigar);

                        var srcOffset = 0,
                            destOffset = 0;
                        var srci = 0,
                            desti = 0;
                        while (srci < srcops.length && desti < destops.length) {
                            if (srcops[srci].op == 'M' && destops[desti].op == 'M') {
                                var blockLen = Math.min(srcops[srci].cnt, destops[desti].cnt);
                                chain.blocks.push([srcOffset, destOffset, blockLen]);
                                if (srcops[srci].cnt == blockLen) {
                                    ++srci;
                                } else {
                                    srcops[srci].cnt -= blockLen;
                                }
                                if (destops[desti].cnt == blockLen) {
                                    ++desti;
                                } else {
                                    destops[desti] -= blockLen;
                                }
                                srcOffset += blockLen;
                                destOffset += blockLen;
                            } else if (srcops[srci].op == 'I') {
                                destOffset += srcops[srci++].cnt;
                            } else if (destops[desti].op == 'I') {
                                srcOffset += destops[desti++].cnt;
                            }
                        }

                        chains.push(chain);
                    }
                }
            }
            resolve(chains);
        });
    });
};

function BBIChainFetcher(uri, credentials) {
    var self = this;
    this.uri = uri;
    this.credentials = credentials;

    this.bwg = new Promise(function (resolve, reject) {
        makeBwg(new URLFetchable(self.uri, { credentials: self.credentials,
            resolver: self.resolver }), function (bwg, err) {
            if (bwg) {
                resolve(bwg);
            } else {
                reject(err);
            }
        });
    });

    this.bwg.then(function (bwg, err) {
        if (err) console.log(err);
    });
}

function pi(x) {
    return parseInt(x);
}

function cleanChr(c) {
    if (c.indexOf('chr') == 0) return c.substr(3);else return c;
}

function bbiFeatureToChain(feature) {
    var chain = {
        srcChr: cleanChr(feature.srcChrom),
        srcMin: parseInt(feature.srcStart),
        srcMax: parseInt(feature.srcEnd),
        srcOri: feature.srcOri,
        destChr: cleanChr(feature.segment),
        destMin: feature.min - 1, // Convert back from bigbed parser
        destMax: feature.max,
        destOri: feature.ori,
        blocks: []
    };
    var srcStarts = feature.srcStarts.split(',').map(pi);
    var destStarts = feature.destStarts.split(',').map(pi);
    var blockLengths = feature.blockLens.split(',').map(pi);
    for (var bi = 0; bi < srcStarts.length; ++bi) {
        chain.blocks.push([srcStarts[bi], destStarts[bi], blockLengths[bi]]);
    }

    return chain;
}

BBIChainFetcher.prototype.fetchChains = function (chr, min, max) {
    return this.bwg.then(function (bwg, err) {
        if (!bwg) throw Error("No BWG");

        return new Promise(function (resolve, reject) {
            bwg.getUnzoomedView().readWigData(chr, min, max, function (feats) {
                resolve(feats.map(bbiFeatureToChain));
            });
        });
    });
};

function AliasChainFetcher(conf) {
    this.conf = conf;
    this.forwardAliases = {};
    var sa = conf.sequenceAliases || [];
    for (var ai = 0; ai < sa.length; ++ai) {
        var al = sa[ai];
        if (al.length < 2) continue;

        var fa = [];
        for (var i = 0; i < al.length - 1; ++i) {
            fa.push(al[i]);
        }this.forwardAliases[al[al.length - 1]] = fa;
    }
}

AliasChainFetcher.prototype.fetchChains = function (chr, min, max) {
    var resp = [];
    var fa = this.forwardAliases[chr] || [];
    for (var i = 0; i < fa.length; ++i) {
        resp.push({
            srcChr: fa[i],
            srcMin: 1,
            srcMax: 1000000000,
            srcOri: '+',
            destChr: chr,
            destMin: 1,
            destMax: 1000000000,
            destOri: '+',
            blocks: [[1, 1, 1000000000]]
        });
    }

    return Promise.resolve(resp);
};

if (typeof module !== 'undefined') {
    module.exports = {
        Chainset: Chainset
    };
}

},{"./bigwig":3,"./bin":4,"./cigar":8,"./das":11,"./utils":58,"es6-promise":63}],8:[function(require,module,exports){
'use strict';

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// chainset.js: liftover support
//

var CIGAR_REGEXP = new RegExp('([0-9]*)([MIDS])', 'g');

function parseCigar(cigar) {
    var cigops = [];
    var match;
    while ((match = CIGAR_REGEXP.exec(cigar)) != null) {
        var count = match[1];
        if (count.length == 0) {
            count = 1;
        }
        cigops.push({ cnt: count | 0, op: match[2] });
    }
    return cigops;
}

if (typeof module !== 'undefined') {
    module.exports = {
        parseCigar: parseCigar
    };
}

},{}],9:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// color.js
//

"use strict";

function DColour(red, green, blue, name) {
    this.red = red | 0;
    this.green = green | 0;
    this.blue = blue | 0;
    if (name) {
        this.name = name;
    }
}

DColour.prototype.toSvgString = function () {
    if (!this.name) {
        this.name = "rgb(" + this.red + "," + this.green + "," + this.blue + ")";
    }

    return this.name;
};

function hex2(x) {
    var y = '00' + x.toString(16);
    return y.substring(y.length - 2);
}

DColour.prototype.toHexString = function () {
    return '#' + hex2(this.red) + hex2(this.green) + hex2(this.blue);
};

var palette = {
    red: new DColour(255, 0, 0, 'red'),
    green: new DColour(0, 255, 0, 'green'),
    blue: new DColour(0, 0, 255, 'blue'),
    yellow: new DColour(255, 255, 0, 'yellow'),
    white: new DColour(255, 255, 255, 'white'),
    black: new DColour(0, 0, 0, 'black'),
    gray: new DColour(180, 180, 180, 'gray'),
    grey: new DColour(180, 180, 180, 'grey'),
    lightskyblue: new DColour(135, 206, 250, 'lightskyblue'),
    lightsalmon: new DColour(255, 160, 122, 'lightsalmon'),
    hotpink: new DColour(255, 105, 180, 'hotpink')
};

var COLOR_RE = new RegExp('^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$');
var CSS_COLOR_RE = /rgb\(([0-9]+),([0-9]+),([0-9]+)\)/;

function dasColourForName(name) {
    var c = palette[name];
    if (!c) {
        var match = COLOR_RE.exec(name);
        if (match) {
            c = new DColour('0x' + match[1] | 0, '0x' + match[2] | 0, '0x' + match[3] | 0, name);
            palette[name] = c;
        } else {
            match = CSS_COLOR_RE.exec(name);
            if (match) {
                c = new DColour(match[1] | 0, match[2] | 0, match[3] | 0, name);
                palette[name] = c;
            } else {
                console.log("couldn't handle color: " + name);
                c = palette.black;
                palette[name] = c;
            }
        }
    }
    return c;
}

function makeColourSteps(steps, stops, colours) {
    var dcolours = [];
    for (var ci = 0; ci < colours.length; ++ci) {
        dcolours.push(dasColourForName(colours[ci]));
    }

    var grad = [];
    STEP_LOOP: for (var si = 0; si < steps; ++si) {
        var rs = 1.0 * si / (steps - 1);
        var score = stops[0] + (stops[stops.length - 1] - stops[0]) * rs;
        for (var i = 0; i < stops.length - 1; ++i) {
            if (score >= stops[i] && score <= stops[i + 1]) {
                var frac = (score - stops[i]) / (stops[i + 1] - stops[i]);
                var ca = dcolours[i];
                var cb = dcolours[i + 1];

                var fill = new DColour(ca.red * (1.0 - frac) + cb.red * frac | 0, ca.green * (1.0 - frac) + cb.green * frac | 0, ca.blue * (1.0 - frac) + cb.blue * frac | 0).toSvgString();
                grad.push(fill);

                continue STEP_LOOP;
            }
        }
        throw 'Bad step';
    }

    return grad;
}

function makeGradient(steps, color1, color2, color3) {
    if (color3) {
        return makeColourSteps(steps, [0, 0.5, 1], [color1, color2, color3]);
    } else {
        return makeColourSteps(steps, [0, 1], [color1, color2]);
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        makeColourSteps: makeColourSteps,
        makeGradient: makeGradient,
        dasColourForName: dasColourForName
    };
}

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadCsv = exports.CsvFile = undefined;

var _papaparse = require("papaparse");

var Papa = _interopRequireWildcard(_papaparse);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.CsvFile = CsvFile;
exports.loadCsv = loadCsv; /* jshint esversion: 6 */

function CsvFile() {}

function loadCsv(uri, options, callback) {
    var csv = new CsvFile();

    csv.uri = uri;
    csv.options = options;

    if (callback) callback(csv);
    return csv;
}

CsvFile.prototype.fetch = function (doneCallback) {
    var config = { download: true,
        header: true,
        error: function error(err, file) {
            if (doneCallback !== undefined) {
                doneCallback(null, err);
            }
        },
        complete: function complete(results, file) {
            if (doneCallback !== undefined) {
                doneCallback(results.data);
            }
        }
    };

    Papa.parse(this.uri, config);
};

},{"papaparse":65}],11:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// das.js: queries and low-level data model.
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
    var pusho = utils.pusho;

    var color = require('./color');
    var makeColourSteps = color.makeColourSteps;
}

var dasLibErrorHandler = function dasLibErrorHandler(errMsg) {
    alert(errMsg);
};
var dasLibRequestQueue = new Array();

function DASSegment(name, start, end, description) {
    this.name = name;
    this.start = start;
    this.end = end;
    this.description = description;
}
DASSegment.prototype.toString = function () {
    return this.name + ':' + this.start + '..' + this.end;
};
DASSegment.prototype.isBounded = function () {
    return this.start && this.end;
};
DASSegment.prototype.toDASQuery = function () {
    var q = 'segment=' + this.name;
    if (this.start && this.end) {
        q += ':' + this.start + ',' + this.end;
    }
    return q;
};

function DASSource(a1, a2) {
    var options;
    if (typeof a1 == 'string') {
        this.uri = a1;
        options = a2 || {};
    } else {
        options = a1 || {};
    }
    for (var k in options) {
        this[k] = options[k];
    }

    if (!this.coords) {
        this.coords = [];
    }
    if (!this.props) {
        this.props = {};
    }

    this.dasBaseURI = this.uri;
    if (this.dasBaseURI && this.dasBaseURI.substr(this.uri.length - 1) != '/') {
        this.dasBaseURI = this.dasBaseURI + '/';
    }
}

DASSource.prototype.getURI = function (uri) {
    if (this.resolver) {
        return this.resolver(uri).then(function (urlOrObj) {
            if (typeof urlOrObj === 'string') {
                return urlOrObj;
            } else {
                return urlOrObj.url;
            }
        });
    } else {
        return Promise.resolve(uri);
    }
};

function DASCoords() {}

function coordsMatch(c1, c2) {
    return c1.taxon == c2.taxon && c1.auth == c2.auth && c1.version == c2.version;
}

//
// DAS 1.6 entry_points command
//

DASSource.prototype.entryPoints = function (callback) {
    var dasURI = this.dasBaseURI + 'entry_points';
    this.doCrossDomainRequest(dasURI, function (responseXML) {
        if (!responseXML) {
            return callback([]);
        }

        var entryPoints = new Array();

        var segs = responseXML.getElementsByTagName('SEGMENT');
        for (var i = 0; i < segs.length; ++i) {
            var seg = segs[i];
            var segId = seg.getAttribute('id');

            var segSize = seg.getAttribute('size');
            var segMin, segMax;
            if (segSize) {
                segMin = 1;segMax = segSize | 0;
            } else {
                segMin = seg.getAttribute('start');
                if (segMin) {
                    segMin |= 0;
                }
                segMax = seg.getAttribute('stop');
                if (segMax) {
                    segMax |= 0;
                }
            }
            var segDesc = null;
            if (seg.firstChild) {
                segDesc = seg.firstChild.nodeValue;
            }
            entryPoints.push(new DASSegment(segId, segMin, segMax, segDesc));
        }
        callback(entryPoints);
    });
};

//
// DAS 1.6 sequence command
// Do we need an option to fall back to the dna command?
//

function DASSequence(name, start, end, alpha, seq) {
    this.name = name;
    this.start = start;
    this.end = end;
    this.alphabet = alpha;
    this.seq = seq;
}

DASSource.prototype.sequence = function (segment, callback) {
    var dasURI = this.dasBaseURI + 'sequence?' + segment.toDASQuery();
    this.doCrossDomainRequest(dasURI, function (responseXML) {
        if (!responseXML) {
            callback([]);
            return;
        } else {
            var seqs = new Array();

            var segs = responseXML.getElementsByTagName('SEQUENCE');
            for (var i = 0; i < segs.length; ++i) {
                var seg = segs[i];
                var segId = seg.getAttribute('id');
                var segMin = seg.getAttribute('start');
                var segMax = seg.getAttribute('stop');
                var segAlpha = 'DNA';
                var segSeq = null;
                if (seg.firstChild) {
                    var rawSeq = seg.firstChild.nodeValue;
                    segSeq = '';
                    var idx = 0;
                    while (true) {
                        var space = rawSeq.indexOf('\n', idx);
                        if (space >= 0) {
                            segSeq += rawSeq.substring(idx, space).toUpperCase();
                            idx = space + 1;
                        } else {
                            segSeq += rawSeq.substring(idx).toUpperCase();
                            break;
                        }
                    }
                }
                seqs.push(new DASSequence(segId, segMin, segMax, segAlpha, segSeq));
            }

            callback(seqs);
        }
    });
};

//
// DAS 1.6 features command
//

function DASFeature() {}

function DASGroup(id) {
    if (id) this.id = id;
}

function DASLink(desc, uri) {
    this.desc = desc;
    this.uri = uri;
}

DASSource.prototype.features = function (segment, options, callback) {
    options = options || {};
    var thisB = this;

    var dasURI;
    if (this.features_uri) {
        dasURI = this.features_uri;
    } else {
        var filters = [];

        if (segment) {
            filters.push(segment.toDASQuery());
        } else if (options.group) {
            var g = options.group;
            if (typeof g == 'string') {
                filters.push('group_id=' + g);
            } else {
                for (var gi = 0; gi < g.length; ++gi) {
                    filters.push('group_id=' + g[gi]);
                }
            }
        }

        if (options.adjacent) {
            var adj = options.adjacent;
            if (typeof adj == 'string') {
                adj = [adj];
            }
            for (var ai = 0; ai < adj.length; ++ai) {
                filters.push('adjacent=' + adj[ai]);
            }
        }

        if (options.type) {
            if (typeof options.type == 'string') {
                filters.push('type=' + options.type);
            } else {
                for (var ti = 0; ti < options.type.length; ++ti) {
                    filters.push('type=' + options.type[ti]);
                }
            }
        }

        if (options.maxbins) {
            filters.push('maxbins=' + options.maxbins);
        }

        if (filters.length > 0) {
            dasURI = this.dasBaseURI + 'features?' + filters.join(';');
        } else {
            callback([], 'No filters specified');
        }
    }

    this.doCrossDomainRequest(dasURI, function (responseXML, req) {
        if (!responseXML) {
            var msg;
            if (req.status == 0) {
                msg = 'server may not support CORS';
            } else {
                msg = 'status=' + req.status;
            }
            callback([], 'Failed request: ' + msg);
            return;
        }
        /*      if (req) {
                    var caps = req.getResponseHeader('X-DAS-Capabilties');
                    if (caps) {
                        alert(caps);
                    }
                } */

        var features = new Array();
        var segmentMap = {};

        var segs = responseXML.getElementsByTagName('SEGMENT');
        for (var si = 0; si < segs.length; ++si) {
            var segmentXML = segs[si];
            var segmentID = segmentXML.getAttribute('id');
            segmentMap[segmentID] = {
                min: segmentXML.getAttribute('start'),
                max: segmentXML.getAttribute('stop')
            };

            var featureXMLs = segmentXML.getElementsByTagName('FEATURE');
            for (var i = 0; i < featureXMLs.length; ++i) {
                var feature = featureXMLs[i];
                var dasFeature = new DASFeature();

                dasFeature.segment = segmentID;
                dasFeature.id = feature.getAttribute('id');
                dasFeature.label = feature.getAttribute('label');

                /*
                                var childNodes = feature.childNodes;
                                for (var c = 0; c < childNodes.length; ++c) {
                                    var cn = childNodes[c];
                                    if (cn.nodeType == Node.ELEMENT_NODE) {
                                        var key = cn.tagName;
                                        //var val = null;
                                        //if (cn.firstChild) {
                                        //   val = cn.firstChild.nodeValue;
                                        //}
                                        dasFeature[key] = 'x';
                                    }
                                } */

                var spos = elementValue(feature, "START");
                var epos = elementValue(feature, "END");
                if ((spos | 0) > (epos | 0)) {
                    dasFeature.min = epos | 0;
                    dasFeature.max = spos | 0;
                } else {
                    dasFeature.min = spos | 0;
                    dasFeature.max = epos | 0;
                }
                {
                    var tec = feature.getElementsByTagName('TYPE');
                    if (tec.length > 0) {
                        var te = tec[0];
                        if (te.firstChild) {
                            dasFeature.type = te.firstChild.nodeValue;
                        }
                        dasFeature.typeId = te.getAttribute('id');
                        dasFeature.typeCv = te.getAttribute('cvId');
                    }
                }
                dasFeature.type = elementValue(feature, "TYPE");
                if (!dasFeature.type && dasFeature.typeId) {
                    dasFeature.type = dasFeature.typeId; // FIXME?
                }

                dasFeature.method = elementValue(feature, "METHOD");
                {
                    var ori = elementValue(feature, "ORIENTATION");
                    if (!ori) {
                        ori = '0';
                    }
                    dasFeature.orientation = ori;
                }
                dasFeature.score = elementValue(feature, "SCORE");
                dasFeature.links = dasLinksOf(feature);
                dasFeature.notes = dasNotesOf(feature);

                var groups = feature.getElementsByTagName("GROUP");
                for (var gi = 0; gi < groups.length; ++gi) {
                    var groupXML = groups[gi];
                    var dasGroup = new DASGroup();
                    dasGroup.type = groupXML.getAttribute('type');
                    dasGroup.id = groupXML.getAttribute('id');
                    dasGroup.links = dasLinksOf(groupXML);
                    dasGroup.notes = dasNotesOf(groupXML);
                    if (!dasFeature.groups) {
                        dasFeature.groups = new Array(dasGroup);
                    } else {
                        dasFeature.groups.push(dasGroup);
                    }
                }

                // Magic notes.  Check with TAD before changing this.
                if (dasFeature.notes) {
                    for (var ni = 0; ni < dasFeature.notes.length; ++ni) {
                        var n = dasFeature.notes[ni];
                        if (n.indexOf('Genename=') == 0) {
                            var gg = new DASGroup();
                            gg.type = 'gene';
                            gg.id = n.substring(9);
                            if (!dasFeature.groups) {
                                dasFeature.groups = new Array(gg);
                            } else {
                                dasFeature.groups.push(gg);
                            }
                        }
                    }
                }

                {
                    var pec = feature.getElementsByTagName('PART');
                    if (pec.length > 0) {
                        var parts = [];
                        for (var pi = 0; pi < pec.length; ++pi) {
                            parts.push(pec[pi].getAttribute('id'));
                        }
                        dasFeature.parts = parts;
                    }
                }
                {
                    var pec = feature.getElementsByTagName('PARENT');
                    if (pec.length > 0) {
                        var parents = [];
                        for (var pi = 0; pi < pec.length; ++pi) {
                            parents.push(pec[pi].getAttribute('id'));
                        }
                        dasFeature.parents = parents;
                    }
                }

                features.push(dasFeature);
            }
        }

        callback(features, undefined, segmentMap);
    }, function (err) {
        callback([], err);
    });
};

function DASAlignment(type) {
    this.type = type;
    this.objects = {};
    this.blocks = [];
}

DASSource.prototype.alignments = function (segment, options, callback) {
    var dasURI = this.dasBaseURI + 'alignment?query=' + segment;
    this.doCrossDomainRequest(dasURI, function (responseXML) {
        if (!responseXML) {
            callback([], 'Failed request ' + dasURI);
            return;
        }

        var alignments = [];
        var aliXMLs = responseXML.getElementsByTagName('alignment');
        for (var ai = 0; ai < aliXMLs.length; ++ai) {
            var aliXML = aliXMLs[ai];
            var ali = new DASAlignment(aliXML.getAttribute('alignType'));
            var objXMLs = aliXML.getElementsByTagName('alignObject');
            for (var oi = 0; oi < objXMLs.length; ++oi) {
                var objXML = objXMLs[oi];
                var obj = {
                    id: objXML.getAttribute('intObjectId'),
                    accession: objXML.getAttribute('dbAccessionId'),
                    version: objXML.getAttribute('objectVersion'),
                    dbSource: objXML.getAttribute('dbSource'),
                    dbVersion: objXML.getAttribute('dbVersion')
                };
                ali.objects[obj.id] = obj;
            }

            var blockXMLs = aliXML.getElementsByTagName('block');
            for (var bi = 0; bi < blockXMLs.length; ++bi) {
                var blockXML = blockXMLs[bi];
                var block = {
                    order: blockXML.getAttribute('blockOrder'),
                    segments: []
                };
                var segXMLs = blockXML.getElementsByTagName('segment');
                for (var si = 0; si < segXMLs.length; ++si) {
                    var segXML = segXMLs[si];
                    var seg = {
                        object: segXML.getAttribute('intObjectId'),
                        min: segXML.getAttribute('start'),
                        max: segXML.getAttribute('end'),
                        strand: segXML.getAttribute('strand'),
                        cigar: elementValue(segXML, 'cigar')
                    };
                    block.segments.push(seg);
                }
                ali.blocks.push(block);
            }

            alignments.push(ali);
        }
        callback(alignments);
    });
};

function DASStylesheet() {
    this.styles = [];
}

DASStylesheet.prototype.pushStyle = function (filters, zoom, style) {
    if (!filters) {
        filters = { type: 'default' };
    }
    var styleHolder = shallowCopy(filters);
    if (zoom) {
        styleHolder.zoom = zoom;
    }
    styleHolder.style = style;
    this.styles.push(styleHolder);
};

function DASStyle() {}

function parseGradient(grad) {
    var steps = grad.getAttribute('steps');
    if (steps) {
        steps = steps | 0;
    } else {
        steps = 50;
    }

    var stops = [];
    var colors = [];
    var se = grad.getElementsByTagName('STOP');
    for (var si = 0; si < se.length; ++si) {
        var stop = se[si];
        stops.push(1.0 * stop.getAttribute('score'));
        colors.push(stop.firstChild.nodeValue);
    }

    return makeColourSteps(steps, stops, colors);
}

DASSource.prototype.stylesheet = function (successCB, failureCB) {
    var dasURI,
        creds = this.credentials;
    if (this.stylesheet_uri) {
        dasURI = this.stylesheet_uri;
        creds = false;
    } else {
        dasURI = this.dasBaseURI + 'stylesheet';
    }

    this.getURI(dasURI).then(function (dasURI) {
        doCrossDomainRequest(dasURI, function (responseXML) {
            if (!responseXML) {
                if (failureCB) {
                    failureCB();
                }
                return;
            }
            var stylesheet = new DASStylesheet();
            var typeXMLs = responseXML.getElementsByTagName('TYPE');
            for (var i = 0; i < typeXMLs.length; ++i) {
                var typeStyle = typeXMLs[i];

                var filter = {};
                filter.type = typeStyle.getAttribute('id'); // Am I right in thinking that this makes DASSTYLE XML invalid?  Ugh.
                filter.label = typeStyle.getAttribute('label');
                filter.method = typeStyle.getAttribute('method');
                var glyphXMLs = typeStyle.getElementsByTagName('GLYPH');
                for (var gi = 0; gi < glyphXMLs.length; ++gi) {
                    var glyphXML = glyphXMLs[gi];
                    var zoom = glyphXML.getAttribute('zoom');
                    var glyph = childElementOf(glyphXML);
                    var style = new DASStyle();
                    style.glyph = glyph.localName;
                    var child = glyph.firstChild;

                    while (child) {
                        if (child.nodeType == Node.ELEMENT_NODE) {
                            if (child.localName == 'BGGRAD') {
                                style[child.localName] = parseGradient(child);
                            } else {
                                style[child.localName] = child.firstChild.nodeValue;
                            }
                        }
                        child = child.nextSibling;
                    }
                    stylesheet.pushStyle(filter, zoom, style);
                }
            }
            successCB(stylesheet);
        }, creds);
    }).catch(function (err) {
        console.log(err);
        failureCB();
    });
};

//
// sources command
// 

function DASRegistry(uri, opts) {
    opts = opts || {};
    this.uri = uri;
    this.opts = opts;
}

DASRegistry.prototype.sources = function (callback, failure, opts) {
    if (!opts) {
        opts = {};
    }

    var filters = [];
    if (opts.taxon) {
        filters.push('organism=' + opts.taxon);
    }
    if (opts.auth) {
        filters.push('authority=' + opts.auth);
    }
    if (opts.version) {
        filters.push('version=' + opts.version);
    }
    var quri = this.uri;
    if (filters.length > 0) {
        quri = quri + '?' + filters.join('&'); // '&' as a separator to hack around dasregistry.org bug.
    }

    doCrossDomainRequest(quri, function (responseXML) {
        if (!responseXML && failure) {
            failure();
            return;
        }

        var sources = [];
        var sourceXMLs = responseXML.getElementsByTagName('SOURCE');
        for (var si = 0; si < sourceXMLs.length; ++si) {
            var sourceXML = sourceXMLs[si];
            var versionXMLs = sourceXML.getElementsByTagName('VERSION');
            if (versionXMLs.length < 1) {
                continue;
            }
            var versionXML = versionXMLs[0];

            var coordXMLs = versionXML.getElementsByTagName('COORDINATES');
            var coords = [];
            for (var ci = 0; ci < coordXMLs.length; ++ci) {
                var coordXML = coordXMLs[ci];
                var coord = new DASCoords();
                coord.auth = coordXML.getAttribute('authority');
                coord.taxon = coordXML.getAttribute('taxid');
                coord.version = coordXML.getAttribute('version');
                coords.push(coord);
            }

            var caps = [];
            var capXMLs = versionXML.getElementsByTagName('CAPABILITY');
            var uri;
            for (var ci = 0; ci < capXMLs.length; ++ci) {
                var capXML = capXMLs[ci];

                caps.push(capXML.getAttribute('type'));

                if (capXML.getAttribute('type') == 'das1:features') {
                    var fep = capXML.getAttribute('query_uri');
                    uri = fep.substring(0, fep.length - 'features'.length);
                }
            }

            var props = {};
            var propXMLs = versionXML.getElementsByTagName('PROP');
            for (var pi = 0; pi < propXMLs.length; ++pi) {
                pusho(props, propXMLs[pi].getAttribute('name'), propXMLs[pi].getAttribute('value'));
            }

            if (uri) {
                var source = new DASSource(uri, {
                    source_uri: sourceXML.getAttribute('uri'),
                    name: sourceXML.getAttribute('title'),
                    desc: sourceXML.getAttribute('description'),
                    coords: coords,
                    props: props,
                    capabilities: caps
                });
                sources.push(source);
            }
        }

        callback(sources);
    });
};

//
// Utility functions
//

function elementValue(element, tag) {
    var children = element.getElementsByTagName(tag);
    if (children.length > 0 && children[0].firstChild) {
        var c = children[0];
        if (c.childNodes.length == 1) {
            return c.firstChild.nodeValue;
        } else {
            var s = '';
            for (var ni = 0; ni < c.childNodes.length; ++ni) {
                s += c.childNodes[ni].nodeValue;
            }
            return s;
        }
    } else {
        return null;
    }
}

function childElementOf(element) {
    if (element.hasChildNodes()) {
        var child = element.firstChild;
        do {
            if (child.nodeType == Node.ELEMENT_NODE) {
                return child;
            }
            child = child.nextSibling;
        } while (child != null);
    }
    return null;
}

function dasLinksOf(element) {
    var links = new Array();
    var maybeLinkChilden = element.getElementsByTagName('LINK');
    for (var ci = 0; ci < maybeLinkChilden.length; ++ci) {
        var linkXML = maybeLinkChilden[ci];
        if (linkXML.parentNode == element) {
            links.push(new DASLink(linkXML.firstChild ? linkXML.firstChild.nodeValue : 'Unknown', linkXML.getAttribute('href')));
        }
    }

    return links;
}

function dasNotesOf(element) {
    var notes = [];
    var maybeNotes = element.getElementsByTagName('NOTE');
    for (var ni = 0; ni < maybeNotes.length; ++ni) {
        if (maybeNotes[ni].firstChild) {
            notes.push(maybeNotes[ni].firstChild.nodeValue);
        }
    }
    return notes;
}

function doCrossDomainRequest(url, handler, credentials, custAuth) {
    // TODO: explicit error handlers?

    if (window.XDomainRequest) {
        var req = new XDomainRequest();
        req.onload = function () {
            var dom = new ActiveXObject("Microsoft.XMLDOM");
            dom.async = false;
            dom.loadXML(req.responseText);
            handler(dom);
        };
        req.open("get", url);
        req.send();
    } else {
        try {
            var req = new XMLHttpRequest();
            var timeout = setTimeout(function () {
                console.log('timing out ' + url);
                req.abort();
                handler(null, req);
            }, 5000);

            req.ontimeout = function () {
                console.log('timeout on ' + url);
            };

            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    clearTimeout(timeout);
                    if (req.status >= 200 || req.status == 0) {
                        handler(req.responseXML, req);
                    }
                }
            };
            req.open("get", url, true);
            // IE10/11 fix: The timeout property may be set only in the time interval between a call to the open method
            //              and the first call to the send method.
            req.timeout = 5000;
            if (credentials) {
                req.withCredentials = true;
            }
            if (custAuth) {
                req.setRequestHeader('X-DAS-Authorisation', custAuth);
            }
            req.overrideMimeType('text/xml');
            req.setRequestHeader('Accept', 'application/xml,*/*');
            req.send();
        } catch (e) {
            handler(null, req, e);
        }
    }
}

DASSource.prototype.doCrossDomainRequest = function (url, handler, errHandler) {
    var custAuth;
    if (this.xUser) {
        custAuth = 'Basic ' + btoa(this.xUser + ':' + this.xPass);
    }

    try {
        return doCrossDomainRequest(url, handler, this.credentials, custAuth);
    } catch (err) {
        if (errHandler) {
            errHandler(err);
        } else {
            throw err;
        }
    }
};

function isDasBooleanTrue(s) {
    s = ('' + s).toLowerCase();
    return s === 'yes' || s === 'true';
}

function isDasBooleanNotFalse(s) {
    if (!s) return false;

    s = ('' + s).toLowerCase();
    return s !== 'no' || s !== 'false';
}

function copyStylesheet(ss) {
    var nss = shallowCopy(ss);
    nss.styles = [];
    for (var si = 0; si < ss.styles.length; ++si) {
        var sh = nss.styles[si] = shallowCopy(ss.styles[si]);
        sh._methodRE = sh._labelRE = sh._typeRE = undefined;
        sh.style = shallowCopy(sh.style);
        sh.style.id = undefined;
        sh.style._gradient = undefined;
    }
    return nss;
}

if (typeof module !== 'undefined') {
    module.exports = {
        DASGroup: DASGroup,
        DASFeature: DASFeature,
        DASStylesheet: DASStylesheet,
        DASStyle: DASStyle,
        DASSource: DASSource,
        DASSegment: DASSegment,
        DASRegistry: DASRegistry,
        DASSequence: DASSequence,
        DASLink: DASLink,

        isDasBooleanTrue: isDasBooleanTrue,
        isDasBooleanNotFalse: isDasBooleanNotFalse,
        copyStylesheet: copyStylesheet,
        coordsMatch: coordsMatch
    };
}

},{"./color":9,"./utils":58}],12:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.paintQuant = exports.createQuantOverlay = exports.clearViewport = exports.drawUnmapped = exports.paint = exports.prepareViewport = exports.prepareSubtiers = exports.drawTier = exports.renderTier = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _featureDraw = require("./feature-draw.js");

var _sequenceDraw = require("./sequence-draw.js");

var _spans = require("./spans.js");

var _utils = require("./utils.js");

var _glyphs = require("./glyphs.js");

var Glyphs = _interopRequireWildcard(_glyphs);

var _das = require("./das.js");

var _color = require("./color.js");

var _cigar = require("./cigar.js");

var _numformats = require("./numformats");

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// The only functions that must be exported by a renderer are renderTier
// and drawTier, the rest are exported for use in other renderers.
exports.renderTier = renderTier;
exports.drawTier = drawTier;
exports.prepareSubtiers = prepareSubtiers;
exports.prepareViewport = prepareViewport;
exports.paint = paint;
exports.drawUnmapped = drawUnmapped;
exports.clearViewport = clearViewport;
exports.createQuantOverlay = createQuantOverlay;
exports.paintQuant = paintQuant;


function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

function drawTier(tier) {
    var canvas = tier.viewport.getContext("2d");
    var retina = tier.browser.retina && window.devicePixelRatio > 1;

    if (tier.sequenceSource) {
        var sequence = tier.currentSequence;
        (0, _sequenceDraw.drawSeqTier)(tier, sequence);
    } else if (tier.currentFeatures) {
        prepareSubtiers(tier, canvas);
    } else {
        console.log("No sequence or features in tier!");
    }

    if (tier.subtiers) {
        var vOffset = R.defaultTo(0, tier.dasSource.vOffset);

        prepareViewport(tier, canvas, retina, true, vOffset);
        paint(tier, canvas, vOffset);
    }

    tier.drawOverlay();
    tier.paintQuant();

    if (typeof tier.dasSource.drawCallback === "function") {
        tier.dasSource.drawCallback(canvas, tier);
    }

    tier.originHaxx = 0;
    tier.browser.arrangeTiers();
}

function glyphsForGroup(canvas, features, y, groupElement, tier) {
    var gstyle = tier.styleForFeature(groupElement);
    var label = void 0;
    var labelWanted = false;

    var glyphs = [];
    var strand = null;

    features.forEach(function (f) {
        if (f.orientation && strand === null) {
            strand = f.orientation;
        }

        if (!label && f.label) {
            label = f.label;
        }

        var style = tier.styleForFeature(f);
        if (style && !f.parts) {
            if ((0, _das.isDasBooleanTrue)(style.LABEL)) labelWanted = true;

            var glyph = glyphForFeature(canvas, f, y, style, tier, null, true);
            if (glyph) glyphs.push(glyph);
        }
    });

    if (glyphs.length === 0) return null;

    var connector = 'flat';
    if (gstyle && gstyle.glyph === 'LINE') {
        // Stick with flat...
    } else {
        if (tier.dasSource.collapseSuperGroups && !tier.bumped) {
            if (strand === '+' || strand === '-') {
                connector = 'collapsed' + strand;
            }
        } else {
            if (strand === '+' || strand === '-') {
                connector = 'hat' + strand;
            }
        }
    }

    var labelText = null;
    if (label && labelWanted || gstyle && ((0, _das.isDasBooleanTrue)(gstyle.LABEL) || (0, _das.isDasBooleanTrue)(gstyle.LABELS))) {
        // HACK, LABELS should work.
        labelText = groupElement.label || label;
    }

    var groupGlyph = new Glyphs.GroupGlyph(glyphs, connector);
    if (labelText) {
        if (strand === '+') {
            labelText = '>' + labelText;
        } else if (strand === '-') {
            labelText = '<' + labelText;
        }
        groupGlyph = new Glyphs.LabelledGlyph(canvas, groupGlyph, labelText, false);
    }
    groupGlyph.bump = true;
    return groupGlyph;
}

function glyphForFeature(canvas, feature, y, style, tier, forceHeight, noLabel) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;
    var glyphType = style.glyph || 'BOX';

    var min = feature.min;
    var max = feature.max;
    var strand = feature.orientation;
    var score = feature.score;
    var label = feature.label || feature.id;

    // Hide glyphs that are smaller than a pixel in width.
    if (tier.dasSource.hideSubpixelGlyphs && (max - min) * scale < 1) return null;

    var minPos = (min - origin) * scale;
    var rawMaxPos = (max - origin + 1) * scale;
    var maxPos = Math.max(rawMaxPos, minPos + 1);

    forceHeight = forceHeight * 1.0;
    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;
    height = height * 1.0;
    var bump = style.BUMP && (0, _das.isDasBooleanTrue)(style.BUMP);

    var glyph = void 0;
    var quant = void 0;

    // Create the glyph
    if (glyphType === 'CROSS' || glyphType === 'EX' || glyphType === 'TRIANGLE' || glyphType === 'DOT' || glyphType === 'SQUARE' || glyphType === 'STAR' || glyphType === 'PLIMSOLL') {
        var _featureToCrossLikeGl = featureToCrossLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight, noLabel);

        var _featureToCrossLikeGl2 = _slicedToArray(_featureToCrossLikeGl, 2);

        glyph = _featureToCrossLikeGl2[0];
        quant = _featureToCrossLikeGl2[1];
    } else if (glyphType === 'HISTOGRAM' || glyphType === 'GRADIENT' && score !== 'undefined') {
        var _featureToGradientLik = featureToGradientLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight);

        var _featureToGradientLik2 = _slicedToArray(_featureToGradientLik, 2);

        glyph = _featureToGradientLik2[0];
        quant = _featureToGradientLik2[1];
    } else if (glyphType === 'HIDDEN') {
        glyph = new Glyphs.PaddedGlyph(null, minPos, maxPos);
        noLabel = true;
    } else if (glyphType === 'ARROW') {
        var color = style.FGCOLOR || 'purple';
        var parallel = (0, _das.isDasBooleanTrue)(style.PARALLEL);
        var sw = (0, _das.isDasBooleanTrue)(style.SOUTHWEST);
        var ne = (0, _das.isDasBooleanTrue)(style.NORTHEAST);
        glyph = new Glyphs.ArrowGlyph(minPos, maxPos, height, color, parallel, sw, ne);
    } else if (glyphType === 'ANCHORED_ARROW') {
        var stroke = style.FGCOLOR || 'none';
        var fill = style.BGCOLOR || 'green';
        glyph = new Glyphs.AArrowGlyph(minPos, maxPos, height, fill, stroke, strand);
        glyph.bump = true;
    } else if (glyphType === 'SPAN') {
        var _stroke = style.FGCOLOR || 'black';
        glyph = new Glyphs.SpanGlyph(minPos, maxPos, height, _stroke);
    } else if (glyphType === 'LINE') {
        var _stroke2 = style.FGCOLOR || 'black';
        var lineStyle = style.STYLE || 'solid';
        glyph = new Glyphs.LineGlyph(minPos, maxPos, height, lineStyle, strand, _stroke2);
    } else if (glyphType === 'PRIMERS') {
        var _stroke3 = style.FGCOLOR || 'black';
        var _fill = style.BGCOLOR || 'red';
        glyph = new Glyphs.PrimersGlyph(minPos, maxPos, height, _fill, _stroke3);
    } else if (glyphType === 'TEXT') {
        var string = style.STRING || 'text';
        var _fill2 = style.FGCOLOR || 'black';
        glyph = new Glyphs.TextGlyph(canvas, minPos, maxPos, height, _fill2, string);
    } else if (glyphType === 'TOOMANY') {
        var _stroke4 = style.FGCOLOR || 'gray';
        var _fill3 = style.BGCOLOR || 'orange';
        glyph = new Glyphs.TooManyGlyph(minPos, maxPos, height, _fill3, _stroke4);
    } else if (glyphType === 'POINT') {
        var _featureToPointGlyph = featureToPointGlyph(tier, feature, style);

        var _featureToPointGlyph2 = _slicedToArray(_featureToPointGlyph, 2);

        glyph = _featureToPointGlyph2[0];
        quant = _featureToPointGlyph2[1];
    } else if (glyphType === '__SEQUENCE') {
        glyph = sequenceGlyph(canvas, tier, feature, style, forceHeight);
    } else if (glyphType === '__INSERTION') {
        var insertionLabels = true;
        if (style.__INSERTIONS !== undefined) insertionLabels = (0, _das.isDasBooleanNotFalse)(style.__INSERTIONS);
        glyph = new Glyphs.TriangleGlyph(minPos, 5, 'S', 5, tier.browser.baseColors['I']);
        if (insertionLabels) glyph = new Glyphs.LabelledGlyph(canvas, glyph, feature.insertion || feature.altAlleles[0], false, 'center', 'above', '7px sans-serif');

        if (maxPos - minPos > 1) {
            var _stroke5 = style.FGCOLOR || 'red';
            var _fill4 = style.BGCOLOR || style.COLOR1 || 'green';
            var bg = new Glyphs.BoxGlyph(minPos, 5, maxPos - minPos, height, _fill4, _stroke5);
            glyph = new Glyphs.GroupGlyph([bg, glyph]);
        }
    } else if (glyphType === '__NONE') {
        return null;
    } else if (glyphType === 'BOX') {
        var _stroke6 = style.FGCOLOR || null;
        var _fill5 = style.BGCOLOR || style.COLOR1 || 'green';
        if (style.BGITEM && feature.itemRgb) _fill5 = feature.itemRgb;
        var _scale = (maxPos - minPos) / (max - min);
        if (feature.type == 'translation' && (feature.method == 'protein_coding' || feature.readframeExplicit) && (!feature.tags || feature.tags.indexOf('cds_start_NF') < 0 || feature.readframeExplicit) && (!tier.dasSource.collapseSuperGroups || tier.bumped) && _scale >= 0.5) {
            var refSeq = getRefSeq(tier, min, max);
            glyph = new Glyphs.AminoAcidGlyph(minPos, maxPos, height, _fill5, refSeq, feature.orientation, feature.readframe);
        } else {
            glyph = new Glyphs.BoxGlyph(minPos, 0, maxPos - minPos, height, _fill5, _stroke6);
        }
    }

    if (((0, _das.isDasBooleanTrue)(style.LABEL) || feature.forceLabel) && label && !noLabel) {
        glyph = new Glyphs.LabelledGlyph(canvas, glyph, label, false);
    }

    if (bump) {
        glyph.bump = true;
    }

    glyph.feature = feature;

    if ((0, _das.isDasBooleanTrue)(style["HIDEAXISLABEL"])) quant = null;

    if (quant) {
        glyph.quant = quant;
    }

    if (style.ZINDEX) {
        glyph.zindex = style.ZINDEX | 0;
    }

    return glyph;
}

function groupFeatures(tier, canvas, y) {
    var glyphs = [];
    var gbsFeatures = {};
    var gbsStyles = {};
    var stackedFeatures = [];

    R.map(function (features) {
        features.forEach(function (feature) {
            var style = tier.styleForFeature(feature);

            if (feature.parts || !style) return;

            if (style.glyph === 'LINEPLOT') {
                (0, _utils.pusho)(gbsFeatures, style.id, feature);
                gbsStyles[style.id] = style;
            } else if (style.glyph === 'STACKED') {
                stackedFeatures.push(feature);
            } else {
                var glyph = glyphForFeature(canvas, feature, y, style, tier);
                if (glyph) glyphs.push(glyph);
            }
        });
    }, tier.ungroupedFeatures);

    if (stackedFeatures.length > 0) {
        glyphs = glyphs.concat(makeStackedBars(stackedFeatures, tier));
    }

    for (var gbs in gbsFeatures) {
        var gf = gbsFeatures[gbs];
        var style = gbsStyles[gbs];
        if (style.glyph === 'LINEPLOT') {
            var lineGraphGlyphs = makeLinePlot(gf, style, tier, y);
            lineGraphGlyphs.forEach(function (g) {
                return glyphs.push(g);
            });
        }
    }

    return glyphs;
}

function glyphifyGroups(tier, canvas, glyphs, y) {
    var groupIds = Object.keys(tier.groupedFeatures);
    var groupGlyphs = {};

    groupIds.sort(function (g1, g2) {
        return tier.groupedFeatures[g2][0].score - tier.groupedFeatures[g1][0].score;
    });

    groupIds.forEach(function (gId) {
        var glyphs = glyphsForGroup(canvas, tier.groupedFeatures[gId], y, tier.groups[gId], tier, tier.dasSource.collapseSuperGroups && !tier.bumped ? 'collapsed_gene' : 'tent');

        if (glyphs) {
            glyphs.group = tier.groups[gId];
            groupGlyphs[gId] = glyphs;
        }
    });

    return groupGlyphs;
}

function bumpSubtiers(tier, glyphs, grid, gridOffset, gridSpacing) {
    var subtierMax = tier.subtierMax || tier.dasSource.subtierMax || tier.browser.defaultSubtierMax;

    var subtiersExceeded = false;

    var unbumpedST = new _featureDraw.SubTier();
    var bumpedSTs = [];

    // We want to add each glyph to either the subtier
    // containing unbumped subtiers, or to the first bumped subtier.
    glyphs.forEach(function (glyph) {
        // if the glyph is to be bumped...
        if (glyph.bump && (tier.bumped || tier.dasSource.collapseSuperGroups)) {

            var glyphTier = bumpedSTs.find(function (st) {
                return st.hasSpaceFor(glyph);
            });

            if (glyphTier) {
                glyphTier.add(glyph);
            } else if (bumpedSTs.length >= subtierMax) {
                subtiersExceeded = true;
            } else {
                var subtier = new _featureDraw.SubTier();
                subtier.add(glyph);
                bumpedSTs.push(subtier);
            }
        } else {
            unbumpedST.add(glyph);
        }
    });

    if (unbumpedST.glyphs.length > 0) {
        bumpedSTs = [unbumpedST].concat(bumpedSTs);
    }

    // Simple hack to make the horizontal grid in bumped subtiers (e.g. lineplots)
    // optional and configurable.
    if (grid) {
        bumpedSTs.forEach(function (subtier) {
            if (subtier.quant) {
                subtier.glyphs.unshift(new Glyphs.GridGlyph(subtier.height, gridOffset, gridSpacing));
            }
        });
    }

    bumpedSTs.forEach(function (subtier) {
        subtier.glyphs.sort(function (g1, g2) {
            return (g1.zindex || 0) - (g2.zindex || 0);
        });
    });

    return [bumpedSTs, subtiersExceeded];
}

// The whole tier is translated downward on its canvas by y pixels
function prepareSubtiers(tier, canvas) {
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var grid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


    var MIN_PADDING = 3;
    tier.padding = typeof tier.dasSource.padding === 'number' ? tier.dasSource.padding : MIN_PADDING;

    tier.scaleVertical = typeof tier.dasSource.scaleVertical === 'boolean' ? tier.dasSource.scaleVertical : false;

    var glyphs = groupFeatures(tier, canvas, y);

    // Merge supergroups
    if (tier.dasSource.collapseSuperGroups && !tier.bumped) {
        var _loop = function _loop(sgId) {
            var sgGroup = tier.superGroups[sgId];
            tier.groups[sgId] = (0, _utils.shallowCopy)(tier.groups[sgId]);
            var group = tier.groups[sgId];
            group.isSuperGroup = true;
            var featuresByType = {};

            var sgMin = 10000000000,
                sgMax = -10000000000;
            var sgSeg = null;

            sgGroup.forEach(function (g, i) {
                var groupedFeature = tier.groupedFeatures[sgGroup[i]];
                if (!groupedFeature) return;

                groupedFeature.forEach(function (feature) {
                    (0, _utils.pusho)(featuresByType, feature.type, feature);
                    sgMin = Math.min(feature.min, sgMin);
                    sgMax = Math.max(feature.max, sgMax);
                    if (feature.segment && !sgSeg) sgSeg = feature.segment;
                });

                if (group && !group.links || group.links.length === 0) {
                    group.links = tier.groups[sgGroup[0]].links;
                }

                delete tier.groupedFeatures[sgGroup[i]];
            });

            tier.groups[sgId].max = sgMax;
            tier.groups[sgId].min = sgMin;
            tier.groups[sgId].segment = sgSeg;

            R.map(function (features) {

                var template = features[0];
                var loc = null;

                features.forEach(function (feature) {
                    var fl = new _spans.Range(feature.min, feature.max);
                    loc = loc ? (0, _spans.union)(loc, fl) : fl;
                });

                var mergedRanges = loc.ranges();

                mergedRanges.forEach(function (range) {
                    var posCoverage = ((range.max() | 0) - (range.min() | 0) + 1) * sgGroup.length;
                    var actCoverage = 0;

                    features.forEach(function (feature) {
                        var fmin = feature.min || 0;
                        var fmax = feature.max || 0;
                        if (fmin <= range.max() && fmax >= range.min()) {

                            actCoverage += Math.min(fmax, range.max()) - Math.max(fmin, range.min()) + 1;
                        }
                    });

                    var newFeature = new _das.DASFeature();
                    for (var key in template) {
                        newFeature[key] = template[key];
                    }

                    newFeature.min = range.min();
                    newFeature.max = range.max();
                    if (newFeature.label && sgGroup.length > 1) {
                        newFeature.label += ' (' + sgGroup.length + ' vars)';
                    }

                    newFeature.visualWeight = 1.0 * actCoverage / posCoverage;

                    (0, _utils.pusho)(tier.groupedFeatures, sgId, newFeature);
                });
            }, featuresByType);

            delete tier.superGroups[sgId]; // Do we want this?
        };

        for (var sgId in tier.superGroups) {
            _loop(sgId);
        }
    }

    // Glyphify groups.
    var groupGlyphs = glyphifyGroups(tier, canvas, glyphs, y);

    R.map(function (superGroup) {
        var sgGlyphs = [];
        var sgMin = 10000000000;
        var sgMax = -10000000000;

        superGroup.forEach(function (glyphs) {
            var gGlyphs = groupGlyphs[glyphs];
            if (gGlyphs) {
                sgGlyphs.push(gGlyphs);
                sgMin = Math.min(sgMin, gGlyphs.min());
                sgMax = Math.max(sgMax, gGlyphs.max());
            }
        });

        sgGlyphs.forEach(function (glyph) {
            glyphs.push(new Glyphs.PaddedGlyph(glyph, sgMin, sgMax));
        });
    }, tier.superGroups);

    R.map(function (glyph) {
        return glyphs.push(glyph);
    }, groupGlyphs);

    var _bumpSubtiers = bumpSubtiers(tier, glyphs, grid, y),
        _bumpSubtiers2 = _slicedToArray(_bumpSubtiers, 2),
        subtiers = _bumpSubtiers2[0],
        subtiersExceeded = _bumpSubtiers2[1];

    tier.glyphCacheOrigin = tier.browser.viewStart;

    if (subtiersExceeded) tier.updateStatus('Bumping limit exceeded, use the track editor to see more features');else tier.updateStatus();

    tier.subtiers = subtiers;
}

// Fills out areas that haven't been fetched as gray blocks
function drawUnmapped(tier, canvas, padding) {
    var drawStart = tier.browser.viewStart - 1000.0 / tier.browser.scale;
    var drawEnd = tier.browser.viewEnd + 1000.0 / tier.browser.scale;
    var unmappedBlocks = [];
    if (tier.knownCoverage) {
        var knownRanges = tier.knownCoverage.ranges();
        knownRanges.forEach(function (range, index) {
            if (index === 0) {
                if (range.min() > drawStart) unmappedBlocks.push({ min: drawStart, max: range.min() - 1 });
            } else {
                unmappedBlocks.push({ min: knownRanges[index - 1].max() + 1, max: range.min() - 1 });
            }

            if (index == knownRanges.length - 1 && range.max() < drawEnd) {
                unmappedBlocks.push({ min: range.max() + 1, max: drawEnd });
            }
        });
    }
    if (unmappedBlocks.length > 0) {
        canvas.fillStyle = 'gray';
        unmappedBlocks.forEach(function (block) {
            var min = (block.min - tier.browser.viewStart) * tier.browser.scale + 1000;
            var max = (block.max - tier.browser.viewStart) * tier.browser.scale + 1000;
            canvas.fillRect(min, 0, max - min, padding);
        });
    }
}

function clearViewport(canvas, width, height) {
    canvas.clearRect(0, 0, width, height);
}

// Make the viewport & canvas the correct size for the tier
function prepareViewport(tier, canvas, retina) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var vOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    canvas.save();
    var desiredWidth = tier.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }

    var fpw = tier.viewport.width | 0;
    if (fpw < desiredWidth - 50) {
        tier.viewport.width = fpw = desiredWidth;
    }

    var lh = tier.padding + vOffset;

    tier.subtiers.forEach(function (s) {
        return lh += s.height + tier.padding;
    });

    lh += 6;
    lh = Math.max(lh, tier.browser.minTierHeight);

    var canvasHeight = lh;
    if (retina) {
        canvasHeight *= 2;
    }

    if (canvasHeight != tier.viewport.height) {
        tier.viewport.height = canvasHeight;
    }

    tier.viewportHolder.style.left = '-1000px';
    tier.viewport.style.width = retina ? '' + fpw / 2 + 'px' : '' + fpw + 'px';
    tier.viewport.style.height = '' + lh + 'px';
    tier.layoutHeight = Math.max(lh, tier.browser.minTierHeight);

    tier.updateHeight();
    tier.norigin = tier.browser.viewStart;

    if (retina) {
        canvas.scale(2, 2);
    }

    if (clear) {
        clearViewport(canvas, fpw, canvasHeight);
    }

    drawUnmapped(tier, canvas, lh);

    canvas.restore();
}

function paint(tier, canvas) {
    var vOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    canvas.save();
    var overlayLabelCanvas = new Glyphs.OverlayLabelCanvas();
    var offset = (tier.glyphCacheOrigin - tier.browser.viewStart) * tier.browser.scale + 1000;
    canvas.translate(offset, vOffset + tier.padding);
    overlayLabelCanvas.translate(0, tier.padding);

    tier.paintToContext(canvas, overlayLabelCanvas, offset);

    if (overlayLabelCanvas.glyphs.length > 0) tier.overlayLabelCanvas = overlayLabelCanvas;else tier.overlayLabelCanvas = null;
    canvas.restore();
}

function getScoreMinMax(tier, style) {
    var smin = tier.quantMin(style);
    var smax = tier.quantMax(style);

    if (!smax) {
        if (smin < 0) {
            smax = 0;
        } else {
            smax = 10;
        }
    }
    if (!smin) {
        smin = 0;
    }
    return [smin, smax];
}

function relScoreOrigin(score, smin, smax) {
    var relScore = (1.0 * score - smin) / (smax - smin);
    var relOrigin = -1.0 * smin / (smax - smin);

    return [relScore, relOrigin];
}

function getRefSeq(tier, min, max) {
    var refSeq = null;
    if (tier.currentSequence) {
        var csStart = tier.currentSequence.start | 0;
        var csEnd = tier.currentSequence.end | 0;
        if (csStart <= max && csEnd >= min) {
            var sfMin = Math.max(min, csStart);
            var sfMax = Math.min(max, csEnd);

            refSeq = tier.currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1);
            while (min < sfMin) {
                refSeq = 'N' + refSeq;
                sfMin--;
            }
            while (max > sfMax) {
                refSeq = refSeq + 'N';
                sfMax++;
            }
        }
    }
    return refSeq;
}

function featureToCrossLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight, noLabel) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var score = feature.score;
    var label = feature.label || feature.id;

    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;
    var requiredHeight = height;

    var glyph = null;
    var quant = null;

    var stroke = style.FGCOLOR || 'black';
    var fill = style.BGCOLOR || 'none';
    var outline = style.STROKECOLOR;

    if (style.BGITEM && feature.itemRgb) {
        stroke = feature.itemRgb;
    } else if ((0, _das.isDasBooleanTrue)(style.COLOR_BY_SCORE2)) {
        var grad = style.BGGRAD || style._gradient;
        if (!grad) {
            grad = (0, _color.makeGradient)(50, style.COLOR1, style.COLOR2, style.COLOR3);
            style._gradient = grad;
        }

        var score2 = feature.score2;
        if (score2 !== undefined || !stroke) {
            score2 = score2 || 0;

            var smin2 = style.MIN2 ? 1.0 * style.MIN2 : 0.0;
            var smax2 = style.MAX2 ? 1.0 * style.MAX2 : 1.0;
            var relScore2 = (1.0 * score2 - smin2) / (smax2 - smin2);

            var step = relScore2 * grad.length | 0;
            R.clamp(0, step, grad.length - 1);
            stroke = grad[step];
        }
    }

    var size = style.SIZE || height;
    if (style.RSIZE) {
        size = 1.0 * style.RSIZE * height;
    }

    if (style.STROKETHRESHOLD) {
        if (size < 1.0 * style.STROKETHRESHOLD) outline = null;
    }

    var mid = (minPos + maxPos) / 2;

    if (glyphType === 'EX') {
        glyph = new Glyphs.ExGlyph(mid, size, stroke);
    } else if (glyphType === 'TRIANGLE') {
        var dir = style.DIRECTION || 'N';
        var width = style.LINEWIDTH || size;
        glyph = new Glyphs.TriangleGlyph(mid, size, dir, width, stroke, outline);
    } else if (glyphType === 'DOT') {
        glyph = new Glyphs.DotGlyph(mid, size, stroke, outline);
    } else if (glyphType === 'PLIMSOLL') {
        glyph = new Glyphs.PlimsollGlyph(mid, size, 0.2 * size, stroke, outline);
    } else if (glyphType === 'SQUARE') {
        glyph = new Glyphs.BoxGlyph(mid - size / 2, 0, size, size, stroke, outline);
    } else if (glyphType === 'STAR') {
        var points = style.POINTS || 5;
        glyph = new Glyphs.StarGlyph(mid, size / 2, points, stroke, outline);
    } else {
        glyph = new Glyphs.CrossGlyph(mid, size, stroke);
    }

    if (fill && fill !== 'none' && maxPos - minPos > 5) {
        var boxGlyph = new Glyphs.BoxGlyph(minPos, 0, maxPos - minPos, size, fill);
        glyph = new Glyphs.GroupGlyph([boxGlyph, glyph]);
    }

    if ((0, _das.isDasBooleanTrue)(style.SCATTER)) {
        var _getScoreMinMax = getScoreMinMax(tier, style),
            _getScoreMinMax2 = _slicedToArray(_getScoreMinMax, 2),
            smin = _getScoreMinMax2[0],
            smax = _getScoreMinMax2[1];

        var _relScoreOrigin = relScoreOrigin(score, smin, smax),
            _relScoreOrigin2 = _slicedToArray(_relScoreOrigin, 2),
            relScore = _relScoreOrigin2[0],
            relOrigin = _relScoreOrigin2[1];

        if (relScore < 0.0 || relScore > 1.0) {
            // Glyph is out of bounds.
            // Should we allow for "partially showing" glyphs?

            return null;
        } else {
            var originShift = function originShift(x) {
                return (x - relOrigin) * requiredHeight;
            };
            height = Math.max(1, originShift(relScore));
            y = y + originShift(1);

            if (relScore >= relOrigin) y = y - height;

            quant = { min: smin, max: smax };

            var heightFudge = 0;
            var featureLabel = R.defaultTo(style.LABEL, feature.forceLabel);

            if ((0, _das.isDasBooleanNotFalse)(featureLabel) && label && !noLabel) {
                glyph = new Glyphs.LabelledGlyph(canvas, glyph, label, true, null, featureLabel == 'above' ? 'above' : 'below');
                if (featureLabel === 'above') {
                    heightFudge = glyph.textHeight + 2;
                }
                noLabel = true;
            }
            glyph = new Glyphs.TranslatedGlyph(glyph, 0, y - size / 2 - heightFudge, requiredHeight);
        }
    }

    return [glyph, quant];
}

function featureToGradientLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var score = feature.score;

    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;
    var requiredHeight = height * 1.0;

    var glyph = null;
    var quant = null;

    var centerOnAxis = (0, _das.isDasBooleanTrue)(style["AXISCENTER"]);

    var _getScoreMinMax3 = getScoreMinMax(tier, style),
        _getScoreMinMax4 = _slicedToArray(_getScoreMinMax3, 2),
        smin = _getScoreMinMax4[0],
        smax = _getScoreMinMax4[1];

    // AUTOMIN & AUTOMAX respectively set the lower and upper bounds


    if ((0, _das.isDasBooleanTrue)(style.AUTOMIN)) {
        smin = tier.currentFeaturesMinScore * 0.95;
        console.log("smin:\t" + smin);
    }
    if ((0, _das.isDasBooleanTrue)(style.AUTOMAX)) {
        smax = tier.currentFeaturesMaxScore * 1.05;
        console.log("smax:\t" + smax);
    }

    if (1.0 * score < 1.0 * smin) {
        score = smin;
    }
    if (1.0 * score > 1.0 * smax) {
        score = smax;
    }

    // Shift smin/smax in case we want to center the histogram
    // on the horizontal axis
    if (centerOnAxis) {
        var tmin = tier.quantMin(style);
        var tmax = tier.quantMax(style);

        if ((0, _das.isDasBooleanTrue)(style.AUTOMIN)) {
            tmin = tier.currentFeaturesMinScore * 0.95;
        }
        if ((0, _das.isDasBooleanTrue)(style.AUTOMAX)) {
            tmax = tier.currentFeaturesMaxScore * 1.05;
        }

        smin = tmin - (tmax - tmin) / 2;
        smax = tmax - (tmax - tmin) / 2;
    }

    var _relScoreOrigin3 = relScoreOrigin(score, smin, smax),
        _relScoreOrigin4 = _slicedToArray(_relScoreOrigin3, 2),
        relScore = _relScoreOrigin4[0],
        relOrigin = _relScoreOrigin4[1];

    if (glyphType === 'HISTOGRAM') {
        var originShift = function originShift(x) {
            return x - Math.max(0, relOrigin);
        };
        height = Math.abs(originShift(relScore)) * requiredHeight;
        y = y + originShift(1.0) * requiredHeight;

        if (relScore >= relOrigin) y -= height;

        if (centerOnAxis) y += height / 2;

        if ((0, _das.isDasBooleanTrue)(style["HIDEAXISLABEL"])) quant = null;else quant = { min: smin, max: smax };
    }

    var stroke = style.FGCOLOR || null;
    var fill = style.BGCOLOR || style.COLOR1 || 'green';
    if (style.BGITEM && feature.itemRgb) fill = feature.itemRgb;
    var alpha = style.ALPHA ? 1.0 * style.ALPHA : null;

    if (style.BGGRAD) {
        var grad = style.BGGRAD;
        var step = relScore * grad.length | 0;
        step = R.clamp(0, step, grad.length - 1);
        fill = grad[step];
    }

    if (style.COLOR2) {
        var _grad = style._gradient;
        if (!_grad) {
            _grad = (0, _color.makeGradient)(50, style.COLOR1, style.COLOR2, style.COLOR3);
            style._gradient = _grad;
        }

        var _step = relScore * _grad.length | 0;
        _step = R.clamp(0, _step, _grad.length - 1);
        fill = _grad[_step];
    }

    var tempGlyph = new Glyphs.BoxGlyph(minPos, y, maxPos - minPos, height, fill, stroke, alpha);
    glyph = new Glyphs.TranslatedGlyph(tempGlyph, 0, 0, requiredHeight);

    return [glyph, quant];
}

function featureToPointGlyph(tier, feature, style) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var score = feature.score;

    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = tier.forceHeight || style.HEIGHT || 30;

    var glyph = null;
    var quant = null;

    var _getScoreMinMax5 = getScoreMinMax(tier, style),
        _getScoreMinMax6 = _slicedToArray(_getScoreMinMax5, 2),
        smin = _getScoreMinMax6[0],
        smax = _getScoreMinMax6[1];

    var yscale = 1.0 * height / (smax - smin);
    var relScore = (1.0 * score - smin) / (smax - smin);
    var sc = (score - 1.0 * smin) * yscale | 0;
    quant = { min: smin, max: smax };

    var fill = style.FGCOLOR || style.COLOR1 || 'black';
    if (style.COLOR2) {
        var grad = style._gradient;
        if (!grad) {
            grad = (0, _color.makeGradient)(50, style.COLOR1, style.COLOR2, style.COLOR3);
            style._gradient = grad;
        }

        var step = relScore * grad.length | 0;
        step = R.clamp(0, step, grad.length - 1);
        fill = grad[step];
    }

    glyph = new Glyphs.PointGlyph((minPos + maxPos) / 2, height - sc, height, fill);

    return [glyph, quant];
}

function sequenceGlyph(canvas, tier, feature, style, forceHeight) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var min = feature.min;
    var max = feature.max;
    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;

    var glyph = null;

    var rawseq = feature.seq;
    var seq = rawseq;
    var rawquals = feature.quals;
    var quals = rawquals;
    var insertionLabels = (0, _das.isDasBooleanTrue)(style.__INSERTIONS);

    var indels = [];
    if (feature.cigar) {
        var ops = (0, _cigar.parseCigar)(feature.cigar);
        seq = '';
        quals = '';
        var cursor = 0;

        ops.forEach(function (co) {
            if (co.op === 'M') {
                seq += rawseq.substr(cursor, co.cnt);
                quals += rawquals.substr(cursor, co.cnt);
                cursor += co.cnt;
            } else if (co.op === 'D') {
                seq += "-".repeat(co.cnt);
                quals += "Z".repeat(co.cnt);
            } else if (co.op === 'I') {
                var inseq = rawseq.substr(cursor, co.cnt);
                var ig = new Glyphs.TranslatedGlyph(new Glyphs.TriangleGlyph(minPos + seq.length * scale, 6, 'S', 5, tier.browser.baseColors['I']), 0, -2, 0);
                if (insertionLabels) ig = new Glyphs.LabelledGlyph(canvas, ig, inseq, false, 'center', 'above', '7px sans-serif');
                ig.feature = { label: 'Insertion: ' + inseq, type: 'insertion', method: 'insertion' };
                indels.push(ig);

                cursor += co.cnt;
            } else if (co.op === 'S') {
                cursor += co.cnt;
            } else {
                console.log('unknown cigop' + co.op);
            }
        });
    }

    var refSeq = getRefSeq(tier, min, max);
    if (seq && refSeq && (style.__SEQCOLOR === 'mismatch' || style.__SEQCOLOR === 'mismatch-all')) {
        var mismatchSeq = [];
        var match = feature.orientation === '-' ? ',' : '.';
        seq.forEach(function (_, i) {
            return mismatchSeq.push(seq[i] == refSeq[i] ? match : seq[i]);
        });
        seq = mismatchSeq.join('');
    }

    var strandColor = feature.orientation === '-' ? style._minusColor || 'lightskyblue' : style._plusColor || 'lightsalmon';

    if (style.__disableQuals) quals = false;

    glyph = new Glyphs.SequenceGlyph(tier.browser.baseColors, strandColor, minPos, maxPos, height, seq, refSeq, style.__SEQCOLOR, quals, !(0, _das.isDasBooleanTrue)(style.__CLEARBG), tier.scaleVertical);

    if (insertionLabels) glyph = new Glyphs.TranslatedGlyph(glyph, 0, 7);

    if (indels.length > 0) {
        indels.splice(0, 0, glyph);
        glyph = new Glyphs.GroupGlyph(indels);
    }

    return glyph;
}

function makeLinePlot(features, style, tier, yshift) {
    yshift = yshift || 0;

    var origin = tier.browser.viewStart,
        scale = tier.browser.scale;
    var height = tier.forceHeight || style.HEIGHT || 30;
    var min = tier.quantMin(style);
    var max = tier.quantMax(style);

    // AUTOMIN & AUTOMAX respectively set the lower and upper bounds
    if ((0, _das.isDasBooleanTrue)(style.AUTOMIN)) {
        // add some basically arbitrary padding
        min = tier.currentFeaturesMinScore * 0.95;
    }
    if ((0, _das.isDasBooleanTrue)(style.AUTOMAX)) {
        max = tier.currentFeaturesMaxScore * 1.05;
    }

    var yscale = 1.0 * height / (max - min);
    var color = style.FGCOLOR || style.COLOR1 || 'black';

    var prevSign = 1;
    var curSign = null;

    var curGlyphPoints = [];
    var glyphSequences = [];

    var prevPoint = null;

    features.forEach(function (f) {
        var px = (((f.min | 0) + (f.max | 0)) / 2 - origin) * scale;
        var sc = (f.score - 1.0 * min) * yscale | 0;

        // Additive tracks are always above the x-axis, and are colored
        // depending on whether the score is positive or negative.
        if ((0, _das.isDasBooleanTrue)(style.ADDITIVE)) {
            curSign = f.score < 0 ? -1 : 1;

            if (curSign !== prevSign) {
                glyphSequences.push({
                    points: curGlyphPoints,
                    color: prevSign === 1 ? style.POSCOLOR : style.NEGCOLOR
                });
                curGlyphPoints = [];
                // Need to add the previous point to this sequence,
                // otherwise there is a gap in the resulting plot
                curGlyphPoints.push(prevPoint);
            }
            prevSign = curSign;
        } else {
            curSign = 1;
        }

        var py = height - sc * curSign + yshift;
        prevPoint = { x: px, y: py };
        curGlyphPoints.push(prevPoint);
    });

    // Need to add the final sequence of points as well.
    if ((0, _das.isDasBooleanTrue)(style.ADDITIVE)) {
        color = curSign === 1 ? style.POSCOLOR : style.NEGCOLOR;
    }
    glyphSequences.push({
        points: curGlyphPoints,
        color: color
    });

    var lggs = glyphSequences.map(function (gs) {
        var lgg = new Glyphs.LineGraphGlyph(gs.points, gs.color, height);
        lgg.quant = { min: min, max: max };

        if (style.ZINDEX) lgg.zindex = style.ZINDEX | 0;

        return lgg;
    });

    return lggs;
}

function makeStackedBars(features, tier) {
    var glyphs = [];

    var posStacks = [],
        negStacks = [];

    var scale = tier.browser.scale,
        origin = tier.browser.viewStart;
    for (var fi = 0; fi < features.length; ++fi) {
        var feature = features[fi];
        var style = tier.styleForFeature(feature);
        var score = feature.score * 1.0;

        var height = tier.forceHeight || style.HEIGHT || 12;
        var requiredHeight = height = 1.0 * height;

        var min = feature.min;
        var max = feature.max;

        var minPos = (min - origin) * scale;
        var rawMaxPos = (max - origin + 1) * scale;
        var maxPos = Math.max(rawMaxPos, minPos + 1);

        // This should somewhat match the 'HISTOGRAM' path.

        var smin = tier.quantMin(style);
        var smax = tier.quantMax(style);

        if (!smax) {
            if (smin < 0) {
                smax = 0;
            } else {
                smax = 10;
            }
        } else {
            smax = smax * 1.0;
        }

        if (!smin) {
            smin = 0;
        } else {
            smin = smin * 1.0;
        }

        var stackOrigin;
        if (score >= 0) {
            stackOrigin = posStacks[min] || 0;
            posStacks[min] = stackOrigin + score;
        } else {
            stackOrigin = negStacks[min] || 0;
            negStacks[min] = stackOrigin + score;
        }

        if (stackOrigin > smax || stackOrigin < smin) {
            // Stack has extended outside of range.
            continue;
        }

        if (stackOrigin + score < smin) {
            score = smin - stackOrigin;
        }
        if (stackOrigin + score > smax) {
            score = smax - stackOrigin;
        }

        var relScoreEnd = (score + stackOrigin - smin) / (smax - smin);
        var relScoreStart = (stackOrigin - smin) / (smax - smin);
        var relScoreMax = Math.max(relScoreStart, relScoreEnd);
        var relScoreMin = Math.min(relScoreStart, relScoreEnd);

        height = (relScoreMax - relScoreMin) * requiredHeight;
        var y = (1.0 - relScoreMax) * requiredHeight;

        var stroke = style.FGCOLOR || null;
        var fill = style.BGCOLOR || style.COLOR1 || 'green';
        if (style.BGITEM && feature.itemRgb) fill = feature.itemRgb;
        var alpha = style.ALPHA ? 1.0 * style.ALPHA : null;

        var gg = new Glyphs.BoxGlyph(minPos, y, maxPos - minPos, height, fill, stroke, alpha);
        gg = new Glyphs.TranslatedGlyph(gg, 0, 0, requiredHeight);
        gg.feature = feature;
        gg.quant = {
            min: smin, max: smax
        };
        if (style.ZINDEX) {
            gg.zindex = style.ZINDEX | 0;
        }
        glyphs.push(gg);
    }
    return glyphs;
}

// height is subtier height
function createQuantOverlay(tier, height) {
    var retina = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var width = 50;

    tier.quantOverlay.height = height;
    tier.quantOverlay.width = retina ? width * 2 : width;
    tier.quantOverlay.style.height = '' + (retina ? height / 2 : height) + 'px';
    tier.quantOverlay.style.width = '' + width + 'px';
    tier.quantOverlay.style.display = 'block';

    var canvas = tier.quantOverlay.getContext('2d');

    if (retina) {
        canvas.scale(2, 2);
    }

    return canvas;
}

function paintQuant(canvas, tier, quant, tics) {
    canvas.save();

    var h = tier.quantOverlay.height;
    var w = 100;

    var ticSpacing = (h + tier.padding * 2) / tics;
    var ticInterval = (quant.max - quant.min) / tics;

    canvas.fillStyle = 'white';
    canvas.globalAlpha = 0.6;
    if (tier.browser.rulerLocation == 'right') {
        canvas.fillRect(w - 30, 0, 30, h + tier.padding * 2);
    } else {
        canvas.fillRect(0, 0, 30, h + tier.padding * 2);
    }
    canvas.globalAlpha = 1.0;

    canvas.strokeStyle = 'black';
    canvas.lineWidth = 1;
    canvas.beginPath();
    if (tier.browser.rulerLocation == 'right') {
        canvas.moveTo(w - 8, tier.padding);
        canvas.lineTo(w, tier.padding);
        canvas.lineTo(w, h + tier.padding);
        canvas.lineTo(w - 8, h + tier.padding);

        for (var t = 1; t < tics - 1; t++) {
            var ty = t * ticSpacing;
            canvas.moveTo(w, ty);
            canvas.lineTo(w - 5, ty);
        }
    } else {
        canvas.moveTo(8, tier.padding);
        canvas.lineTo(0, tier.padding);
        canvas.lineTo(0, h + tier.padding);
        canvas.lineTo(8, h + tier.padding);

        for (var _t = 1; _t < tics - 1; _t++) {
            var _ty = _t * ticSpacing;
            canvas.moveTo(0, _ty);
            canvas.lineTo(5, _ty);
        }
    }
    canvas.stroke();

    canvas.fillStyle = 'black';

    if (tier.browser.rulerLocation == 'right') {
        canvas.textAlign = 'right';
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.max), w - 9, 8);
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.min), w - 9, h + tier.padding);

        for (var _t2 = 1; _t2 < tics - 1; _t2++) {
            var _ty2 = _t2 * ticSpacing;
            canvas.fillText((0, _numformats.formatQuantLabel)(1.0 * quant.max - _t2 * ticInterval), w - 9, _ty2 + 3);
        }
    } else {
        canvas.textAlign = 'left';
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.max), 9, 8);
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.min), 9, h + tier.padding);

        for (var _t3 = 1; _t3 < tics - 1; _t3++) {
            var _ty3 = _t3 * ticSpacing;
            canvas.fillText((0, _numformats.formatQuantLabel)(1.0 * quant.max - _t3 * ticInterval), 9, _ty3 + 3);
        }
    }

    canvas.restore();
}

},{"./cigar.js":8,"./color.js":9,"./das.js":11,"./feature-draw.js":21,"./glyphs.js":24,"./numformats":30,"./sequence-draw.js":38,"./spans.js":43,"./utils.js":58,"ramda":67}],13:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// domui.js: SVG UI components
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
}

Browser.prototype.removeAllPopups = function () {
    removeChildren(this.hPopupHolder);
    removeChildren(this.popupHolder);
};

Browser.prototype.makeTooltip = function (ele, text) {
    var isin = false;
    var thisB = this;
    var timer = null;
    var _outlistener;
    _outlistener = function outlistener(ev) {
        isin = false;
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        ele.removeEventListener('mouseout', _outlistener, false);
    };

    var setup = function setup(ev) {
        var mx = ev.clientX + window.scrollX,
            my = ev.clientY + window.scrollY;
        if (!timer) {
            timer = setTimeout(function () {
                var ttt;
                if (typeof text === 'function') {
                    ttt = text();
                } else {
                    ttt = text;
                }

                var popup = makeElement('div', [makeElement('div', null, { className: 'tooltip-arrow' }), makeElement('div', ttt, { className: 'tooltip-inner' })], { className: 'tooltip bottom in' }, {
                    display: 'block',
                    top: '' + (my + 20) + 'px',
                    left: '' + Math.max(mx - 30, 20) + 'px'
                });
                thisB.hPopupHolder.appendChild(popup);
                var _moveHandler;
                _moveHandler = function moveHandler(ev) {
                    try {
                        thisB.hPopupHolder.removeChild(popup);
                    } catch (e) {
                        // May have been removed by other code which clears the popup layer.
                    }
                    window.removeEventListener('mousemove', _moveHandler, false);
                    if (isin) {
                        if (ele.offsetParent == null) {} else {
                            setup(ev);
                        }
                    }
                };
                window.addEventListener('mousemove', _moveHandler, false);
                timer = null;
            }, 1000);
        }
    };

    ele.addEventListener('mouseover', function (ev) {
        isin = true;
        ele.addEventListener('mouseout', _outlistener, false);
        setup(ev);
    }, false);
    ele.addEventListener('DOMNodeRemovedFromDocument', function (ev) {
        isin = false;
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }, false);
};

Browser.prototype.popit = function (ev, name, ele, opts) {
    var thisB = this;
    if (!opts) opts = {};
    if (!ev) ev = {};

    var width = opts.width || 200;

    var mx, my;

    if (ev.clientX) {
        var mx = ev.clientX,
            my = ev.clientY;
    } else {
        mx = 500;my = 50;
    }
    mx += document.documentElement.scrollLeft || document.body.scrollLeft;
    my += document.documentElement.scrollTop || document.body.scrollTop;
    var winWidth = window.innerWidth;

    var top = my;
    var left = Math.min(mx - width / 2 - 4, winWidth - width - 30);

    var popup = makeElement('div');
    popup.className = 'popover fade ' + (ev.clientX ? 'bottom ' : '') + 'in';
    popup.style.display = 'block';
    popup.style.position = 'absolute';
    popup.style.top = '' + top + 'px';
    popup.style.left = '' + left + 'px';
    popup.style.width = width + 'px';
    if (width > 276) {
        // HACK Bootstrappification...
        popup.style.maxWidth = width + 'px';
    }

    popup.appendChild(makeElement('div', null, { className: 'arrow' }));

    if (name) {
        var closeButton = makeElement('button', '', { className: 'close' });
        closeButton.innerHTML = '&times;';

        closeButton.addEventListener('mouseover', function (ev) {
            closeButton.style.color = 'red';
        }, false);
        closeButton.addEventListener('mouseout', function (ev) {
            closeButton.style.color = 'black';
        }, false);
        closeButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();
            thisB.removeAllPopups();
        }, false);
        var tbar = makeElement('h4', [makeElement('span', name, null, { maxWidth: '200px' }), closeButton], {/*className: 'popover-title' */}, { paddingLeft: '10px', paddingRight: '10px' });

        var dragOX, dragOY;
        var moveHandler, _upHandler;
        moveHandler = function moveHandler(ev) {
            ev.stopPropagation();ev.preventDefault();
            left = left + (ev.clientX - dragOX);
            if (left < 8) {
                left = 8;
            }if (left > winWidth - width - 32) {
                left = winWidth - width - 26;
            }
            top = top + (ev.clientY - dragOY);
            top = Math.max(10, top);
            popup.style.top = '' + top + 'px';
            popup.style.left = '' + Math.min(left, winWidth - width - 10) + 'px';
            dragOX = ev.clientX;dragOY = ev.clientY;
        };
        _upHandler = function upHandler(ev) {
            ev.stopPropagation();ev.preventDefault();
            window.removeEventListener('mousemove', moveHandler, false);
            window.removeEventListener('mouseup', _upHandler, false);
        };
        tbar.addEventListener('mousedown', function (ev) {
            ev.preventDefault();ev.stopPropagation();
            dragOX = ev.clientX;dragOY = ev.clientY;
            window.addEventListener('mousemove', moveHandler, false);
            window.addEventListener('mouseup', _upHandler, false);
        }, false);

        popup.appendChild(tbar);
    }

    popup.appendChild(makeElement('div', ele, { className: 'popover-content' }, {
        padding: '0px'
    }));
    this.hPopupHolder.appendChild(popup);

    var popupHandle = {
        node: popup,
        displayed: true
    };
    popup.addEventListener('DOMNodeRemoved', function (ev) {
        if (ev.target == popup) {
            popupHandle.displayed = false;
        }
    }, false);
    return popupHandle;
};

function makeTreeTableSection(title, content, visible) {
    var ttButton = makeElement('i');
    function update() {
        if (visible) {
            ttButton.className = 'fa fa-caret-down';
            content.style.display = 'table';
        } else {
            ttButton.className = 'fa fa-caret-right';
            content.style.display = 'none';
        }
    }
    update();

    ttButton.addEventListener('click', function (ev) {
        ev.preventDefault();ev.stopPropagation();
        visible = !visible;
        update();
    }, false);

    var heading = makeElement('h6', [ttButton, ' ', title], {}, { display: 'block', background: 'gray', color: 'white', width: '100%', padding: '5px 2px', margin: '0px' });
    return makeElement('div', [heading, content], {});
}

if (typeof module !== 'undefined') {
    module.exports = {
        makeTreeTableSection: makeTreeTableSection
    };
}

},{"./cbrowser":6,"./utils":58}],14:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.drawTier = exports.renderTier = undefined;

var _defaultRenderer = require("./default-renderer");

var DefaultRenderer = _interopRequireWildcard(_defaultRenderer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.renderTier = renderTier;
exports.drawTier = drawTier;


function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

function drawTier(tier) {
    var canvas = tier.viewport.getContext("2d");
    var retina = tier.browser.retina && window.devicePixelRatio > 1;
    if (retina) {
        canvas.scale(2, 2);
    }

    var features = tier.currentFeatures;
    var sequence = tier.currentSequence;
    if (tier.sequenceSource) {
        DefaultRenderer.drawSeqTier(tier, sequence);
    } else if (features) {
        DefaultRenderer.prepareSubtiers(tier, canvas);
    } else {
        console.log("No sequence or features in tier!");
    }

    if (tier.subtiers) {
        DefaultRenderer.prepareViewport(tier, canvas, retina, true);
    }

    tier.drawOverlay();
    tier.paintQuant();

    if (typeof tier.dasSource.drawCallback === "function") {
        tier.dasSource.drawCallback(canvas, tier);
    }

    tier.originHaxx = 0;
    tier.browser.arrangeTiers();
}

},{"./default-renderer":12}],15:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// encode.js: interface for ENCODE DCC services
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var Promise = require('es6-promise').Promise;
}

function lookupEncodeURI(uri, json) {
    if (uri.indexOf('?') < 0) uri = uri + '?soft=true';

    return new Promise(function (accept, reject) {
        var req = new XMLHttpRequest();
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (req.status >= 300) {
                    reject('Error code ' + req.status);
                } else {
                    var resp = JSON.parse(req.response);
                    accept(json ? resp : resp.location);
                }
            }
        };

        req.open('GET', uri, true);
        req.setRequestHeader('Accept', 'application/json');
        req.responseType = 'text';
        req.send();
    });
}

function EncodeURLHolder(url) {
    this.rawurl = url;
}

EncodeURLHolder.prototype.getURLPromise = function () {
    if (this.urlPromise && this.urlPromiseValidity > Date.now()) {
        return this.urlPromise;
    } else {
        this.urlPromise = lookupEncodeURI(this.rawurl, true).then(function (resp) {
            return resp.location;
        });
        this.urlPromiseValidity = Date.now() + 12 * 3600 * 1000;
        return this.urlPromise;
    }
};

function EncodeFetchable(url, start, end, opts) {
    if (!opts) {
        if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object') {
            opts = start;
            start = undefined;
        } else {
            opts = {};
        }
    }

    this.url = typeof url === 'string' ? new EncodeURLHolder(url) : url;
    this.start = start || 0;
    if (end) {
        this.end = end;
    }
    this.opts = opts;
}

EncodeFetchable.prototype.slice = function (s, l) {
    if (s < 0) {
        throw 'Bad slice ' + s;
    }

    var ns = this.start,
        ne = this.end;
    if (ns && s) {
        ns = ns + s;
    } else {
        ns = s || ns;
    }
    if (l && ns) {
        ne = ns + l - 1;
    } else {
        ne = ne || l - 1;
    }
    return new EncodeFetchable(this.url, ns, ne, this.opts);
};

EncodeFetchable.prototype.fetchAsText = function (callback) {
    var self = this;
    var req = new XMLHttpRequest();
    var length;
    self.url.getURLPromise().then(function (url) {
        req.open('GET', url, true);

        if (self.end) {
            if (self.end - self.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);
            length = self.end - self.start + 1;
        }

        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (req.status == 200 || req.status == 206) {
                    return callback(req.responseText);
                } else {
                    return callback(null);
                }
            }
        };
        if (self.opts.credentials) {
            req.withCredentials = true;
        }
        req.send();
    }).catch(function (err) {
        console.log(err);
        return callback(null);
    });
};

EncodeFetchable.prototype.salted = function () {
    return this;
};

EncodeFetchable.prototype.fetch = function (callback, attempt, truncatedLength) {
    var self = this;

    attempt = attempt || 1;
    if (attempt > 3) {
        return callback(null);
    }

    self.url.getURLPromise().then(function (url) {
        var req = new XMLHttpRequest();
        var length;
        req.open('GET', url, true);
        req.overrideMimeType('text/plain; charset=x-user-defined');
        if (self.end) {
            if (self.end - self.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);
            length = self.end - self.start + 1;
        }
        req.responseType = 'arraybuffer';
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (req.status == 200 || req.status == 206) {
                    if (req.response) {
                        var bl = req.response.byteLength;
                        if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {
                            return self.fetch(callback, attempt + 1, bl);
                        } else {
                            return callback(req.response);
                        }
                    } else if (req.mozResponseArrayBuffer) {
                        return callback(req.mozResponseArrayBuffer);
                    } else {
                        var r = req.responseText;
                        if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {
                            return self.fetch(callback, attempt + 1, r.length);
                        } else {
                            return callback(bstringToBuffer(req.responseText));
                        }
                    }
                } else {
                    return self.fetch(callback, attempt + 1);
                }
            }
        };
        if (self.opts.credentials) {
            req.withCredentials = true;
        }
        req.send();
    }).catch(function (err) {
        console.log(err);
    });
};

function bstringToBuffer(result) {
    if (!result) {
        return null;
    }

    var ba = new Uint8Array(result.length);
    for (var i = 0; i < ba.length; ++i) {
        ba[i] = result.charCodeAt(i);
    }
    return ba.buffer;
}

if (typeof module !== 'undefined') {
    module.exports = {
        lookupEncodeURI: lookupEncodeURI,
        EncodeFetchable: EncodeFetchable
    };
}

},{"es6-promise":63}],16:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// ensembljson.js -- query the Ensembl REST API.
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;
}

function EnsemblFeatureSource(source) {
    FeatureSourceBase.call(this);
    this.source = source;
    this.base = source.uri || '//rest.ensembl.org';
    if (this.base.indexOf('//') === 0) {
        var proto = window.location.protocol;
        if (proto == 'http:' || proto == 'https:') {
            // Protocol-relative URLs okay.
        } else {
            this.base = 'http:' + this.base;
        }
    }
    this.species = source.species || 'human';

    if (typeof source.type === 'string') {
        this.type = [source.type];
    } else {
        this.type = source.type || ['regulatory'];
    }
}

EnsemblFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);
EnsemblFeatureSource.prototype.constructor = EnsemblFeatureSource;

EnsemblFeatureSource.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();

    var tsStyle = new DASStyle();
    tsStyle.glyph = '__NONE';
    if (this.type.indexOf('exon') >= 0) stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);
    if (this.type.indexOf('exon') >= 0 || this.type.indexOf('transcript') >= 0) stylesheet.pushStyle({ type: 'gene' }, null, tsStyle);

    var cdsStyle = new DASStyle();
    cdsStyle.glyph = 'BOX';
    cdsStyle.FGCOLOR = 'black';
    cdsStyle.BGCOLOR = 'red';
    cdsStyle.HEIGHT = 8;
    cdsStyle.BUMP = true;
    cdsStyle.LABEL = true;
    cdsStyle.ZINDEX = 10;
    stylesheet.pushStyle({ type: 'cds' }, null, cdsStyle);

    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'SQUARE';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: '.+_UTR_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'S';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: 'missense_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'N';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: 'splice_.+_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'STAR';
        varStyle.POINTS = 6;
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: 'regulatory_region_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'variation' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'SQUARE';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: '.+_UTR_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'S';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: 'missense_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'N';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: 'splice_.+_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'STAR';
        varStyle.POINTS = 6;
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: 'regulatory_region_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'indel' }, null, varStyle);
    }

    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = 'orange';
    wigStyle.HEIGHT = 8;
    wigStyle.BUMP = true;
    wigStyle.LABEL = true;
    wigStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
    return callback(stylesheet);
};

EnsemblFeatureSource.prototype.getScales = function () {
    return [];
};

EnsemblFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;
    var url = this.base + '/overlap/region/' + this.species + '/' + chr + ':' + min + '-' + max;

    var filters = [];
    for (var ti = 0; ti < this.type.length; ++ti) {
        filters.push('feature=' + this.type[ti]);
    }
    filters.push('content-type=application/json');
    url = url + '?' + filters.join(';');

    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            thisB.busy--;
            thisB.notifyActivity();

            if (req.status >= 300) {
                var err = 'Error code ' + req.status;
                try {
                    var jr = JSON.parse(req.response);
                    if (jr.error) {
                        err = jr.error;
                    }
                } catch (ex) {};

                callback(err, null);
            } else {
                var jf = JSON.parse(req.response);
                var features = [];
                for (var fi = 0; fi < jf.length; ++fi) {
                    var j = jf[fi];

                    var notes = [];
                    var f = new DASFeature();
                    f.segment = chr;
                    f.min = j['start'] | 0;
                    f.max = j['end'] | 0;
                    f.type = j.feature_type || 'unknown';
                    f.id = j.ID;

                    if (j.Parent) {
                        var grp = new DASGroup();
                        grp.id = j.Parent;
                        f.groups = [grp];
                    }

                    if (j.strand) {
                        if (j.strand < 0) f.orientation = '-';else if (j.strand > 0) f.orientation = '+';
                    }

                    if (j.consequence_type) f.method = j.consequence_type;

                    if (j.alt_alleles) {
                        notes.push('Alleles=' + j.alt_alleles.join('/'));
                        if (j.alt_alleles.length > 1) {
                            if (j.alt_alleles[1].length != j.alt_alleles[0].length || j.alt_alleles[1] == '-') {
                                f.type = 'indel';
                            }
                        }
                    }

                    if (notes.length > 0) {
                        f.notes = notes;
                    }
                    features.push(f);
                }
                callback(null, features);
            }
        }
    };

    thisB.busy++;
    thisB.notifyActivity();

    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

EnsemblFeatureSource.prototype.capabilities = function () {
    var caps = {};
    if (this.type && this.type.indexOf('transcript') >= 0) {
        caps.search = ['gene'];
    }
    return caps;
};

EnsemblFeatureSource.prototype.search = function (query, callback) {
    var url = this.base + '/lookup/symbol/' + this.species + '/' + query + '?content-type=application/json';
    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) if (req.status >= 300 || req.status < 200) {
            var err = 'Error code ' + req.status;
            try {
                var jr = JSON.parse(req.response);
                if (jr.error) {
                    err = jr.error;
                }
            } catch (ex) {};

            if (req.status == 400) // E! returns an error if the lookup fails.  Who knows?
                return callback([]);else return callback(null, err);
        } else {
            var resp = JSON.parse(req.response);
            var result = [];

            if (resp && resp.seq_region_name) {
                result.push({
                    segment: resp.seq_region_name,
                    min: resp.start,
                    max: resp.end
                });
            }

            return callback(result);
        }
    };

    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

dalliance_registerSourceAdapterFactory('ensembl', function (source) {
    return { features: new EnsemblFeatureSource(source) };
});

},{"./das":11,"./sourceadapters":41}],17:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-config.js
//

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;

    var das = require('./das');
    var copyStylesheet = das.copyStylesheet;
}

Browser.prototype.exportFullConfig = function (opts) {
    opts = opts || {};

    var config = {
        chr: this.chr,
        viewStart: this.viewStart | 0,
        viewEnd: this.viewEnd | 0,
        cookieKey: 'dalliance_' + hex_sha1(Date.now()),

        coordSystem: this.coordSystem,

        sources: this.exportSourceConfig(),

        chains: this.exportChains()
    };

    if (this.prefix) config.prefix = this.prefix;

    return config;
};

Browser.prototype.exportChains = function () {
    var cc = {};
    var cs = this.chains || {};
    for (var k in cs) {
        cc[k] = cs[k].exportConfig();
    }
    return cc;
};

Browser.prototype.exportSourceConfig = function (opts) {
    opts = opts || {};

    var sourceConfig = [];
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var source = shallowCopy(tier.dasSource);

        if (source.noPersist) continue;

        source.coords = undefined;
        source.props = undefined;
        if (!source.disabled) source.disabled = undefined;

        if (tier.config.stylesheet) {
            source.style = copyStylesheet(tier.config.stylesheet).styles;
            source.stylesheet_uri = undefined;
        } else if (source.style) {
            source.style = copyStylesheet({ styles: source.style }).styles;
        }

        if (typeof tier.config.name === 'string') {
            source.name = tier.config.name;
        }

        if (tier.config.height !== undefined) {
            source.forceHeight = tier.config.height;
        }
        if (tier.config.forceMin !== undefined) {
            source.forceMin = tier.config.forceMin;
        }
        if (tier.config.forceMinDynamic) source.forceMinDynamic = tier.config.forceMinDynamic;
        if (tier.config.forceMax !== undefined) {
            source.forceMax = tier.config.forceMax;
        }
        if (tier.config.bumped !== undefined) {
            source.bumped = tier.config.bumped;
        }
        if (tier.config.forceMaxDynamic) source.forceMaxDynamic = tier.config.forceMaxDynamic;

        sourceConfig.push(source);
    }

    return sourceConfig;
};

Browser.prototype.exportPageTemplate = function (opts) {
    opts = opts || {};
    var template = '<html>\n' + '  <head>\n' + '    <script language="javascript" src="' + this.resolveURL('$$dalliance-compiled.js') + '"></script>\n' + '    <script language="javascript">\n' + '      var dalliance_browser = new Browser(' + JSON.stringify(this.exportFullConfig(opts), null, 2) + ');\n' + '    </script>\n' + '  </head>\n' + '  <body>\n' + '    <div id="svgHolder">Dalliance goes here</div>\n' + '  </body>\n' + '<html>\n';

    return template;
};

},{"./cbrowser":6,"./das":11,"./sha1":40,"./utils":58}],18:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-image.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var g = require('./glyphs');
    var OverlayLabelCanvas = g.OverlayLabelCanvas;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
    var formatLongInt = nf.formatLongInt;

    var VERSION = require('./version');

    var drawSeqTierGC = require('./sequence-draw').drawSeqTierGC;
}

function fillTextRightJustified(g, text, x, y) {
    g.fillText(text, x - g.measureText(text).width, y);
}

Browser.prototype.exportImage = function (opts) {
    opts = opts || {};

    var fpw = opts.width || this.featurePanelWidth;
    var padding = 3;
    var ypos = 0;
    if (opts.banner || opts.region) {
        ypos = 40;
    }

    var backupFPW = this.featurePanelWidth;
    var backupScale = this.scale;
    this.featurePanelWidth = fpw;
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);

    var totHeight = ypos;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (ti > 0) totHeight += padding;
        var tier = this.tiers[ti];

        tier.backupSubtiers = tier.subtiers;
        tier.backupOriginHaxx = tier.originHaxx;
        tier.backupLayoutHeight = tier.layoutHeight;

        if (tier.subtiers) {
            var renderer = this.getTierRenderer(tier);
            if (renderer && renderer.prepareSubtiers) {
                renderer.prepareSubtiers(tier, tier.viewport.getContext('2d'));
            }

            if (tier.subtiers) {
                var lh = tier.padding;
                for (var s = 0; s < tier.subtiers.length; ++s) {
                    lh = lh + tier.subtiers[s].height + tier.padding;
                }
                lh += 6;
                tier.layoutHeight = Math.max(lh, this.minTierHeight);
            }
        }

        if (tier.layoutHeight !== undefined) totHeight += tier.layoutHeight;
    }
    var mult = opts.resolutionMultiplier || 1.0;
    var margin = 200;

    var cw = (fpw + margin) * mult | 0;
    var ch = totHeight * mult | 0;
    var c = makeElement('canvas', null, { width: cw, height: ch });
    var g = c.getContext('2d');
    g.fillStyle = 'white';
    g.fillRect(0, 0, cw, ch);

    g.scale(mult, mult);

    if (opts.region) {
        g.save();
        g.fillStyle = 'black';
        g.font = '12pt sans-serif';
        g.fillText(this.chr + ':' + formatLongInt(this.viewStart) + '..' + formatLongInt(this.viewEnd), margin + 100, 28);
        g.restore();
    }

    if (opts.banner) {
        g.save();
        g.fillStyle = 'black';
        g.font = '12pt sans-serif';
        fillTextRightJustified(g, 'Graphics from Biodalliance ' + VERSION, margin + fpw - 100, 28);
        g.restore();
    }

    g.font = '10px sans-serif';

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var offset = (tier.glyphCacheOrigin - this.viewStart) * this.scale;

        var oc = new OverlayLabelCanvas();
        g.save(); // 1
        g.translate(0, ypos);

        g.save(); // 2
        g.beginPath();
        g.moveTo(margin, 0);
        g.lineTo(margin + fpw, 0);
        g.lineTo(margin + fpw, tier.layoutHeight);
        g.lineTo(margin, tier.layoutHeight);
        g.closePath();
        g.clip();
        g.translate(margin, 0);

        g.save(); // 3
        g.translate(offset, 0);
        if (tier.subtiers) {
            tier.paintToContext(g, oc, offset + 1000);
        } else {
            drawSeqTierGC(tier, tier.currentSequence, g);
        }
        g.restore(); // 2

        g.save(); // 3
        g.translate(offset, 0);
        oc.draw(g, -offset, fpw - offset);
        g.restore(); // 2
        g.restore(); // 1

        var hasQuant = false;
        var pos = 0;
        var subtiers = tier.subtiers || [];
        for (var sti = 0; sti < subtiers.length; ++sti) {
            var subtier = subtiers[sti];

            if (subtier.quant) {
                hasQuant = true;
                var q = subtier.quant;
                var h = subtier.height;

                var numTics = 2;
                if (h > 40) {
                    numTics = 1 + (h / 20 | 0);
                }
                var ticSpacing = h / (numTics - 1);
                var ticInterval = (q.max - q.min) / (numTics - 1);

                g.beginPath();
                g.moveTo(margin + 5, pos);
                g.lineTo(margin, pos);
                g.lineTo(margin, pos + subtier.height);
                g.lineTo(margin + 5, pos + subtier.height);
                for (var t = 1; t < numTics - 1; ++t) {
                    var ty = t * ticSpacing;
                    g.moveTo(margin, pos + ty);
                    g.lineTo(margin + 3, pos + ty);
                }
                g.strokeStyle = 'black';
                g.strokeWidth = 2;
                g.stroke();

                g.fillStyle = 'black';
                fillTextRightJustified(g, formatQuantLabel(q.max), margin - 3, pos + 7);
                fillTextRightJustified(g, formatQuantLabel(q.min), margin - 3, pos + subtier.height);
                for (var t = 1; t < numTics - 1; ++t) {
                    var ty = t * ticSpacing;
                    fillTextRightJustified(g, formatQuantLabel(1.0 * q.max - t * ticInterval), margin - 3, pos + ty + 3);
                }
            }

            pos += subtier.height + padding;
        }

        var labelName;
        if (typeof tier.config.name === 'string') labelName = tier.config.name;else labelName = tier.dasSource.name;
        var labelWidth = g.measureText(labelName).width;
        g.fillStyle = 'black';
        g.fillText(labelName, margin - (hasQuant ? 28 : 12) - labelWidth, (tier.layoutHeight + 3) / 2);

        g.restore(); // 0

        ypos += tier.layoutHeight + padding;

        tier.subtiers = tier.backupSubtiers;
        tier.originHaxx = tier.backupOriginHaxx;
        tier.layoutHeight = tier.backupLayoutHeight;
    }

    if (opts.highlights) {
        g.save();

        g.beginPath();
        g.moveTo(margin, 0);
        g.lineTo(margin + fpw, 0);
        g.lineTo(margin + fpw, ypos);
        g.lineTo(margin, ypos);
        g.closePath();
        g.clip();

        g.translate(margin + offset, 0);
        var origin = this.viewStart;
        var visStart = this.viewStart;
        var visEnd = this.viewEnd;

        for (var hi = 0; hi < this.highlights.length; ++hi) {
            var h = this.highlights[hi];
            if ((h.chr === this.chr || h.chr === 'chr' + this.chr) && h.min < visEnd && h.max > visStart) {
                g.globalAlpha = this.defaultHighlightAlpha;
                g.fillStyle = this.defaultHighlightFill;
                g.fillRect((h.min - origin) * this.scale, 0, (h.max - h.min) * this.scale, ypos);
            }
        }
        g.restore();
    }

    var rulerPos = -1;
    if (opts.ruler == 'center') {
        rulerPos = margin + (this.viewEnd - this.viewStart + 1) * this.scale / 2;
    } else if (opts.ruler == 'left') {
        rulerPos = margin;
    } else if (opts.ruler == 'right') {
        rulerPos = margin + (this.viewEnd - this.viewStart + 1) * this.scale;
    }
    if (rulerPos >= 0) {
        g.strokeStyle = 'blue';
        g.beginPath();
        g.moveTo(rulerPos, 0);
        g.lineTo(rulerPos, ypos);
        g.stroke();
    }

    this.featurePanelWidth = backupFPW;
    this.scale = backupScale;

    return c.toDataURL('image/png');
};

},{"./cbrowser":6,"./glyphs":24,"./numformats":30,"./sequence-draw":38,"./version":60}],19:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-ui.js
//

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
}

Browser.prototype.openExportPanel = function () {
    var b = this;
    if (this.uiMode === 'export') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var exportForm = makeElement('div', null, { className: 'export-form' });
        var exportSelect = makeElement('select');
        exportSelect.appendChild(makeElement('option', 'SVG', { value: 'svg' }));
        exportSelect.appendChild(makeElement('option', 'Image', { value: 'png' }));
        exportSelect.appendChild(makeElement('option', 'Dalliance config', { value: 'config' }));
        exportSelect.appendChild(makeElement('option', 'Dalliance sources', { value: 'sources' }));
        exportSelect.appendChild(makeElement('option', 'Dalliance page', { value: 'page' }));
        exportSelect.value = 'svg';

        exportSelect.addEventListener('change', function (ev) {
            removeChildren(exportContent);
            setupEOT();
        }, false);
        exportForm.appendChild(makeElement('p', ['Export as: ', exportSelect]));

        var exportHighlightsToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportHighlights });
        exportHighlightsToggle.addEventListener('change', function (ev) {
            b.exportHighlights = exportHighlightsToggle.checked;
            b.storeStatus();
        }, false);
        var exportRulerToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportRuler });
        exportRulerToggle.addEventListener('change', function (ev) {
            b.exportRuler = exportRulerToggle.checked;
            b.storeStatus();
        }, false);
        var exportRegionToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportRegion });
        exportRegionToggle.addEventListener('change', function (ev) {
            b.exportRegion = exportRegionToggle.checked;
            b.storeStatus();
        }, false);
        var exportBannerToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportBanner });
        exportBannerToggle.addEventListener('change', function (ev) {
            b.exportBanner = exportBannerToggle.checked;
            b.storeStatus();
        }, false);
        var exportScale = makeElement('input', null, { type: 'text', value: '1.0' });
        var exportWidth = makeElement('input', null, { type: 'text', value: '800' });

        var exportButton = makeElement('button', 'Export', { className: 'btn btn-primary' });
        exportButton.addEventListener('click', function (ev) {
            removeChildren(exportContent);

            var blobURL;
            var note, type, name;
            if (exportSelect.value === 'svg') {
                blobURL = URL.createObjectURL(b.makeSVG({ highlights: exportHighlightsToggle.checked,
                    banner: b.exportBanner,
                    region: b.exportRegion,
                    ruler: exportRulerToggle.checked ? b.rulerLocation : 'none',
                    width: parseInt(exportWidth.value) || 800 }));
                note = 'SVG';
                type = 'image/svg';
                name = 'dalliance-view.svg';
            } else if (exportSelect.value === 'png') {
                var mult = parseFloat(exportScale.value);
                if (mult < 0.1 || mult > 10) {
                    alert('bad scale ' + mult);
                    return;
                }

                blobURL = b.exportImage({ highlights: exportHighlightsToggle.checked,
                    banner: b.exportBanner,
                    region: b.exportRegion,
                    ruler: exportRulerToggle.checked ? b.rulerLocation : 'none',
                    resolutionMultiplier: mult,
                    width: parseInt(exportWidth.value) || 800 });
                note = 'Image';
                type = 'image/png';
                name = 'dalliance-view.png';
            } else if (exportSelect.value === 'config') {
                var config = JSON.stringify(b.exportFullConfig(), null, 2);
                var blob = new Blob([config], { type: 'text/plain' });
                blobURL = URL.createObjectURL(blob);
                note = 'Configuration';
                type = 'text/plain';
                name = 'dalliance-config.json';
            } else if (exportSelect.value === 'sources') {
                var config = JSON.stringify(b.exportSourceConfig(), null, 2);
                var blob = new Blob([config], { type: 'text/plain' });
                blobURL = URL.createObjectURL(blob);
                note = 'Source array';
                type = 'text/plain';
                name = 'dalliance-sources.json';
            } else if (exportSelect.value === 'page') {
                var page = b.exportPageTemplate();
                var type = 'text/html';
                var blob = new Blob([page], { type: type });
                blobURL = URL.createObjectURL(blob);
                note = 'Page template';
                name = 'dalliance-view.html';
            }

            if (blobURL) {
                var downloadLink = makeElement('a', '[Download]', {
                    href: blobURL,
                    download: name,
                    type: type
                });

                var previewLink = makeElement('a', '[Preview in browser]', {
                    href: blobURL,
                    type: type,
                    target: '_new'
                });

                exportContent.appendChild(makeElement('p', ['' + note + ' created: ', downloadLink, previewLink]));
            }
        }, false);

        b.addViewListener(function () {
            removeChildren(exportContent);
        });
        b.addTierListener(function () {
            removeChildren(exportContent);
        });

        var exportContent = makeElement('p', '');

        var eotHighlights = makeElement('tr', [makeElement('th', 'Include highlights', {}, { width: '400px', textAlign: 'right' }), makeElement('td', exportHighlightsToggle)]);
        var eotGuideline = makeElement('tr', [makeElement('th', 'Include vertical guideline', {}, { textAlign: 'right' }), makeElement('td', exportRulerToggle)]);
        var eotScale = makeElement('tr', [makeElement('th', 'Scale multiplier', {}, { textAlign: 'right' }), makeElement('td', exportScale)]);
        var eotWidth = makeElement('tr', [makeElement('th', 'Width (logical px)', {}, { textAlign: 'right' }), makeElement('td', exportWidth)]);
        var eotRegion = makeElement('tr', [makeElement('th', 'Label with genomic coordinates', {}, { textAlign: 'right' }), makeElement('td', exportRegionToggle)]);
        var eotBanner = makeElement('tr', [makeElement('th', 'Include banner', {}, { textAlign: 'right' }), makeElement('td', exportBannerToggle)]);

        var exportOptsTable = makeElement('table', [eotHighlights, eotGuideline, eotWidth, eotScale, eotRegion], null, { width: '500px' });
        var setupEOT = function setupEOT() {
            var es = exportSelect.value;
            eotHighlights.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotGuideline.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotScale.style.display = es == 'png' ? 'table-row' : 'none';
            eotWidth.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotRegion.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotBanner.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
        };
        setupEOT();

        exportForm.appendChild(exportOptsTable);
        exportForm.appendChild(exportButton);
        exportForm.appendChild(exportContent);

        if (this.uiMode !== 'none') this.hideToolPanel();
        this.browserHolder.insertBefore(exportForm, this.svgHolder);
        this.activeToolPanel = exportForm;

        this.setUiMode('export');
    }
};

},{"./cbrowser":6,"./utils":58}],20:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// exports.js: shim to export symbols into global namespace for ease of embedding
//

var browser = require('./cbrowser');
var chainset = require('./chainset');
var sa = require('./sourceadapters');
var utils = require('./utils');
var das = require('./das');
var sc = require('./sourcecompare');

window.Browser = browser.Browser;
window.sourcesAreEqual = sc.sourcesAreEqual;
window.Chainset = chainset.Chainset; // Pre-0.12 configurations need this.

// Useful for info plugins.  Should be reconsidered in the future.
window.makeElement = utils.makeElement;

// Allow source plugins to be loaded separately.
window.dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
window.dalliance_registerParserFactory = sa.registerParserFactory;
window.dalliance_makeParser = sa.makeParser;

// DAS* objects for some plugins -- remove when plugin API changes...

window.DASSequence = das.DASSequence;
window.DASFeature = das.DASFeature;
window.DASGroup = das.DASGroup;
window.DASStylesheet = das.DASStylesheet;
window.DASStyle = das.DASStyle;
window.DASSource = das.DASSource; // Pre-0.8 configurations used this.  Still some around...

var ruler = require("./rulers");
window.Ruler = ruler.Ruler;
window.rulerDrawCallback = ruler.rulerDrawCallback;

window.WrappedRenderer = require("./wrapped-renderer.es6");

},{"./cbrowser":6,"./chainset":7,"./das":11,"./rulers":35,"./sourceadapters":41,"./sourcecompare":42,"./utils":58,"./wrapped-renderer.es6":61}],21:[function(require,module,exports){
//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// feature-draw.js: new feature-tier renderer
//

"use strict";

if (typeof require !== 'undefined') {
    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
}

function SubTier() {
    this.glyphs = [];
    this.height = 0;
    this.quant = null;
}

SubTier.prototype.indexFor = function (glyph) {
    var gmin = glyph.min();
    var lb = 0,
        ub = this.glyphs.length;
    while (ub > lb) {
        var mid = (lb + ub) / 2 | 0;
        if (mid >= this.glyphs.length) return this.glyphs.length;
        var mg = this.glyphs[mid];
        if (gmin < mg.min()) {
            ub = mid;
        } else {
            lb = mid + 1;
        }
    }
    return ub;
};

SubTier.prototype.add = function (glyph) {
    var ind = this.indexFor(glyph);
    this.glyphs.splice(ind, 0, glyph);
    this.height = Math.max(this.height, glyph.height());
    if (glyph.quant && this.quant == null) {
        this.quant = glyph.quant;
    }
};

SubTier.prototype.hasSpaceFor = function (glyph) {
    var ind = this.indexFor(glyph);
    if (ind > 0 && this.glyphs[ind - 1].max() >= glyph.min()) return false;
    if (ind < this.glyphs.length && this.glyphs[ind].min() <= glyph.max()) return false;

    return true;
};

DasTier.prototype.paintToContext = function (gc, oc, offset) {
    var subtiers = this.subtiers;
    var fpw = this.viewport.width | 0;

    gc.save();
    for (var s = 0; s < subtiers.length; ++s) {
        var quant = null;
        var glyphs = subtiers[s].glyphs;
        for (var i = 0; i < glyphs.length; ++i) {
            var glyph = glyphs[i];
            if (glyph.min() < fpw - offset && glyph.max() > -offset) {
                var glyph = glyphs[i];
                glyph.draw(gc, oc);
                if (glyph.quant) {
                    quant = glyph.quant;
                }
            }
        }

        if (quant && quant.min < 0 && quant.max > 0 && this.dasSource.zeroLine) {
            var ry = subtiers[0].height * (quant.max / (quant.max - quant.min));
            gc.save();
            gc.strokeStyle = this.dasSource.zeroLine;
            gc.lineWidth = 0.5;
            gc.beginPath();
            gc.moveTo(-1000, ry);
            gc.lineTo(fpw + 1000, ry);
            gc.stroke();
            gc.restore();
        }

        if (this.scaleVertical) {
            var scale = this.browser.scale;
            gc.translate(0, scale + this.padding);
            oc.translate(0, scale + this.padding);
        } else {
            gc.translate(0, subtiers[s].height + this.padding);
            oc.translate(0, subtiers[s].height + this.padding);
        }
    }
    gc.restore();

    if (quant && this.quantLeapThreshold && this.featureSource && this.browser.sourceAdapterIsCapable(this.featureSource, 'quantLeap')) {
        var ry = subtiers[0].height * (1.0 - (this.quantLeapThreshold - quant.min) / (quant.max - quant.min));

        gc.save();
        gc.strokeStyle = 'red';
        gc.lineWidth = 0.3;
        gc.beginPath();
        gc.moveTo(-1000, ry);
        gc.lineTo(fpw + 1000, ry);
        gc.stroke();
        gc.restore();
    }
};

DasTier.prototype.paintQuant = function () {
    if (!this.quantOverlay) return;

    var retina = this.browser.retina && window.devicePixelRatio > 1;

    var quant;
    if (this.subtiers && this.subtiers.length > 0) quant = this.subtiers[0].quant;

    if (quant) {
        var h = this.subtiers[0].height;
        var w = 50;
        this.quantOverlay.height = this.viewport.height;
        this.quantOverlay.width = retina ? w * 2 : w;
        this.quantOverlay.style.height = '' + (retina ? this.quantOverlay.height / 2 : this.quantOverlay.height) + 'px';
        this.quantOverlay.style.width = '' + w + 'px';
        this.quantOverlay.style.display = 'block';
        var ctx = this.quantOverlay.getContext('2d');
        if (retina) ctx.scale(2, 2);

        var numTics = 2;
        if (h > 40) {
            numTics = 1 + (h / 20 | 0);
        }
        var ticSpacing = (h + this.padding * 2) / (numTics - 1);
        var ticInterval = (quant.max - quant.min) / (numTics - 1);

        ctx.fillStyle = 'white';
        ctx.globalAlpha = 0.6;
        if (this.browser.rulerLocation == 'right') {
            ctx.fillRect(w - 30, 0, 30, h + this.padding * 2);
        } else {
            ctx.fillRect(0, 0, 30, h + this.padding * 2);
        }
        ctx.globalAlpha = 1.0;

        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();

        if (this.browser.rulerLocation == 'right') {
            ctx.moveTo(w - 8, this.padding);
            ctx.lineTo(w, this.padding);
            ctx.lineTo(w, h + this.padding);
            ctx.lineTo(w - 8, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.moveTo(w, ty);
                ctx.lineTo(w - 5, ty);
            }
        } else {
            ctx.moveTo(8, this.padding);
            ctx.lineTo(0, this.padding);
            ctx.lineTo(0, h + this.padding);
            ctx.lineTo(8, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.moveTo(0, ty);
                ctx.lineTo(5, ty);
            }
        }
        ctx.stroke();

        ctx.fillStyle = 'black';

        if (this.browser.rulerLocation == 'right') {
            ctx.textAlign = 'right';
            ctx.fillText(formatQuantLabel(quant.max), w - 9, 8);
            ctx.fillText(formatQuantLabel(quant.min), w - 9, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.fillText(formatQuantLabel(1.0 * quant.max - t * ticInterval), w - 9, ty + 3);
            }
        } else {
            ctx.textAlign = 'left';
            ctx.fillText(formatQuantLabel(quant.max), 9, 8);
            ctx.fillText(formatQuantLabel(quant.min), 9, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.fillText(formatQuantLabel(1.0 * quant.max - t * ticInterval), 9, ty + 3);
            }
        }
    } else {
        this.quantOverlay.style.display = 'none';
    }
};

DasTier.prototype.styleForFeature = function (f) {
    var ssScale = this.browser.zoomForCurrentScale();

    if (!this.stylesheet) {
        return null;
    }

    var maybe = null;
    var ss = this.stylesheet.styles;
    for (var si = 0; si < ss.length; ++si) {
        var sh = ss[si];
        if (sh.zoom && sh.zoom != ssScale) {
            continue;
        }

        if (sh.orientation) {
            if (sh.orientation != f.orientation) {
                continue;
            }
        }

        var labelRE = sh._labelRE;
        if (!labelRE || !labelRE.test) {
            labelRE = new RegExp('^' + sh.label + '$');
            sh._labelRE = labelRE;
        }
        if (sh.label && !labelRE.test(f.label)) {
            continue;
        }
        var methodRE = sh._methodRE;
        if (!methodRE || !methodRE.test) {
            methodRE = new RegExp('^' + sh.method + '$');
            sh._methodRE = methodRE;
        }
        if (sh.method && !methodRE.test(f.method)) {
            continue;
        }
        if (sh.type) {
            if (sh.type == 'default') {
                if (!maybe) {
                    maybe = sh.style;
                }
                continue;
            } else {
                var typeRE = sh._typeRE;
                if (!typeRE || !typeRE.test) {
                    typeRE = new RegExp('^' + sh.type + '$');
                    sh._typeRE = typeRE;
                }
                if (!typeRE.test(f.type)) continue;
            }
        }
        return sh.style;
    }
    return maybe;
};

DasTier.prototype.quantMin = function (style) {
    if (this.forceMinDynamic) {
        return this.currentFeaturesMinScore || 0;
    } else if (typeof this.forceMin === 'number') {
        return this.forceMin;
    } else {
        return style.MIN || this.currentFeaturesMinScore || 0;
    }
};

DasTier.prototype.quantMax = function (style) {
    if (this.forceMaxDynamic) {
        return this.currentFeaturesMaxScore || 0;
    } else if (typeof this.forceMax === 'number') {
        return this.forceMax;
    } else {
        return style.MAX || this.currentFeaturesMaxScore || 0;
    }
};

if (typeof module !== 'undefined') {
    module.exports = {
        SubTier: SubTier
    };
}

},{"./numformats":30,"./tier":54}],22:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// feature-popup.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var pick = utils.pick;
    var pushnew = utils.pushnew;
    var makeElement = utils.makeElement;
}

var TAGVAL_NOTE_RE = new RegExp('^([A-Za-z_-]+)=(.+)');

Browser.prototype.addFeatureInfoPlugin = function (handler) {
    if (!this.featureInfoPlugins) {
        this.featureInfoPlugins = [];
    }
    this.featureInfoPlugins.push(handler);
};

function FeatureInfo(hit, feature, group) {
    var name = pick(group.type, feature.type);
    var fid = pick(group.label, feature.label, group.id, feature.id);
    if (fid && fid.indexOf('__dazzle') != 0) {
        name = name + ': ' + fid;
    }

    this.hit = hit;
    this.feature = feature;
    this.group = group;
    this.title = name;
    this.sections = [];
}

FeatureInfo.prototype.setTitle = function (t) {
    this.title = t;
};

FeatureInfo.prototype.add = function (label, info) {
    if (typeof info === 'string') {
        info = makeElement('span', info);
    }
    this.sections.push({ label: label, info: info });
};

Browser.prototype.featurePopup = function (ev, __ignored_feature, hit, tier) {
    var hi = hit.length;
    var feature = --hi >= 0 ? hit[hi] : {};
    var group = --hi >= 0 ? hit[hi] : {};

    var featureInfo = new FeatureInfo(hit, feature, group);
    featureInfo.tier = tier;
    var fips = this.featureInfoPlugins || [];
    for (var fipi = 0; fipi < fips.length; ++fipi) {
        try {
            fips[fipi](feature, featureInfo);
        } catch (e) {
            console.log(e.stack || e);
        }
    }
    fips = tier.featureInfoPlugins || [];
    for (fipi = 0; fipi < fips.length; ++fipi) {
        try {
            fips[fipi](feature, featureInfo);
        } catch (e) {
            console.log(e.stack || e);
        }
    }

    this.removeAllPopups();

    var table = makeElement('table', null, { className: 'table table-striped table-condensed' });
    table.style.width = '100%';
    table.style.margin = '0px';

    var idx = 0;
    if (feature.method && !tier.dasSource.suppressMethod) {
        var row = makeElement('tr', [makeElement('th', 'Method'), makeElement('td', feature.method)]);
        table.appendChild(row);
        ++idx;
    }
    {
        var loc;
        if (group.segment) {
            loc = group;
        } else {
            loc = feature;
        }
        var row = makeElement('tr', [makeElement('th', 'Location'), makeElement('td', loc.segment + ':' + loc.min + '-' + loc.max, {}, { minWidth: '200px' })]);
        table.appendChild(row);
        ++idx;
    }
    if (feature.score !== undefined && feature.score !== null && feature.score != '-' && !feature.suppressScore && !tier.dasSource.suppressScore) {
        var row = makeElement('tr', [makeElement('th', 'Score'), makeElement('td', '' + feature.score)]);
        table.appendChild(row);
        ++idx;
    }
    {
        var links = maybeConcat(group.links, feature.links);
        if (links && links.length > 0) {
            var row = makeElement('tr', [makeElement('th', 'Links'), makeElement('td', links.map(function (l) {
                return makeElement('div', makeElement('a', l.desc, { href: l.uri, target: '_new' }));
            }))]);
            table.appendChild(row);
            ++idx;
        }
    }
    {
        var notes = maybeConcat(group.notes, feature.notes);
        for (var ni = 0; ni < notes.length; ++ni) {
            var k = 'Note';
            var v = notes[ni];
            var m = v.match(TAGVAL_NOTE_RE);
            if (m) {
                k = m[1];
                v = m[2];
            }

            var row = makeElement('tr', [makeElement('th', k), makeElement('td', v)]);
            table.appendChild(row);
            ++idx;
        }
    }

    for (var fisi = 0; fisi < featureInfo.sections.length; ++fisi) {
        var section = featureInfo.sections[fisi];
        table.appendChild(makeElement('tr', [makeElement('th', section.label), makeElement('td', section.info)]));
    }

    this.popit(ev, featureInfo.title || 'Feature', table, { width: 450 });
};

function maybeConcat(a, b) {
    var l = [];
    if (a) {
        for (var i = 0; i < a.length; ++i) {
            pushnew(l, a[i]);
        }
    }
    if (b) {
        for (var i = 0; i < b.length; ++i) {
            pushnew(l, b[i]);
        }
    }
    return l;
}

},{"./cbrowser":6,"./utils":58}],23:[function(require,module,exports){
"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var pusho = utils.pusho;
    var pushnewo = utils.pushnewo;
}

function sortFeatures(tier) {
    var dmin = tier.browser.drawnStart,
        dmax = tier.browser.drawnEnd;
    var ungroupedFeatures = {};
    var groupedFeatures = {};
    var drawnGroupedFeatures = {};
    var groupMins = {},
        groupMaxes = {};
    var groups = {};
    var superGroups = {};
    var groupsToSupers = {};
    var nonPositional = [];
    var minScore, maxScore;
    var fbid;

    var init_fbid = function init_fbid() {
        fbid = {};
        for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {
            var f = tier.currentFeatures[fi];
            if (f.id) {
                fbid[f.id] = f;
            }
        }
    };

    var superParentsOf = function superParentsOf(f) {
        // FIXME: should recur.
        var spids = [];
        if (f.parents) {
            for (var pi = 0; pi < f.parents.length; ++pi) {
                var pid = f.parents[pi];
                var p = fbid[pid];
                if (!p) {
                    continue;
                }
                // alert(p.type + ':' + p.typeCv);
                if (p.typeCv == 'SO:0000704') {
                    pushnew(spids, pid);
                }
            }
        }
        return spids;
    };

    for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {
        var f = tier.currentFeatures[fi];
        if (f.parts) {
            continue;
        }

        var drawn = f.min <= dmax && f.max >= dmin;

        if (!f.min || !f.max) {
            nonPositional.push(f);
            continue;
        }

        if (f.score && f.score != '.' && f.score != '-') {
            var sc = 1.0 * f.score;
            if (!minScore || sc < minScore) {
                minScore = sc;
            }
            if (!maxScore || sc > maxScore) {
                maxScore = sc;
            }
        }

        var fGroups = [];
        var fSuperGroup = null;
        if (f.groups) {
            for (var gi = 0; gi < f.groups.length; ++gi) {
                var g = f.groups[gi];
                var gid = g.id;
                if (g.type == 'gene') {
                    // Like a super-grouper...
                    fSuperGroup = gid;
                    groups[gid] = g;
                } else if (g.type == 'translation') {
                    // have to ignore this to get sensible results from bj-e :-(.
                } else {
                    pusho(groupedFeatures, gid, f);
                    groups[gid] = g;
                    fGroups.push(gid);

                    var ogm = groupMins[gid];
                    if (!ogm || f.min < ogm) groupMins[gid] = f.min;

                    ogm = groupMaxes[gid];
                    if (!ogm || f.max > ogm) groupMaxes[gid] = f.max;
                }
            }
        }

        if (f.parents) {
            if (!fbid) {
                init_fbid();
            }
            for (var pi = 0; pi < f.parents.length; ++pi) {
                var pid = f.parents[pi];
                var p = fbid[pid];
                if (!p) {
                    // alert("couldn't find " + pid);
                    continue;
                }
                if (!p.parts) {
                    p.parts = [f];
                }
                pushnewo(groupedFeatures, pid, p);
                pusho(groupedFeatures, pid, f);

                if (!groups[pid]) {
                    groups[pid] = {
                        type: p.type,
                        id: p.id,
                        label: p.label || p.id
                    };
                }
                fGroups.push(pid);

                var ogm = groupMins[pid];
                if (!ogm || f.min < ogm) groupMins[pid] = f.min;

                ogm = groupMaxes[pid];
                if (!ogm || f.max > ogm) groupMaxes[pid] = f.max;

                var sgs = superParentsOf(p);
                if (sgs.length > 0) {
                    fSuperGroup = sgs[0];
                    var sp = fbid[sgs[0]];
                    groups[sgs[0]] = {
                        type: sp.type,
                        id: sp.id,
                        label: sp.label || sp.id
                    };
                    if (!tier.dasSource.collapseSuperGroups) {
                        tier.dasSource.collapseSuperGroups = true;
                    }
                }
            }
        }

        if (fGroups.length == 0) {
            if (drawn) pusho(ungroupedFeatures, f.type, f);
        } else if (fSuperGroup) {
            for (var g = 0; g < fGroups.length; ++g) {
                var gid = fGroups[g];
                pushnewo(superGroups, fSuperGroup, gid);
                groupsToSupers[gid] = fSuperGroup;
            }
        }
    }

    for (var gid in groupedFeatures) {
        var group = groups[gid];
        if (typeof group.min !== 'number') group.min = groupMins[gid];
        if (typeof group.max !== 'number') group.max = groupMaxes[gid];

        if (groupMaxes[gid] >= dmin && groupMins[gid] <= dmax) drawnGroupedFeatures[gid] = groupedFeatures[gid];
    }

    tier.ungroupedFeatures = ungroupedFeatures;
    tier.groupedFeatures = drawnGroupedFeatures;
    tier.groups = groups;
    tier.superGroups = superGroups;
    tier.groupsToSupers = groupsToSupers;

    if (minScore) {
        if (minScore > 0) {
            minScore = 0;
        } else if (maxScore < 0) {
            maxScore = 0;
        }
        tier.currentFeaturesMinScore = minScore;
        tier.currentFeaturesMaxScore = maxScore;
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        sortFeatures: sortFeatures
    };
}

},{"./utils":58}],24:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// glyphs.js: components which know how to draw themselves
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var union = spans.union;
    var Range = spans.Range;

    var utils = require('./utils');
    var makeElementNS = utils.makeElementNS;
    var AMINO_ACID_TRANSLATION = utils.AMINO_ACID_TRANSLATION;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;
}

function PathGlyphBase(stroke, fill) {
    this._stroke = stroke;
    this._fill = fill;
}

PathGlyphBase.prototype.draw = function (g) {
    g.beginPath();
    this.drawPath(g);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }
    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
};

PathGlyphBase.prototype.toSVG = function () {
    var g = new SVGPath();
    this.drawPath(g);

    return makeElementNS(NS_SVG, 'path', null, { d: g.toPathData(),
        fill: this._fill || 'none',
        stroke: this._stroke || 'none' });
};

PathGlyphBase.prototype.drawPath = function (g) {
    throw 'drawPath method on PathGlyphBase must be overridden';
};

function BoxGlyph(x, y, width, height, fill, stroke, alpha, radius) {
    this.x = x;
    this.y = y;
    this._width = width;
    this._height = height;
    this.fill = fill;
    this.stroke = stroke;
    this._alpha = alpha;
    this._radius = radius || 0;
}

BoxGlyph.prototype.draw = function (g) {
    var r = this._radius;

    if (r > 0) {
        g.beginPath();
        g.moveTo(this.x + r, this.y);
        g.lineTo(this.x + this._width - r, this.y);
        g.arcTo(this.x + this._width, this.y, this.x + this._width, this.y + r, r);
        g.lineTo(this.x + this._width, this.y + this._height - r);
        g.arcTo(this.x + this._width, this.y + this._height, this.x + this._width - r, this.y + this._height, r);
        g.lineTo(this.x + r, this.y + this._height);
        g.arcTo(this.x, this.y + this._height, this.x, this.y + this._height - r, r);
        g.lineTo(this.x, this.y + r);
        g.arcTo(this.x, this.y, this.x + r, this.y, r);
        g.closePath();

        if (this._alpha != null) {
            g.save();
            g.globalAlpha = this._alpha;
        }

        if (this.fill) {
            g.fillStyle = this.fill;
            g.fill();
        }
        if (this.stroke) {
            g.strokeStyle = this.stroke;
            g.lineWidth = 0.5;
            g.stroke();
        }

        if (this._alpha != null) {
            g.restore();
        }
    } else {
        if (this._alpha != null) {
            g.save();
            g.globalAlpha = this._alpha;
        }

        if (this.fill) {
            g.fillStyle = this.fill;
            g.fillRect(this.x, this.y, this._width, this._height);
        }

        if (this.stroke) {
            g.strokeStyle = this.stroke;
            g.lineWidth = 0.5;
            g.strokeRect(this.x, this.y, this._width, this._height);
        }

        if (this._alpha != null) {
            g.restore();
        }
    }
};

BoxGlyph.prototype.toSVG = function () {
    var s = makeElementNS(NS_SVG, 'rect', null, { x: this.x,
        y: this.y,
        width: this._width,
        height: this._height,
        stroke: this.stroke || 'none',
        strokeWidth: 0.5,
        fill: this.fill || 'none' });
    if (this._alpha != null) {
        s.setAttribute('opacity', this._alpha);
    }

    return s;
};

BoxGlyph.prototype.min = function () {
    return this.x;
};

BoxGlyph.prototype.max = function () {
    return this.x + this._width;
};

BoxGlyph.prototype.height = function () {
    return this.y + this._height;
};

function GroupGlyph(glyphs, connector) {
    this.glyphs = glyphs;
    this.connector = connector;
    this.h = glyphs[0].height();

    var covList = [];
    for (var g = 0; g < glyphs.length; ++g) {
        var gg = glyphs[g];
        covList.push(new Range(gg.min(), gg.max()));
        this.h = Math.max(this.h, gg.height());
    }
    this.coverage = union(covList);
}

GroupGlyph.prototype.drawConnectors = function (g) {
    var ranges = this.coverage.ranges();
    for (var r = 1; r < ranges.length; ++r) {
        var gl = ranges[r];
        var last = ranges[r - 1];
        if (last && gl.min() > last.max()) {
            var start = last.max();
            var end = gl.min();
            var mid = (start + end) / 2;

            if (this.connector === 'hat+') {
                g.moveTo(start, this.h / 2);
                g.lineTo(mid, 0);
                g.lineTo(end, this.h / 2);
            } else if (this.connector === 'hat-') {
                g.moveTo(start, this.h / 2);
                g.lineTo(mid, this.h);
                g.lineTo(end, this.h / 2);
            } else if (this.connector === 'collapsed+') {
                g.moveTo(start, this.h / 2);
                g.lineTo(end, this.h / 2);
                if (end - start > 4) {
                    g.moveTo(mid - 2, this.h / 2 - 3);
                    g.lineTo(mid + 2, this.h / 2);
                    g.lineTo(mid - 2, this.h / 2 + 3);
                }
            } else if (this.connector === 'collapsed-') {
                g.moveTo(start, this.h / 2);
                g.lineTo(end, this.h / 2);
                if (end - start > 4) {
                    g.moveTo(mid + 2, this.h / 2 - 3);
                    g.lineTo(mid - 2, this.h / 2);
                    g.lineTo(mid + 2, this.h / 2 + 3);
                }
            } else {
                g.moveTo(start, this.h / 2);
                g.lineTo(end, this.h / 2);
            }
        }
        last = gl;
    }
};

GroupGlyph.prototype.draw = function (g, oc) {
    for (var i = 0; i < this.glyphs.length; ++i) {
        var gl = this.glyphs[i];
        gl.draw(g, oc);
    }

    g.strokeStyle = 'black';
    g.beginPath();
    this.drawConnectors(g);
    g.stroke();
};

GroupGlyph.prototype.toSVG = function () {
    var g = makeElementNS(NS_SVG, 'g');
    for (var i = 0; i < this.glyphs.length; ++i) {
        g.appendChild(this.glyphs[i].toSVG());
    }

    var p = new SVGPath();
    this.drawConnectors(p);

    var pathData = p.toPathData();
    if (pathData.length > 0) {
        var path = makeElementNS(NS_SVG, 'path', null, { d: p.toPathData(),
            fill: 'none',
            stroke: 'black',
            strokeWidth: 0.5 });
        g.appendChild(path);
    }

    return g;
};

GroupGlyph.prototype.min = function () {
    return this.coverage.min();
};

GroupGlyph.prototype.max = function () {
    return this.coverage.max();
};

GroupGlyph.prototype.height = function () {
    return this.h;
};

function LineGraphGlyph(points, color, height) {
    this.points = points;
    this.color = color;
    this._height = height || 50;
}

LineGraphGlyph.prototype.min = function () {
    return this.points[0].x;
    // return this.points[0];
};

LineGraphGlyph.prototype.max = function () {
    return this.points[this.points.length - 1].x;
    // return this.points[this.points.length - 2];
};

LineGraphGlyph.prototype.height = function () {
    return this._height;
};

LineGraphGlyph.prototype.draw = function (g) {
    g.save();
    g.strokeStyle = this.color;
    g.lineWidth = 2;
    g.beginPath();
    this.points.forEach(function (p, i) {
        if (i === 0) g.moveTo(p.x, p.y);else g.lineTo(p.x, p.y);
    });
    g.stroke();
    g.restore();
};

LineGraphGlyph.prototype.toSVG = function () {
    var p = new SVGPath();
    for (var i = 0; i < this.points.length; ++i) {
        var x = this.points[i].x;
        var y = this.points[i].y;
        if (i == 0) {
            p.moveTo(x, y);
        } else {
            p.lineTo(x, y);
        }
    }

    return makeElementNS(NS_SVG, 'path', null, { d: p.toPathData(),
        fill: 'none',
        stroke: this.color,
        strokeWidth: '2px' });
};

function LabelledGlyph(GLOBAL_GC, glyph, text, unmeasured, anchor, align, font) {
    this.glyph = glyph;
    this.text = text;
    this.anchor = anchor || 'left';
    this.align = align || 'below';
    if (font) {
        this.font = font;
    }
    if (this.font) {
        GLOBAL_GC.save();
        GLOBAL_GC.font = this.font;
    }
    var metrics = GLOBAL_GC.measureText(text);
    if (this.font) {
        GLOBAL_GC.restore();
    }
    this.textLen = metrics.width;
    this.textHeight = 5;
    this.bump = glyph.bump;
    this.measured = !unmeasured;
}

LabelledGlyph.prototype.toSVG = function () {
    var child = this.glyph.toSVG();
    var opts = {};

    if (this.align == 'above') {
        child = makeElementNS(NS_SVG, 'g', child, { transform: "translate(0, " + (this.textHeight | 0 + 2) + ")" });
        opts.y = this.textHeight;
    } else {
        opts.y = this.glyph.height() + 15;
    }

    if (this.font) {
        opts.fontSize = 7;
    }

    if ('center' == this.anchor) {
        opts.x = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;
    } else {
        opts.x = this.glyph.min();
    }

    return makeElementNS(NS_SVG, 'g', [child, makeElementNS(NS_SVG, 'text', this.text, opts)]);
};

LabelledGlyph.prototype.min = function () {
    return this.glyph.min();
};

LabelledGlyph.prototype.max = function () {
    if (this.measured) return Math.max(this.glyph.max(), 1.0 * this.glyph.min() + this.textLen + 10);else return this.glyph.max();
};

LabelledGlyph.prototype.height = function () {
    var h = this.glyph.height();
    if (this.measured) {
        if (this.align == 'above') {
            h += this.textHeight + 2;
        } else {
            h += 20;
        }
    }
    return h;
};

LabelledGlyph.prototype.draw = function (g, oc) {
    if (this.align == 'above') {
        g.save();
        g.translate(0, this.textHeight + 2);
    }
    this.glyph.draw(g);
    if (this.align == 'above') {
        g.restore();
    }

    oc.registerGlyph(this);
};

LabelledGlyph.prototype.drawOverlay = function (g, minVisible, maxVisible) {
    g.fillStyle = 'black';
    if (this.font) {
        g.save();
        g.font = this.font;
    }
    var p;
    if ('center' == this.anchor) {
        p = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;
    } else {
        p = this.glyph.min();
        if (p < minVisible) {
            p = Math.min(minVisible, this.glyph.max() - this.textLen);
        }
    }
    g.fillText(this.text, p, this.align == 'above' ? this.textHeight : this.glyph.height() + 15);
    if (this.font) {
        g.restore();
    }
};

function CrossGlyph(x, height, stroke) {
    this._x = x;
    this._height = height;
    this._stroke = stroke;
}

CrossGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;

    g.beginPath();
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);
    g.moveTo(this._x - hh, hh);
    g.lineTo(this._x + hh, hh);

    g.strokeStyle = this._stroke;
    g.lineWidth = 1;

    g.stroke();
};

CrossGlyph.prototype.toSVG = function () {
    var hh = this._height / 2;

    var g = new SVGPath();
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);
    g.moveTo(this._x - hh, hh);
    g.lineTo(this._x + hh, hh);

    return makeElementNS(NS_SVG, 'path', null, { d: g.toPathData(),
        fill: 'none',
        stroke: this._stroke,
        strokeWidth: '1px' });
};

CrossGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

CrossGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

CrossGlyph.prototype.height = function () {
    return this._height;
};

function ExGlyph(x, height, stroke) {
    this._x = x;
    this._height = height;
    this._stroke = stroke;
}

ExGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;

    g.beginPath();
    g.moveTo(this._x - hh, 0);
    g.lineTo(this._x + hh, this._height);
    g.moveTo(this._x - hh, this._height);
    g.lineTo(this._x + hh, 0);

    g.strokeStyle = this._stroke;
    g.lineWidth = 1;

    g.stroke();
};

ExGlyph.prototype.toSVG = function () {
    var hh = this._height / 2;

    var g = new SVGPath();
    g.moveTo(this._x - hh, 0);
    g.lineTo(this._x + hh, this._height);
    g.moveTo(this._x - hh, this._height);
    g.lineTo(this._x + hh, 0);

    return makeElementNS(NS_SVG, 'path', null, { d: g.toPathData(),
        fill: 'none',
        stroke: this._stroke,
        strokeWidth: '1px' });
};

ExGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

ExGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

ExGlyph.prototype.height = function () {
    return this._height;
};

function TriangleGlyph(x, height, dir, width, fill, stroke) {
    PathGlyphBase.call(this, stroke, fill);

    this._x = x;
    this._height = height;
    this._dir = dir;
    this._width = width;
}

TriangleGlyph.prototype = Object.create(PathGlyphBase.prototype);

TriangleGlyph.prototype.drawPath = function (g) {
    var hh = this._height / 2;
    var hw = this._width / 2;

    if (this._dir === 'S') {
        g.moveTo(this._x, this._height);
        g.lineTo(this._x - hw, 0);
        g.lineTo(this._x + hw, 0);
    } else if (this._dir === 'W') {
        g.moveTo(this._x + hw, hh);
        g.lineTo(this._x - hw, 0);
        g.lineTo(this._x - hw, this._height);
    } else if (this._dir === 'E') {
        g.moveTo(this._x - hw, hh);
        g.lineTo(this._x + hw, 0);
        g.lineTo(this._x + hw, this._height);
    } else {
        g.moveTo(this._x, 0);
        g.lineTo(this._x + hw, this._height);
        g.lineTo(this._x - hw, this._height);
    }

    g.closePath();
};

TriangleGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

TriangleGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

TriangleGlyph.prototype.height = function () {
    return this._height;
};

function DotGlyph(x, height, fill, stroke) {
    this._x = x;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

DotGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;
    g.fillStyle = this._stroke;
    g.beginPath();
    g.arc(this._x, hh, hh, 0, 6.29);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }

    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
};

DotGlyph.prototype.toSVG = function () {
    var hh = this._height / 2;
    return makeElementNS(NS_SVG, 'circle', null, { cx: this._x, cy: hh, r: hh,
        fill: this._fill || 'none',
        stroke: this._stroke || 'none',
        strokeWidth: '1px' });
};

DotGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

DotGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

DotGlyph.prototype.height = function () {
    return this._height;
};

function PaddedGlyph(glyph, minp, maxp) {
    this.glyph = glyph;
    this._min = minp;
    this._max = maxp;
    if (glyph) {
        this.bump = glyph.bump;
    }
}

PaddedGlyph.prototype.draw = function (g, oc) {
    if (this.glyph) this.glyph.draw(g, oc);
};

PaddedGlyph.prototype.toSVG = function () {
    if (this.glyph) {
        return this.glyph.toSVG();
    } else {
        return makeElementNS(NS_SVG, 'g');
    }
};

PaddedGlyph.prototype.min = function () {
    return this._min;
};

PaddedGlyph.prototype.max = function () {
    return this._max;
};

PaddedGlyph.prototype.height = function () {
    if (this.glyph) {
        return this.glyph.height();
    } else {
        return 1;
    }
};

function AArrowGlyph(min, max, height, fill, stroke, ori) {
    PathGlyphBase.call(this, stroke, fill);
    this._min = min;
    this._max = max;
    this._height = height;
    this._ori = ori;
}

AArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);

AArrowGlyph.prototype.min = function () {
    return this._min;
};

AArrowGlyph.prototype.max = function () {
    return this._max;
};

AArrowGlyph.prototype.height = function () {
    return this._height;
};

AArrowGlyph.prototype.drawPath = function (g) {
    var maxPos = this._max;
    var minPos = this._min;
    var height = this._height;
    var lInset = 0;
    var rInset = 0;
    var minLength = this._height + 2;
    var instep = 0.333333 * this._height;
    var y = 0;

    if (this._ori) {
        if (this._ori === '+') {
            rInset = 0.5 * this._height;
        } else if (this._ori === '-') {
            lInset = 0.5 * this._height;
        }
    }

    if (maxPos - minPos < minLength) {
        minPos = (maxPos + minPos - minLength) / 2;
        maxPos = minPos + minLength;
    }

    g.moveTo(minPos + lInset, y + instep);
    g.lineTo(maxPos - rInset, y + instep);
    g.lineTo(maxPos - rInset, y);
    g.lineTo(maxPos, y + this._height / 2);
    g.lineTo(maxPos - rInset, y + height);
    g.lineTo(maxPos - rInset, y + instep + instep);
    g.lineTo(minPos + lInset, y + instep + instep);
    g.lineTo(minPos + lInset, y + height);
    g.lineTo(minPos, y + height / 2);
    g.lineTo(minPos + lInset, y);
    g.lineTo(minPos + lInset, y + instep);
};

function SpanGlyph(min, max, height, stroke) {
    PathGlyphBase.call(this, stroke, null);
    this._min = min;
    this._max = max;
    this._height = height;
}

SpanGlyph.prototype = Object.create(PathGlyphBase.prototype);

SpanGlyph.prototype.min = function () {
    return this._min;
};
SpanGlyph.prototype.max = function () {
    return this._max;
};
SpanGlyph.prototype.height = function () {
    return this._height;
};

SpanGlyph.prototype.drawPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;
    g.moveTo(minPos, hh);
    g.lineTo(maxPos, hh);
    g.moveTo(minPos, 0);
    g.lineTo(minPos, height);
    g.moveTo(maxPos, 0);
    g.lineTo(maxPos, height);
};

function LineGlyph(min, max, height, style, strand, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._style = style;
    this._strand = strand;
    this._stroke = stroke;
}

LineGlyph.prototype.min = function () {
    return this._min;
};
LineGlyph.prototype.max = function () {
    return this._max;
};
LineGlyph.prototype.height = function () {
    return this._height;
};

LineGlyph.prototype.drawPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;

    if (this._style === 'hat') {
        g.moveTo(minPos, hh);
        g.lineTo((minPos + maxPos) / 2, this._strand === '-' ? height : 0);
        g.lineTo(maxPos, hh);
    } else {
        g.moveTo(minPos, hh);
        g.lineTo(maxPos, hh);
    }
};

LineGlyph.prototype.draw = function (g) {
    g.beginPath();
    this.drawPath(g);
    g.strokeStyle = this._stroke;
    if (this._style === 'dashed' && g.setLineDash) {
        g.save();
        g.setLineDash([3]);
        g.stroke();
        g.restore();
    } else {
        g.stroke();
    }
};

LineGlyph.prototype.toSVG = function () {
    var g = new SVGPath();
    this.drawPath(g);

    var opts = { d: g.toPathData(),
        stroke: this._stroke || 'none' };
    if (this._style === 'dashed') {
        opts['strokeDasharray'] = '3';
    }

    return makeElementNS(NS_SVG, 'path', null, opts);
};

function PrimersGlyph(min, max, height, fill, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

PrimersGlyph.prototype.min = function () {
    return this._min;
};
PrimersGlyph.prototype.max = function () {
    return this._max;
};
PrimersGlyph.prototype.height = function () {
    return this._height;
};

PrimersGlyph.prototype.drawStemPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;
    g.moveTo(minPos, hh);
    g.lineTo(maxPos, hh);
};

PrimersGlyph.prototype.drawTrigsPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;
    g.moveTo(minPos, 0);
    g.lineTo(minPos + height, hh);
    g.lineTo(minPos, height);
    g.lineTo(minPos, 0);
    g.moveTo(maxPos, 0);
    g.lineTo(maxPos - height, hh);
    g.lineTo(maxPos, height);
    g.lineTo(maxPos, 0);
};

PrimersGlyph.prototype.draw = function (g) {
    g.beginPath();
    this.drawStemPath(g);
    g.strokeStyle = this._stroke;
    g.stroke();
    g.beginPath();
    this.drawTrigsPath(g);
    g.fillStyle = this._fill;
    g.fill();
};

PrimersGlyph.prototype.toSVG = function () {
    var s = new SVGPath();
    this.drawStemPath(s);
    var t = new SVGPath();
    this.drawTrigsPath(t);

    return makeElementNS(NS_SVG, 'g', [makeElementNS(NS_SVG, 'path', null, { d: s.toPathData(),
        stroke: this._stroke || 'none' }), makeElementNS(NS_SVG, 'path', null, { d: t.toPathData(),
        fill: this._fill || 'none' })]);
};

function ArrowGlyph(min, max, height, color, parallel, sw, ne) {
    PathGlyphBase.call(this, null, color);
    this._min = min;
    this._max = max;
    this._height = height;
    this._color = color;
    this._parallel = parallel;
    this._sw = sw;
    this._ne = ne;
}

ArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);

ArrowGlyph.prototype.min = function () {
    return this._min;
};
ArrowGlyph.prototype.max = function () {
    return this._max;
};
ArrowGlyph.prototype.height = function () {
    return this._height;
};

ArrowGlyph.prototype.drawPath = function (g) {
    var min = this._min,
        max = this._max,
        height = this._height;

    if (this._parallel) {
        var hh = height / 2;
        var instep = 0.4 * height;
        if (this._sw) {
            g.moveTo(min + hh, height - instep);
            g.lineTo(min + hh, height);
            g.lineTo(min, hh);
            g.lineTo(min + hh, 0);
            g.lineTo(min + hh, instep);
        } else {
            g.moveTo(min, height - instep);
            g.lineTo(min, instep);
        }
        if (this._ne) {
            g.lineTo(max - hh, instep);
            g.lineTo(max - hh, 0);
            g.lineTo(max, hh);
            g.lineTo(max - hh, height);
            g.lineTo(max - hh, height - instep);
        } else {
            g.lineTo(max, instep);
            g.lineTo(max, height - instep);
        }
        g.closePath();
    } else {
        var mid = (min + max) / 2;
        var instep = 0.4 * (max - min);
        var th = height / 3;

        if (this._ne) {
            g.moveTo(min + instep, th);
            g.lineTo(min, th);
            g.lineTo(mid, 0);
            g.lineTo(max, th);
            g.lineTo(max - instep, th);
        } else {
            g.moveTo(min + instep, 0);
            g.lineTo(max - instep, 0);
        }
        if (this._sw) {
            g.lineTo(max - instep, height - th);
            g.lineTo(max, height - th);
            g.lineTo(mid, height);
            g.lineTo(min, height - th);
            g.lineTo(min + instep, height - th);
        } else {
            g.lineTo(max - instep, height);
            g.lineTo(min + instep, height);
        }
        g.closePath();
    }
};

function TooManyGlyph(min, max, height, fill, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

TooManyGlyph.prototype.min = function () {
    return this._min;
};
TooManyGlyph.prototype.max = function () {
    return this._max;
};
TooManyGlyph.prototype.height = function () {
    return this._height;
};

TooManyGlyph.prototype.toSVG = function () {
    return makeElementNS(NS_SVG, 'rect', null, { x: this._min,
        y: 0,
        width: this._max - this._min,
        height: this._height,
        stroke: this._stroke || 'none',
        fill: this._fill || 'none' });
};

TooManyGlyph.prototype.draw = function (g) {
    if (this._fill) {
        g.fillStyle = this._fill;
        g.fillRect(this._min, 0, this._max - this._min, this._height);
    }
    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.strokeRect(this._min, 0, this._max - this._min, this._height);
        g.beginPath();
        for (var n = 2; n < this._height; n += 3) {
            g.moveTo(this._min, n);
            g.lineTo(this._max, n);
        }
        g.stroke();
    }
};

function TextGlyph(GLOBAL_GC, min, max, height, fill, string) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._string = string;
    this._textLen = GLOBAL_GC.measureText(string).width;
}

TextGlyph.prototype.min = function () {
    return this._min;
};
TextGlyph.prototype.max = function () {
    return Math.max(this._max, this._min + this._textLen);
};
TextGlyph.prototype.height = function () {
    return this._height;
};

TextGlyph.prototype.draw = function (g) {
    g.fillStyle = this._fill;
    g.fillText(this._string, this._min, this._height - 4);
};

TextGlyph.prototype.toSVG = function () {
    return makeElementNS(NS_SVG, 'text', this._string, { x: this._min, y: this._height - 4 });
};

function aminoTileColor(aa, start, color) {
    var ALTERNATE_COLOR = {
        'red': 'darkred',
        'purple': 'mediumpurple',
        'blue': 'darkblue',
        'green': 'darkgreen'
    };
    var color2 = ALTERNATE_COLOR[color.toLowerCase()];
    var tileColors;
    if (!color2) tileColors = ['rgb(73, 68, 149)', 'rgb(9, 0, 103)'];
    // default to UCSC colors
    else tileColors = [color, color2];

    if (aa == '?') return 'black';else if (aa == 'M') return 'greenyellow';else if (aa == '*') return 'crimson';else return tileColors[start % 2];
}

function reverseComplement(sequence) {
    var seq_dict = { 'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G' };
    var rev_seq = sequence.split('').reverse().join('');
    var rev_compl_seq = [];
    for (var b = 0; b < rev_seq.length; ++b) {
        var base = rev_seq.substr(b, 1).toUpperCase();
        rev_compl_seq.push(base in seq_dict ? seq_dict[base] : 'N');
    }
    return rev_compl_seq.join('');
}

function AminoAcidGlyph(min, max, height, fill, seq, orientation, readframe) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._seq = seq;
    this._orientation = orientation;
    this._readframe = readframe;
}

AminoAcidGlyph.prototype.min = function () {
    return this._min;
};
AminoAcidGlyph.prototype.max = function () {
    return this._max;
};
AminoAcidGlyph.prototype.height = function () {
    return this._height;
};

AminoAcidGlyph.prototype.draw = function (gc) {
    var seq = this._seq;
    var color = this._fill;

    if (!seq) return;

    var scale = (this._max - this._min + 1) / seq.length;

    var prevOverhang = (3 - this._readframe) % 3;
    var nextOverhang = (seq.length - prevOverhang) % 3;
    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;

    if (leftOverhang > 0) {
        gc.fillStyle = color;
        gc.fillRect(this._min, 0, scale * leftOverhang, this._height);
    }

    for (var p = leftOverhang; p < seq.length; p += 3) {
        var codon = seq.substr(p, 3).toUpperCase();
        if (this._orientation == '-') codon = reverseComplement(codon);
        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';
        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;
        gc.fillStyle = color;
        gc.fillRect(this._min + p * scale, 0, scale * codon.length, this._height);

        if (scale >= 8 && codon.length == 3) {
            gc.fillStyle = 'white';
            gc.fillText(aa, this._min + (p + 1) * scale, this._height);
        }
    }
};

AminoAcidGlyph.prototype.toSVG = function () {
    var g = makeElementNS(NS_SVG, 'g');
    var seq = this._seq;
    var color = this._fill;

    if (!seq) return g;

    var scale = (this._max - this._min + 1) / seq.length;

    var prevOverhang = (3 - this._readframe) % 3;
    var nextOverhang = (seq.length - prevOverhang) % 3;
    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;

    if (leftOverhang > 0) {
        g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
            x: this._min,
            y: 0,
            width: scale * leftOverhang,
            height: this._height,
            fill: color }));
    }
    for (var p = leftOverhang; p < seq.length; p += 3) {
        var codon = seq.substr(p, 3).toUpperCase();
        if (this._orientation == '-') codon = reverseComplement(codon);
        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';
        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;
        g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
            x: this._min + p * scale,
            y: 0,
            width: scale * codon.length,
            height: this._height,
            fill: color }));

        if (scale >= 8 && codon.length == 3) {
            g.appendChild(makeElementNS(NS_SVG, 'text', aa, {
                x: this._min + (p + 1) * scale,
                y: this._height,
                fill: 'white' }));
        }
    }
    return g;
};

var isRetina = typeof window !== 'undefined' && window.devicePixelRatio > 1;
var __dalliance_SequenceGlyphCache = {};
var altPattern = new RegExp('^[ACGT-]$');
var isCloseUp = function isCloseUp(scale) {
    return scale >= 8;
};

function SequenceGlyph(baseColors, strandColor, min, max, height, seq, ref, scheme, quals, fillbg, scaleVertical) {
    this.baseColors = baseColors;
    this._strandColor = strandColor;
    this._min = min;
    this._max = max;
    this._height = height;
    this._seq = seq;
    this._ref = ref;
    this._scheme = scheme;
    this._quals = quals;
    this._fillbg = fillbg;
    this._scaleVertical = scaleVertical;
}

SequenceGlyph.prototype.min = function () {
    return this._min;
};
SequenceGlyph.prototype.max = function () {
    return this._max;
};
SequenceGlyph.prototype.height = function () {
    return this._height;
};

SequenceGlyph.prototype.alphaForQual = function (qual) {
    return 0.1 + 0.9 * Math.max(0.0, Math.min(1.0 * qual / 30.0, 1.0));
};

SequenceGlyph.prototype.draw = function (gc) {
    var seq = this._seq;
    var ref = this._ref;
    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';
    var all = this._scheme === 'mismatch-all';

    var seqLength = seq ? seq.length : this._max - this._min + 1;
    var scale = (this._max - this._min + 1) / seqLength;

    if (mismatch && !isCloseUp(scale)) {
        gc.fillStyle = this._strandColor;
        if (this._scaleVertical) gc.fillRect(this._min, scale, this._max - this._min, scale);else gc.fillRect(this._min, this._height / 4, this._max - this._min, this._height / 2);
    }

    for (var p = 0; p < seqLength; ++p) {
        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';

        if (!altPattern.test(base) && !isCloseUp(scale)) continue;

        var color = this.baseColors[base];

        if (this._quals) {
            var qc = this._quals.charCodeAt(p) - 33;
            var oldAlpha = gc.globalAlpha; // NB hoisted!
            gc.globalAlpha = this.alphaForQual(qc);
        }

        if (!color) {
            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';
            if (base == 'N' || refBase == 'N') color = 'gray';else color = this._strandColor;

            if (all) base = refBase;
        }

        gc.fillStyle = color;

        var alt = altPattern.test(base);
        if (this._fillbg || !isCloseUp(scale) || !alt) {
            if (this._scaleVertical) gc.fillRect(this._min + p * scale, scale, scale, scale);else gc.fillRect(this._min + p * scale, 0, scale, this._height);
        }
        if (isCloseUp(scale) && alt) {
            var key = color + '_' + base;
            var img = __dalliance_SequenceGlyphCache[key];
            if (!img) {
                img = document.createElement('canvas');
                if (isRetina) {
                    img.width = 16;
                    img.height = 20;
                } else {
                    img.width = 8;
                    img.height = 10;
                }
                var imgGc = img.getContext('2d');
                if (isRetina) {
                    imgGc.scale(2, 2);
                }
                imgGc.fillStyle = this._fillbg ? 'black' : color;
                var w = imgGc.measureText(base).width;
                imgGc.fillText(base, 0.5 * (8.0 - w), 8);
                __dalliance_SequenceGlyphCache[key] = img;
            }
            var dy = this._scaleVertical ? scale : 0;
            if (isRetina) gc.drawImage(img, this._min + p * scale + 0.5 * (scale - 8), dy, 8, 10);else gc.drawImage(img, this._min + p * scale + 0.5 * (scale - 8), dy);
        }

        if (this._quals) {
            gc.globalAlpha = oldAlpha;
        }
    }
};

SequenceGlyph.prototype.toSVG = function () {
    var seq = this._seq;
    var ref = this._ref;
    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';
    var all = this._scheme === 'mismatch-all';
    var scale = (this._max - this._min + 1) / this._seq.length;
    var g = makeElementNS(NS_SVG, 'g');

    for (var p = 0; p < seq.length; ++p) {
        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';
        var color = this.baseColors[base];

        if (!color) {
            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';
            if (base == 'N' || refBase == 'N') color = 'gray';else color = this._strandColor;

            if (all) base = refBase;
        }

        var alpha = 1.0;
        if (this._quals) {
            var qc = this._quals.charCodeAt(p) - 33;
            alpha = this.alphaForQual(qc);
        }

        var alt = altPattern.test(base);
        if (this._fillbg || !isCloseUp(scale) || !alt) {
            g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
                x: this._min + p * scale,
                y: 0,
                width: scale,
                height: this._height,
                fill: color,
                fillOpacity: alpha }));
        }

        if (isCloseUp(scale) && alt) {
            g.appendChild(makeElementNS(NS_SVG, 'text', base, {
                x: this._min + (0.5 + p) * scale,
                y: 8,
                textAnchor: 'middle',
                fill: this._fillbg ? 'black' : color,
                fillOpacity: alpha }));
        }
    }

    return g;
};

function TranslatedGlyph(glyph, x, y, height) {
    this.glyph = glyph;
    this._height = height;
    this._x = x;
    this._y = y;
}

TranslatedGlyph.prototype.height = function () {
    if (this._height) {
        return this._height;
    } else {
        return this.glyph.height() + this._y;
    }
};

TranslatedGlyph.prototype.min = function () {
    return this.glyph.min() + this._x;
};

TranslatedGlyph.prototype.max = function () {
    return this.glyph.max() + this._x;
};

TranslatedGlyph.prototype.minY = function () {
    return this._y;
};

TranslatedGlyph.prototype.maxY = function () {
    return this._y + this.glyph.height();
};

TranslatedGlyph.prototype.draw = function (g, o) {
    g.save();
    g.translate(this._x, this._y);
    this.glyph.draw(g, o);
    g.restore();
};

TranslatedGlyph.prototype.toSVG = function () {
    var s = this.glyph.toSVG();
    s.setAttribute('transform', 'translate(' + this._x + ',' + this._y + ')');
    return s;
};

function PointGlyph(x, y, height, fill) {
    this._x = x;
    this._y = y;
    this._height = height;
    this._fill = fill;
}

PointGlyph.prototype.min = function () {
    return this._x - 2;
};

PointGlyph.prototype.max = function () {
    return this._x + 2;
};

PointGlyph.prototype.height = function () {
    return this._height;
};

PointGlyph.prototype.draw = function (g) {
    g.save();
    g.globalAlpha = 0.3;
    g.fillStyle = this._fill;
    g.beginPath();
    g.arc(this._x, this._y, 1.5, 0, 6.29);
    g.fill();
    g.restore();
};

PointGlyph.prototype.toSVG = function () {
    return makeElementNS(NS_SVG, 'circle', null, { cx: this._x, cy: this._y, r: 2,
        fill: this._fill,
        stroke: 'none' });
};

function GridGlyph(height, yOffset, spacing) {
    this._height = height || 50;
    this.yOffset = yOffset || 0;
    this.spacing = spacing || 10;
}

GridGlyph.prototype.notSelectable = true;

GridGlyph.prototype.min = function () {
    return -100000;
};

GridGlyph.prototype.max = function () {
    return 100000;
};

GridGlyph.prototype.height = function () {
    return this._height;
};

GridGlyph.prototype.draw = function (g) {
    g.save();
    g.strokeStyle = 'black';
    g.lineWidth = 0.1;

    g.beginPath();
    for (var y = this.yOffset; y <= this._height + this.yOffset; y += this.spacing) {
        // for (var y = 0; y <= this._height; y += 10) {
        g.moveTo(-5000, y);
        g.lineTo(5000, y);
    }
    g.stroke();
    g.restore();
};

GridGlyph.prototype.toSVG = function () {
    var p = new SVGPath();
    for (var y = 0; y <= this._height; y += 10) {
        p.moveTo(-5000, y);
        p.lineTo(5000, y);
    }

    return makeElementNS(NS_SVG, 'path', null, { d: p.toPathData(),
        fill: 'none',
        stroke: 'black',
        strokeWidth: '0.1px' });
};

function StarGlyph(x, r, points, fill, stroke) {
    PathGlyphBase.call(this, stroke, fill);
    this._x = x;
    this._r = r;
    this._points = points;
}

StarGlyph.prototype = Object.create(PathGlyphBase.prototype);

StarGlyph.prototype.min = function () {
    return this._x - this._r;
};

StarGlyph.prototype.max = function () {
    return this._x + this._r;
};

StarGlyph.prototype.height = function () {
    return 2 * this._r;
};

StarGlyph.prototype.drawPath = function (g) {
    var midX = this._x,
        midY = this._r,
        r = this._r;
    for (var p = 0; p < this._points; ++p) {
        var theta = p * 6.28 / this._points;
        var px = midX + r * Math.sin(theta);
        var py = midY - r * Math.cos(theta);
        if (p == 0) {
            g.moveTo(px, py);
        } else {
            g.lineTo(px, py);
        }
        theta = (p + 0.5) * 6.28 / this._points;
        px = midX + 0.4 * r * Math.sin(theta);
        py = midY - 0.4 * r * Math.cos(theta);
        g.lineTo(px, py);
    }
    g.closePath();
};

function PlimsollGlyph(x, height, overhang, fill, stroke) {
    this._x = x;
    this._height = height;
    this._overhang = overhang;
    this._fill = fill;
    this._stroke = stroke;
    this._hh = height / 2;
}

PlimsollGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;
    g.fillStyle = this._stroke;
    g.beginPath();
    g.arc(this._x, hh, hh - this._overhang, 0, 6.29);
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }

    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
};

PlimsollGlyph.prototype.toSVG = function () {
    var hh = this._hh;
    return makeElementNS(NS_SVG, 'g', [makeElementNS(NS_SVG, 'circle', null, { cx: this._x, cy: hh, r: hh - this._overhang }), makeElementNS(NS_SVG, 'line', null, { x1: this._x, y1: 0, x2: this._x, y2: this._height })], { fill: this._fill || 'none',
        stroke: this._stroke || 'none',
        strokeWidth: '1px' });
};

PlimsollGlyph.prototype.min = function () {
    return this._x - this._hh;
};

PlimsollGlyph.prototype.max = function () {
    return this._x + this._hh;
};

PlimsollGlyph.prototype.height = function () {
    return this._height;
};

function OverlayLabelCanvas() {
    this.ox = 0;
    this.oy = 0;
    this.glyphs = [];
}

OverlayLabelCanvas.prototype.translate = function (x, y) {
    this.ox += x;
    this.oy += y;
};

OverlayLabelCanvas.prototype.registerGlyph = function (g) {
    this.glyphs.push({
        x: this.ox,
        y: this.oy,
        glyph: g
    });
};

OverlayLabelCanvas.prototype.draw = function (g, minVisible, maxVisible) {
    for (var gi = 0; gi < this.glyphs.length; ++gi) {
        var gg = this.glyphs[gi];
        g.save();
        g.translate(gg.x, gg.y);
        gg.glyph.drawOverlay(g, minVisible, maxVisible);
        g.restore();
    }
};

if (typeof module !== 'undefined') {
    module.exports = {
        BoxGlyph: BoxGlyph,
        GroupGlyph: GroupGlyph,
        LineGraphGlyph: LineGraphGlyph,
        LabelledGlyph: LabelledGlyph,
        CrossGlyph: CrossGlyph,
        ExGlyph: ExGlyph,
        TriangleGlyph: TriangleGlyph,
        DotGlyph: DotGlyph,
        PaddedGlyph: PaddedGlyph,
        AArrowGlyph: AArrowGlyph,
        SpanGlyph: SpanGlyph,
        LineGlyph: LineGlyph,
        PrimersGlyph: PrimersGlyph,
        ArrowGlyph: ArrowGlyph,
        TooManyGlyph: TooManyGlyph,
        TextGlyph: TextGlyph,
        SequenceGlyph: SequenceGlyph,
        AminoAcidGlyph: AminoAcidGlyph,
        TranslatedGlyph: TranslatedGlyph,
        GridGlyph: GridGlyph,
        StarGlyph: StarGlyph,
        PointGlyph: PointGlyph,
        PlimsollGlyph: PlimsollGlyph,

        OverlayLabelCanvas: OverlayLabelCanvas
    };
}

},{"./spans":43,"./svg-utils":47,"./utils":58}],25:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// jbjson.js -- query JBrowse-style REST data stores
//

if (typeof require !== 'undefined') {
    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;
}

function JBrowseStore(base, query) {
    this.base = base;
    this.query = query;
}

function jbori(strand) {
    if (strand > 0) return '+';else if (strand <= 0) return '-';
}

JBrowseStore.prototype.features = function (segment, opts, callback) {
    opts = opts || {};

    var url = this.base + '/features/' + segment.name;

    var filters = [];
    if (this.query) {
        filters.push(this.query);
    }
    if (segment.isBounded) {
        filters.push('start=' + segment.start);
        filters.push('end=' + segment.end);
    }
    if (filters.length > 0) {
        url = url + '?' + filters.join('&');
    }

    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            if (req.status >= 300) {
                callback(null, 'Error code ' + req.status);
            } else {
                var jf = JSON.parse(req.response)['features'];
                var features = [];

                for (var fi = 0; fi < jf.length; ++fi) {
                    var j = jf[fi];

                    var f = new DASFeature();
                    f.segment = segment.name;
                    f.min = (j['start'] | 0) + 1;
                    f.max = j['end'] | 0;

                    if (j.score) {
                        f.score = j.score;
                    }

                    if (j.name) {
                        f.label = j.name;
                    }
                    if (j.strand) f.orientation = jbori(j.strand);

                    f.type = j.type || 'unknown';

                    if (j.subfeatures && j.subfeatures.length > 0) {
                        f.id = j.uniqueID;

                        var blocks = [];
                        var cds = [];
                        var all = [];

                        for (var si = 0; si < j.subfeatures.length; ++si) {
                            var sj = j.subfeatures[si];
                            var sf = shallowCopy(f);
                            sf.min = sj.start + 1;
                            sf.max = sj.end;
                            sf.groups = [f];

                            all.push(sf);
                            blocks.push(new Range(sf.min, sf.max));
                            if (sj.type === 'CDS') cds.push(sf);
                        }

                        if (cds.length > 0) {
                            spans = union(blocks);
                            var txGroup = shallowCopy(f);
                            txGroup.type = 'transcript';
                            spans.ranges().forEach(function (exon) {
                                features.push({
                                    segment: segment.name,
                                    min: exon.min(),
                                    max: exon.max(),
                                    orientation: f.orientation,
                                    groups: [txGroup],
                                    type: 'transcript'
                                });
                            });

                            var tlGroup = shallowCopy(f);
                            cds.forEach(function (cdsExon) {
                                cdsExon.type = 'translation';
                                cdsExon.groups = [tlGroup];
                                features.push(cdsExon);
                            });
                        } else {
                            all.forEach(function (f) {
                                features.push(f);
                            });
                        }
                    } else {
                        features.push(f);
                    }
                }
                callback(features);
            }
        }
    };

    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

if (typeof module !== 'undefined') {
    module.exports = {
        JBrowseStore: JBrowseStore
    };
}

},{"./das":11,"./spans":43,"./utils":58}],26:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// kspace.js
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var pusho = utils.pusho;

    var sa = require('./sourceadapters');
    var MappedFeatureSource = sa.MappedFeatureSource;
    var CachingFeatureSource = sa.CachingFeatureSource;
    var BWGFeatureSource = sa.BWGFeatureSource;
    var RemoteBWGFeatureSource = sa.RemoteBWGFeatureSource;
    var BAMFeatureSource = sa.BAMFeatureSource;
    var RemoteBAMFeatureSource = sa.RemoteBAMFeatureSource;
    var DummySequenceSource = sa.DummySequenceSource;
    var DummyFeatureSource = sa.DummyFeatureSource;

    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var sample = require('./sample');
    var downsample = sample.downsample;
    var getBaseCoverage = sample.getBaseCoverage;

    var das = require('./das');
    var DASSequence = das.DASSequence;

    var Promise = require('es6-promise').Promise;
}

function FetchPool() {
    var self = this;
    this.reqs = [];
    this.awaitedFeatures = {};
    this.requestsIssued = new Promise(function (resolve, reject) {
        self.notifyRequestsIssued = resolve;
    });
}

FetchPool.prototype.addRequest = function (xhr) {
    this.reqs.push(xhr);
};

FetchPool.prototype.abortAll = function () {
    for (var i = 0; i < this.reqs.length; ++i) {
        this.reqs[i].abort();
    }
};

function KSCacheBaton(chr, min, max, scale, features, status, coverage) {
    this.chr = chr;
    this.min = min;
    this.max = max;
    this.coverage = coverage;
    this.scale = scale;
    this.features = features || [];
    this.status = status;
}

KSCacheBaton.prototype.toString = function () {
    return this.chr + ":" + this.min + ".." + this.max + ";scale=" + this.scale;
};

function KnownSpace(tierMap, chr, min, max, scale, seqSource) {
    this.tierMap = tierMap;
    this.chr = chr;
    this.min = min;
    this.max = max;
    this.scale = scale;
    this.seqSource = seqSource || new DummySequenceSource();
    this.viewCount = 0;

    this.featureCache = {};
    this.latestViews = {};
}

KnownSpace.prototype.cancel = function () {
    this.cancelled = true;
};

KnownSpace.prototype.bestCacheOverlapping = function (chr, min, max) {
    var baton = this.featureCache[this.tierMap[0]];
    if (baton) {
        return baton;
    } else {
        return null;
    }
};

KnownSpace.prototype.retrieveFeatures = function (tiers, chr, min, max, scale) {
    if (scale != scale) {
        throw "retrieveFeatures called with silly scale";
    }

    if (chr != this.chr) {
        throw "Can't extend Known Space to a new chromosome";
    }
    if (min < 1) {
        min = 1;
    }

    this.min = min;
    this.max = max;
    this.scale = scale;

    if (this.pool) {
        this.pool.abortAll();
    }
    this.pool = new FetchPool();
    this.awaitedSeq = new Awaited();
    this.seqWasFetched = false;
    this.viewCount++;

    this.startFetchesForTiers(tiers);
    this.pool.notifyRequestsIssued();
};

function filterFeatures(features, min, max) {
    var ff = [];
    var featuresByGroup = {};

    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (!f.min || !f.max) {
            ff.push(f);
        } else if (f.groups && f.groups.length > 0) {
            pusho(featuresByGroup, f.groups[0].id, f);
        } else if (f.min <= max && f.max >= min) {
            ff.push(f);
        }
    }

    for (var gid in featuresByGroup) {
        var gf = featuresByGroup[gid];
        var gmin = 100000000000,
            gmax = -100000000000;
        for (var fi = 0; fi < gf.length; ++fi) {
            var f = gf[fi];
            gmin = Math.min(gmin, f.min);
            gmax = Math.max(gmax, f.max);
        }
        if (gmin <= max || gmax >= min) {
            for (var fi = 0; fi < gf.length; ++fi) {
                ff.push(gf[fi]);
            }
        }
    }

    return ff;
}

KnownSpace.prototype.invalidate = function (tier) {
    if (!this.pool) {
        return;
    }

    this.featureCache[tier] = null;
    this.startFetchesForTiers([tier]);
};

KnownSpace.prototype.startFetchesForTiers = function (tiers) {
    var thisB = this;

    var awaitedSeq = this.awaitedSeq;
    var needSeq = false;

    var gex;

    for (var t = 0; t < tiers.length; ++t) {
        var tierRenderer = tiers[t].browser.getTierRenderer(tiers[t]);
        try {
            if (this.startFetchesFor(tiers[t], awaitedSeq)) {
                needSeq = true;
            }
        } catch (ex) {
            var tier = tiers[t];

            tier.currentFeatures = [];
            tier.currentSequence = null;
            console.log('Error fetching tier source');
            console.log(ex);
            gex = ex;
            console.log(ex.stack);
            tierRenderer.renderTier(ex, tier);
            tier.wasRendered();
        }
    }

    if (needSeq && !this.seqWasFetched) {
        this.seqWasFetched = true;
        var smin = this.min,
            smax = this.max;

        if (this.cs) {
            if (this.cs.start <= smin && this.cs.end >= smax) {
                var cachedSeq;
                if (this.cs.start == smin && this.cs.end == smax) {
                    cachedSeq = this.cs;
                } else {
                    cachedSeq = new DASSequence(this.cs.name, smin, smax, this.cs.alphabet, this.cs.seq.substring(smin - this.cs.start, smax + 1 - this.cs.start));
                }
                return awaitedSeq.provide(cachedSeq);
            }
        }

        this.seqSource.fetch(this.chr, smin, smax, this.pool, function (err, seq) {
            if (seq) {
                if (!thisB.cs || smin <= thisB.cs.start && smax >= thisB.cs.end || smin >= thisB.cs.end || smax <= thisB.cs.start || smax - smin > thisB.cs.end - thisB.cs.start) {
                    thisB.cs = seq;
                }
                awaitedSeq.provide(seq);
            } else {
                console.log('Sequence loading failed', err);
                awaitedSeq.provide(null);
            }
        });
    }

    if (gex) throw gex;
};

KnownSpace.prototype.startFetchesFor = function (tier, awaitedSeq) {
    var thisB = this;

    var viewID = this.viewCount;
    var source = tier.getSource() || new DummyFeatureSource();
    var needsSeq = tier.needsSequence(this.scale);
    var baton = thisB.featureCache[tier];
    var styleFilters = tier.getActiveStyleFilters(this.scale);
    var wantedTypes;
    if (styleFilters) wantedTypes = styleFilters.typeList();
    var chr = this.chr,
        min = this.min,
        max = this.max;

    if (wantedTypes === undefined) {
        return false;
    }
    if (baton && baton.chr === this.chr && baton.min <= min && baton.max >= max) {
        var cachedFeatures = baton.features;
        if (baton.min < min || baton.max > max) {
            cachedFeatures = filterFeatures(cachedFeatures, min, max);
        }

        thisB.provision(tier, baton.chr, intersection(baton.coverage, new Range(min, max)), baton.scale, wantedTypes, cachedFeatures, baton.status, needsSeq ? awaitedSeq : null);

        var availableScales = source.getScales();

        if (!tier.dasSource.refetchOnZoom && (baton.scale <= this.scale || !availableScales)) {
            return needsSeq;
        }
    }

    if (source.instrument) console.log('Starting  fetch ' + viewID + ' (' + min + ', ' + max + ')');

    source.fetch(chr, min, max, this.scale, wantedTypes, this.pool, function (status, features, scale, coverage) {
        if (source.instrument) console.log('Finishing fetch ' + viewID);

        var latestViewID = thisB.latestViews[tier] || -1;
        if (thisB.cancelled || latestViewID > viewID) {
            return;
        }

        if (!coverage) {
            coverage = new Range(min, max);
        }

        if (!baton || min < baton.min || max > baton.max) {
            // FIXME should be merging in some cases?
            thisB.featureCache[tier] = new KSCacheBaton(chr, min, max, scale, features, status, coverage);
        }

        thisB.latestViews[tier] = viewID;
        thisB.provision(tier, chr, coverage, scale, wantedTypes, features, status, needsSeq ? awaitedSeq : null);
    }, styleFilters);
    return needsSeq;
};

KnownSpace.prototype.provision = function (tier, chr, coverage, actualScale, wantedTypes, features, status, awaitedSeq) {
    var tierRenderer = tier.browser.getTierRenderer(tier);
    if (status) {
        tier.setFeatures(chr, coverage, actualScale, [], null);
        if (!features) {
            var e = new Error(status);
            status = "Error fetching data: " + status + "; see browser console";
            console.log("Error fetching data for tier " + tier.dasSource.name + ":");
            console.log(tier.dasSource);
            console.log("Stack trace:");
            console.log(e.stack);
        }
        tierRenderer.renderTier(status, tier);
        tier.wasRendered();
    } else {
        var mayDownsample = false;
        var needBaseComposition = false;
        var src = tier.getSource();
        while (MappedFeatureSource.prototype.isPrototypeOf(src) || CachingFeatureSource.prototype.isPrototypeOf(src) || OverlayFeatureSource.prototype.isPrototypeOf(src)) {

            if (OverlayFeatureSource.prototype.isPrototypeOf(src)) {
                src = src.sources[0];
            } else {
                src = src.source;
            }
        }
        if (BWGFeatureSource.prototype.isPrototypeOf(src) || RemoteBWGFeatureSource.prototype.isPrototypeOf(src) || BAMFeatureSource.prototype.isPrototypeOf(src) || RemoteBAMFeatureSource.prototype.isPrototypeOf(src)) {

            mayDownsample = true;
        }

        if (!src.opts || !src.opts.forceReduction && !src.opts.noDownsample) {
            if ( /* (actualScale < (this.scale/2) && features.length > 200)  || */
            mayDownsample && wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('density') >= 0) {
                features = downsample(features, this.scale);
            }
        }

        if (wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('base-coverage') >= 0) {
            // Base-composition coverage track
            needBaseComposition = true;
        }

        if (awaitedSeq) {
            awaitedSeq.await(function (seq) {
                if (needBaseComposition) {
                    features = getBaseCoverage(features, seq, tier.browser.baseColors);
                }
                tier.setFeatures(chr, coverage, actualScale, features, seq);
                tierRenderer.renderTier(status, tier);
                tier.wasRendered();
            });
        } else {
            tier.setFeatures(chr, coverage, actualScale, features);
            tierRenderer.renderTier(status, tier);
            tier.wasRendered();
        }
    }
};

if (typeof module !== 'undefined') {
    module.exports = {
        KnownSpace: KnownSpace
    };
}

},{"./das":11,"./overlay":31,"./sample":36,"./sourceadapters":41,"./spans":43,"./utils":58,"es6-promise":63}],27:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// lh3utils.js: common support for lh3's file formats
//

if (typeof require !== 'undefined') {
    var jszlib = require('jszlib');
    var jszlib_inflate_buffer = jszlib.inflateBuffer;
    var arrayCopy = jszlib.arrayCopy;
}

function Vob(b, o) {
    this.block = b;
    this.offset = o;
}

Vob.prototype.toString = function () {
    return '' + this.block + ':' + this.offset;
};

function readVob(ba, offset, allowZero) {
    var block = (ba[offset + 6] & 0xff) * 0x100000000 + (ba[offset + 5] & 0xff) * 0x1000000 + (ba[offset + 4] & 0xff) * 0x10000 + (ba[offset + 3] & 0xff) * 0x100 + (ba[offset + 2] & 0xff);
    var bint = ba[offset + 1] << 8 | ba[offset];
    if (block == 0 && bint == 0 && !allowZero) {
        return null; // Should only happen in the linear index?
    } else {
        return new Vob(block, bint);
    }
}

function unbgzf(data, lim) {
    lim = Math.min(lim || 1, data.byteLength - 50);
    var oBlockList = [];
    var ptr = [0];
    var totalSize = 0;

    while (ptr[0] < lim) {
        var ba = new Uint8Array(data, ptr[0], 12); // FIXME is this enough for all credible BGZF block headers?
        var xlen = ba[11] << 8 | ba[10];
        // dlog('xlen[' + (ptr[0]) +']=' + xlen);
        var unc = jszlib_inflate_buffer(data, 12 + xlen + ptr[0], Math.min(65536, data.byteLength - 12 - xlen - ptr[0]), ptr);
        ptr[0] += 8;
        totalSize += unc.byteLength;
        oBlockList.push(unc);
    }

    if (oBlockList.length == 1) {
        return oBlockList[0];
    } else {
        var out = new Uint8Array(totalSize);
        var cursor = 0;
        for (var i = 0; i < oBlockList.length; ++i) {
            var b = new Uint8Array(oBlockList[i]);
            arrayCopy(b, 0, out, cursor, b.length);
            cursor += b.length;
        }
        return out.buffer;
    }
}

function Chunk(minv, maxv) {
    this.minv = minv;this.maxv = maxv;
}

//
// Binning (transliterated from SAM1.3 spec)
//

/* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */
function reg2bin(beg, end) {
    --end;
    if (beg >> 14 == end >> 14) return ((1 << 15) - 1) / 7 + (beg >> 14);
    if (beg >> 17 == end >> 17) return ((1 << 12) - 1) / 7 + (beg >> 17);
    if (beg >> 20 == end >> 20) return ((1 << 9) - 1) / 7 + (beg >> 20);
    if (beg >> 23 == end >> 23) return ((1 << 6) - 1) / 7 + (beg >> 23);
    if (beg >> 26 == end >> 26) return ((1 << 3) - 1) / 7 + (beg >> 26);
    return 0;
}

/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */
var MAX_BIN = ((1 << 18) - 1) / 7;
function reg2bins(beg, end) {
    var i = 0,
        k,
        list = [];
    --end;
    list.push(0);
    for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {
        list.push(k);
    }for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {
        list.push(k);
    }for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {
        list.push(k);
    }for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {
        list.push(k);
    }for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {
        list.push(k);
    }return list;
}

if (typeof module !== 'undefined') {
    module.exports = {
        unbgzf: unbgzf,
        readVob: readVob,
        reg2bin: reg2bin,
        reg2bins: reg2bins,
        Chunk: Chunk
    };
}

},{"jszlib":64}],28:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// memstore.js
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var dalliance_makeParser = sa.makeParser;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var textXHR = utils.textXHR;
}

function MemStore() {
    this.featuresByChr = {};
    this.maxLength = 1;
    this.chrRing = null;
}

MemStore.prototype.addFeatures = function (features) {
    var dirty = {};
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        var chr = f.segment || f.chr;
        var fa = this.featuresByChr[chr];
        if (!fa) {
            fa = [];
            this.featuresByChr[chr] = fa;
        }
        fa.push(f);
        dirty[chr] = true;

        var len = f.max - f.min + 1;
        if (len > this.maxLength) this.maxLength = len;
    }

    for (chr in dirty) {
        var fa = this.featuresByChr[chr];
        fa.sort(function (f1, f2) {
            var d = f1.min - f2.min;
            if (d != 0) return d;
            return f1.max - f2.max;
        });
    }
    this.chrRing = null;
};

MemStore.prototype._indexFor = function (fa, p) {
    var lb = 0,
        ub = fa.length;
    while (ub > lb) {
        var mid = (lb + ub) / 2 | 0;
        if (mid >= fa.length) return fa.length;
        var mg = fa[mid];
        if (p < mg.min) {
            ub = mid;
        } else {
            lb = mid + 1;
        }
    }
    return ub;
};

MemStore.prototype.fetch = function (chr, min, max) {
    var fa = this.featuresByChr[chr];
    if (!fa) {
        if (chr.indexOf('chr') == 0) fa = this.featuresByChr[chr.substring(3)];else fa = this.featuresByChr['chr' + chr];
    }
    if (!fa) return [];

    var mini = Math.max(0, this._indexFor(fa, min - this.maxLength - 1));
    var maxi = Math.min(fa.length - 1, this._indexFor(fa, max));

    var res = [];
    for (var fi = mini; fi <= maxi; ++fi) {
        var f = fa[fi];
        if (f.min <= max && f.max >= min) res.push(f);
    }
    return res;
};

MemStore.prototype.findNextFeature = function (chr, pos, dir) {
    if (this.chrRing == null) {
        this.chrRing = [];
        for (var chr in this.featuresByChr) {
            this.chrRing.push(chr);
        }
        this.chrRing.sort();
    }

    var fa = this.featuresByChr[chr];
    if (!fa) {
        if (chr.indexOf('chr') == 0) {
            chr = chr.substring(3);
            fa = this.featuresByChr[chr];
        } else {
            chr = 'chr' + chr;
            fa = this.featuresByChr[chr];
        }
    }
    if (!fa) return null;

    var i = Math.max(0, Math.min(this._indexFor(fa, pos), fa.length - 1));
    if (dir > 0) {
        while (i < fa.length) {
            var f = fa[i++];
            if (f.min > pos) return f;
        }
        var chrInd = this.chrRing.indexOf(chr) + 1;
        if (chrInd >= this.chrRing.length) chrInd = 0;
        return this.findNextFeature(this.chrRing[chrInd], 0, dir);
    } else {
        while (i >= 0) {
            var f = fa[i--];
            if (f.max < pos) return f;
        }
        var chrInd = this.chrRing.indexOf(chr) - 1;
        if (chrInd < 0) chrInd = this.chrRing.length - 1;
        return this.findNextFeature(this.chrRing[chrInd], 10000000000, dir);
    }
};

function MemStoreFeatureSource(source) {
    this.source = source;
    FeatureSourceBase.call(this);
    this.storeHolder = new Awaited();
    this.parser = dalliance_makeParser(source.payload);
    if (!this.parser) {
        throw "Unsupported memstore payload: " + source.payload;
    }

    var thisB = this;
    this._load(function (resp, err) {
        if (!resp) {
            thisB.error = err || "No data";
            thisB.storeHolder.provide(null);
        } else {
            var store = new MemStore();
            var features = [];
            var lines = resp.split('\n');

            var session = thisB.parser.createSession(function (f) {
                features.push(f);
            });
            for (var li = 0; li < lines.length; ++li) {
                var line = lines[li];
                if (line.length > 0) {
                    session.parse(line);
                }
            }
            session.flush();

            store.addFeatures(features);

            thisB.storeHolder.provide(store);
        }
    });
}

MemStoreFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

MemStoreFeatureSource.prototype._load = function (callback) {
    if (this.source.blob) {
        var r = new FileReader();
        r.onloadend = function () {
            return callback(r.result, r.error);
        };
        r.readAsText(this.source.blob);
    } else {
        if (this.source.credentials) var opts = { credentials: this.source.credentials };
        textXHR(this.source.uri, callback, opts);
    }
};

MemStoreFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, cnt) {
    var thisB = this;
    this.storeHolder.await(function (store) {
        if (store) {
            var f = store.fetch(chr, min, max);
            return cnt(null, f, 100000000);
        } else {
            return cnt(thisB.error);
        }
    });
};

MemStoreFeatureSource.prototype.getStyleSheet = function (callback) {
    if (this.parser && this.parser.getStyleSheet) this.parser.getStyleSheet(callback);
};

MemStoreFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.parser && this.parser.getDefaultFIPs) this.parser.getDefaultFIPs(callback);
};

MemStoreFeatureSource.prototype.getScales = function () {
    return 100000000;
};

MemStoreFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    var thisB = this;
    this.storeHolder.await(function (store) {
        if (store) {
            return callback(store.findNextFeature(chr, pos, dir));
        } else {
            return callback(null, thisB.error);
        }
    });
};

MemStoreFeatureSource.prototype.capabilities = function () {
    var caps = { leap: true };
    return caps;
};

dalliance_registerSourceAdapterFactory('memstore', function (source) {
    return { features: new MemStoreFeatureSource(source) };
});

},{"./das":11,"./sourceadapters":41,"./utils":58}],29:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.drawTier = exports.renderTier = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _sequenceDraw = require("./sequence-draw.js");

var _glyphs = require("./glyphs.js");

var _defaultRenderer = require("./default-renderer");

var DefaultRenderer = _interopRequireWildcard(_defaultRenderer);

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.renderTier = renderTier;
exports.drawTier = drawTier;

/* Renders multiple tiers in a single track.
   Works by simply drawing several tiers to a single canvas.
   Actual rendering is done using default-renderer.es6.
   A multi-tier renderer is configured by adding the following to a tier's
   configuration:
   renderer: 'multi',
   multi: {
       multi_id: "multi_1",
   }

   All subtiers with the "multi_1" multi_id will be drawn to this tier's canvas.
 */

function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

function drawTier(multiTier) {
    var multiConfig = multiTier.dasSource.multi;
    var getSubConfig = function getSubConfig(t) {
        return t.dasSource.sub;
    };

    multiTier.glyphCacheOrigin = multiTier.browser.viewStart;

    multiTier.subtiers = [];

    // Padding is used for finding the correct canvas size and must be set
    if (!multiTier.padding) multiTier.padding = 3;

    var canvas = multiTier.viewport.getContext("2d");
    var retina = multiTier.browser.retina && window.devicePixelRatio > 1;
    if (retina) {
        canvas.scale(2, 2);
    }

    // Filter out only tiers that are to be drawn in this multitier,
    // and also have fetched data.
    var tiers = multiTier.browser.tiers.filter(function (tier) {
        return _typeof(getSubConfig(tier)) === "object" && getSubConfig(tier).multi_id === multiConfig.multi_id && (tier.currentFeatures || tier.currentSequence);
    });

    // The shortest distance from the top of the canvas to a subtier
    var minOffset = R.pipe(R.map(function (tier) {
        return tier.dasSource.sub.offset;
    }), R.reduce(function (acc, offset) {
        return offset < acc ? offset : acc;
    }, 0))(tiers);

    tiers.forEach(function (tier) {
        if (tier.sequenceSource) {
            (0, _sequenceDraw.drawSeqTier)(tier, tier.currentSequence);
        } else if (tier.currentFeatures) {
            if (tier.dasSource.renderer !== "sub" && tier.dasSource.renderer !== "multi") {

                var renderer = tier.browser.getTierRenderer(tier);
                renderer.prepareSubtiers(tier);
            } else {
                DefaultRenderer.prepareSubtiers(tier, canvas, 0.0, false);
            }
            tier.subtiers.forEach(function (st) {
                return st.offset = tier.dasSource.sub.offset;
            });

            multiTier.subtiers = multiTier.subtiers.concat(tier.subtiers);
        }
    });

    // The canvas should fit all subtiers, including offsets, but no more
    var canvasHeight = R.pipe(R.map(function (tier) {
        return R.map(function (subtier) {
            return subtier.height + getSubConfig(tier).offset;
        }, tier.subtiers);
    }), R.flatten, R.reduce(function (acc, h) {
        return h > acc ? h : acc;
    }, -Infinity), R.add(-minOffset))(tiers);

    prepareViewport(multiTier, canvas, retina, canvasHeight, true);

    tiers.sort(function (t1, t2) {
        return getSubConfig(t1).z > getSubConfig(t2).z;
    });

    tiers.forEach(function (tier) {
        // Need to save and restore canvas to make sure that the subtiers are
        // drawn on top of one another, if not shifted...
        canvas.save();

        // better to translate here than shove a yoffset deep in the renderer
        canvas.translate(0, getSubConfig(tier).offset);

        DefaultRenderer.paint(tier, canvas, retina);

        canvas.restore();
    });

    if (multiConfig.grid) {
        var grid = new _glyphs.GridGlyph(canvasHeight, multiConfig.grid_offset, multiConfig.grid_spacing);
        grid.draw(canvas);
    }

    multiTier.drawOverlay();

    if (multiConfig.quant) {
        var quantCanvas = DefaultRenderer.createQuantOverlay(multiTier, canvasHeight + multiTier.padding * 2, retina);
        quantCanvas.save();
        DefaultRenderer.paintQuant(quantCanvas, multiTier, multiConfig.quant, 10);
        quantCanvas.restore();
    }

    if (typeof multiTier.dasSource.drawCallback === "function") {
        canvas.save();
        multiTier.dasSource.drawCallback(canvas, multiTier);
        canvas.restore();
    }

    multiTier.originHaxx = 0;
    multiTier.browser.arrangeTiers();
}

function prepareViewport(tier, canvas, retina, canvasHeight) {
    var clear = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

    canvas.save();
    var desiredWidth = tier.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }

    var fpw = tier.viewport.width | 0;
    if (fpw < desiredWidth - 50) {
        tier.viewport.width = fpw = desiredWidth;
    }

    canvasHeight += 2 * tier.padding;
    canvasHeight = Math.max(canvasHeight, tier.browser.minTierHeight);

    if (canvasHeight != tier.viewport.height) {
        tier.viewport.height = canvasHeight;

        if (retina) {
            tier.viewport.height *= 2;
        }
    }

    tier.viewportHolder.style.left = '-1000px';
    tier.viewport.style.width = retina ? '' + fpw / 2 + 'px' : '' + fpw + 'px';
    tier.viewport.style.height = '' + canvasHeight + 'px';
    tier.layoutHeight = Math.max(canvasHeight, tier.browser.minTierHeight);

    tier.updateHeight();
    tier.norigin = tier.browser.viewStart;

    if (clear) {
        DefaultRenderer.clearViewport(canvas, fpw, canvasHeight);
    }

    DefaultRenderer.drawUnmapped(tier, canvas, canvasHeight);

    canvas.restore();
}

},{"./default-renderer":12,"./glyphs.js":24,"./sequence-draw.js":38,"ramda":67}],30:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// memstore.js
//

function formatLongInt(n) {
    return (n | 0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

function formatQuantLabel(v) {
    var t = '' + v;
    var dot = t.indexOf('.');
    if (dot < 0) {
        return t;
    } else {
        var dotThreshold = 2;
        if (t.substring(0, 1) == '-') {
            ++dotThreshold;
        }

        if (dot >= dotThreshold) {
            return t.substring(0, dot);
        } else {
            return t.substring(0, dot + 2);
        }
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        formatLongInt: formatLongInt,
        formatQuantLabel: formatQuantLabel
    };
}

},{}],31:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// overlay.js: featuresources composed from multiple underlying sources
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
    var arrayIndexOf = utils.arrayIndexOf;
}

function OverlayFeatureSource(sources, opts) {
    this.sources = sources;
    this.opts = opts || {};
    this.activityListeners = [];
    this.readinessListeners = [];
    this.changeListeners = [];
    this.business = [];
    this.readiness = [];

    for (var i = 0; i < this.sources.length; ++i) {
        this.initN(i);
    }

    if (typeof opts.merge === 'function') {
        this.merge = opts.merge;
    } else if (opts.merge == 'concat') {
        this.merge = OverlayFeatureSource_merge_concat;
    } else if (opts.merge == 'alternates') {
        this.merge = OverlayFeatureSource_merge_concat;
        this.filterDispatchOnMethod = true;
    } else {
        this.merge = OverlayFeatureSource_merge_byKey;
    }
}

OverlayFeatureSource.prototype.initN = function (n) {
    var s = this.sources[n];
    var thisB = this;
    this.business[n] = 0;

    if (s.addActivityListener) {
        s.addActivityListener(function (b) {
            thisB.business[n] = b;
            thisB.notifyActivity();
        });
    }
    if (s.addChangeListener) {
        s.addChangeListener(function () {
            thisB.notifyChange();
        });
    }
    if (s.addReadinessListener) {
        s.addReadinessListener(function (r) {
            thisB.readiness[n] = r;
            thisB.notifyReadiness();
        });
    }
};

OverlayFeatureSource.prototype.addReadinessListener = function (l) {
    this.readinessListeners.push(l);
    this.notifyReadinessListener(l);
};

OverlayFeatureSource.prototype.removeReadinessListener = function (l) {
    var idx = arrayIndexOf(this.readinessListeners, l);
    if (idx >= 0) {
        this.readinessListeners.splice(idx, 1);
    }
};

OverlayFeatureSource.prototype.notifyReadiness = function () {
    for (var i = 0; i < this.readinessListeners.length; ++i) {
        this.notifyReadinessListener(this.readinessListeners[i]);
    }
};

OverlayFeatureSource.prototype.notifyReadinessListener = function (l) {
    var r = null;
    for (var i = 0; i < this.readiness.length; ++i) {
        if (this.readiness[i] != null) {
            r = this.readiness[i];break;
        }
    }
    try {
        l(r);
    } catch (e) {
        console.log(e);
    }
};

OverlayFeatureSource.prototype.addActivityListener = function (l) {
    this.activityListeners.push(l);
};

OverlayFeatureSource.prototype.removeActivityListener = function (l) {
    var idx = arrayIndexOf(this.activityListeners, l);
    if (idx >= 0) {
        this.activityListeners.splice(idx, 1);
    }
};

OverlayFeatureSource.prototype.notifyActivity = function () {
    var busy = 0;
    for (var i = 0; i < this.business.length; ++i) {
        busy += this.business[i];
    }

    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](busy);
        } catch (e) {
            console.log(e);
        }
    }
};

OverlayFeatureSource.prototype.addChangeListener = function (listener) {
    this.changeListeners.push(listener);
};

OverlayFeatureSource.prototype.removeChangeListener = function (l) {
    var idx = arrayIndexOf(this.changeListeners, l);
    if (idx >= 0) {
        this.changeListeners.splice(idx, 1);
    }
};

OverlayFeatureSource.prototype.notifyChange = function () {
    for (var li = 0; li < this.changeListeners.length; ++li) {
        try {
            this.changeListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

OverlayFeatureSource.prototype.getScales = function () {
    return this.sources[0].getScales();
};

OverlayFeatureSource.prototype.getStyleSheet = function (callback) {
    return this.sources[0].getStyleSheet(callback);
};

OverlayFeatureSource.prototype.capabilities = function () {
    var caps = {};
    var s0 = this.sources[0];
    if (s0.capabilities) caps = shallowCopy(s0.capabilities());

    for (var i = 1; i < this.sources.length; ++i) {
        var si = this.sources[i];
        if (si.capabilities) {
            var co = si.capabilities();
            if (co.search) {
                caps.search = co.search;
            }
        }
    }

    return caps;
};

OverlayFeatureSource.prototype.search = function (query, callback) {
    for (var i = 0; i < this.sources.length; ++i) {
        if (_sourceAdapterIsCapable(this.sources[i], 'search')) {
            return this.sources[i].search(query, callback);
        }
    }
};

OverlayFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback, styleFilters) {
    var sources;
    if (this.filterDispatchOnMethod) {
        sources = [];
        var sfl = styleFilters.list();
        for (var si = 0; si < this.sources.length; ++si) {
            var source = this.sources[si];
            for (var fi = 0; fi < sfl.length; ++fi) {
                var filter = sfl[fi];
                if (!filter.method || filter.method == source.name) {
                    sources.push(source);
                    break;
                }
            }
        }
    } else {
        sources = this.sources;
    }

    var baton = new OverlayBaton(this, callback, sources);
    for (var si = 0; si < sources.length; ++si) {
        this.fetchN(baton, si, sources[si], chr, min, max, scale, types, pool, styleFilters);
    }
};

OverlayFeatureSource.prototype.fetchN = function (baton, si, source, chr, min, max, scale, types, pool, styleFilters) {
    // FIXME should we try to prune styleFilters?
    source.fetch(chr, min, max, scale, types, pool, function (status, features, scale) {
        return baton.completed(si, status, features, scale);
    }, styleFilters);
};

OverlayFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    return this.sources[0].quantFindNextFeature(chr, pos, dir, threshold, callback);
};

OverlayFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    return this.sources[0].findNextFeature(chr, pos, dir, callback);
};

function OverlayBaton(source, callback, sources) {
    this.source = source;
    this.callback = callback;
    this.sources = sources;
    this.count = sources.length;

    this.returnCount = 0;
    this.statusCount = 0;
    this.returns = [];
    this.features = [];
    this.statuses = [];
    this.scale = null;
}

OverlayBaton.prototype.completed = function (index, status, features, scale) {
    if (this.scale == null || index == 0) this.scale = scale;

    if (this.returns[index]) throw 'Multiple returns for source ' + index;

    this.returns[index] = true;
    this.returnCount++;

    this.features[index] = features;

    if (status) {
        this.statuses[index] = status;
        this.statusCount++;
    }

    if (this.returnCount == this.count) {
        if (this.statusCount > 0) {
            var message = '';
            for (var si = 0; si < this.count; ++si) {
                var s = this.statuses[si];
                if (s) {
                    if (message.length > 0) message += ', ';
                    message += s;
                }
            }
            return this.callback(message, null, this.scale);
        } else {
            this.callback(null, this.source.merge(this.features, this.sources), this.scale);
        }
    }
};

OverlayFeatureSource.prototype.getDefaultFIPs = function (callback) {
    for (var si = 0; si < this.sources.length; ++si) {
        var s = this.sources[si];
        if (s.getDefaultFIPs) s.getDefaultFIPs(callback);
    }
};

OverlayFeatureSource.prototype.keyForFeature = function (feature) {
    return '' + feature.min + '..' + feature.max;
};

function OverlayFeatureSource_merge_byKey(featureSets) {
    var omaps = [];

    for (var fsi = 1; fsi < featureSets.length; ++fsi) {
        var om = {};
        var of = featureSets[fsi];
        for (var fi = 0; fi < of.length; ++fi) {
            om[this.keyForFeature(of[fi])] = of[fi];
        }
        omaps.push(om);
    }

    var mf = [];
    var fl = featureSets[0];
    for (var fi = 0; fi < fl.length; ++fi) {
        var f = fl[fi];

        for (var oi = 0; oi < omaps.length; ++oi) {
            var om = omaps[oi];
            of = om[this.keyForFeature(f)];
            if (of) {
                for (var k in of) {
                    if (k === 'score') {
                        f.score2 = of.score;
                    } else if (k === 'min' || k === 'max' || k === 'segment' || k === '_cachedStyle') {
                        // do nothing
                    } else {
                        f[k] = of[k];
                    }
                }
            }
        }
        mf.push(f);
    }
    return mf;
}

function OverlayFeatureSource_merge_concat(featureSets, sources) {
    var features = [];
    for (var fsi = 0; fsi < featureSets.length; ++fsi) {
        var fs = featureSets[fsi];
        var name = sources[fsi].name;
        for (var fi = 0; fi < fs.length; ++fi) {
            var f = fs[fi];
            f.method = name;
            features.push(f);
        }
    }
    return features;
}

function _sourceAdapterIsCapable(s, cap) {
    if (!s.capabilities) return false;else return s.capabilities()[cap];
}

if (typeof module !== 'undefined') {
    module.exports = {
        OverlayFeatureSource: OverlayFeatureSource
    };
}

},{"./utils":58}],32:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// bedwig.js
//

"use strict";

if (typeof require !== 'undefined') {
    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;
    var readInt = bin.readInt;

    var bbi = require('./bigwig');
    var BIG_WIG_MAGIC = bbi.BIG_WIG_MAGIC;
    var BIG_BED_MAGIC = bbi.BIG_BED_MAGIC;

    var lh3utils = require('./lh3utils');
    var unbgzf = lh3utils.unbgzf;

    var bam = require('./bam');
    var BAM_MAGIC = bam.BAM_MAGIC;
    var BAI_MAGIC = bam.BAI_MAGIC;

    var tbi = require('./tabix');
    var TABIX_MAGIC = tbi.TABIX_MAGIC;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

function probeResource(source, listener, retry) {
    var BED_REGEXP = new RegExp('^\\w+\\s[0-9]+\\s[0-9]+.*$');
    var KV_REGEXP = /([^=]+)=\"?([^\"]+)\"?/;
    var VCFHEAD_RE = /^##\s*fileformat=VCFv4\..+/;

    var fetchable;
    if (source.blob) fetchable = new BlobFetchable(source.blob);else if (source.transport == 'encode') fetchable = new EncodeFetchable(source.uri);else fetchable = new URLFetchable(source.uri, { credentials: source.credentials });

    fetchable.slice(0, 1 << 16).salted().fetch(function (result, error) {
        if (!result) {
            if (!retry) {
                source.credentials = true;
                probeResource(source, listener, true);
            }

            return listener(source, "Couldn't fetch data");
        }

        var ba = new Uint8Array(result);
        var la = new Uint32Array(result, 0, 1);
        var magic = la[0];
        if (magic == BIG_WIG_MAGIC || magic == BIG_BED_MAGIC) {
            source.tier_type = 'bwg';
            var nameExtractPattern = new RegExp('/?([^/]+?)(.bw|.bb|.bigWig|.bigBed)?$');
            var match = nameExtractPattern.exec(source.uri || source.blob.name);
            if (match) {
                source.name = match[1];
            }

            return listener(source, null);
        } else if (magic == BAI_MAGIC) {
            source.tier_type = 'bai';
            return listener(source, null);
        } else if (ba[0] == 31 || ba[1] == 139) {
            var unc = unbgzf(result);
            var uncba = new Uint8Array(unc);
            magic = readInt(uncba, 0);
            if (magic == BAM_MAGIC) {
                source.tier_type = 'bam';
                var nameExtractPattern = new RegExp('/?([^/]+?)(.bam)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match) {
                    source.name = match[1];
                }

                return listener(source, null);
            } else if (magic == TABIX_MAGIC) {
                source.tier_type = 'tabix-index';
                return listener(source, null);
            } else if (magic == 0x69662323) {
                source.tier_type = 'tabix';
                source.payload = 'vcf';
                var nameExtractPattern = new RegExp('/?([^/]+?)(.vcf)?(.gz)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match) {
                    source.name = match[1];
                }

                return listener(source, null);
            } else {
                console.log('magic = ' + magic.toString(16));
                return listener(source, "Unsupported format");
            }
        } else {
            var text = String.fromCharCode.apply(null, ba);
            var lines = text.split("\n");

            if (lines.length > 0 && VCFHEAD_RE.test(lines[0])) {
                source.tier_type = 'memstore';
                source.payload = 'vcf';
                var nameExtractPattern = new RegExp('/?([^/]+?)(\.vcf)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match && !source.name) {
                    source.name = match[1];
                }
                return listener(source, null);
            }

            for (var li = 0; li < lines.length; ++li) {
                var line = lines[li].replace('\r', '');
                if (line.length == 0) continue;

                if (line.indexOf('browser') == 0) continue;

                if (line.indexOf('track') == 0) {
                    var maybeType = 'bed';
                    var toks = line.split(/\s/);
                    for (var ti = 1; ti < toks.length; ++ti) {
                        var m = KV_REGEXP.exec(toks[ti]);
                        if (m) {
                            if (m[1] == 'type' && m[2] == 'wiggle_0') {
                                maybeType = 'wig';
                            } else if (m[0] == 'name') {
                                source.name = m[2];
                            }
                        }
                    }

                    finishProbeBedWig(source, maybeType);
                    return listener(source, null);
                }

                if (line.indexOf('fixedStep') == 0) {
                    finishProbeBedWig(source, 'wig');
                    return listener(source, null);
                }

                if (line.indexOf('variableStep') == 0) {
                    finishProbeBedWig(source, 'wig');
                    return listener(source, null);
                }

                if (BED_REGEXP.test(line)) {
                    finishProbeBedWig(source, null);
                    return listener(source, null);
                }

                break;
            }

            return listener(source, "Unsupported format");
        }
    }, { timeout: 1500 }); // Timeout to catch mixed-origin case on Chromium.
}

function finishProbeBedWig(source, maybeType) {
    source.tier_type = 'memstore';
    var nameExtractPattern = new RegExp('/?([^/]+?)(.(bed|wig))?$');
    var match = nameExtractPattern.exec(source.uri || source.blob.name);
    if (match) {
        if (!source.name) source.name = match[1];
        if (!maybeType && match[3]) {
            maybeType = match[3];
        }
    }
    source.payload = maybeType || 'bed';
}

if (typeof module !== 'undefined') {
    module.exports = {
        probeResource: probeResource
    };
}

},{"./bam":1,"./bigwig":3,"./bin":4,"./encode":15,"./lh3utils":27,"./tabix":49}],33:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sourceadapters = require("./sourceadapters.js");

var _das = require("./das.js");

var _csv = require("./csv.es6");

var Csv = _interopRequireWildcard(_csv);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint esversion: 6 */

var QtlMapSource = function (_FeatureSourceBase) {
    _inherits(QtlMapSource, _FeatureSourceBase);

    function QtlMapSource(source) {
        _classCallCheck(this, QtlMapSource);

        var _this = _possibleConstructorReturn(this, (QtlMapSource.__proto__ || Object.getPrototypeOf(QtlMapSource)).call(this));

        _this.qtlCsv = Csv.loadCsv(source.uri, { mode: "file" }, function () {});

        return _this;
    }

    _createClass(QtlMapSource, [{
        key: "fetch",
        value: function fetch(chr, min, max, scale, types, pool, callback) {
            var cmMin = min / 1000000;
            var cmMax = max / 1000000;

            var features = [];
            var prevPos = 0;

            this.qtlCsv.fetch(function (results, error) {
                if (error) {
                    return callback(error);
                }

                results.forEach(function (row) {
                    if (row["Chr"] === chr) {
                        var feature = new _das.DASFeature();

                        feature.segment = chr;
                        var pos = row["Mb"];

                        feature.min = pos * 1000000;
                        feature.max = pos * 1000000;

                        if (row["LRS"]) {
                            feature.score = row["LRS"];
                        } else if (row["LOD"]) {
                            feature.score = row["LOD"];
                        }

                        features.push(feature);
                    }
                });

                return callback(null, features, 1);
            });
        }
    }]);

    return QtlMapSource;
}(_sourceadapters.FeatureSourceBase);

(0, _sourceadapters.registerSourceAdapterFactory)('qtl', function (source) {
    return {
        features: new QtlMapSource(source)
    };
});

},{"./csv.es6":10,"./das.js":11,"./sourceadapters.js":41}],34:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sourceadapters = require("./sourceadapters.js");

var _das = require("./das.js");

var _csv = require("./csv.es6");

var Csv = _interopRequireWildcard(_csv);

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint esversion: 6 */

var RqtlGenotypeSource = function (_FeatureSourceBase) {
    _inherits(RqtlGenotypeSource, _FeatureSourceBase);

    function RqtlGenotypeSource(source) {
        _classCallCheck(this, RqtlGenotypeSource);

        var _this = _possibleConstructorReturn(this, (RqtlGenotypeSource.__proto__ || Object.getPrototypeOf(RqtlGenotypeSource)).call(this));

        _this.source = source;
        _this.URIBase = source.URIBase;
        _this.control = null;
        return _this;
    }

    _createClass(RqtlGenotypeSource, [{
        key: "fetchControl",
        value: function fetchControl() {
            var _this2 = this;

            return new Promise(function (resolve, reject) {
                if (_this2.source.control) {
                    _this2.configure(_this2.source.control);

                    resolve();
                } else if (_this2.source.controlURI) {
                    var req = new XMLHttpRequest();

                    req.open("GET", _this2.source.controlURI);

                    req.onload = function () {
                        _this2.configure(JSON.parse(req.responseText));
                        resolve();
                    };

                    req.onerror = function () {
                        console.log("Error when fetching control file");
                        console.log(e.stack);
                        reject();
                    };

                    req.send();
                }
            });
        }
    }, {
        key: "configure",
        value: function configure(control) {
            if (!control.geno || !control.gmap) {
                var _e = new Error("RQTL control misconfigured");
                console.log(_e.stack);
                return;
            }
            this.control = control;
            this.genoCsv = Csv.loadCsv(this.URIBase + this.control.geno);
            this.gmapCsv = Csv.loadCsv(this.URIBase + this.control.gmap);
            this.alleles = this.control.alleles;
            this.genotypes = this.control.genotypes;

            this.transposed = R.defaultTo(true, this.source.transposed);
            this.markerPositions = {};
        }
    }, {
        key: "fetchGmap",
        value: function fetchGmap(chr, callback) {
            var _this3 = this;

            return new Promise(function (resolve, reject) {
                _this3.gmapCsv.fetch(function (results, error) {
                    if (error) {
                        reject(error);
                    }

                    var sorted = results.sort(function (r1, r2) {
                        if (r1.chr < r2.chr) return -1;else if (r1.chr > r2.chr) return 1;else return r1.Mb - r2.Mb;
                    });

                    sorted.map(function (row, index) {
                        var chr = row.chr;
                        var min = row.Mb;
                        min = min * 1000000 + 10;
                        var max = min + 1000;
                        if (index < sorted.length - 1) {
                            var nextRow = sorted[index + 1];
                            if (nextRow.chr === row.chr) {
                                max = nextRow.Mb;
                                max = max * 1000000 - 1000;
                            }
                        }
                        _this3.markerPositions[row.marker] = { chr: chr, min: min, max: max };
                    });

                    resolve(chr, callback);
                });
            });
        }
    }, {
        key: "fetchGeno",
        value: function fetchGeno(chr, callback) {
            var _this4 = this;

            return new Promise(function (resolve, reject) {
                _this4.genoCsv.fetch(function (results, error) {
                    if (error) {
                        reject(error);
                    }

                    var features = [];

                    if (_this4.transposed) {
                        // the current row holds the marker as well as the
                        // corresponding genotypes for all individuals
                        results.forEach(function (row) {
                            var marker = row.marker;
                            var pos = _this4.markerPositions[marker];

                            // then, for each marker, add all the individuals.
                            Object.keys(row).forEach(function (indId) {
                                if ((indId !== "id" || indId !== "marker") && _this4.markerPositions[marker].chr === chr) {
                                    var feature = new _das.DASFeature();
                                    feature.label = marker;
                                    feature.type = indId;

                                    feature.method = row[indId];

                                    feature.segment = chr;
                                    feature.min = pos.min;
                                    feature.max = pos.max;

                                    features.push(feature);
                                }
                            });
                        });
                    } else {
                        // in this case each key in the results is a marker
                        results.forEach(function (row) {
                            Object.keys(row).map(function (marker) {
                                if (marker !== "id") {
                                    var feature = new _das.DASFeature();
                                    feature.method = row[marker];

                                    var pos = _this4.markerPositions[marker];
                                    feature.min = pos.min;
                                    feature.max = pos.max;

                                    features.push(feature);
                                }
                            });
                        });
                    }

                    resolve();
                    return callback(null, features, 1);
                });
            });
        }
    }, {
        key: "fetch",
        value: function fetch(chr, min, max, scale, types, pool, callback) {
            var _this5 = this;

            console.log("Fetching genotype track");

            var cmMin = min / 1000000;
            var cmMax = max / 1000000;

            if (this.control === null) {
                this.fetchControl(chr, callback).then(function () {
                    return _this5.fetchGmap(chr, callback);
                }).then(function () {
                    return _this5.fetchGeno(chr, callback);
                });
            } else {
                // this.fetchGmap(chr, callback)
                this.fetchGeno(chr, callback);
                // .then(() => this.fetchGeno(chr, callback));
            }
        }
    }]);

    return RqtlGenotypeSource;
}(_sourceadapters.FeatureSourceBase);

(0, _sourceadapters.registerSourceAdapterFactory)('rqtl-genotype', function (source) {
    return {
        features: new RqtlGenotypeSource(source)
    };
});

},{"./csv.es6":10,"./das.js":11,"./sourceadapters.js":41,"ramda":67}],35:[function(require,module,exports){
/* jshint esversion: 6 */

"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Ruler = Ruler;
exports.rulerDrawCallback = rulerDrawCallback;


function Ruler(options) {
    var self = this;

    self.value = options.value;
    self.min = options.min;
    self.max = options.max;
    self.width = options.width;
    self.color = options.color;

    Object.keys(self).map(function (key) {
        if (self[key] === undefined) {
            console.log("WARNING: Ruler option " + key + " not set");
        }
    });
}

Ruler.prototype.constructor = Ruler;

function rulerDrawCallback(canvas, tier) {
    var rulers = tier.dasSource.rulers;

    if (!rulers) {
        console.log("Tier uses ruler callback but has no rulers!");
    } else if (!(rulers instanceof Array)) {
        console.log("rulers.js: 'rulers' should be an Array");
    }

    rulers.map(function (r) {
        var rulerY = (r.max - r.value) * r.height;
        var viewWidth = tier.viewport.width;
        var oldLineWidth = canvas.lineWidth;

        canvas.strokeStyle = r.color;
        canvas.beginPath();
        canvas.moveTo(-viewWidth, rulerY + r.offset);
        // Other parts of the code rely on not having changed the lineWidth...
        // So we need to change it back when we're done.
        canvas.lineWidth = r.width;
        canvas.lineTo(2 * viewWidth, rulerY + r.offset);
        canvas.stroke();
        canvas.lineWidth = oldLineWidth;
    });
}

},{}],36:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// sample.js: downsampling of quantitative features
//

"use strict";

if (typeof require !== 'undefined') {
    var das = require('./das');
    var DASFeature = das.DASFeature;

    var parseCigar = require('./cigar').parseCigar;

    var shallowCopy = require('./utils').shallowCopy;
}

var __DS_SCALES = [1, 2, 5];

function ds_scale(n) {
    return __DS_SCALES[n % __DS_SCALES.length] * Math.pow(10, n / __DS_SCALES.length | 0);
}

function DSBin(scale, min, max) {
    this.scale = scale;
    this.tot = 0;
    this.cnt = 0;
    this.hasScore = false;
    this.min = min;this.max = max;
    this.features = [];
}

function _featureOrder(a, b) {
    if (a.min < b.min) {
        return -1;
    } else if (a.min > b.min) {
        return 1;
    } else if (a.max < b.max) {
        return -1;
    } else if (b.max > a.max) {
        return 1;
    } else {
        return 0;
    }
}

DSBin.prototype.score = function () {
    if (this.cnt == 0) {
        return 0;
    } else if (this.hasScore) {
        return this.tot / this.cnt;
    } else {
        var features = this.features;
        features.sort(_featureOrder);

        var maxSeen = -10000000000;
        var cov = 0,
            lap = 0;

        for (var fi = 1; fi < features.length; ++fi) {
            var f = features[fi];
            var lMin = Math.max(f.min, this.min);
            var lMax = Math.min(f.max, this.max);
            lap += lMax - lMin + 1;

            if (lMin > maxSeen) {
                cov += lMax - lMin + 1;
                maxSeen = lMax;
            } else {
                if (lMax > maxSeen) {
                    cov += lMax - maxSeen;
                    maxSeen = lMax;
                }
            }
        }

        if (cov > 0) return 1.0 * lap / cov;else return 0;
    }
};

DSBin.prototype.feature = function (f) {
    if (f.score !== undefined) {
        this.tot += f.score;
        this.hasScore = true;
    }

    ++this.cnt;
    this.features.push(f);
};

function downsample(features, targetRez) {
    var sn = 0;
    while (ds_scale(sn + 1) < targetRez) {
        ++sn;
    }
    var scale = ds_scale(sn);

    var binTots = [];
    var maxBin = -10000000000;
    var minBin = 10000000000;
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (f.groups && f.groups.length > 0) {
            // Don't downsample complex features (?)
            return features;
        }

        var minLap = f.min / scale | 0;
        var maxLap = f.max / scale | 0;
        maxBin = Math.max(maxBin, maxLap);
        minBin = Math.min(minBin, minLap);
        for (var b = minLap; b <= maxLap; ++b) {
            var bm = binTots[b];
            if (!bm) {
                bm = new DSBin(scale, b * scale, (b + 1) * scale - 1);
                binTots[b] = bm;
            }
            bm.feature(f);
        }
    }

    var sampledFeatures = [];
    for (var b = minBin; b <= maxBin; ++b) {
        var bm = binTots[b];
        if (bm) {
            var f = new DASFeature();
            f.segment = features[0].segment;
            f.min = b * scale + 1;
            f.max = (b + 1) * scale;
            f.score = bm.score();
            f.type = 'density';
            sampledFeatures.push(f);
        }
    }

    var afterDS = Date.now();
    return sampledFeatures;
}

/** Data structure to store information for
a base position:

pos: position of the base.
*/
function BaseBin(pos) {

    this._pos = pos;
    this._bases = {};
    this._totalCount = 0;
}

/** Keep record for incidence of a base,
with related qual score and strand for a position.

Params
    base: base (e.g A, T, G, C, N) observed at position.
    qual: numeric quality score.
    strand: '+' or '-'.
*/
BaseBin.prototype.recordBase = function (base, qual, strand) {
    if (!this._bases[base]) {
        var strandComposition = { '+': 0, '-': 0 };
        strandComposition[strand]++;
        this._bases[base] = {
            cnt: 1,
            totalQual: qual,
            strandCnt: strandComposition
        };
    } else {
        var baseComposition = this._bases[base];
        baseComposition.cnt++;
        baseComposition.totalQual += qual;
        baseComposition.strandCnt[strand]++;
    }
    this._totalCount++;
};

/** Returns count of total number of bases observed at position */
BaseBin.prototype.totalCount = function () {
    return this._totalCount;
};

/** Returns the base position */
BaseBin.prototype.pos = function () {
    return this._pos;
};

/** Creates a list of tag, info pairs in the form
[tag]=[info] for each base, for use in feature-popup */
BaseBin.prototype.infoList = function () {
    var info = [];
    var totalCount = this._totalCount;
    var totalCountStr = "Depth=" + totalCount.toString();
    info.push(totalCountStr);
    for (var base in this._bases) {
        var baseComposition = this._bases[base];
        var baseCnt = baseComposition.cnt;
        var basePercentage = baseCnt * 100 / totalCount;
        var plusStrandCnt = baseComposition.strandCnt['+'];
        var minusStrandCnt = baseComposition.strandCnt['-'];
        var meanQual = baseComposition.totalQual / baseCnt;

        var baseInfoString = [base, '=', baseCnt, ' (', basePercentage.toFixed(0), '%, ', plusStrandCnt, ' +, ', minusStrandCnt, ' -, Qual: ', meanQual.toFixed(0), ')'];
        info.push(baseInfoString.join(''));
    }
    return info;
};

/** Return a list of objects for creating a
histogram showing composition of different bases at a
given location.

Current implementation is hacky: the logic involves
overlaying BoxGlyphs on top of each other, thus the score
is not meaningful, but only used to manipulate height.

Params:
  ref: reference base at position
  threshold: value between 0 and 1 representing min allele frequency
              below which the allele will be ignored in histogram.
              (interpreted as noise)
              Similar to 'allele threshold' parameter in IGV

Returns a list of objects containing 2 properties
    base: such as A, T, G, C, N, - (del)
    score: a numeric score for determining height of histogram
The list is ordered such that a preceeding object always have a
score >= the current object, and the ref base will be the last item.

Example: There are 50 T's and 40 A's (total depth = 90)
at a base where ref=A. The function will return
[T: 90, A: 40]. When creating a histogram with overlap,
this will give an appearance of 40 A's (bottom) and 50 T's (top):
#######
#  T  #
#  T  #
#  T  #
#  T  #
#  T  #
#######
#  A  #
#  A  #
#  A  #
#  A  #
#######
*/
BaseBin.prototype.baseScoreList = function (ref, threshold) {
    var baseScoreList = [];
    var totalCount = this._totalCount;
    var minCount = threshold * totalCount;
    for (var base in this._bases) {
        var baseCount = this._bases[base].cnt;
        if (baseCount < minCount || base == ref) continue;
        var baseScorePair = { base: base, score: totalCount };
        baseScoreList.push(baseScorePair);
        totalCount -= baseCount;
    }
    baseScoreList.push({ base: ref, score: totalCount });
    return baseScoreList;
};

/** Generates an aligned read from the raw sequence of a BAM record
using given cigar string.

Params:
  rawseq: unaligned read sequence from Bam record
  rawquals: unaligned read quals from Bam record
  cigar: Bam cigar string from Bam record

Returns an object with 2 properties:
  seq: string containing aligned read
  quals: string containing printable-character representation
         of sequencing quality score
*/
function alignSeqUsingCigar(rawseq, rawquals, cigar) {
    var ops = parseCigar(cigar);
    var seq = [];
    var quals = [];
    var cursor = 0;
    for (var ci = 0; ci < ops.length; ++ci) {
        var co = ops[ci];
        if (co.op == 'M') {
            seq.push(rawseq.substr(cursor, co.cnt));
            quals.push(rawquals.substr(cursor, co.cnt));
            cursor += co.cnt;
        } else if (co.op == 'D') {
            for (var oi = 0; oi < co.cnt; ++oi) {
                seq.push('-');
                quals.push('Z');
            }
        } else if (co.op == 'I') {
            cursor += co.cnt;
        } else if (co.op == 'S') {
            cursor += co.cnt;
        } else {
            console.log('unknown cigop' + co.op);
        }
    }
    var processedSeq = { seq: seq.join(''), quals: quals.join('') };
    return processedSeq;
}

/** Constructs the reference sequence for a given window.

Params
    currentSequence: DasSequence object containing ref sequence
                     in current browser view.
    min, max: min and max position for window.

Returns a string containing the refseq, padded with 'N' where sequence is not
    available.
*/
function getRefSeq(currentSequence, min, max) {
    var refSeq = [];
    if (currentSequence) {
        var csStart = currentSequence.start | 0;
        var csEnd = currentSequence.end | 0;
        if (csStart <= max && csEnd >= min) {
            var sfMin = Math.max(min, csStart);
            var sfMax = Math.min(max, csEnd);

            for (var i = 0; i < sfMin - min; i++) {
                refSeq.push('N');
            }refSeq.push(currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1));
            for (var i = 0; i < max - sfMax; i++) {
                refSeq.push('N');
            }
        }
    }
    return refSeq.join('');
}

/** Constructs features necessary for a coverage track showing
base composition for BAM reads

Params
    features: a list of features from BAM records.
    currentRefSeq: a DASSequence object containing reference sequence.
    baseColors: an object mapping base to desired colors.

Returns a list of features of type base-coverage.
*/
function getBaseCoverage(features, currentRefSeq, baseColors) {
    var minBin = null;
    var maxBin = null;

    var allBins = [];

    // Populate BaseBins
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (f.groups && f.groups.length > 0) {
            // Don't downsample complex features
            return features;
        }
        var processedSeq = alignSeqUsingCigar(f.seq, f.quals, f.cigar);
        var seq = processedSeq.seq;
        var quals = processedSeq.quals;
        var strand = f.orientation;
        var minForFeature = f.min || 0;
        var maxForFeature = f.max || 0;
        var ind = 0;

        for (var b = minForFeature; b <= maxForFeature; ++b) {
            var bm = allBins[b];
            if (!bm) {
                bm = new BaseBin(b);
                allBins[b] = bm;
            }
            var base = seq.charAt(ind);
            var qual = quals.charCodeAt(ind) - 33; // Generate numeric qual score
            bm.recordBase(base, qual, strand);
            ind++;
        }

        if (!minBin) minBin = minForFeature;else minBin = Math.min(minBin, minForFeature);
        if (!maxBin) maxBin = maxForFeature;else maxBin = Math.max(maxBin, maxForFeature);
    }

    // Generate coverage features
    var refSeq = getRefSeq(currentRefSeq, minBin, maxBin);
    var baseFeatures = [];
    var ind = 0;
    for (var b = minBin; b <= maxBin; ++b) {
        var bm = allBins[b];
        if (bm) {
            var f = new DASFeature();
            f.segment = features[0].segment;
            f.min = bm.pos();
            f.max = f.min;
            f.notes = [];
            f.notes = f.notes.concat(bm.infoList());
            f.type = 'base-coverage';
            f.suppressScore = true;
            if (refSeq) {
                var refBase = refSeq.charAt(ind);
                var refString = 'Ref=' + refBase;
                f.notes.unshift(refString);
                var baseScoreList = bm.baseScoreList(refBase, 0.2);
                // TODO: shift 0.2 threshold to a config parameter
                for (var i = 0; i < baseScoreList.length; i++) {
                    var base = baseScoreList[i].base;
                    var score = baseScoreList[i].score;
                    var fBase = shallowCopy(f);
                    fBase.score = score;
                    // Color by baseColor when mismatch occurs
                    // otherwise, BoxGlyph to COLOR1 in style
                    if (baseScoreList.length > 1 || base != refBase) fBase.itemRgb = baseColors[base];

                    baseFeatures.push(fBase);
                }
            } else {
                // No refSeq, only show coverage height.
                baseFeatures.push(f);
            }
        }
        ind++;
    }
    return baseFeatures;
}

if (typeof module !== 'undefined') {
    module.exports = {
        downsample: downsample,
        getBaseCoverage: getBaseCoverage
    };
}

},{"./cigar":8,"./das":11,"./utils":58}],37:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bin.js general binary data support
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;

    var connectTrix = require('./trix').connectTrix;
}

var REGION_PATTERN = /^([\d+,\w,\.,\_,\-]+)[\s:]+([0-9,\.]+?)([KkMmGg])?((-|\.\.|\s)+([0-9,\.]+)([KkMmGg])?)?$/;

function parseLocCardinal(n, m) {
    var i = parseFloat(n.replace(/,/g, ''));
    if (m === 'k' || m === 'K') {
        return i * 1000 | 0;
    } else if (m == 'm' || m === 'M') {
        return i * 1000000 | 0;
    } else {
        return i | 0;
    }
}

Browser.prototype.search = function (g, statusCallback, opts) {
    var thisB = this;
    opts = opts || {};
    var srPadding = opts.padding || this.defaultSearchRegionPadding;

    var m = REGION_PATTERN.exec(g);

    if (m) {
        var chr = m[1],
            start,
            end;
        if (m[6]) {
            start = parseLocCardinal(m[2], m[3]);
            end = parseLocCardinal(m[6], m[7]);
        } else {
            var width = this.viewEnd - this.viewStart + 1;
            start = parseLocCardinal(m[2], m[3]) - width / 2 | 0;
            end = start + width - 1;
        }
        this.setLocation(chr, start, end, statusCallback);
    } else {
        if (!g || g.length == 0) {
            return false;
        }

        var searchCount = 0;
        var foundLatch = false;

        var searchCallback = function searchCallback(found, err) {
            --searchCount;
            if (err) {
                return statusCallback(err);
            }

            if (!found) found = [];
            var min = 500000000,
                max = -100000000;
            var nchr = null;
            for (var fi = 0; fi < found.length; ++fi) {
                var f = found[fi];

                if (nchr == null) {
                    nchr = f.segment;
                }
                min = Math.min(min, f.min);
                max = Math.max(max, f.max);
            }

            if (!nchr) {
                if (searchCount == 0 && !foundLatch) return statusCallback("no match for '" + g + "'");
            } else {
                foundLatch = true;
                thisB.highlightRegion(nchr, min, max);

                var mid = (max + min) / 2 | 0;
                var padding = Math.max(srPadding, 0.3 * (max - min + 1) | 0);
                thisB.setLocation(nchr, min - padding, max + padding, statusCallback);
            }
        };

        var doTrixSearch = function doTrixSearch(tier, trix) {
            trix.lookup(g, function (result, status) {
                if (result == null || result.length < 2) {
                    return tier.featureSource.search(g, searchCallback);
                } else {
                    var hit = result[1].split(',')[0];
                    return tier.featureSource.search(hit, searchCallback);
                }
            });
        };

        if (this.searchEndpoint) {
            searchCount = 1;
            return this.doDasSearch(thisB.searchEndpoint, g, searchCallback);
        }

        for (var ti = 0; ti < this.tiers.length; ++ti) {
            (function (tier) {
                if (thisB.sourceAdapterIsCapable(tier.featureSource, 'search')) {
                    if (tier.dasSource.trixURI) {
                        ++searchCount;
                        if (tier.trix) {
                            doTrixSearch(tier, tier.trix);
                        } else {
                            var ix = new URLFetchable(tier.dasSource.trixURI, { credentials: tier.dasSource.credentials,
                                resolver: tier.dasSource.resolver });

                            var ixx = new URLFetchable(tier.dasSource.trixxURI || tier.dasSource.trixURI + 'x', { credentials: tier.dasSource.credentials,
                                resolver: tier.dasSource.resolver });

                            connectTrix(ix, ixx, function (trix) {
                                tier.trix = trix;
                                doTrixSearch(tier, trix);
                            });
                        }
                    } else {
                        ++searchCount;
                        tier.featureSource.search(g, searchCallback);
                    }
                } else if (tier.dasSource.provides_search) {
                    ++searchCount;
                    thisB.doDasSearch(tier.dasSource, g, searchCallback);
                }
            })(this.tiers[ti]);
        }
    }
};

Browser.prototype.doDasSearch = function (source, g, searchCallback) {
    var thisB = this;
    source.features(null, { group: g, type: 'transcript' }, function (found) {
        if (!found) found = [];
        var min = 500000000,
            max = -100000000;
        var nchr = null;

        var found2 = [];
        for (var fi = 0; fi < found.length; ++fi) {
            var f = found[fi];

            if (f.label.toLowerCase() != g.toLowerCase()) {
                // ...because Dazzle can return spurious overlapping features.
                continue;
            }
            found2.push(f);
        }

        return searchCallback(found2);
    }, false);
};

},{"./bin":4,"./cbrowser":6,"./trix":56}],38:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2012
//
// sequence-draw.js: renderers for sequence-related data
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var formatLongInt = utils.formatLongInt;
    var makeElementNS = utils.makeElementNS;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;

    var nf = require('./numformats');
    var formatLongInt = nf.formatLongInt;
}

var MIN_TILE = 100;
var rulerTileColors = ['black', 'white'];

var steps = [1, 2, 5];

var NS_SVG = 'http://www.w3.org/2000/svg';

function tileSizeForScale(scale, min) {
    if (!min) {
        min = MIN_TILE;
    }

    function ts(p) {
        return steps[p % steps.length] * Math.pow(10, p / steps.length | 0);
    }
    var pow = steps.length;
    while (scale * ts(pow) < min) {
        ++pow;
    }
    return ts(pow);
}

function drawSeqTier(tier, seq) {
    var gc = tier.viewport.getContext('2d');
    var retina = tier.browser.retina && window.devicePixelRatio > 1;
    var desiredWidth = tier.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }
    var fpw = tier.viewport.width | 0; // this.browser.featurePanelWidth;
    if (fpw < desiredWidth - 50) {
        tier.viewport.width = fpw = desiredWidth;
    }

    var height = 50;
    if (seq && seq.seq) {
        height += 25;
    }

    var canvasHeight = height;
    if (retina) canvasHeight *= 2;

    tier.viewport.height = canvasHeight;
    tier.viewport.style.height = '' + height + 'px';
    tier.viewport.style.width = retina ? '' + fpw / 2 + 'px' : '' + fpw + 'px';
    tier.layoutHeight = height;
    tier.updateHeight();

    if (tier.background) {
        gc.fillStyle = tier.background;
        gc.fillRect(0, 0, fpw, tier.viewport.height);
    }
    if (retina) {
        gc.scale(2, 2);
    }

    gc.translate(1000, 0);
    drawSeqTierGC(tier, seq, gc);
    tier.norigin = tier.browser.viewStart;
    tier.viewportHolder.style.left = '-1000px';
}

function drawSeqTierGC(tier, seq, gc) {
    var scale = tier.browser.scale,
        knownStart = tier.browser.viewStart - 1000 / scale | 0,
        knownEnd = tier.browser.viewEnd + 2000 / scale,
        currentSeqMax = tier.browser.currentSeqMax;

    var seqTierMax = knownEnd;
    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {
        seqTierMax = currentSeqMax;
    }
    var tile = tileSizeForScale(scale);
    var pos = Math.max(0, (knownStart / tile | 0) * tile);

    var origin = tier.browser.viewStart;

    while (pos <= seqTierMax) {
        gc.fillStyle = pos / tile % 2 == 0 ? 'white' : 'black';
        gc.strokeStyle = 'black';
        gc.fillRect((pos - origin) * scale, 8, tile * scale, 3);
        gc.strokeRect((pos - origin) * scale, 8, tile * scale, 3);

        gc.fillStyle = 'black';
        gc.fillText(formatLongInt(pos), (pos - origin) * scale, 22);

        pos += tile;
    }

    if (seq && seq.seq) {
        for (var p = knownStart; p <= knownEnd; ++p) {
            if (p >= seq.start && p <= seq.end) {
                var base = seq.seq.substr(p - seq.start, 1).toUpperCase();
                var color = tier.browser.baseColors[base];
                if (!color) {
                    color = 'gray';
                }

                gc.fillStyle = color;

                if (scale >= 8) {
                    var w = gc.measureText(base).width;
                    // console.log(scale-w);
                    gc.fillText(base, (p - origin) * scale + (scale - w) * 0.5, 52);
                } else {
                    gc.fillRect((p - origin) * scale, 42, scale, 12);
                }
            }
        }
    }
}

function svgSeqTier(tier, seq) {
    var scale = tier.browser.scale,
        knownStart = tier.browser.viewStart - 1000 / scale | 0,
        knownEnd = tier.browser.viewEnd + 2000 / scale,
        currentSeqMax = tier.browser.currentSeqMax;

    var fpw = tier.viewport.width | 0;

    var seqTierMax = knownEnd;
    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {
        seqTierMax = currentSeqMax;
    }
    var tile = tileSizeForScale(scale);
    var pos = Math.max(0, (knownStart / tile | 0) * tile);

    var origin = tier.browser.viewStart;

    var g = makeElementNS(NS_SVG, 'g', [], { fontSize: '8pt' });
    while (pos <= seqTierMax) {
        g.appendChild(makeElementNS(NS_SVG, 'rect', null, { x: (pos - origin) * scale,
            y: 8,
            width: tile * scale,
            height: 3,
            fill: pos / tile % 2 == 0 ? 'white' : 'black',
            stroke: 'black' }));

        g.appendChild(makeElementNS(NS_SVG, 'text', formatLongInt(pos), { x: (pos - origin) * scale,
            y: 28,
            fill: 'black', stroke: 'none' }));

        pos += tile;
    }

    if (seq && seq.seq) {
        for (var p = knownStart; p <= knownEnd; ++p) {
            if (p >= seq.start && p <= seq.end) {
                var base = seq.seq.substr(p - seq.start, 1).toUpperCase();
                var color = tier.browser.baseColors[base];
                if (!color) {
                    color = 'gray';
                }

                if (scale >= 8) {
                    g.appendChild(makeElementNS(NS_SVG, 'text', base, {
                        x: (0.5 + p - origin) * scale,
                        y: 52,
                        textAnchor: 'middle',
                        fill: color }));
                } else {
                    g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
                        x: (p - origin) * scale,
                        y: 42,
                        width: scale,
                        height: 12,
                        fill: color }));
                }
            }
        }
    }

    return g;
}

if (typeof module !== 'undefined') {
    module.exports = {
        drawSeqTier: drawSeqTier,
        drawSeqTierGC: drawSeqTierGC,
        svgSeqTier: svgSeqTier
    };
}

},{"./numformats":30,"./svg-utils":47,"./utils":58}],39:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// session.js
//

"use strict";

if (typeof require != 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var sc = require('./sourcecompare');
    var sourceDataURI = sc.sourceDataURI;
    var sourcesAreEqual = sc.sourcesAreEqual;

    var VERSION = require('./version');

    var utils = require('./utils');
    var miniJSONify = utils.miniJSONify;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;
}

Browser.prototype.nukeStatus = function () {
    delete localStorage['dalliance.' + this.cookieKey + '.view-chr'];
    delete localStorage['dalliance.' + this.cookieKey + '.view-start'];
    delete localStorage['dalliance.' + this.cookieKey + '.view-end'];
    delete localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];
    delete localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'];
    delete localStorage['dalliance.' + this.cookieKey + '.saved-zoom'];

    delete localStorage['dalliance.' + this.cookieKey + '.sources'];
    delete localStorage['dalliance.' + this.cookieKey + '.hubs'];
    delete localStorage['dalliance.' + this.cookieKey + '.version'];

    delete localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];
    delete localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];
    delete localStorage['dalliance.' + this.cookieKey + '.ruler-location'];
};

Browser.prototype.storeStatus = function () {
    this.storeViewStatus();
    this.storeTierStatus();
};

Browser.prototype.storeViewStatus = function () {
    if (!this.cookieKey || this.noPersist || this.noPersistView) {
        return;
    }

    localStorage['dalliance.' + this.cookieKey + '.view-chr'] = this.chr;
    localStorage['dalliance.' + this.cookieKey + '.view-start'] = this.viewStart | 0;
    localStorage['dalliance.' + this.cookieKey + '.view-end'] = this.viewEnd | 0;
    localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'] = '' + this.isSnapZooming;
    localStorage['dalliance.' + this.cookieKey + '.saved-zoom'] = this.savedZoom;
    if (this.currentSeqMax) {
        localStorage['dalliance.' + this.cookieKey + '.current-seq-length'] = this.currentSeqMax;
    }
};

Browser.prototype.storeTierStatus = function () {
    if (!this.cookieKey || this.noPersist) {
        return;
    }

    var currentSourceList = [];
    for (var t = 0; t < this.tiers.length; ++t) {
        var tt = this.tiers[t];
        var ts = tt.dasSource;
        if (!ts.noPersist) {
            currentSourceList.push({ source: tt.dasSource, config: tt.config || {} });
        }
    }
    localStorage['dalliance.' + this.cookieKey + '.sources'] = JSON.stringify(currentSourceList);

    var coveredHubURLs = {};
    var currentHubList = [];
    for (var hi = 0; hi < this.hubObjects.length; ++hi) {
        var tdb = this.hubObjects[hi];
        var hc = { url: tdb.hub.url, genome: tdb.genome };
        if (tdb.credentials) hc.credentials = tdb.credentials;
        if (tdb.mapping) hc.mapping = tdb.mapping;
        coveredHubURLs[hc.url] = true;
        currentHubList.push(hc);
    }

    // Needed to handle hubs that failed to connect, or hubs that haven't
    // connected yet when we're called soon after startup.
    for (var hi = 0; hi < this.hubs.length; ++hi) {
        var hc = this.hubs[hi];
        if (typeof hc === 'string') hc = { url: hc };
        if (!coveredHubURLs[hc.url]) currentHubList.push(hc);
    }

    localStorage['dalliance.' + this.cookieKey + '.hubs'] = JSON.stringify(currentHubList);

    localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'] = this.reverseScrolling;
    localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'] = this.reverseKeyScrolling;
    localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'] = this.singleBaseHighlight;
    localStorage['dalliance.' + this.cookieKey + '.ruler-location'] = this.rulerLocation;

    localStorage['dalliance.' + this.cookieKey + '.export-ruler'] = this.exportRuler;
    localStorage['dalliance.' + this.cookieKey + '.export-highlights'] = this.exportHighlights;

    localStorage['dalliance.' + this.cookieKey + '.version'] = VERSION.CONFIG;
};

Browser.prototype.restoreStatus = function () {
    if (this.noPersist) return;

    var storedConfigVersion = localStorage['dalliance.' + this.cookieKey + '.version'];
    if (storedConfigVersion) {
        storedConfigVersion = storedConfigVersion | 0;
    } else {
        storedConfigVersion = -100;
    }
    if (VERSION.CONFIG != storedConfigVersion) {
        return;
    }

    var storedConfigHash = localStorage['dalliance.' + this.cookieKey + '.configHash'] || '';
    var pageConfigHash = hex_sha1(miniJSONify({
        sources: this.sources,
        hubs: this.hubs,
        rulerLocation: this.rulerLocation
    }));
    if (pageConfigHash != storedConfigHash) {
        localStorage['dalliance.' + this.cookieKey + '.configHash'] = pageConfigHash;
        return;
    }

    var defaultSourcesByURI = {};
    for (var si = 0; si < this.sources.length; ++si) {
        var source = this.sources[si];
        if (!source) continue;

        var uri = sourceDataURI(source);
        var ul = defaultSourcesByURI[uri];
        if (!ul) defaultSourcesByURI[uri] = ul = [];
        ul.push(source);
    }

    if (!this.noPersistView) {
        var qChr = localStorage['dalliance.' + this.cookieKey + '.view-chr'];
        var qMin = localStorage['dalliance.' + this.cookieKey + '.view-start'] | 0;
        var qMax = localStorage['dalliance.' + this.cookieKey + '.view-end'] | 0;
        if (qChr && qMin && qMax) {
            this.chr = qChr;
            this.viewStart = qMin;
            this.viewEnd = qMax;

            var csm = localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];
            if (csm) {
                this.currentSeqMax = csm | 0;
            }

            this.isSnapZooming = localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'] == 'true';

            var sz = parseFloat(localStorage['dalliance.' + this.cookieKey + '.saved-zoom']);
            if (typeof sz === 'number' && !isNaN(sz)) {
                this.savedZoom = sz;
            }
        }
    }

    var rs = localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];
    this.reverseScrolling = rs && rs == 'true';
    var rks = localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];
    this.reverseKeyScrolling = rks && rks == 'true';
    var sbh = localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'];
    this.singleBaseHighlight = sbh && sbh == 'true';

    var rl = localStorage['dalliance.' + this.cookieKey + '.ruler-location'];
    if (rl) this.rulerLocation = rl;

    var x = localStorage['dalliance.' + this.cookieKey + '.export-ruler'];
    if (x) this.exportRuler = x === 'true';
    var x = localStorage['dalliance.' + this.cookieKey + '.export-highlights'];
    if (x) this.exportHighlights = x === 'true';

    var sourceStr = localStorage['dalliance.' + this.cookieKey + '.sources'];
    if (sourceStr) {
        var storedSources = JSON.parse(sourceStr);
        this.sources = [];
        this.restoredConfigs = [];
        for (var si = 0; si < storedSources.length; ++si) {
            var source = this.sources[si] = storedSources[si].source;
            this.restoredConfigs[si] = storedSources[si].config;
            var uri = sourceDataURI(source);
            var ul = defaultSourcesByURI[uri] || [];
            for (var osi = 0; osi < ul.length; ++osi) {
                var oldSource = ul[osi];
                if (sourcesAreEqual(source, oldSource)) {
                    for (var k in oldSource) {
                        if (oldSource.hasOwnProperty(k) && (typeof oldSource[k] === 'function' || oldSource[k] instanceof Blob)) {
                            source[k] = oldSource[k];
                        }
                    }
                }
            }
        }
    }

    var hubStr = localStorage['dalliance.' + this.cookieKey + '.hubs'];
    if (hubStr) {
        this.hubs = JSON.parse(hubStr);
    }

    return true;
};

Browser.prototype.reset = function () {
    for (var i = this.tiers.length - 1; i >= 0; --i) {
        this.removeTier({ index: i }, true);
    }
    for (var i = 0; i < this.defaultSources.length; ++i) {
        var s = this.defaultSources[i];
        if (!s.disabled) this.addTier(this.defaultSources[i]);
    }

    this.highlights.splice(0, this.highlights.length);

    this.setLocation(this.defaultChr, this.defaultStart, this.defaultEnd);
};

},{"./cbrowser":6,"./sha1":40,"./sourcecompare":42,"./utils":58,"./version":60}],40:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS 180-1
 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

"use strict";

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */

var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad = ""; /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s) {
  return rstr2hex(rstr_sha1(str2rstr_utf8(s)));
}
function b64_sha1(s) {
  return rstr2b64(rstr_sha1(str2rstr_utf8(s)));
}
function any_sha1(s, e) {
  return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);
}
function hex_hmac_sha1(k, d) {
  return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function b64_hmac_sha1(k, d) {
  return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function any_hmac_sha1(k, d, e) {
  return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);
}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test() {
  return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA1 of a raw string
 */
function rstr_sha1(s) {
  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
}

/*
 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
 */
function rstr_hmac_sha1(key, data) {
  var bkey = rstr2binb(key);
  if (bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

  var ipad = Array(16),
      opad = Array(16);
  for (var i = 0; i < 16; i++) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input) {
  // try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for (var i = 0; i < input.length; i++) {
    x = input.charCodeAt(i);
    output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input) {
  // try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for (var i = 0; i < len; i += 3) {
    var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
    for (var j = 0; j < 4; j++) {
      if (i * 8 + j * 6 > input.length * 8) output += b64pad;else output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding) {
  var divisor = encoding.length;
  var remainders = Array();
  var i, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for (i = 0; i < dividend.length; i++) {
    dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. We stop when the dividend is zero.
   * All remainders are stored for later use.
   */
  while (dividend.length > 0) {
    quotient = Array();
    x = 0;
    for (i = 0; i < dividend.length; i++) {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;
    }
    remainders[remainders.length] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for (i = remainders.length - 1; i >= 0; i--) {
    output += encoding.charAt(remainders[i]);
  } /* Append leading zero equivalents */
  var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
  for (i = output.length; i < full_length; i++) {
    output = encoding[0] + output;
  }return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input) {
  var output = "";
  var i = -1;
  var x, y;

  while (++i < input.length) {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if (x <= 0x7F) output += String.fromCharCode(x);else if (x <= 0x7FF) output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);else if (x <= 0xFFFF) output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);else if (x <= 0x1FFFFF) output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    output += String.fromCharCode(input.charCodeAt(i) & 0xFF, input.charCodeAt(i) >>> 8 & 0xFF);
  }return output;
}

function str2rstr_utf16be(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 0xFF, input.charCodeAt(i) & 0xFF);
  }return output;
}

/*
 * Convert a raw string to an array of big-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binb(input) {
  var output = Array(input.length >> 2);
  for (var i = 0; i < output.length; i++) {
    output[i] = 0;
  }for (var i = 0; i < input.length * 8; i += 8) {
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;
  }return output;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2rstr(input) {
  var output = "";
  for (var i = 0; i < input.length * 32; i += 8) {
    output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);
  }return output;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function binb_sha1(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << 24 - len % 32;
  x[(len + 64 >> 9 << 4) + 15] = len;

  var w = Array(80);
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  var e = -1009589776;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for (var j = 0; j < 80; j++) {
      if (j < 16) w[j] = x[i + j];else w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = bit_rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d) {
  if (t < 20) return b & c | ~b & d;
  if (t < 40) return b ^ c ^ d;
  if (t < 60) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t) {
  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xFFFF;
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}

if (typeof module !== 'undefined') {
  module.exports = {
    b64_sha1: b64_sha1,
    hex_sha1: hex_sha1
  };
}

},{}],41:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// sourceadapters.js
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var arrayIndexOf = utils.arrayIndexOf;
    var shallowCopy = utils.shallowCopy;
    var resolveUrlToPage = utils.resolveUrlToPage;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;
    var DASFeature = das.DASFeature;
    var DASSequence = das.DASSequence;
    var DASLink = das.DASLink;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;

    var twoBit = require('./twoBit');
    var makeTwoBit = twoBit.makeTwoBit;

    var bbi = require('./bigwig');
    var makeBwg = bbi.makeBwg;

    var bam = require('./bam');
    var makeBam = bam.makeBam;
    var BamFlags = bam.BamFlags;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;

    var parseCigar = require('./cigar').parseCigar;

    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;

    var JBrowseStore = require('./jbjson').JBrowseStore;

    var Chainset = require('./chainset').Chainset;

    var style = require('./style');
    var StyleFilterSet = style.StyleFilterSet;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

var __dalliance_sourceAdapterFactories = {};

function dalliance_registerSourceAdapterFactory(type, factory) {
    __dalliance_sourceAdapterFactories[type] = factory;
}

var __dalliance_parserFactories = {};

function dalliance_registerParserFactory(type, factory) {
    __dalliance_parserFactories[type] = factory;
}

function dalliance_makeParser(type) {
    if (__dalliance_parserFactories[type]) {
        return __dalliance_parserFactories[type](type);
    }
}

DasTier.prototype.initSources = function () {
    var thisTier = this;

    var sources = this.browser.createSources(this.dasSource);
    this.featureSource = sources.features || new DummyFeatureSource();
    this.sequenceSource = sources.sequence;

    if (this.featureSource && this.featureSource.addChangeListener) {
        this.featureSource.addChangeListener(function () {
            thisTier.browser.refreshTier(thisTier);
        });
    }
};

Browser.prototype.createSources = function (config) {
    var self = this;
    var sources = self.sourceCache.get(config);
    if (sources) return sources;

    var fs, ss;
    if (config.tier_type === "multi") {
        return { fs: null, ss: null };
    }

    if (config.tier_type === "external") {
        console.log("configuring external source");

        console.log(_typeof(config.external_fetch));
        if (config.external_fetch && typeof config.external_fetch === "function") {
            fs = new FeatureSourceBase();
            fs.fetch = function (a, b, c, d, e, f, g) {
                return config.external_fetch(a, b, c, d, e, f, g)();
            };
            ss = null;
            console.log("external source:");
            console.log(fs);
        } else {
            console.log("misconfigured external feature source");
        }
    } else if (config.tier_type == 'sequence' || config.twoBitURI || config.twoBitBlob) {
        if (config.twoBitURI || config.twoBitBlob) {
            ss = new TwoBitSequenceSource(config);
        } else if (config.ensemblURI) {
            ss = new EnsemblSequenceSource(config);
        } else {
            ss = new DASSequenceSource(config);
        }
    } else if (config.tier_type && __dalliance_sourceAdapterFactories[config.tier_type]) {
        var saf = __dalliance_sourceAdapterFactories[config.tier_type];
        var ns;
        ns = saf(config);
        fs = ns.features;
        ss = ns.sequence;
    } else if (config.bwgURI || config.bwgBlob) {
        var worker = this.getWorker();
        if (worker) fs = new RemoteBWGFeatureSource(config, worker, this);else fs = new BWGFeatureSource(config);
    } else if (config.bamURI || config.bamBlob) {
        var worker = this.getWorker();
        if (worker) fs = new RemoteBAMFeatureSource(config, worker, this);else fs = new BAMFeatureSource(config);
    } else if (config.jbURI) {
        fs = new JBrowseFeatureSource(config);
    } else if (config.uri || config.features_uri) {
        fs = new DASFeatureSource(config);
    }

    if (config.overlay) {
        var sources = [];
        if (fs) sources.push(new CachingFeatureSource(fs));

        for (var oi = 0; oi < config.overlay.length; ++oi) {
            var cs = this.createSources(config.overlay[oi]);
            if (cs && cs.features) sources.push(cs.features);
        }
        fs = new OverlayFeatureSource(sources, config);
    }

    if (config.sequenceAliases) {
        fs = new MappedFeatureSource(fs, new Chainset({ type: 'alias', sequenceAliases: config.sequenceAliases }));
    }

    if (config.mapping) {
        fs = new MappedFeatureSource(fs, this.chains[config.mapping]);
    }

    if (config.name && fs && !fs.name) {
        fs.name = config.name;
    }

    if (typeof fs !== 'undefined' && fs !== null && config.tier_type !== "external") {
        fs = new CachingFeatureSource(fs);
    }

    if (typeof fs !== 'undefined' && fs !== null || typeof ss !== 'undefined' && ss != null) {
        sources = {
            features: fs,
            sequence: ss
        };
        this.sourceCache.put(config, sources);
    }

    return sources;
};

DasTier.prototype.fetchStylesheet = function (cb) {
    var ssSource;
    // Somewhat ugly workaround for the special case of DAS sources...
    if (this.dasSource.tier_type === "multi-track") {
        ssSource = this.getSource();
    } else if (this.dasSource.stylesheet_uri || !this.dasSource.tier_type && !this.dasSource.bwgURI && !this.dasSource.bwgBlob && !this.dasSource.bamURI && !this.dasSource.bamBlob && !this.dasSource.twoBitURI && !this.dasSource.twoBitBlob && !this.dasSource.jbURI && !this.dasSource.overlay) {
        ssSource = new DASFeatureSource(this.dasSource);
    } else {
        ssSource = this.getSource();
    }
    // console.log(ssSource);
    ssSource.getStyleSheet(cb);
};

var __cfs_id_seed = 0;

function CachingFeatureSource(source) {
    var thisB = this;

    this.source = source;
    this.cfsid = 'cfs' + ++__cfs_id_seed;
    if (source.name) {
        this.name = source.name;
    }
    if (source.addChangeListener) {
        source.addChangeListener(function () {
            thisB.cfsid = 'cfs' + ++__cfs_id_seed;
        });
    }
}

CachingFeatureSource.prototype.addReadinessListener = function (listener) {
    if (this.source.addReadinessListener) return this.source.addReadinessListener(listener);else listener(null);
};

CachingFeatureSource.prototype.removeReadinessListener = function (listener) {
    if (this.source.removeReadinessListener) return this.source.removeReadinessListener(listener);
};

CachingFeatureSource.prototype.search = function (query, callback) {
    if (this.source.search) return this.source.search(query, callback);
};

CachingFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.source.getDefaultFIPs) return this.source.getDefaultFIPs(callback);
};

CachingFeatureSource.prototype.getStyleSheet = function (callback) {
    this.source.getStyleSheet(callback);
};

CachingFeatureSource.prototype.getScales = function () {
    return this.source.getScales();
};

CachingFeatureSource.prototype.addActivityListener = function (l) {
    if (this.source.addActivityListener) {
        this.source.addActivityListener(l);
    }
};

CachingFeatureSource.prototype.removeActivityListener = function (l) {
    if (this.source.removeActivityListener) {
        this.source.removeActivityListener(l);
    }
};

CachingFeatureSource.prototype.addChangeListener = function (l) {
    if (this.source.addChangeListener) this.source.addChangeListener(l);
};

CachingFeatureSource.prototype.removeChangeListener = function (l) {
    if (this.source.removeChangeListener) this.source.removeChangeListener(l);
};

CachingFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    this.source.findNextFeature(chr, pos, dir, callback);
};

CachingFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    this.source.quantFindNextFeature(chr, pos, dir, threshold, callback);
};

CachingFeatureSource.prototype.capabilities = function () {
    if (this.source.capabilities) {
        return this.source.capabilities();
    } else {
        return {};
    }
};

CachingFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback, styleFilters) {
    if (!pool) {
        throw Error('Fetch pool is null');
    }

    var self = this;
    var cacheKey = this.cfsid;

    var awaitedFeatures = pool.awaitedFeatures[cacheKey];
    if (awaitedFeatures && awaitedFeatures.started) {
        if (awaitedFeatures.styleFilters.doesNotContain(styleFilters)) {
            // console.log('Fetch already started with wrong parameters, skipping cache.');
            self.source.fetch(chr, min, max, scale, types, pool, callback, styleFilters);
            return;
        }
    } else if (awaitedFeatures) {
        if (awaitedFeatures.styleFilters) awaitedFeatures.styleFilters.addAll(styleFilters);
    } else {
        awaitedFeatures = new Awaited();
        var typeList = null;
        if (styleFilters) {
            awaitedFeatures.styleFilters = styleFilters;
            typeList = awaitedFeatures.styleFilters.typeList();
        }
        pool.awaitedFeatures[cacheKey] = awaitedFeatures;

        pool.requestsIssued.then(function () {
            awaitedFeatures.started = true;
            self.source.fetch(chr, min, max, scale, typeList, pool, function (status, features, scale, coverage) {
                if (!awaitedFeatures.res) awaitedFeatures.provide({ status: status, features: features, scale: scale, coverage: coverage });
            }, awaitedFeatures.styleFilters);
        }).catch(function (err) {
            console.log(err);
        });
    }

    awaitedFeatures.await(function (af) {
        callback(af.status, af.features, af.scale, af.coverage);
    });
};

function FeatureSourceBase() {
    this.busy = 0;
    this.activityListeners = [];
    this.readinessListeners = [];
    this.readiness = null;
}

FeatureSourceBase.prototype.addReadinessListener = function (listener) {
    this.readinessListeners.push(listener);
    listener(this.readiness);
};

FeatureSourceBase.prototype.removeReadinessListener = function (listener) {
    var idx = arrayIndexOf(this.readinessListeners, listener);
    if (idx >= 0) {
        this.readinessListeners.splice(idx, 1);
    }
};

FeatureSourceBase.prototype.notifyReadiness = function () {
    for (var li = 0; li < this.readinessListeners.length; ++li) {
        try {
            this.readinessListeners[li](this.readiness);
        } catch (e) {
            console.log(e);
        }
    }
};

FeatureSourceBase.prototype.addActivityListener = function (listener) {
    this.activityListeners.push(listener);
};

FeatureSourceBase.prototype.removeActivityListener = function (listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0) {
        this.activityListeners.splice(idx, 1);
    }
};

FeatureSourceBase.prototype.notifyActivity = function () {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

FeatureSourceBase.prototype.getScales = function () {
    return null;
};

FeatureSourceBase.prototype.fetch = function (chr, min, max, scale, types, pool, cnt) {
    return cnt(null, [], 1000000000);
};

FeatureSourceBase.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();
    var defStyle = new DASStyle();
    defStyle.glyph = 'BOX';
    defStyle.BGCOLOR = 'blue';
    defStyle.FGCOLOR = 'black';
    stylesheet.pushStyle({ type: 'default' }, null, defStyle);
    return callback(stylesheet);
};

function DASFeatureSource(dasSource) {
    this.dasSource = new DASSource(dasSource);
    this.busy = 0;
    this.activityListeners = [];
}

DASFeatureSource.prototype.addActivityListener = function (listener) {
    this.activityListeners.push(listener);
};

DASFeatureSource.prototype.removeActivityListener = function (listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0) this.activityListeners.splice(idx, 1);
};

DASFeatureSource.prototype.notifyActivity = function () {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

DASFeatureSource.prototype.getStyleSheet = function (callback) {
    this.dasSource.stylesheet(function (stylesheet) {
        callback(stylesheet);
    }, function () {
        callback(null, "Couldn't fetch DAS stylesheet");
    });
};

DASFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    if (types && types.length === 0) {
        callback(null, [], scale);
        return;
    }

    if (!this.dasSource.uri && !this.dasSource.features_uri) {
        // FIXME should this be making an error callback???
        return;
    }

    if (this.dasSource.dasStaticFeatures && this.cachedStaticFeatures) {
        return callback(null, this.cachedStaticFeatures, this.cachedStaticScale);
    }

    var tryMaxBins = this.dasSource.maxbins !== false;
    var fops = {
        type: types
    };
    if (tryMaxBins) {
        fops.maxbins = 1 + ((max - min) / scale | 0);
    }

    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();

    this.dasSource.features(new DASSegment(chr, min, max), fops, function (features, status) {

        thisB.busy--;
        thisB.notifyActivity();

        var retScale = scale;
        if (!tryMaxBins) {
            retScale = 0.1;
        }
        if (!status && thisB.dasSource.dasStaticFeatures) {
            thisB.cachedStaticFeatures = features;
            thisB.cachedStaticScale = retScale;
        }
        callback(status, features, retScale);
    });
};

DASFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    if (this.dasSource.capabilities && arrayIndexOf(this.dasSource.capabilities, 'das1:adjacent-feature') >= 0) {
        var thisB = this;
        if (this.dasAdjLock) {
            return console.log('Already looking for a next feature, be patient!');
        }
        this.dasAdjLock = true;
        var fops = {
            adjacent: chr + ':' + (pos | 0) + ':' + (dir > 0 ? 'F' : 'B')
        };
        var types = thisTier.getDesiredTypes(thisTier.browser.scale);
        if (types) {
            fops.types = types;
        }
        thisTier.dasSource.features(null, fops, function (res) {
            thisB.dasAdjLock = false;
            if (res.length > 0 && res[0] !== null) {
                callback(res[0]);
            }
        });
    }
};

function DASSequenceSource(dasSource) {
    this.dasSource = new DASSource(dasSource);
    this.awaitedEntryPoints = new Awaited();

    var thisB = this;
    this.dasSource.entryPoints(function (ep) {
        thisB.awaitedEntryPoints.provide(ep);
    });
}

DASSequenceSource.prototype.fetch = function (chr, min, max, pool, callback) {
    this.dasSource.sequence(new DASSegment(chr, min, max), function (seqs) {
        if (seqs.length == 1) {
            return callback(null, seqs[0]);
        } else {
            return callback("Didn't get sequence");
        }
    });
};

DASSequenceSource.prototype.getSeqInfo = function (chr, cnt) {
    this.awaitedEntryPoints.await(function (ep) {
        for (var epi = 0; epi < ep.length; ++epi) {
            if (ep[epi].name == chr) {
                return cnt({ length: ep[epi].end });
            }
        }
        return cnt();
    });
};

function TwoBitSequenceSource(source) {
    var thisB = this;
    this.source = source;
    this.twoBit = new Awaited();
    var data;
    if (source.twoBitURI) {
        data = new URLFetchable(source.twoBitURI, { credentials: source.credentials, resolver: source.resolver });
    } else if (source.twoBitBlob) {
        data = new BlobFetchable(source.twoBitBlob);
    } else {
        throw Error("No twoBitURI or twoBitBlob parameter");
    }

    makeTwoBit(data, function (tb, error) {
        if (error) {
            console.log(error);
        } else {
            thisB.twoBit.provide(tb);
        }
    });
}

TwoBitSequenceSource.prototype.fetch = function (chr, min, max, pool, callback) {
    this.twoBit.await(function (tb) {
        tb.fetch(chr, min, max, function (seq, err) {
            if (err) {
                return callback(err, null);
            } else {
                var sequence = new DASSequence(chr, min, max, 'DNA', seq);
                return callback(null, sequence);
            }
        });
    });
};

TwoBitSequenceSource.prototype.getSeqInfo = function (chr, cnt) {
    this.twoBit.await(function (tb) {
        var seq = tb.getSeq(chr);
        if (seq) {
            tb.getSeq(chr).length(function (l) {
                cnt({ length: l });
            });
        } else {
            cnt();
        }
    });
};

function EnsemblSequenceSource(source) {
    this.source = source;
    // http://data.gramene.org/ensembl/info/assembly/triticum_aestivum/2B?content-type=application/json
    // http://data.gramene.org/ensembl/sequence/region/triticum_aestivum/2B:8001..18000:1?content-type=application/json
}

EnsemblSequenceSource.prototype.fetch = function (chr, min, max, pool, callback) {
    var url = this.source.ensemblURI + '/sequence/region/' + this.source.species + '/' + chr + ':' + min + '..' + max + ':1?content-type=application/json';
    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            var jr;
            if (req.status >= 300) {
                var err = 'Error code ' + req.status;
                try {
                    jr = JSON.parse(req.response);
                    if (jr.error) {
                        err = jr.error;
                    }
                } finally {
                    callback(err, null);
                }
            } else {
                jr = JSON.parse(req.response);
                var sequence = new DASSequence(chr, min, max, 'DNA', jr.seq);
                return callback(null, sequence);
            }
        }
    };
    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

EnsemblSequenceSource.prototype.getSeqInfo = function (chr, cnt) {
    var url = this.source.ensemblURI + '/info/assembly/' + this.source.species + '/' + chr + '?content-type=application/json';
    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            if (req.status >= 300) {
                cnt();
            } else {
                var jr = JSON.parse(req.response);
                cnt(jr);
            }
        }
    };
    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

DASFeatureSource.prototype.getScales = function () {
    return [];
};

var bwg_preflights = {};

function BWGFeatureSource(bwgSource) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.readiness = 'Connecting';
    this.bwgSource = this.opts = bwgSource;
    thisB.bwgHolder = new Awaited();

    if (this.opts.preflight) {
        var pfs = bwg_preflights[this.opts.preflight];
        if (!pfs) {
            pfs = new Awaited();
            bwg_preflights[this.opts.preflight] = pfs;

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        pfs.provide('success');
                    } else {
                        pfs.provide('failure');
                    }
                }
            };
            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true); // Instead, ensure we always preflight a unique URI.
            if (this.opts.credentials) {
                req.withCredentials = true;
            }
            req.send();
        }
        pfs.await(function (status) {
            if (status === 'success') {
                thisB.init();
            }
        });
    } else {
        thisB.init();
    }
}

BWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

BWGFeatureSource.prototype.init = function () {
    var thisB = this;
    var arg;

    var uri = this.bwgSource.uri || this.bwgSource.bwgURI;
    if (uri) {
        if (this.bwgSource.transport === 'encode') {
            arg = new EncodeFetchable(uri, { credentials: this.opts.credentials });
        } else {
            arg = new URLFetchable(uri, { credentials: this.opts.credentials, resolver: this.opts.resolver });
        }
    } else {
        arg = new BlobFetchable(this.bwgSource.bwgBlob);
    }

    makeBwg(arg, function (bwg, err) {
        if (err) {
            thisB.error = err;
            thisB.readiness = null;
            thisB.notifyReadiness();
            thisB.bwgHolder.provide(null);
        } else {
            thisB.bwgHolder.provide(bwg);
            thisB.readiness = null;
            thisB.notifyReadiness();
            if (bwg.type == 'bigbed') {
                bwg.getExtraIndices(function (ei) {
                    thisB.extraIndices = ei;
                });
            }
        }
    });
};

BWGFeatureSource.prototype.capabilities = function () {
    var caps = { leap: true };
    if (this.bwgHolder.res && this.bwgHolder.res.type == 'bigwig') caps.quantLeap = true;
    if (this.extraIndices && this.extraIndices.length > 0) {
        caps.search = [];
        for (var eii = 0; eii < this.extraIndices.length; ++eii) {
            caps.search.push(this.extraIndices[eii].field);
        }
    }
    return caps;
};

BWGFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;
    this.bwgHolder.await(function (bwg) {
        if (typeof bwg === 'undefined' || bwg === null) {
            return callback(thisB.error || "Can't access binary file", null, null);
        }

        var data;
        var wantDensity = !types || types.length === 0 || arrayIndexOf(types, 'density') >= 0;
        if (thisB.opts.clientBin) {
            wantDensity = false;
        }
        var scaleFactor = thisB.opts.scaleFactor || 1.0;
        if (bwg.type == 'bigwig' || wantDensity || typeof thisB.opts.forceReduction !== 'undefined') {
            var zoom = -1;
            for (var z = 0; z < bwg.zoomLevels.length; ++z) {
                if (bwg.zoomLevels[z].reduction <= scale * scaleFactor) {
                    zoom = z;
                } else {
                    break;
                }
            }
            if (typeof thisB.opts.forceReduction !== 'undefined') {
                zoom = thisB.opts.forceReduction;
            }

            if (zoom < 0) {
                data = bwg.getUnzoomedView();
            } else {
                data = bwg.getZoomedView(zoom);
            }
        } else {
            data = bwg.getUnzoomedView();
        }

        thisB.busy++;
        thisB.notifyActivity();
        data.readWigData(chr, min, max, function (features) {
            thisB.busy--;
            thisB.notifyActivity();

            var fs = 1000000000;
            if (bwg.type === 'bigwig') {
                var is = (max - min) / features.length / 2;
                if (is < fs) {
                    fs = is;
                }
            }
            if (thisB.opts.link) {
                for (var fi = 0; fi < features.length; ++fi) {
                    var f = features[fi];
                    if (f.label) {
                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\$\$/, f.label))];
                    }
                }
            }
            callback(null, features, fs);
        });
    });
};

BWGFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    // var beforeQFNF = Date.now()|0;
    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();
    this.bwgHolder.res.thresholdSearch(chr, pos, dir, threshold, function (a, b) {
        thisB.busy--;
        thisB.notifyActivity();
        // var afterQFNF = Date.now()|0;
        // console.log('QFNF took ' + (afterQFNF - beforeQFNF) + 'ms');
        return callback(a, b);
    });
};

BWGFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();
    this.bwgHolder.res.getUnzoomedView().getFirstAdjacent(chr, pos, dir, function (res) {
        thisB.busy--;
        thisB.notifyActivity();
        if (res.length > 0 && res[0] !== null) {
            callback(res[0]);
        }
    });
};

BWGFeatureSource.prototype.getScales = function () {
    var bwg = this.bwgHolder.res;
    if (bwg /* && bwg.type == 'bigwig' */) {
            var scales = [1]; // Can we be smarter about inferring baseline scale?
            for (var z = 0; z < bwg.zoomLevels.length; ++z) {
                scales.push(bwg.zoomLevels[z].reduction);
            }
            return scales;
        } else {
        return null;
    }
};

BWGFeatureSource.prototype.search = function (query, callback) {
    if (!this.extraIndices || this.extraIndices.length === 0) {
        return callback(null, 'No indices available');
    }

    var index = this.extraIndices[0];
    return index.lookup(query, callback);
};

BWGFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.opts.noExtraFeatureInfo) return true;

    this.bwgHolder.await(function (bwg) {
        if (!bwg) return;

        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {
            var fip = function fip(feature, featureInfo) {
                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {
                    if (featureInfo.hit[hi].isSuperGroup) return;
                }
                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {
                    var f = bwg.schema.fields[fi];
                    featureInfo.add(f.comment, feature[f.name]);
                }
            };

            callback(fip);
        } else {
            // No need to do anything.
        }
    });
};

BWGFeatureSource.prototype.getStyleSheet = function (callback) {
    var thisB = this;

    this.bwgHolder.await(function (bwg) {
        if (!bwg) {
            return callback(null, 'bbi error');
        }

        var stylesheet = new DASStylesheet();
        if (bwg.type == 'bigbed') {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'blue';
            wigStyle.HEIGHT = 8;
            wigStyle.BUMP = true;
            wigStyle.LABEL = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'bigbed' }, null, wigStyle);
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'red';
            wigStyle.HEIGHT = 10;
            wigStyle.BUMP = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'translation' }, null, wigStyle);

            var tsStyle = new DASStyle();
            tsStyle.glyph = 'BOX';
            tsStyle.FGCOLOR = 'black';
            tsStyle.BGCOLOR = 'white';
            tsStyle.HEIGHT = 10;
            tsStyle.ZINDEX = 10;
            tsStyle.BUMP = true;
            tsStyle.LABEL = true;
            stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

            var densStyle = new DASStyle();
            densStyle.glyph = 'HISTOGRAM';
            densStyle.COLOR1 = 'white';
            densStyle.COLOR2 = 'black';
            densStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'density' }, null, densStyle);
        } else {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'HISTOGRAM';
            wigStyle.COLOR1 = 'white';
            wigStyle.COLOR2 = 'black';
            wigStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
        }

        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {
            stylesheet.geneHint = true;
        }

        return callback(stylesheet);
    });
};

function RemoteBWGFeatureSource(bwgSource, worker, browser) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.worker = worker;
    this.readiness = 'Connecting';
    this.bwgSource = this.opts = bwgSource;
    this.keyHolder = new Awaited();

    if (bwgSource.resolver) {
        this.resolverKey = browser.registerResolver(bwgSource.resolver);
    }

    this.init();
}

RemoteBWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

RemoteBWGFeatureSource.prototype.init = function () {
    var thisB = this;
    var uri = this.uri || this.bwgSource.uri || this.bwgSource.bwgURI;
    var blob = this.bwgSource.blob || this.bwgSource.bwgBlob;

    var cnt = function cnt(key, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (key) {
            thisB.worker.postCommand({ command: 'meta', connection: key }, function (meta, err) {
                if (err) {
                    thisB.error = err;
                    thisB.keyHolder.provide(null);
                } else {
                    thisB.meta = meta;
                    thisB.keyHolder.provide(key);
                }
            });
        } else {
            thisB.error = err;
            thisB.keyHolder.provide(null);
        }
    };

    if (blob) {
        this.worker.postCommand({ command: 'connectBBI', blob: blob }, cnt);
    } else {
        this.worker.postCommand({
            command: 'connectBBI',
            uri: resolveUrlToPage(uri),
            resolver: this.resolverKey,
            transport: this.bwgSource.transport,
            credentials: this.bwgSource.credentials }, cnt);
    }
};

RemoteBWGFeatureSource.prototype.capabilities = function () {
    var caps = { leap: true };

    if (this.meta && this.meta.type == 'bigwig') caps.quantLeap = true;
    if (this.meta && this.meta.extraIndices && this.meta.extraIndices.length > 0) {
        caps.search = [];
        for (var eii = 0; eii < this.meta.extraIndices.length; ++eii) {
            caps.search.push(this.meta.extraIndices[eii].field);
        }
    }
    return caps;
};

RemoteBWGFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.keyHolder.await(function (key) {
        if (!key) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Can't access binary file", null, null);
        }

        var zoom = -1;
        var wantDensity = !types || types.length === 0 || arrayIndexOf(types, 'density') >= 0;
        if (thisB.opts.clientBin) {
            wantDensity = false;
        }
        if (thisB.meta.type == 'bigwig' || wantDensity || typeof thisB.opts.forceReduction !== 'undefined') {
            for (var z = 1; z < thisB.meta.zoomLevels.length; ++z) {
                if (thisB.meta.zoomLevels[z] <= scale) {
                    zoom = z - 1; // Scales returned in metadata start at 1, unlike "real" zoom levels.
                } else {
                    break;
                }
            }
            if (typeof thisB.opts.forceReduction !== 'undefined') {
                zoom = thisB.opts.forceReduction;
            }
        }

        thisB.worker.postCommand({ command: 'fetch', connection: key, chr: chr, min: min, max: max, zoom: zoom }, function (features, error) {
            thisB.busy--;
            thisB.notifyActivity();

            var fs = 1000000000;
            if (thisB.meta.type === 'bigwig') {
                var is = (max - min) / features.length / 2;
                if (is < fs) {
                    fs = is;
                }
            }
            if (thisB.opts.link) {
                for (var fi = 0; fi < features.length; ++fi) {
                    var f = features[fi];
                    if (f.label) {
                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\$\$/, f.label))];
                    }
                }
            }
            callback(error, features, fs);
        });
    });
};

RemoteBWGFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    var thisB = this;
    this.busy++;
    this.notifyActivity();
    this.worker.postCommand({ command: 'quantLeap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir, threshold: threshold, under: false }, function (result, err) {
        console.log(result, err);
        thisB.busy--;
        thisB.notifyActivity();
        return callback(result, err);
    });
};

RemoteBWGFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    var thisB = this;
    this.busy++;
    this.notifyActivity();
    this.worker.postCommand({ command: 'leap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir }, function (result, err) {
        thisB.busy--;
        thisB.notifyActivity();
        if (result.length > 0 && result[0] !== null) {
            callback(result[0]);
        }
    });
};

RemoteBWGFeatureSource.prototype.getScales = function () {
    var meta = this.meta;
    if (meta) {
        return meta.zoomLevels;
    } else {
        return null;
    }
};

RemoteBWGFeatureSource.prototype.search = function (query, callback) {
    if (!this.meta.extraIndices || this.meta.extraIndices.length === 0) {
        return callback(null, 'No indices available');
    }

    var thisB = this;
    this.busy++;
    this.notifyActivity();
    var index = this.meta.extraIndices[0];
    this.worker.postCommand({ command: 'search', connection: this.keyHolder.res, query: query, index: index }, function (result, err) {
        thisB.busy--;
        thisB.notifyActivity();

        callback(result, err);
    });
};

RemoteBWGFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.opts.noExtraFeatureInfo) return true;

    var thisB = this;
    this.keyHolder.await(function (key) {
        var bwg = thisB.meta;
        if (!bwg) return;

        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {
            var fip = function fip(feature, featureInfo) {
                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {
                    if (featureInfo.hit[hi].isSuperGroup) return;
                }
                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {
                    var f = bwg.schema.fields[fi];
                    featureInfo.add(f.comment, feature[f.name]);
                }
            };

            callback(fip);
        } else {
            // No need to do anything.
        }
    });
};

RemoteBWGFeatureSource.prototype.getStyleSheet = function (callback) {
    var thisB = this;

    this.keyHolder.await(function (key) {
        var bwg = thisB.meta;
        if (!bwg) {
            return callback(null, 'bbi error');
        }

        var stylesheet = new DASStylesheet();
        if (bwg.type == 'bigbed') {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'blue';
            wigStyle.HEIGHT = 8;
            wigStyle.BUMP = true;
            wigStyle.LABEL = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'bigbed' }, null, wigStyle);

            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'red';
            wigStyle.HEIGHT = 10;
            wigStyle.BUMP = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'translation' }, null, wigStyle);

            var tsStyle = new DASStyle();
            tsStyle.glyph = 'BOX';
            tsStyle.FGCOLOR = 'black';
            tsStyle.BGCOLOR = 'white';
            tsStyle.HEIGHT = 10;
            tsStyle.ZINDEX = 10;
            tsStyle.BUMP = true;
            tsStyle.LABEL = true;
            stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

            var densStyle = new DASStyle();
            densStyle.glyph = 'HISTOGRAM';
            densStyle.COLOR1 = 'white';
            densStyle.COLOR2 = 'black';
            densStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'density' }, null, densStyle);
        } else {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'HISTOGRAM';
            wigStyle.COLOR1 = 'white';
            wigStyle.COLOR2 = 'black';
            wigStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
        }

        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {
            stylesheet.geneHint = true;
        }

        return callback(stylesheet);
    });
};

function bamRecordToFeature(r, group) {
    if (r.flag & BamFlags.SEGMENT_UNMAPPED) return;

    var len;
    if (r.seq) len = r.seq.length;else len = r.seqLength;

    if (r.cigar) {
        len = 0;
        var ops = parseCigar(r.cigar);
        for (var ci = 0; ci < ops.length; ++ci) {
            var co = ops[ci];
            if (co.op == 'M' || co.op == 'D') len += co.cnt;
        }
    }

    var f = new DASFeature();
    f.min = r.pos + 1;
    f.max = r.pos + len;
    f.segment = r.segment;
    f.type = 'bam';
    f.id = r.readName;
    f.notes = [/* 'Sequence=' + r.seq, 'CIGAR=' + r.cigar, */'MQ=' + r.mq];
    f.cigar = r.cigar;
    f.seq = r.seq;
    f.quals = r.quals;
    f.orientation = r.flag & BamFlags.REVERSE_COMPLEMENT ? '-' : '+';
    f.bamRecord = r;

    if (group && r.flag & BamFlags.MULTIPLE_SEGMENTS) {
        f.groups = [{ id: r.readName,
            type: 'readpair' }];
    }

    return f;
}

function BAMFeatureSource(bamSource) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.bamSource = bamSource;
    this.opts = { credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup };
    this.bamHolder = new Awaited();

    if (this.opts.preflight) {
        var pfs = bwg_preflights[this.opts.preflight];
        if (!pfs) {
            pfs = new Awaited();
            bwg_preflights[this.opts.preflight] = pfs;

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        pfs.provide('success');
                    } else {
                        pfs.provide('failure');
                    }
                }
            };
            // req.setRequestHeader('cache-control', 'no-cache');    /* Doesn't work, not an allowed request header in CORS */
            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true); // Instead, ensure we always preflight a unique URI.
            if (this.opts.credentials) {
                req.withCredentials = 'true';
            }
            req.send();
        }
        pfs.await(function (status) {
            if (status === 'success') {
                thisB.init();
            }
        });
    } else {
        thisB.init();
    }
}

BAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

BAMFeatureSource.prototype.init = function () {
    var thisB = this;
    var bamF, baiF;
    if (this.bamSource.bamBlob) {
        bamF = new BlobFetchable(this.bamSource.bamBlob);
        baiF = new BlobFetchable(this.bamSource.baiBlob);
    } else {
        bamF = new URLFetchable(this.bamSource.bamURI, { credentials: this.opts.credentials, resolver: this.opts.resolver });
        baiF = new URLFetchable(this.bamSource.baiURI || this.bamSource.bamURI + '.bai', { credentials: this.opts.credentials, resolver: this.opts.resolver });
    }
    makeBam(bamF, baiF, null, function (bam, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (bam) {
            thisB.bamHolder.provide(bam);
        } else {
            thisB.error = err;
            thisB.bamHolder.provide(null);
        }
    });
};

BAMFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var light = types && types.length == 1 && types[0] == 'density';

    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.bamHolder.await(function (bam) {
        if (!bam) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Couldn't fetch BAM");
        }

        bam.fetch(chr, min, max, function (bamRecords, error) {
            thisB.busy--;
            thisB.notifyActivity();

            if (error) {
                callback(error, null, null);
            } else {
                var features = [];
                for (var ri = 0; ri < bamRecords.length; ++ri) {
                    var r = bamRecords[ri];

                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);
                    if (f) features.push(f);
                }
                callback(null, features, 1000000000);
            }
        }, { light: light });
    });
};

BAMFeatureSource.prototype.getScales = function () {
    return 1000000000;
};

BAMFeatureSource.prototype.getStyleSheet = function (callback) {
    this.bamHolder.await(function (bam) {
        var stylesheet = new DASStylesheet();
        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'black';
        densStyle.COLOR2 = 'red';
        densStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'density' }, 'low', densStyle);
        stylesheet.pushStyle({ type: 'density' }, 'medium', densStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = '__SEQUENCE';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = false;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'bam' }, 'high', wigStyle);

        return callback(stylesheet);
    });
};

function RemoteBAMFeatureSource(bamSource, worker) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.bamSource = bamSource;
    this.worker = worker;
    this.opts = { credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup };
    this.keyHolder = new Awaited();

    if (bamSource.resolver) {
        this.resolverKey = browser.registerResolver(bamSource.resolver);
    }

    this.init();
}

RemoteBAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

RemoteBAMFeatureSource.prototype.init = function () {
    var thisB = this;
    var uri = this.bamSource.uri || this.bamSource.bamURI;
    var indexUri = this.bamSource.indexUri || this.bamSource.baiURI || uri + '.bai';

    var blob = this.bamSource.bamBlob || this.bamSource.blob;
    var indexBlob = this.bamSource.baiBlob || this.bamSource.indexBlob;

    var cnt = function cnt(result, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (result) {
            thisB.keyHolder.provide(result);
        } else {
            thisB.error = err;
            thisB.keyHolder.provide(null);
        }
    };

    if (blob) {
        this.worker.postCommand({ command: 'connectBAM', blob: blob, indexBlob: indexBlob }, cnt);
    } else {
        this.worker.postCommand({
            command: 'connectBAM',
            uri: resolveUrlToPage(uri),
            resolver: this.resolverKey,
            indexUri: resolveUrlToPage(indexUri),
            credentials: this.bamSource.credentials,
            indexChunks: this.bamSource.indexChunks }, cnt);
    }
};

RemoteBAMFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var light = types && types.length == 1 && types[0] == 'density';
    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.keyHolder.await(function (key) {
        if (!key) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Couldn't fetch BAM");
        }

        thisB.worker.postCommand({ command: 'fetch', connection: key, chr: chr, min: min, max: max, opts: { light: light } }, function (bamRecords, error) {
            // console.log('retrieved ' + bamRecords.length + ' via worker.');

            thisB.busy--;
            thisB.notifyActivity();

            if (error) {
                callback(error, null, null);
            } else {
                var features = [];
                for (var ri = 0; ri < bamRecords.length; ++ri) {
                    var r = bamRecords[ri];
                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);
                    if (f) features.push(f);
                }
                callback(null, features, 1000000000);
            }
        });
    });
};

RemoteBAMFeatureSource.prototype.getScales = function () {
    return 1000000000;
};

RemoteBAMFeatureSource.prototype.getStyleSheet = function (callback) {
    this.keyHolder.await(function (bam) {
        var stylesheet = new DASStylesheet();

        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'black';
        densStyle.COLOR2 = 'red';
        densStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'density' }, 'low', densStyle);
        stylesheet.pushStyle({ type: 'density' }, 'medium', densStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = '__SEQUENCE';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = false;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'bam' }, 'high', wigStyle);
        return callback(stylesheet);
    });
};

function MappedFeatureSource(source, mapping) {
    this.source = source;
    this.mapping = mapping;

    this.activityListeners = [];
    this.busy = 0;
}

MappedFeatureSource.prototype.addActivityListener = function (listener) {
    this.activityListeners.push(listener);
};

MappedFeatureSource.prototype.removeActivityListener = function (listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0) this.activityListeners.splice(idx, 0);
};

MappedFeatureSource.prototype.notifyActivity = function () {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

MappedFeatureSource.prototype.getStyleSheet = function (callback) {
    return this.source.getStyleSheet(callback);
};

MappedFeatureSource.prototype.getScales = function () {
    return this.source.getScales();
};

MappedFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.source.getDefaultFIPs) return this.source.getDefaultFIPs(callback);
};

MappedFeatureSource.prototype.simplifySegments = function (segs, minGap) {
    if (segs.length === 0) return segs;

    segs.sort(function (s1, s2) {
        var d = s1.name - s2.name;
        if (d) return d;
        d = s1.start - s2.start;
        if (d) return d;
        return s1.end - s2.end; // Should never come to this...?
    });

    var ssegs = [];
    var currentSeg = segs[0];
    for (var si = 0; si < segs.length; ++si) {
        var ns = segs[si];

        // console.log(ns.name + ' ' + ns.start + ' ' + ns.end);
        if (ns.name != currentSeg.name || ns.start > currentSeg.end + minGap) {
            ssegs.push(currentSeg);
            currentSeg = ns;
        } else {
            currentSeg = new DASSegment(currentSeg.name, Math.min(currentSeg.start, ns.start), Math.max(currentSeg.end, ns.end));
        }
    }
    ssegs.push(currentSeg);
    return ssegs;
};

MappedFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback, styleFilters) {
    var thisB = this;
    var fetchLength = max - min + 1;

    thisB.busy++;
    thisB.notifyActivity();

    this.mapping.sourceBlocksForRange(chr, min, max, function (mseg) {
        if (mseg.length === 0) {
            thisB.busy--;
            thisB.notifyActivity();

            callback("No mapping available for this regions", [], scale);
        } else {
            mseg = thisB.simplifySegments(mseg, Math.max(100, 0.05 * fetchLength));

            var mappedFeatures = [];
            var mappedLoc = null;
            var count = mseg.length;
            var finalStatus;

            mseg.map(function (seg) {
                thisB.source.fetch(seg.name, seg.start, seg.end, scale, types, pool, function (status, features, fscale) {
                    if (status && !finalStatus) finalStatus = status;

                    if (features) {
                        for (var fi = 0; fi < features.length; ++fi) {
                            var f = features[fi];
                            var sn = f.segment;
                            if (sn.indexOf('chr') === 0) {
                                sn = sn.substr(3);
                            }

                            var mappings = thisB.mapping.mapSegment(sn, f.min, f.max);

                            if (mappings.length === 0) {
                                if (f.parts && f.parts.length > 0) {
                                    mappedFeatures.push(f);
                                }
                            } else {
                                for (var mi = 0; mi < mappings.length; ++mi) {
                                    var m = mappings[mi];
                                    var mf = shallowCopy(f);
                                    mf.segment = m.segment;
                                    mf.min = m.min;
                                    mf.max = m.max;
                                    if (m.partialMin) mf.partialMin = m.partialMin;
                                    if (m.partialMax) mf.partialMax = m.partialMax;

                                    if (m.flipped) {
                                        if (f.orientation == '-') {
                                            mf.orientation = '+';
                                        } else if (f.orientation == '+') {
                                            mf.orientation = '-';
                                        }
                                    }
                                    mappedFeatures.push(mf);
                                }
                            }
                        }
                    }

                    var m1 = thisB.mapping.mapPoint(seg.name, seg.start);
                    var m2 = thisB.mapping.mapPoint(seg.name, seg.end);

                    if (m1 && m2) {
                        var segDestCoverage = new Range(m1.pos, m2.pos);
                        if (mappedLoc) mappedLoc = union(mappedLoc, segDestCoverage);else mappedLoc = segDestCoverage;
                    }

                    --count;
                    if (count === 0) {
                        thisB.busy--;
                        thisB.notifyActivity();
                        callback(finalStatus, mappedFeatures, fscale, mappedLoc);
                    }
                }, styleFilters);
            });
        }
    });
};

function DummyFeatureSource() {}

DummyFeatureSource.prototype.getScales = function () {
    return null;
};

DummyFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, cnt) {
    return cnt(null, [], 1000000000);
};

DummyFeatureSource.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();
    var defStyle = new DASStyle();
    defStyle.glyph = 'BOX';
    defStyle.BGCOLOR = 'blue';
    defStyle.FGCOLOR = 'black';
    stylesheet.pushStyle({ type: 'default' }, null, defStyle);
    return callback(stylesheet);
};

function DummySequenceSource() {}

DummySequenceSource.prototype.fetch = function (chr, min, max, pool, cnt) {
    return cnt(null, null);
};

function JBrowseFeatureSource(source) {
    this.store = new JBrowseStore(source.jbURI, source.jbQuery);
}

JBrowseFeatureSource.prototype.getScales = function () {
    return null;
};

JBrowseFeatureSource.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();

    var cdsStyle = new DASStyle();
    cdsStyle.glyph = 'BOX';
    cdsStyle.FGCOLOR = 'black';
    cdsStyle.BGCOLOR = 'red';
    cdsStyle.HEIGHT = 10;
    cdsStyle.BUMP = true;
    cdsStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'translation' }, null, cdsStyle);

    var tsStyle = new DASStyle();
    tsStyle.glyph = 'BOX';
    tsStyle.FGCOLOR = 'black';
    tsStyle.BGCOLOR = 'white';
    tsStyle.HEIGHT = 10;
    tsStyle.ZINDEX = 10;
    tsStyle.BUMP = true;
    tsStyle.LABEL = true;
    stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = 'green';
    wigStyle.HEIGHT = 8;
    wigStyle.BUMP = true;
    wigStyle.LABEL = true;
    wigStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'default' }, null, wigStyle);

    return callback(stylesheet);
};

JBrowseFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    if (types && types.length === 0) {
        callback(null, [], scale);
        return;
    }

    var fops = {};

    this.store.features(new DASSegment(chr, min, max), fops, function (features, status) {
        callback(status, features, 100000);
    });
};

Browser.prototype.sourceAdapterIsCapable = function (s, cap) {
    if (!s.capabilities) return false;else return s.capabilities()[cap];
};

if (typeof module !== 'undefined') {
    module.exports = {
        FeatureSourceBase: FeatureSourceBase,

        TwoBitSequenceSource: TwoBitSequenceSource,
        EnsemblSequenceSource: EnsemblSequenceSource,
        DASSequenceSource: DASSequenceSource,
        MappedFeatureSource: MappedFeatureSource,
        CachingFeatureSource: CachingFeatureSource,
        BWGFeatureSource: BWGFeatureSource,
        RemoteBWGFeatureSource: RemoteBWGFeatureSource,
        BAMFeatureSource: BAMFeatureSource,
        RemoteBAMFeatureSource: RemoteBAMFeatureSource,
        DummyFeatureSource: DummyFeatureSource,
        DummySequenceSource: DummySequenceSource,
        DASFeatureSource: DASFeatureSource,

        registerSourceAdapterFactory: dalliance_registerSourceAdapterFactory,
        registerParserFactory: dalliance_registerParserFactory,
        makeParser: dalliance_makeParser
    };

    // Standard set of plugins.
    require('./ensembljson');
    require('./tabix-source');
    require('./memstore');
    require('./bedwig');
    require('./vcf');
    require('./rqtl-genotype-source.es6');
    require('./qtl-source.es6');
    require('./test-source.es6');
}

},{"./bam":1,"./bedwig":2,"./bigwig":3,"./bin":4,"./cbrowser":6,"./chainset":7,"./cigar":8,"./das":11,"./encode":15,"./ensembljson":16,"./jbjson":25,"./memstore":28,"./overlay":31,"./qtl-source.es6":33,"./rqtl-genotype-source.es6":34,"./spans":43,"./style":44,"./tabix-source":48,"./test-source.es6":50,"./tier":54,"./twoBit":57,"./utils":58,"./vcf":59}],42:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2015
//
// sourcecompare.js
//


function sourceDataURI(conf) {
    if (conf.uri) {
        return conf.uri;
    } else if (conf.blob) {
        return 'file:' + conf.blob.name;
    } else if (conf.bwgBlob) {
        return 'file:' + conf.bwgBlob.name;
    } else if (conf.bamBlob) {
        return 'file:' + conf.bamBlob.name;
    } else if (conf.twoBitBlob) {
        return 'file:' + conf.twoBitBlob.name;
    }

    return conf.bwgURI || conf.bamURI || conf.jbURI || conf.twoBitURI || 'https://www.biodalliance.org/magic/no_uri';
}

function sourceStyleURI(conf) {
    if (conf.stylesheet_uri) return conf.stylesheet_uri;else if (conf.tier_type == 'sequence' || conf.twoBitURI || conf.twoBitBlob) return 'https://www.biodalliance.org/magic/sequence';else return sourceDataURI(conf);
}

function sourcesAreEqualModuloStyle(a, b) {
    if (sourceDataURI(a) != sourceDataURI(b)) return false;

    if (a.mapping != b.mapping) return false;

    if (a.tier_type != b.tier_type) return false;

    if (a.overlay) {
        if (!b.overlay || b.overlay.length != a.overlay.length) return false;
        for (var oi = 0; oi < a.overlay.length; ++oi) {
            if (!sourcesAreEqualModuloStyle(a.overlay[oi], b.overlay[oi])) return false;
        }
    } else {
        if (b.overlay) return false;
    }

    return true;
}

function sourcesAreEqual(a, b) {
    if (sourceDataURI(a) != sourceDataURI(b) || sourceStyleURI(a) != sourceStyleURI(b)) return false;

    if (a.mapping != b.mapping) return false;

    if (a.tier_type != b.tier_type) return false;

    if (a.overlay) {
        if (!b.overlay || b.overlay.length != a.overlay.length) return false;
        for (var oi = 0; oi < a.overlay.length; ++oi) {
            if (!sourcesAreEqual(a.overlay[oi], b.overlay[oi])) return false;
        }
    } else {
        if (b.overlay) return false;
    }

    return true;
}

if (typeof module !== 'undefined') {
    module.exports = {
        sourcesAreEqual: sourcesAreEqual,
        sourcesAreEqualModuloStyle: sourcesAreEqualModuloStyle,
        sourceDataURI: sourceDataURI,
        sourceStyleURI: sourceStyleURI
    };
}

},{}],43:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// spans.js: JavaScript Intset/Location port.
//

"use strict";

function Range(min, max) {
    if (typeof min != 'number' || typeof max != 'number') throw 'Bad range ' + min + ',' + max;
    this._min = min;
    this._max = max;
}

Range.prototype.min = function () {
    return this._min;
};

Range.prototype.max = function () {
    return this._max;
};

Range.prototype.contains = function (pos) {
    return pos >= this._min && pos <= this._max;
};

Range.prototype.isContiguous = function () {
    return true;
};

Range.prototype.ranges = function () {
    return [this];
};

Range.prototype._pushRanges = function (ranges) {
    ranges.push(this);
};

Range.prototype.toString = function () {
    return '[' + this._min + '-' + this._max + ']';
};

function _Compound(ranges) {
    // given: a set of unsorted possibly overlapping ranges
    // sort the input ranges
    var sorted = ranges.sort(_rangeOrder);
    // merge overlaps between adjacent ranges
    var merged = [];
    var current = sorted.shift();
    sorted.forEach(function (range) {
        if (range._min <= current._max) {
            if (range._max > current._max) {
                current._max = range._max;
            }
        } else {
            merged.push(current);
            current = range;
        }
    });
    merged.push(current);
    this._ranges = merged;
}

_Compound.prototype.min = function () {
    return this._ranges[0].min();
};

_Compound.prototype.max = function () {
    return this._ranges[this._ranges.length - 1].max();
};

// returns the index of the first range that is not less than pos
_Compound.prototype.lower_bound = function (pos) {
    // first check if pos is out of range
    var r = this.ranges();
    if (pos > this.max()) return r.length;
    if (pos < this.min()) return 0;
    // do a binary search
    var a = 0,
        b = r.length - 1;
    while (a <= b) {
        var m = Math.floor((a + b) / 2);
        if (pos > r[m]._max) {
            a = m + 1;
        } else if (pos < r[m]._min) {
            b = m - 1;
        } else {
            return m;
        }
    }
    return a;
};

_Compound.prototype.contains = function (pos) {
    var lb = this.lower_bound(pos);
    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {
        return true;
    }
    return false;
};

_Compound.prototype.insertRange = function (range) {
    var lb = this.lower_bound(range._min);
    if (lb === this._ranges.length) {
        // range follows this
        this._ranges.push(range);
        return;
    }

    var r = this.ranges();
    if (range._max < r[lb]._min) {
        // range preceeds lb
        this._ranges.splice(lb, 0, range);
        return;
    }

    // range overlaps lb (at least)
    if (r[lb]._min < range._min) range._min = r[lb]._min;
    var ub = lb + 1;
    while (ub < r.length && r[ub]._min <= range._max) {
        ub++;
    }
    ub--;
    // ub is the upper bound of the new range
    if (r[ub]._max > range._max) range._max = r[ub]._max;

    // splice range into this._ranges
    this._ranges.splice(lb, ub - lb + 1, range);
    return;
};

_Compound.prototype.isContiguous = function () {
    return this._ranges.length > 1;
};

_Compound.prototype.ranges = function () {
    return this._ranges;
};

_Compound.prototype._pushRanges = function (ranges) {
    for (var ri = 0; ri < this._ranges.length; ++ri) {
        ranges.push(this._ranges[ri]);
    }
};

_Compound.prototype.toString = function () {
    var s = '';
    for (var r = 0; r < this._ranges.length; ++r) {
        if (r > 0) {
            s = s + ',';
        }
        s = s + this._ranges[r].toString();
    }
    return s;
};

function union(s0, s1) {
    if (!(s0 instanceof _Compound)) {
        if (!(s0 instanceof Array)) s0 = [s0];
        s0 = new _Compound(s0);
    }

    if (s1) s0.insertRange(s1);

    return s0;
}

function intersection(s0, s1) {
    var r0 = s0.ranges();
    var r1 = s1.ranges();
    var l0 = r0.length,
        l1 = r1.length;
    var i0 = 0,
        i1 = 0;
    var or = [];

    while (i0 < l0 && i1 < l1) {
        var s0 = r0[i0],
            s1 = r1[i1];
        var lapMin = Math.max(s0.min(), s1.min());
        var lapMax = Math.min(s0.max(), s1.max());
        if (lapMax >= lapMin) {
            or.push(new Range(lapMin, lapMax));
        }
        if (s0.max() > s1.max()) {
            ++i1;
        } else {
            ++i0;
        }
    }

    if (or.length == 0) {
        return null; // FIXME
    } else if (or.length == 1) {
        return or[0];
    } else {
        return new _Compound(or);
    }
}

function coverage(s) {
    var tot = 0;
    var rl = s.ranges();
    for (var ri = 0; ri < rl.length; ++ri) {
        var r = rl[ri];
        tot += r.max() - r.min() + 1;
    }
    return tot;
}

function rangeOrder(a, b) {
    if (a.min() < b.min()) {
        return -1;
    } else if (a.min() > b.min()) {
        return 1;
    } else if (a.max() < b.max()) {
        return -1;
    } else if (b.max() > a.max()) {
        return 1;
    } else {
        return 0;
    }
}

function _rangeOrder(a, b) {
    if (a._min < b._min) {
        return -1;
    } else if (a._min > b._min) {
        return 1;
    } else if (a._max < b._max) {
        return -1;
    } else if (b._max > a._max) {
        return 1;
    } else {
        return 0;
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        Range: Range,
        union: union,
        intersection: intersection,
        coverage: coverage,
        rangeOver: rangeOrder,
        _rangeOrder: _rangeOrder
    };
}

},{}],44:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2014
//
// style.js
//

"use strict";

function StyleFilter(type, method, label) {
    this.type = type;
    this.method = method;
    this.label = label;
}

StyleFilter.prototype.equals = function (o) {
    return this.type == o.type && this.method == o.method && this.label == o.label;
};

StyleFilter.prototype.toString = function () {
    var fs = [];
    if (this.type) fs.push('type=' + this.type);
    if (this.method) fs.push('method=' + this.method);
    if (this.label) fs.push('label=' + this.label);
    return 'StyleFilter<' + fs.join(';') + '>';
};

function StyleFilterSet(filters) {
    this._filters = {};
    if (filters) {
        for (var fi = 0; fi < filters.length; ++fi) {
            this.add(filters[fi]);
        }
    }
}

StyleFilterSet.prototype.add = function (filter) {
    var fs = filter.toString();
    if (!this._filters[fs]) {
        this._filters[fs] = filter;
        this._list = null;
    }
};

StyleFilterSet.prototype.addAll = function (filterSet) {
    var l = filterSet.list();
    for (var fi = 0; fi < l.length; ++fi) {
        this.add(l[fi]);
    }
};

StyleFilterSet.prototype.doesNotContain = function (filterSet) {
    var l = filterSet.list();
    for (var fi = 0; fi < l.length; ++fi) {
        if (!this._filters[fi.toString()]) return true;
    }
    return false;
};

StyleFilterSet.prototype.list = function () {
    if (!this._list) {
        this._list = [];
        for (var k in this._filters) {
            if (this._filters.hasOwnProperty(k)) {
                this._list.push(this._filters[k]);
            }
        }
    }
    return this._list;
};

StyleFilterSet.prototype.typeList = function () {
    var types = [];
    var list = this.list();
    for (var fi = 0; fi < list.length; ++fi) {
        var filter = list[fi];
        var type = filter.type;
        if (!type || type == 'default') return null;
        if (types.indexOf(type) < 0) types.push(type);
    }
    return types;
};

if (typeof module !== 'undefined') {
    module.exports = {
        StyleFilter: StyleFilter,
        StyleFilterSet: StyleFilterSet
    };
}

},{}],45:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.renderTier = renderTier;
exports.drawTier = drawTier;

/* To be used by tiers which are to be drawn in a multitier
   using the multi-renderer.

   Subtiers are configured by adding the following to a tier's source configuration:
       renderer: 'sub',
       sub: {
           multi_id: "multi_1",
           offset: 130,
           z: 2,
       }
   This would define a subtier that's to be rendered in the multi-tier with
   id "multi_1", with the top of the subtier at 130 pixels and at z-index 2.
 */

function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

// drawTier is called when this tier's data has been fetched,
// so by refreshing the multiTier from here, we can be sure that
// there's something new worth drawing in it
function drawTier(tier) {
    var browser = tier.browser;

    var multiTier = browser.tiers.filter(function (t) {
        return t.dasSource.renderer === 'multi' && t.dasSource.multi.multi_id === tier.dasSource.sub.multi_id;
    });

    multiTier.forEach(function (t) {
        return browser.refreshTier(t);
    });
}

},{}],46:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// svg-export.js
//

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var makeElementNS = utils.makeElementNS;

    var VERSION = require('./version');

    var svgSeqTier = require('./sequence-draw').svgSeqTier;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
    var formatLongInt = nf.formatLongInt;
}

Browser.prototype.makeSVG = function (opts) {
    opts = opts || {};
    var minTierHeight = opts.minTierHeight || 20;
    var padding = 3;
    var fpw = opts.width || this.featurePanelWidth;

    var backupFPW = this.featurePanelWidth;
    var backupScale = this.scale;
    this.featurePanelWidth = fpw;
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);

    var b = this;
    var saveDoc = document.implementation.createDocument(NS_SVG, 'svg', null);

    var saveRoot = makeElementNS(NS_SVG, 'g', null, {
        fontFamily: 'helvetica',
        fontSize: '8pt'
    });
    saveDoc.documentElement.appendChild(saveRoot);

    var margin = 200;

    if (opts.banner) {
        var dallianceAnchor = makeElementNS(NS_SVG, 'a', makeElementNS(NS_SVG, 'text', 'Graphics from Biodalliance ' + VERSION, {
            x: b.featurePanelWidth + margin - 100,
            y: 35,
            strokeWidth: 0,
            fontSize: '12pt',
            textAnchor: 'end',
            fill: 'blue'
        }));
        dallianceAnchor.setAttribute('xmlns:xlink', NS_XLINK);
        dallianceAnchor.setAttribute('xlink:href', 'http://www.biodalliance.org/');

        saveRoot.appendChild(dallianceAnchor);
    }

    if (opts.region) {
        saveRoot.appendChild(makeElementNS(NS_SVG, 'text', this.chr + ':' + formatLongInt(this.viewStart) + '..' + formatLongInt(this.viewEnd), {
            x: margin + 100,
            y: 35,
            strokeWidth: 0,
            fontSize: '12pt',
            textAnchor: 'start'
        }));
    }

    var clipRect = makeElementNS(NS_SVG, 'rect', null, {
        x: margin,
        y: 50,
        width: b.featurePanelWidth,
        height: 100000
    });
    var clip = makeElementNS(NS_SVG, 'clipPath', clipRect, { id: 'featureClip' });
    saveRoot.appendChild(clip);

    var pos = 70;
    var tierHolder = makeElementNS(NS_SVG, 'g', null, {});

    for (var ti = 0; ti < b.tiers.length; ++ti) {
        var tier = b.tiers[ti];
        tier.backupSubtiers = tier.subtiers;
        tier.backupOriginHaxx = tier.originHaxx;
        tier.backupLayoutHeight = tier.layoutHeight;

        var renderer = b.getTierRenderer(tier);
        if (renderer && renderer.prepareSubtiers) {
            renderer.prepareSubtiers(tier, tier.viewport.getContext('2d'));
        }

        var tierSVG = makeElementNS(NS_SVG, 'g', null, { clipPath: 'url(#featureClip)', clipRule: 'nonzero' });
        var tierLabels = makeElementNS(NS_SVG, 'g');
        var tierTopPos = pos;

        var tierBackground = makeElementNS(NS_SVG, 'rect', null, { x: 0, y: tierTopPos, width: '10000', height: 50, fill: tier.background });
        tierSVG.appendChild(tierBackground);

        if (tier.sequenceSource) {
            var seqTrack = svgSeqTier(tier, tier.currentSequence);

            tierSVG.appendChild(makeElementNS(NS_SVG, 'g', seqTrack, { transform: 'translate(' + margin + ', ' + pos + ')' }));
            pos += 80;
        } else {
            if (!tier.subtiers) {
                continue;
            }

            var offset = (tier.glyphCacheOrigin - b.viewStart) * b.scale;
            var hasQuant = false;
            for (var sti = 0; sti < tier.subtiers.length; ++sti) {
                pos += padding;
                var subtier = tier.subtiers[sti];

                var glyphElements = [];
                for (var gi = 0; gi < subtier.glyphs.length; ++gi) {
                    var glyph = subtier.glyphs[gi];
                    glyphElements.push(glyph.toSVG());
                }

                tierSVG.appendChild(makeElementNS(NS_SVG, 'g', glyphElements, { transform: 'translate(' + (margin + offset) + ', ' + pos + ')' }));

                if (subtier.quant) {
                    hasQuant = true;
                    var q = subtier.quant;
                    var h = subtier.height;

                    var numTics = 2;
                    if (h > 40) {
                        numTics = 1 + (h / 20 | 0);
                    }
                    var ticSpacing = h / (numTics - 1);
                    var ticInterval = (q.max - q.min) / (numTics - 1);

                    var path = new SVGPath();
                    path.moveTo(margin + 5, pos);
                    path.lineTo(margin, pos);
                    path.lineTo(margin, pos + subtier.height);
                    path.lineTo(margin + 5, pos + subtier.height);
                    for (var t = 1; t < numTics - 1; ++t) {
                        var ty = t * ticSpacing;
                        path.moveTo(margin, pos + ty);
                        path.lineTo(margin + 3, pos + ty);
                    }

                    tierLabels.appendChild(makeElementNS(NS_SVG, 'path', null, { d: path.toPathData(), fill: 'none', stroke: 'black', strokeWidth: '2px' }));
                    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.max), { x: margin - 3, y: pos + 7, textAnchor: 'end' }));
                    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.min), { x: margin - 3, y: pos + subtier.height, textAnchor: 'end' }));
                    for (var t = 1; t < numTics - 1; ++t) {
                        var ty = t * ticSpacing;
                        tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(1.0 * q.max - t * ticInterval), { x: margin - 3, y: pos + ty + 3, textAnchor: 'end' }));
                    }
                }

                pos += subtier.height + padding;
            }

            if (pos - tierTopPos < minTierHeight) {
                pos = tierTopPos + minTierHeight;
            }
        }

        var labelName;
        if (typeof tier.config.name === 'string') labelName = tier.config.name;else labelName = tier.dasSource.name;
        tierLabels.appendChild(makeElementNS(NS_SVG, 'text', labelName, { x: margin - (hasQuant ? 20 : 12), y: (pos + tierTopPos + 8) / 2, fontSize: '10pt', textAnchor: 'end' }));

        tierBackground.setAttribute('height', pos - tierTopPos);
        tierHolder.appendChild(makeElementNS(NS_SVG, 'g', [tierSVG, tierLabels]));

        tier.subtiers = tier.backupSubtiers;
        tier.originHaxx = tier.backupOriginHaxx;
        tier.layoutHeight = tier.backupLayoutHeight;
    }

    if (opts.highlights) {
        var highlights = this.highlights || [];
        for (var hi = 0; hi < highlights.length; ++hi) {
            var h = highlights[hi];
            if ((h.chr == this.chr || h.chr == 'chr' + this.chr) && h.min < this.viewEnd && h.max > this.viewStart) {
                var tmin = (Math.max(h.min, this.viewStart) - this.viewStart) * this.scale;
                var tmax = (Math.min(h.max, this.viewEnd) - this.viewStart) * this.scale;

                tierHolder.appendChild(makeElementNS(NS_SVG, 'rect', null, { x: margin + tmin, y: 70, width: tmax - tmin, height: pos - 70,
                    stroke: 'none', fill: this.defaultHighlightFill, fillOpacity: this.defaultHighlightAlpha }));
            }
        }
    }

    var rulerPos = -1;
    if (opts.ruler == 'center') {
        rulerPos = margin + (this.viewEnd - this.viewStart) * this.scale / 2;
    } else if (opts.ruler == 'left') {
        rulerPos = margin;
    } else if (opts.ruler == 'right') {
        rulerPos = margin + (this.viewEnd - this.viewStart) * this.scale;
    }
    if (rulerPos >= 0) {
        tierHolder.appendChild(makeElementNS(NS_SVG, 'line', null, { x1: rulerPos, y1: 70, x2: rulerPos, y2: pos,
            stroke: 'blue' }));
    }

    saveRoot.appendChild(tierHolder);
    saveDoc.documentElement.setAttribute('width', b.featurePanelWidth + 20 + margin);
    saveDoc.documentElement.setAttribute('height', pos + 50);

    this.featurePanelWidth = backupFPW;
    this.scale = backupScale;

    var svg = void 0;
    if (typeof XMLSerializer !== 'undefined') {
        svg = new XMLSerializer().serializeToString(saveDoc);
    } else {
        var root = saveDoc.documentElement;
        root.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        svg = root.outerHTML;
    }

    if (opts.output && opts.output === 'string') {
        return svg;
    } else {
        return new Blob([svg], { type: 'image/svg+xml' });
    }
};

},{"./cbrowser":6,"./numformats":30,"./sequence-draw":38,"./svg-utils":47,"./utils":58,"./version":60}],47:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// svg-utils.js
//

var NS_SVG = 'http://www.w3.org/2000/svg';
var NS_XLINK = 'http://www.w3.org/1999/xlink';

function SVGPath() {
    this.ops = [];
}

SVGPath.prototype.moveTo = function (x, y) {
    this.ops.push('M ' + x + ' ' + y);
};

SVGPath.prototype.lineTo = function (x, y) {
    this.ops.push('L ' + x + ' ' + y);
};

SVGPath.prototype.closePath = function () {
    this.ops.push('Z');
};

SVGPath.prototype.toPathData = function () {
    return this.ops.join(' ');
};

if (typeof module !== 'undefined') {
    module.exports = {
        NS_SVG: NS_SVG,
        NS_XLINK: NS_XLINK,
        SVGPath: SVGPath
    };
}

},{}],48:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tabix-source.js
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var dalliance_makeParser = sa.makeParser;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;

    var utils = require('./utils');
    var Awaited = utils.Awaited;

    var connectTabix = require('./tabix').connectTabix;
}

function TabixFeatureSource(source) {
    FeatureSourceBase.call(this);
    this.readiness = 'Connecting';
    this.source = source;

    this.tabixHolder = new Awaited();
    var thisB = this;

    var parser = dalliance_makeParser(source.payload);
    if (!parser) {
        throw 'Unsuported tabix payload ' + source.payload;
    } else {
        this.parser = parser;
    }

    var data, index;
    if (this.source.blob) {
        data = new BlobFetchable(this.source.blob);
        index = new BlobFetchable(this.source.indexBlob);
    } else {
        data = new URLFetchable(this.source.uri, { credentials: this.source.credentials, resolver: this.source.resolver });
        index = new URLFetchable(this.source.indexURI || this.source.uri + '.tbi', { credentials: this.source.credentials, resolver: this.source.resolver });
    }
    connectTabix(data, index, function (tabix, err) {
        thisB.tabixHolder.provide(tabix);
        tabix.fetchHeader(function (lines, err) {
            if (lines) {
                var session = parser.createSession(function () {/* Null sink because we shouldn't get records */});
                for (var li = 0; li < lines.length; ++li) {
                    session.parse(lines[li]);
                }
                session.flush();
            }
        });
        thisB.readiness = null;
        thisB.notifyReadiness();
    });
}

TabixFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

TabixFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.tabixHolder.await(function (tabix) {
        tabix.fetch(chr, min, max, function (records, error) {
            thisB.busy--;
            thisB.notifyActivity();

            var features = [];
            var session = thisB.parser.createSession(function (f) {
                features.push(f);
            });
            for (var ri = 0; ri < records.length; ++ri) {
                var f = session.parse(records[ri]);
            }
            session.flush();
            callback(null, features, 1000000000);
        });
    });
};

TabixFeatureSource.prototype.getStyleSheet = function (callback) {
    if (this.parser && this.parser.getStyleSheet) this.parser.getStyleSheet(callback);
};

TabixFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.parser && this.parser.getDefaultFIPs) this.parser.getDefaultFIPs(callback);
};

dalliance_registerSourceAdapterFactory('tabix', function (source) {
    return { features: new TabixFeatureSource(source) };
});

},{"./bin":4,"./sourceadapters":41,"./tabix":49,"./utils":58}],49:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// tabix.js: basic support for tabix-indexed flatfiles
//

"use strict";

var TABIX_MAGIC = 0x01494254;

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var bin = require('./bin');
    var readInt = bin.readInt;
    var readShort = bin.readShort;
    var readByte = bin.readByte;
    var readInt64 = bin.readInt64;
    var readFloat = bin.readFloat;

    var lh3utils = require('./lh3utils');
    var readVob = lh3utils.readVob;
    var unbgzf = lh3utils.unbgzf;
    var reg2bins = lh3utils.reg2bins;
    var Chunk = lh3utils.Chunk;
}

function TabixFile() {}

function connectTabix(data, tbi, callback) {
    var tabix = new TabixFile();
    tabix.data = data;
    tabix.tbi = tbi;

    tabix.tbi.fetch(function (header) {
        // Do we really need to fetch the whole thing? :-(
        if (!header) {
            return callback(null, "Couldn't access Tabix");
        }

        var unchead = unbgzf(header, header.byteLength);
        var uncba = new Uint8Array(unchead);
        var magic = readInt(uncba, 0);
        if (magic != TABIX_MAGIC) {
            return callback(null, 'Not a tabix index');
        }

        var nref = readInt(uncba, 4);
        tabix.format = readInt(uncba, 8);
        tabix.colSeq = readInt(uncba, 12);
        tabix.colStart = readInt(uncba, 16);
        tabix.colEnd = readInt(uncba, 20);
        tabix.meta = readInt(uncba, 24);
        tabix.skip = readInt(uncba, 28);
        var nameLength = readInt(uncba, 32);

        tabix.indices = [];

        var p = 36;
        tabix.chrToIndex = {};
        tabix.indexToChr = [];
        for (var i = 0; i < nref; ++i) {
            var name = '';

            while (true) {
                var ch = uncba[p++];
                if (ch == 0) break;

                name += String.fromCharCode(ch);
            }

            tabix.chrToIndex[name] = i;
            if (name.indexOf('chr') == 0) {
                tabix.chrToIndex[name.substring(3)] = i;
            } else {
                tabix.chrToIndex['chr' + name] = i;
            }
            tabix.indexToChr.push(name);
        }

        var minBlockIndex = 1000000000;
        for (var ref = 0; ref < nref; ++ref) {
            var blockStart = p;
            var nbin = readInt(uncba, p);p += 4;
            for (var b = 0; b < nbin; ++b) {
                var bin = readInt(uncba, p);
                var nchnk = readInt(uncba, p + 4);
                p += 8 + nchnk * 16;
            }
            var nintv = readInt(uncba, p);p += 4;

            var q = p;
            for (var i = 0; i < nintv; ++i) {
                var v = readVob(uncba, q);q += 8;
                if (v) {
                    var bi = v.block;
                    if (v.offset > 0) bi += 65536;

                    if (bi < minBlockIndex) minBlockIndex = bi;
                    break;
                }
            }
            p += nintv * 8;

            var ub = uncba;
            if (nbin > 0) {
                tabix.indices[ref] = new Uint8Array(unchead, blockStart, p - blockStart);
            }
        }

        tabix.headerMax = minBlockIndex;

        callback(tabix);
    }, { timeout: 50000 });
}

// Copy-paste from BamFile

TabixFile.prototype.blocksForRange = function (refId, min, max) {
    var index = this.indices[refId];
    if (!index) {
        return [];
    }

    var intBinsL = reg2bins(min, max);
    var intBins = [];
    for (var i = 0; i < intBinsL.length; ++i) {
        intBins[intBinsL[i]] = true;
    }
    var leafChunks = [],
        otherChunks = [];

    var nbin = readInt(index, 0);
    var p = 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(index, p);
        var nchnk = readInt(index, p + 4);
        p += 8;
        if (intBins[bin]) {
            for (var c = 0; c < nchnk; ++c) {
                var cs = readVob(index, p, true);
                var ce = readVob(index, p + 8, true);
                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));
                p += 16;
            }
        } else {
            p += nchnk * 16;
        }
    }

    var nintv = readInt(index, p);
    var lowest = null;
    var minLin = Math.min(min >> 14, nintv - 1),
        maxLin = Math.min(max >> 14, nintv - 1);
    for (var i = minLin; i <= maxLin; ++i) {
        var lb = readVob(index, p + 4 + i * 8);
        if (!lb) {
            continue;
        }
        if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {
            lowest = lb;
        }
    }

    var prunedOtherChunks = [];
    if (lowest != null) {
        for (var i = 0; i < otherChunks.length; ++i) {
            var chnk = otherChunks[i];
            if (chnk.maxv.block >= lowest.block && chnk.maxv.offset >= lowest.offset) {
                prunedOtherChunks.push(chnk);
            }
        }
    }
    otherChunks = prunedOtherChunks;

    var intChunks = [];
    for (var i = 0; i < otherChunks.length; ++i) {
        intChunks.push(otherChunks[i]);
    }
    for (var i = 0; i < leafChunks.length; ++i) {
        intChunks.push(leafChunks[i]);
    }

    intChunks.sort(function (c0, c1) {
        var dif = c0.minv.block - c1.minv.block;
        if (dif != 0) {
            return dif;
        } else {
            return c0.minv.offset - c1.minv.offset;
        }
    });
    var mergedChunks = [];
    if (intChunks.length > 0) {
        var cur = intChunks[0];
        for (var i = 1; i < intChunks.length; ++i) {
            var nc = intChunks[i];
            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) {
                    // no point splitting mid-block
                    cur = new Chunk(cur.minv, nc.maxv);
                } else {
                mergedChunks.push(cur);
                cur = nc;
            }
        }
        mergedChunks.push(cur);
    }

    return mergedChunks;
};

TabixFile.prototype.fetch = function (chr, min, max, callback) {
    var thisB = this;

    var chrId = this.chrToIndex[chr];
    if (chrId == undefined) return callback([]);

    var canonicalChr = this.indexToChr[chrId];

    var chunks;
    if (chrId === undefined) {
        chunks = [];
    } else {
        chunks = this.blocksForRange(chrId, min, max);
        if (!chunks) {
            callback(null, 'Error in index fetch');
        }
    }

    var records = [];
    var index = 0;
    var data;

    function tramp() {
        if (index >= chunks.length) {
            return callback(records);
        } else if (!data) {
            var c = chunks[index];
            var fetchMin = c.minv.block;
            var fetchMax = c.maxv.block + (1 << 16); // *sigh*
            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function (r) {
                data = unbgzf(r, c.maxv.block - c.minv.block + 1);
                return tramp();
            });
        } else {
            var ba = new Uint8Array(data);
            thisB.readRecords(ba, chunks[index].minv.offset, records, min, max, canonicalChr);
            data = null;
            ++index;
            return tramp();
        }
    }
    tramp();
};

TabixFile.prototype.readRecords = function (ba, offset, sink, min, max, chr) {
    LINE_LOOP: while (true) {
        var line = '';
        while (offset < ba.length) {
            var ch = ba[offset++];
            if (ch == 10) {
                var toks = line.split('\t');

                if (toks[this.colSeq - 1] == chr) {
                    var fmin = parseInt(toks[this.colStart - 1]);
                    var fmax = fmin;
                    if (this.colEnd > 0) fmax = parseInt(toks[this.colEnd - 1]);
                    if (this.format & 0x10000) ++fmin;

                    if (fmin <= max && fmax >= min) sink.push(line);
                }
                continue LINE_LOOP;
            } else {
                line += String.fromCharCode(ch);
            }
        }
        return;
    }
};

TabixFile.prototype.fetchHeader = function (callback) {
    var self = this;
    var fetchPtr = 0,
        ptr = 0,
        line = '';
    var lines = [];

    self.data.slice(0, self.headerMax).fetch(function (chnk) {
        if (!chnk) {
            return callback(null, "Fetch failed");
        }
        var ba = new Uint8Array(unbgzf(chnk, chnk.byteLength));
        var ptr = 0,
            line = '',
            lines = [];
        while (ptr < ba.length) {
            var ch = ba[ptr++];
            if (ch == 10) {
                if (line.charCodeAt(0) == self.meta) {
                    lines.push(line);
                    line = '';
                } else {
                    return callback(lines);
                }
            } else {
                line += String.fromCharCode(ch);
            }
        }
        callback(lines);
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        connectTabix: connectTabix,
        TABIX_MAGIC: TABIX_MAGIC
    };
}

},{"./bin":4,"./lh3utils":27,"./spans":43}],50:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sourceadapters = require("./sourceadapters.js");

var _das = require("./das.js");

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint esversion: 6 */

/*
 Source that can be configured to produce any type of feature,
 useful for testing renderers.
 */

var TestSource = function (_FeatureSourceBase) {
    _inherits(TestSource, _FeatureSourceBase);

    function TestSource(source) {
        _classCallCheck(this, TestSource);

        var _this = _possibleConstructorReturn(this, (TestSource.__proto__ || Object.getPrototypeOf(TestSource)).call(this));

        _this.features = R.defaultTo([], source.features);
        return _this;
    }

    _createClass(TestSource, [{
        key: "genFeature",
        value: function genFeature(conf) {
            var feature = new _das.DASFeature();

            for (var key in conf) {
                feature[key] = conf[key];
            }
        }
    }, {
        key: "fetch",
        value: function fetch(chr, min, max, scale, types, pool, callback) {
            var features = R.forEach(this.genFeature, this.features);
            return callback(null, features, 1);
        }
    }]);

    return TestSource;
}(_sourceadapters.FeatureSourceBase);

(0, _sourceadapters.registerSourceAdapterFactory)('test-source', function (source) {
    return { features: new TestSource(source) };
});

},{"./das.js":11,"./sourceadapters.js":41,"ramda":67}],51:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// thub.js: support for track-hub style registries
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var textXHR = utils.textXHR;
    var relativeURL = utils.relativeURL;
    var shallowCopy = utils.shallowCopy;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
}

var THUB_STANZA_REGEXP = /\n\s*\n/;
var THUB_PARSE_REGEXP = /(\w+) +(.+)\n?/;
var THUB_SUBGROUP_REGEXP = /subGroup[1-9]/;

var THUB_PENNANT_PREFIX = 'http://genome.ucsc.edu/images/';

function TrackHub(url) {
    this.genomes = {};
    this.url = url;
}

function TrackHubTrack() {}

TrackHubTrack.prototype.get = function (k) {
    if (this[k]) return this[k];else if (this._parent) return this._parent.get(k);
};

function TrackHubDB(hub) {
    this.hub = hub;
}

TrackHubDB.prototype.getTracks = function (callback) {
    var thisB = this;
    if (this._tracks) {
        return callback(this._tracks);
    }

    textXHR(this.absURL, function (trackFile, err) {
        if (err) {
            return callback(null, err);
        }

        // trackFile = trackFile.replace(/\#.*/g, '');
        trackFile = trackFile.replace('\\\n', ' ');

        var tracks = [];
        var tracksById = {};
        var stanzas = trackFile.split(THUB_STANZA_REGEXP);
        for (var s = 0; s < stanzas.length; ++s) {
            var toks = stanzas[s].replace(/\#.*/g, '').split(THUB_PARSE_REGEXP);
            var track = new TrackHubTrack();
            track._db = thisB;
            for (var l = 0; l < toks.length - 2; l += 3) {
                var k = toks[l + 1],
                    v = toks[l + 2];
                if (k.match(THUB_SUBGROUP_REGEXP)) {
                    if (!track.subgroups) track.subgroups = {};
                    var sgtoks = v.split(/\s/);
                    var sgtag = sgtoks[0];
                    var sgrecord = { name: sgtoks[1], tags: [], titles: [] };
                    for (var sgti = 2; sgti < sgtoks.length; ++sgti) {
                        var grp = sgtoks[sgti].split(/=/);
                        sgrecord.tags.push(grp[0]);
                        sgrecord.titles.push(grp[1]);
                    }
                    track.subgroups[sgtag] = sgrecord;
                } else if (k === 'subGroups') {
                    var sgtoks = v.split(/(\w+)=(\w+)/);
                    track.sgm = {};
                    for (var sgti = 0; sgti < sgtoks.length - 2; sgti += 3) {
                        track.sgm[sgtoks[sgti + 1]] = sgtoks[sgti + 2];
                    }
                } else {
                    track[toks[l + 1]] = toks[l + 2];
                }
            }

            if (track.track && (track.type || track.container || track.view || track.bigDataUrl)) {
                tracks.push(track);
                tracksById[track.track] = track;
            } else {
                // console.log('skipping ', track);
            }
        }

        var toplevels = [];
        var composites = [];
        for (var ti = 0; ti < tracks.length; ++ti) {
            var track = tracks[ti];
            var top = true;
            if (track.parent) {
                var ptoks = track.parent.split(/\s+/);
                var parent = tracksById[ptoks[0]];
                if (parent) {
                    track._parent = parent;

                    if (!parent.children) parent.children = [];
                    parent.children.push(track);

                    if (parent) top = false;
                } else {
                    console.log("Couldn't find parent " + ptoks[0] + '(' + track.parent + ')');
                }
            }
            if (track.compositeTrack) {
                composites.push(track);
            } else if (top) {
                toplevels.push(track);
            }
        }

        for (var ci = 0; ci < composites.length; ++ci) {
            var comp = composites[ci];
            if (!comp.children) continue;

            var parentOfViews = false;
            for (var ki = 0; ki < comp.children.length; ++ki) {
                var k = comp.children[ki];
                if (k.view) {
                    k.shortLabel = comp.shortLabel + ": " + k.shortLabel;
                    toplevels.push(k);
                    parentOfViews = true;
                }
            }
            if (!parentOfViews) toplevels.push(comp);
        }

        thisB._tracks = toplevels;
        return callback(thisB._tracks, null);
    }, { credentials: this.credentials, salt: true });
};

function connectTrackHub(hubURL, callback, opts) {
    opts = opts || {};
    opts.salt = true;

    textXHR(hubURL, function (hubFile, err) {
        if (err) {
            return callback(null, err);
        }

        var toks = hubFile.split(THUB_PARSE_REGEXP);
        var hub = new TrackHub(hubURL);
        if (opts.credentials) {
            hub.credentials = opts.credentials;
        }
        for (var l = 0; l < toks.length - 2; l += 3) {
            hub[toks[l + 1]] = toks[l + 2];
        }

        if (hub.genomesFile) {
            var genURL = relativeURL(hubURL, hub.genomesFile);
            textXHR(genURL, function (genFile, err) {
                if (err) {
                    return callback(null, err);
                }

                var stanzas = genFile.split(THUB_STANZA_REGEXP);
                for (var s = 0; s < stanzas.length; ++s) {
                    var toks = stanzas[s].split(THUB_PARSE_REGEXP);
                    var gprops = new TrackHubDB(hub);
                    if (opts.credentials) {
                        gprops.credentials = opts.credentials;
                    }

                    for (var l = 0; l < toks.length - 2; l += 3) {
                        gprops[toks[l + 1]] = toks[l + 2];
                    }

                    if (gprops.twoBitPath) {
                        gprops.twoBitPath = relativeURL(genURL, gprops.twoBitPath);
                    }

                    if (gprops.genome && gprops.trackDb) {
                        gprops.absURL = relativeURL(genURL, gprops.trackDb);
                        hub.genomes[gprops.genome] = gprops;
                    }
                }

                callback(hub);
            }, opts);
        } else {
            callback(null, 'No genomesFile');
        }
    }, opts);
}

TrackHubTrack.prototype.toDallianceSource = function () {
    var source = {
        name: this.shortLabel,
        desc: this.longLabel
    };
    if (this._db.mapping) {
        source.mapping = this._db.mapping;
    }

    var pennantIcon = this.get('pennantIcon');
    if (pennantIcon) {
        var ptoks = pennantIcon.split(/\s+/);
        source.pennant = THUB_PENNANT_PREFIX + ptoks[0];
    }

    var searchTrix = this.get('searchTrix');
    if (searchTrix) {
        source.trixURI = relativeURL(this._db.absURL, searchTrix);
    }

    if (this.container == 'multiWig') {
        source.merge = 'concat';
        source.overlay = [];
        var children = this.children || [];
        source.style = [];
        source.noDownsample = true;

        for (var ci = 0; ci < children.length; ++ci) {
            var ch = children[ci];
            var cs = ch.toDallianceSource();
            source.overlay.push(cs);

            if (cs.style) {
                for (var si = 0; si < cs.style.length; ++si) {
                    var style = cs.style[si];
                    style.method = ch.shortLabel; // FIXME
                    if (this.aggregate == 'transparentOverlay') style.style.ALPHA = 0.5;
                    source.style.push(style);
                }
            }
        }
        return source;
    } else {
        var type = this.type;
        if (!type) {
            var p = this;
            while (p._parent && !p.type) {
                p = p._parent;
            }
            type = p.type;
        }
        if (!type) return;
        var typeToks = type.split(/\s+/);
        if (typeToks[0] == 'bigBed' && this.bigDataUrl) {
            var bedTokens = typeToks[1] | 0;
            var bedPlus = typeToks[2] == '+';

            source.bwgURI = relativeURL(this._db.absURL, this.bigDataUrl);
            source.style = this.bigbedStyles();
            if (this._db.credentials) {
                source.credentials = true;
            }
            if (bedTokens >= 12 && bedPlus) source.collapseSuperGroups = true;
            return source;
        } else if (typeToks[0] == 'bigWig' && this.bigDataUrl) {
            source.bwgURI = relativeURL(this._db.absURL, this.bigDataUrl);
            source.style = this.bigwigStyles();
            source.noDownsample = true; // FIXME seems like a blunt instrument...

            if (this.yLineOnOff && this.yLineOnOff == 'on') {
                source.quantLeapThreshold = this.yLineMark !== undefined ? 1.0 * this.yLineMark : 0.0;
            }

            if (this._db.credentials) {
                source.credentials = true;
            }

            return source;
        } else if (typeToks[0] == 'bam' && this.bigDataUrl) {
            source.bamURI = relativeURL(this._db.absURL, this.bigDataUrl);
            if (this._db.credentials) {
                source.credentials = true;
            }
            return source;
        } else if (typeToks[0] == 'vcfTabix' && this.bigDataUrl) {
            source.uri = relativeURL(this._db.absURL, this.bigDataUrl);
            source.tier_type = 'tabix';
            source.payload = 'vcf';
            if (this._db.credentials) {
                source.credentials = true;
            }
            return source;
        } else {
            console.log('Unsupported ' + this.type);
        }
    }
};

TrackHubTrack.prototype.bigwigStyles = function () {
    var type = this.type;
    if (!type) {
        var p = this;
        while (p._parent && !p.type) {
            p = p._parent;
        }
        type = p.type;
    }
    if (!type) return;
    var typeToks = type.split(/\s+/);

    var min, max;
    if (typeToks.length >= 3) {
        min = 1.0 * typeToks[1];
        max = 1.0 * typeToks[2];
    }

    var height;
    if (this.maxHeightPixels) {
        var mhpToks = this.maxHeightPixels.split(/:/);
        if (mhpToks.length == 3) {
            height = mhpToks[1] | 0;
        } else {
            console.log('maxHeightPixels should be of the form max:default:min');
        }
    }

    var gtype = 'bars';
    if (this.graphTypeDefault) {
        gtype = this.graphTypeDefault;
    }

    var color = 'black';
    var altColor = null;
    if (this.color) {
        color = 'rgb(' + this.color + ')';
    }
    if (this.altColor) {
        altColor = 'rgb(' + this.altColor + ')';
    }

    var stylesheet = new DASStylesheet();
    var wigStyle = new DASStyle();
    if (gtype == 'points') {
        wigStyle.glyph = 'POINT';
    } else {
        wigStyle.glyph = 'HISTOGRAM';
    }

    if (altColor) {
        wigStyle.COLOR1 = color;
        wigStyle.COLOR2 = altColor;
    } else {
        wigStyle.BGCOLOR = color;
    }
    wigStyle.HEIGHT = height || 30;
    if (min || max) {
        wigStyle.MIN = min;
        wigStyle.MAX = max;
    }
    stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
    return stylesheet.styles;
};

TrackHubTrack.prototype.bigbedStyles = function () {
    var itemRgb = ('' + this.get('itemRgb')).toLowerCase() == 'on';
    var visibility = this.get('visibility') || 'full';
    var color = this.get('color');
    if (color) color = 'rgb(' + color + ')';else color = 'blue';

    var stylesheet = new DASStylesheet();
    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = color;
    wigStyle.HEIGHT = visibility == 'full' || visibility == 'pack' ? 12 : 8;
    wigStyle.BUMP = visibility == 'full' || visibility == 'pack';
    wigStyle.LABEL = visibility == 'full' || visibility == 'pack';
    wigStyle.ZINDEX = 20;
    if (itemRgb) wigStyle.BGITEM = true;

    var cbs = this.get('colorByStrand');
    if (cbs) {
        var cbsToks = cbs.split(/\s+/);

        var plus = shallowCopy(wigStyle);
        plus.BGCOLOR = 'rgb(' + cbsToks[0] + ')';
        stylesheet.pushStyle({ type: 'bigbed', orientation: '+' }, null, plus);

        var minus = shallowCopy(wigStyle);
        minus.BGCOLOR = 'rgb(' + cbsToks[1] + ')';
        stylesheet.pushStyle({ type: 'bigbed', orientation: '-' }, null, minus);
    } else {
        stylesheet.pushStyle({ type: 'bigbed' }, null, wigStyle);
    }

    var tlStyle = new DASStyle();
    tlStyle.glyph = 'BOX';
    tlStyle.FGCOLOR = 'black';
    if (itemRgb) tlStyle.BGITEM = true;
    tlStyle.BGCOLOR = 'red';
    tlStyle.HEIGHT = 10;
    tlStyle.BUMP = true;
    tlStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'translation' }, null, tlStyle);

    var tsStyle = new DASStyle();
    tsStyle.glyph = 'BOX';
    tsStyle.FGCOLOR = 'black';
    tsStyle.BGCOLOR = 'white';
    tsStyle.HEIGHT = 10;
    tsStyle.ZINDEX = 10;
    tsStyle.BUMP = true;
    tsStyle.LABEL = true;
    stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

    return stylesheet.styles;
};

function THUB_COMPARE(g, h) {
    if (g.priority && h.priority) {
        return 1.0 * g.priority - 1.0 * h.priority;
    } else if (g.priority) {
        return 1;
    } else if (h.priority) {
        return -1;
    } else {
        return g.shortLabel.localeCompare(h.shortLabel);
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        connectTrackHub: connectTrackHub,
        THUB_COMPARE: THUB_COMPARE
    };
}

},{"./das":11,"./utils":58}],52:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tier-actions.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
}

Browser.prototype.mergeSelectedTiers = function () {
    var sources = [];
    var styles = [];

    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {
        var tier = this.tiers[this.selectedTiers[sti]];
        sources.push(shallowCopy(tier.dasSource));
        var ss = tier.stylesheet.styles;
        for (var si = 0; si < ss.length; ++si) {
            var sh = ss[si];
            var nsh = shallowCopy(sh);
            nsh.method = tier.dasSource.name.replace(/[()+*?]/g, '\\$&');
            nsh._methodRE = null;
            nsh.style = shallowCopy(sh.style);
            if (nsh.style.ZINDEX === undefined) nsh.style.ZINDEX = sti;

            if (tier.forceMin) {
                nsh.style.MIN = tier.forceMin;
            }
            if (tier.forceMax) {
                nsh.style.MAX = tier.forceMax;
            }

            styles.push(nsh);
        }
    }

    this.addTier({ name: 'Merged',
        merge: 'concat',
        overlay: sources,
        noDownsample: true,
        style: styles });

    this.setSelectedTier(this.tiers.length - 1);
};

},{"./cbrowser":6,"./utils":58}],53:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tier-edit.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;

    var das = require('./das');
    var isDasBooleanTrue = das.isDasBooleanTrue;
    var isDasBooleanNotFalse = das.isDasBooleanNotFalse;
    var copyStylesheet = das.copyStylesheet;

    var color = require('./color');
    var dasColourForName = color.dasColourForName;

    var sourceDataURI = require('./sourcecompare').sourceDataURI;
}

var __dalliance_smallGlyphs = {
    DOT: true,
    EX: true,
    STAR: true,
    SQUARE: true,
    CROSS: true,
    TRIANGLE: true,
    PLIMSOLL: true
};

Browser.prototype.openTierPanel = function (tier) {
    var b = this;

    if (this.uiMode === 'tier' && this.manipulatingTier === tier) {
        this.hideToolPanel();
        this.setUiMode('none');
    } else if (!tier) {
        return;
    } else {
        var setStyleColors = function setStyleColors(style) {
            if (style.BGGRAD) return;

            if (numColors == 1) {
                if (style.glyph == 'LINEPLOT' || __dalliance_smallGlyphs[style.glyph]) {
                    style.FGCOLOR = tierColorField.value;
                } else {
                    style.BGCOLOR = tierColorField.value;
                }
                style.COLOR1 = style.COLOR2 = style.COLOR3 = null;
            } else {
                style.COLOR1 = tierColorField.value;
                style.COLOR2 = tierColorField2.value;
                if (numColors > 2) {
                    style.COLOR3 = tierColorField3.value;
                } else {
                    style.COLOR3 = null;
                }
            }
            style._gradient = null;
            style._plusColor = tierPlusColorField.value;
            style._minusColor = tierMinusColorField.value;
        };

        var mutateStylesheet = function mutateStylesheet(visitor) {
            var nss = copyStylesheet(tier.stylesheet);
            var ssScale = tier.browser.zoomForCurrentScale();

            for (var i = 0; i < nss.styles.length; ++i) {
                var sh = nss.styles[i];
                if (sh.zoom && sh.zoom != ssScale) {
                    continue;
                }

                visitor(sh.style);
            }

            return nss;
        };

        var changeColor = function changeColor(ev) {
            tier.mergeStylesheet(mutateStylesheet(setStyleColors));
        };

        this.manipulatingTier = tier;

        var tierForm = makeElement('div', null, { className: 'tier-edit' });

        var aboutBanner = makeElement('div', "About '" + (tier.config.Name || tier.dasSource.name) + "'", null, { background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center' });
        tierForm.appendChild(aboutBanner);

        var about = makeElement('div', [makeElement('p', tier.dasSource.desc)]);
        var aboutNotes = [];
        var sduri = sourceDataURI(tier.dasSource);
        if (sduri && (sduri.indexOf('http://') == 0 || sduri.indexOf('https://') == 0 || sduri.indexOf('//') == 0) && sduri !== 'https://www.biodalliance.org/magic/no_uri') {
            aboutNotes.push(makeElement('li', makeElement('a', '(Download data)', { href: sduri })));
        }

        if (tier.dasSource.mapping) {
            var coords = this.chains[tier.dasSource.mapping].coords;
            aboutNotes.push(makeElement('li', 'Mapped from ' + coords.auth + coords.version));
        }

        if (aboutNotes.length > 0) {
            about.appendChild(makeElement('ul', aboutNotes));
        }

        tierForm.appendChild(about);

        var semanticBanner = makeElement('span', ' (styles for current zoom level)', null, { display: 'none' });
        var editBanner = makeElement('div', ['Edit', semanticBanner], null, { background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center' });
        tierForm.appendChild(editBanner);

        var tierNameField = makeElement('input', null, { type: 'text' });
        var tierPinnedToggle = makeElement('input', null, { type: 'checkbox', disabled: this.disablePinning });

        var glyphField = makeElement('select');
        glyphField.appendChild(makeElement('option', 'Histogram', { value: 'HISTOGRAM' }));
        glyphField.appendChild(makeElement('option', 'Line Plot', { value: 'LINEPLOT' }));
        glyphField.appendChild(makeElement('option', 'Ribbon', { value: 'GRADIENT' }));
        glyphField.appendChild(makeElement('option', 'Scatter', { value: 'SCATTER' }));

        var tierColorField = makeElement('input', null, { type: 'text', value: '#dd00dd' });
        var tierColorField2 = makeElement('input', null, { type: 'text', value: '#dd00dd' });
        var tierColorField3 = makeElement('input', null, { type: 'text', value: '#dd00dd' });

        var tierPlusColorField = makeElement('input', null, { type: 'text', value: '#ffa07a' });
        var tierMinusColorField = makeElement('input', null, { type: 'text', value: '#87cefa' });

        try {
            tierColorField.type = tierColorField2.type = tierColorField3.type = 'color';
            tierPlusColorField.type = tierMinusColorField.type = 'color';
        } catch (e) {
            // IE throws if attempt to set type to 'color'.
        }

        var tierColorFields = [tierColorField, tierColorField2, tierColorField3];
        var colorListPlus = makeElement('i', null, { className: 'fa fa-plus-circle' });
        var colorListMinus = makeElement('i', null, { className: 'fa fa-minus-circle' });
        var numColors = 1;
        var colorListElement = makeElement('td', tierColorFields);
        var setNumColors = function setNumColors(n) {
            numColors = n;
            for (var i = 0; i < n; ++i) {
                tierColorFields[i].style.display = 'block';
            }for (var i = n; i < tierColorFields.length; ++i) {
                tierColorFields[i].style.display = 'none';
            }
        };
        colorListPlus.addEventListener('click', function (ev) {
            if (numColors < 3) {
                setNumColors(numColors + 1);
                changeColor(null);
            }
        }, false);
        colorListMinus.addEventListener('click', function (ev) {
            if (numColors > 1) {
                setNumColors(numColors - 1);
                changeColor(null);
            }
        }, false);

        var tierMinField = makeElement('input', null, { type: 'text', value: '0.0' });
        var tierMaxField = makeElement('input', null, { type: 'text', value: '10.0' });
        var tierMinToggle = makeElement('input', null, { type: 'checkbox' });
        var tierMaxToggle = makeElement('input', null, { type: 'checkbox' });

        var quantLeapToggle = makeElement('input', null, { type: 'checkbox', checked: tier.quantLeapThreshold !== undefined });
        var quantLeapThreshField = makeElement('input', null, { type: 'text', value: tier.quantLeapThreshold, disabled: !quantLeapToggle.checked });

        var tierHeightField = makeElement('input', null, { type: 'text', value: '50' });

        var bumpToggle = makeElement('input', null, { type: 'checkbox' });
        var bumpLimit = makeElement('input', null, { type: 'text' });
        var labelToggle = makeElement('input', null, { type: 'checkbox' });

        var mainStyle = null;
        if (tier.stylesheet.styles.length > 0) {
            var s = mainStyle = tier.stylesheet.styles[0].style;
        }

        var refresh = function refresh() {
            if (typeof tier.config.name === 'string') tierNameField.value = tier.config.name;else tierNameField.value = tier.dasSource.name;

            tierPinnedToggle.checked = tier.pinned;

            if (tier.forceHeight) {
                tierHeightField.value = '' + tier.forceHeight;
            } else if (mainStyle && mainStyle.HEIGHT) {
                tierHeightField.value = '' + mainStyle.HEIGHT;
            }

            if (typeof tier.quantLeapThreshold == 'number') {
                quantLeapToggle.checked = true;
                quantLeapThreshField.disabled = false;
                if (parseFloat(quantLeapThreshField.value) != tier.quantLeapThreshold) quantLeapThreshField.value = tier.quantLeapThreshold;
            } else {
                quantLeapToggle.checked = false;
                quantLeapThreshField.disabled = true;
            }

            if (typeof tier.subtierMax == 'number') {
                bumpLimit.value = '' + tier.subtierMax;
            } else {
                bumpLimit.value = '' + (tier.dasSource.subtierMax || tier.browser.defaultSubtierMax);
            }

            if (tier.stylesheet.styles.length > 0) {
                var s = null;
                var isQuantitative = false,
                    isSimpleQuantitative = false;
                var ssScale = tier.browser.zoomForCurrentScale();
                var activeStyleCount = 0;

                for (var si = 0; si < tier.stylesheet.styles.length; ++si) {
                    var sh = tier.stylesheet.styles[si];
                    if (sh.zoom && sh.zoom != ssScale) {
                        continue;
                    }
                    ++activeStyleCount;
                    var ss = tier.stylesheet.styles[si].style;

                    if (!s) {
                        s = mainStyle = ss;
                    }

                    if (ss.glyph == 'LINEPLOT' || ss.glyph == 'HISTOGRAM' || ss.glyph == 'GRADIENT' || isDasBooleanTrue(ss.SCATTER)) {
                        if (!isQuantitative) s = mainStyle = ss;
                        isQuantitative = true;
                    }
                }
                if (!s) {
                    return;
                }

                semanticBanner.style.display = activeStyleCount == tier.stylesheet.styles.length ? 'none' : 'inline';

                isSimpleQuantitative = isQuantitative && activeStyleCount == 1;
                var isGradient = s.COLOR2 || s.BGGRAD;

                if (isQuantitative) {
                    minRow.style.display = 'table-row';
                    maxRow.style.display = 'table-row';
                    bumpRow.style.display = 'none';
                    labelRow.style.display = 'none';
                } else {
                    minRow.style.display = 'none';
                    maxRow.style.display = 'none';
                    bumpRow.style.display = 'table-row';
                    bumpToggle.checked = isDasBooleanTrue(mainStyle.BUMP);
                    bumpLimit.disabled = !isDasBooleanTrue(mainStyle.BUMP);
                    labelRow.style.display = 'table-row';
                    labelToggle.checked = isDasBooleanTrue(mainStyle.LABEL);
                }

                if (isSimpleQuantitative) {
                    styleRow.style.display = 'table-row';
                    colorRow.style.display = 'table-row';
                } else {
                    styleRow.style.display = 'none';
                    colorRow.style.display = 'none';
                }

                var numColors = 1;
                if (s.COLOR1) {
                    tierColorField.value = dasColourForName(s.COLOR1).toHexString();
                    if (s.COLOR2) {
                        tierColorField2.value = dasColourForName(s.COLOR2).toHexString();
                        if (s.COLOR3) {
                            tierColorField3.value = dasColourForName(s.COLOR3).toHexString();
                            numColors = 3;
                        } else {
                            numColors = 2;
                        }
                    }
                } else {
                    if (s.glyph == 'LINEPLOT' || s.glyph == 'DOT' && s.FGCOLOR) {
                        tierColorField.value = dasColourForName(s.FGCOLOR).toHexString();
                    } else if (s.BGCOLOR) {
                        tierColorField.value = dasColourForName(s.BGCOLOR).toHexString();
                    }
                }
                setNumColors(numColors);

                if (s._plusColor) tierPlusColorField.value = dasColourForName(s._plusColor).toHexString() || s._plusColor;
                if (s._minusColor) tierMinusColorField.value = dasColourForName(s._minusColor).toHexString() || s._minusColor;
                if (isDasBooleanTrue(s.SCATTER)) {
                    glyphField.value = 'SCATTER';
                } else {
                    glyphField.value = s.glyph;
                }

                var setMinValue, setMaxValue;
                if (s.MIN !== undefined) {
                    var x = parseFloat(s.MIN);
                    if (!isNaN(x)) setMinValue = x;
                }
                if (!tier.forceMinDynamic && (s.MIN !== undefined || tier.forceMin !== undefined)) {
                    tierMinToggle.checked = true;
                    tierMinField.disabled = false;
                } else {
                    tierMinToggle.checked = false;
                    tierMinField.disabled = true;
                }

                if (s.MAX !== undefined) {
                    var x = parseFloat(s.MAX);
                    if (!isNaN(x)) setMaxValue = x;
                }
                if (!tier.forceMaxDynamic && (s.MAX !== undefined || tier.forceMax !== undefined)) {
                    tierMaxToggle.checked = true;
                    tierMaxField.disabled = false;
                } else {
                    tierMaxToggle.checked = false;
                    tierMaxField.disabled = true;
                }

                if (tier.forceMin != undefined) {
                    setMinValue = tier.forceMin;
                }
                if (tier.forceMax != undefined) {
                    setMaxValue = tier.forceMax;
                }
                if (typeof setMinValue == 'number' && setMinValue != parseFloat(tierMinField.value)) {
                    tierMinField.value = setMinValue;
                }
                if (typeof setMaxValue == 'number' && setMaxValue != parseFloat(tierMaxField.value)) {
                    tierMaxField.value = setMaxValue;
                }

                var seqStyle = getSeqStyle(tier.stylesheet);
                if (seqStyle) {
                    seqMismatchRow.style.display = 'table-row';
                    seqMismatchToggle.checked = seqStyle.__SEQCOLOR === 'mismatch';
                    seqInsertRow.style.display = 'table-row';
                    seqInsertToggle.checked = isDasBooleanTrue(seqStyle.__INSERTIONS);
                    seqIgnoreQualsRow.style.display = 'table-row';
                    seqIgnoreQualsToggle.checked = seqStyle.__disableQuals === undefined || seqStyle.__disableQuals === false;
                    console.log(seqStyle.__disableQuals);
                } else {
                    seqMismatchRow.style.display = 'none';
                    seqInsertRow.style.display = 'none';
                    seqIgnoreQualsRow.style.display = 'none';
                }

                if (seqStyle && seqMismatchToggle.checked && !isSimpleQuantitative) {
                    plusStrandColorRow.style.display = 'table-row';
                    minusStrandColorRow.style.display = 'table-row';
                } else {
                    plusStrandColorRow.style.display = 'none';
                    minusStrandColorRow.style.display = 'none';
                }
            }

            if (isQuantitative && tier.browser.sourceAdapterIsCapable(tier.featureSource, 'quantLeap')) quantLeapRow.style.display = 'table-row';else quantLeapRow.style.display = 'none';
        };

        var seqMismatchToggle = makeElement('input', null, { type: 'checkbox' });
        var seqMismatchRow = makeElement('tr', [makeElement('th', 'Highlight mismatches & strands'), makeElement('td', seqMismatchToggle)]);
        seqMismatchToggle.addEventListener('change', function (ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__SEQCOLOR = seqMismatchToggle.checked ? 'mismatch' : 'base';
            tier.mergeStylesheet(nss);
        });

        var seqInsertToggle = makeElement('input', null, { type: 'checkbox' });
        var seqInsertRow = makeElement('tr', [makeElement('th', 'Show insertions'), makeElement('td', seqInsertToggle)]);
        seqInsertToggle.addEventListener('change', function (ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__INSERTIONS = seqInsertToggle.checked ? 'yes' : 'no';
            tier.mergeStylesheet(nss);
        });

        var seqIgnoreQualsToggle = makeElement('input', null, { type: 'checkbox' });
        var seqIgnoreQualsRow = makeElement('tr', [makeElement('th', 'Reflect base quality as base color transparency'), makeElement('td', seqIgnoreQualsToggle)]);
        seqIgnoreQualsToggle.addEventListener('change', function (ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__disableQuals = !seqIgnoreQualsToggle.checked;
            console.log(seqStyle.__disableQuals);
            tier.mergeStylesheet(nss);
        });

        var styleRow = makeElement('tr', [makeElement('th', 'Style'), makeElement('td', glyphField)]);
        var colorRow = makeElement('tr', [makeElement('th', ['Colour(s)', colorListPlus, colorListMinus]), colorListElement]);
        var plusStrandColorRow = makeElement('tr', [makeElement('th', 'Plus Strand Color'), makeElement('td', tierPlusColorField)]);
        var minusStrandColorRow = makeElement('tr', [makeElement('th', 'Minus Strand Color'), makeElement('td', tierMinusColorField)]);
        var minRow = makeElement('tr', [makeElement('th', 'Min value'), makeElement('td', [tierMinToggle, ' ', tierMinField])]);
        var maxRow = makeElement('tr', [makeElement('th', 'Max value'), makeElement('td', [tierMaxToggle, ' ', tierMaxField])]);
        var quantLeapRow = makeElement('tr', [makeElement('th', 'Threshold leap:'), makeElement('td', [quantLeapToggle, ' ', quantLeapThreshField])]);
        var bumpRow = makeElement('tr', [makeElement('th', 'Bump overlaps'), makeElement('td', [bumpToggle, ' limit: ', bumpLimit])]);
        var labelRow = makeElement('tr', [makeElement('th', 'Label features'), makeElement('td', labelToggle)]);

        var tierTable = makeElement('table', [makeElement('tr', [makeElement('th', 'Name', {}, { width: '150px', textAlign: 'right' }), tierNameField]), makeElement('tr', [makeElement('th', 'Pin to top'), tierPinnedToggle]), makeElement('tr', [makeElement('th', 'Height'), makeElement('td', tierHeightField)]), styleRow, colorRow, plusStrandColorRow, minusStrandColorRow, minRow, maxRow, quantLeapRow, bumpRow, labelRow, seqMismatchRow, seqInsertRow, seqIgnoreQualsRow]);

        refresh();

        tierForm.appendChild(tierTable);

        var resetButton = makeElement('button', 'Reset track', { className: 'btn' }, { marginLeft: 'auto', marginRight: 'auto', display: 'block' });
        resetButton.addEventListener('click', function (ev) {
            tier.setConfig({});
        }, false);
        tierForm.appendChild(resetButton);

        tierNameField.addEventListener('input', function (ev) {
            tier.mergeConfig({ name: tierNameField.value });
        }, false);

        tierPinnedToggle.addEventListener('change', function (ev) {
            tier.mergeConfig({ pinned: tierPinnedToggle.checked });
        }, false);

        for (var ci = 0; ci < tierColorFields.length; ++ci) {
            tierColorFields[ci].addEventListener('change', changeColor, false);
        }

        tierPlusColorField.addEventListener('change', changeColor, false);
        tierMinusColorField.addEventListener('change', changeColor, false);

        glyphField.addEventListener('change', function (ev) {
            var nss = mutateStylesheet(function (ts) {
                if (glyphField.value === 'SCATTER') {
                    ts.SCATTER = true;
                    ts.glyph = 'DOT';
                    ts.SIZE = '3';
                } else {
                    ts.glyph = glyphField.value;
                    ts.SCATTER = undefined;
                }
                setStyleColors(ts);
            });
            tier.mergeStylesheet(nss);
        }, false);

        tierMinToggle.addEventListener('change', function (ev) {
            var conf = { forceMinDynamic: !tierMinToggle.checked };
            tierMinField.disabled = !tierMinToggle.checked;
            var x = parseFloat(tierMinField.value);
            if (tierMinToggle.checked && typeof x == 'number' && !isNaN(x)) conf.forceMin = parseFloat(x);
            tier.mergeConfig(conf);
        });
        tierMinField.addEventListener('input', function (ev) {
            var x = parseFloat(tierMinField.value);
            if (typeof x == 'number' && !isNaN(x)) tier.mergeConfig({ forceMin: x });
        }, false);

        tierMaxToggle.addEventListener('change', function (ev) {
            var conf = { forceMaxDynamic: !tierMaxToggle.checked };
            tierMaxField.disabled = !tierMaxToggle.checked;
            var x = parseFloat(tierMaxField.value);
            if (tierMaxToggle.checked && typeof x == 'number' && !isNaN(x)) conf.forceMax = parseFloat(x);
            tier.mergeConfig(conf);
        });
        tierMaxField.addEventListener('input', function (ev) {
            var x = parseFloat(tierMaxField.value);
            if (typeof x == 'number' && !isNaN(x)) tier.mergeConfig({ forceMax: x });
        }, false);

        tierHeightField.addEventListener('input', function (ev) {
            var x = parseFloat(tierHeightField.value);
            if (typeof x == 'number' && !isNaN(x)) tier.mergeConfig({ height: Math.min(500, x | 0) });
        }, false);

        var updateQuant = function updateQuant() {
            quantLeapThreshField.disabled = !quantLeapToggle.checked;
            if (quantLeapToggle.checked) {
                var x = parseFloat(quantLeapThreshField.value);
                if (typeof x == 'number' && !isNaN(x)) {
                    tier.mergeConfig({ quantLeapThreshold: parseFloat(quantLeapThreshField.value) });
                }
            } else {
                tier.mergeConfig({ quantLeapThreshold: null });
            }
        };
        quantLeapToggle.addEventListener('change', function (ev) {
            updateQuant();
        }, false);
        quantLeapThreshField.addEventListener('input', function (ev) {
            updateQuant();
        }, false);

        labelToggle.addEventListener('change', function (ev) {
            var nss = mutateStylesheet(function (style) {
                style.LABEL = labelToggle.checked ? 'yes' : 'no';
            });
            tier.mergeStylesheet(nss);
        }, false);
        bumpToggle.addEventListener('change', function (ev) {
            var nss = mutateStylesheet(function (style) {
                style.BUMP = bumpToggle.checked ? 'yes' : 'no';
            });
            tier.mergeStylesheet(nss);
        }, false);
        bumpLimit.addEventListener('input', function (ev) {
            var x = parseInt(bumpLimit.value);
            if (typeof x == 'number' && x > 0) {
                tier.mergeConfig({ subtierMax: x });
            }
        }, false);

        this.showToolPanel(tierForm);
        this.setUiMode('tier');

        tier.addTierListener(refresh);

        var currentScale = tier.browser.scale;
        tier.browser.addViewListener(function () {
            if (tier.browser.scale != currentScale) {
                currentScale = tier.browser.scale;
                refresh();
            }
        });
    }
};

function getSeqStyle(stylesheet) {
    for (var si = 0; si < stylesheet.styles.length; ++si) {
        var ss = stylesheet.styles[si].style;
        if (ss.glyph === '__SEQUENCE') {
            return ss;
        }
    }
}

},{"./cbrowser":6,"./color":9,"./das":11,"./sourcecompare":42,"./utils":58}],54:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// tier.js: (try) to encapsulate the functionality of a browser tier.
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var shallowCopy = utils.shallowCopy;
    var pushnew = utils.pushnew;
    var miniJSONify = utils.miniJSONify;
    var arrayIndexOf = utils.arrayIndexOf;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;

    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;

    var style = require('./style');
    var StyleFilter = style.StyleFilter;
    var StyleFilterSet = style.StyleFilterSet;

    var sc = require('./sourcecompare');
    var sourceDataURI = sc.sourceDataURI;

    var Promise = require('es6-promise').Promise;

    var sortFeatures = require('./features').sortFeatures;
}

var __tier_idSeed = 0;

function DasTier(browser, source, config, background) {
    var _this = this;

    this.config = config || {};
    this.id = 'tier' + ++__tier_idSeed;
    this.browser = browser;
    this.dasSource = shallowCopy(source);
    this.background = background;

    this.viewport = makeElement('canvas', null, { width: '' + ((this.browser.featurePanelWidth | 0) + 2000),
        height: "30",
        className: 'viewport_12_5' }, { position: 'inline-block',
        margin: '0px', border: '0px' });
    this.viewportHolder = makeElement('div', this.viewport, { className: 'viewport-holder_12_5' }, { background: background,
        position: 'absolute',
        padding: '0px', margin: '0px',
        border: '0px',
        left: '-1000px',
        minHeight: '200px' });
    this.overlay = makeElement('canvas', null, { width: +(this.browser.featurePanelWidth | 0),
        height: "30",
        className: 'viewport-overlay' });

    this.notifier = makeElement('div', '', { className: 'notifier' });
    this.notifierHolder = makeElement('div', this.notifier, { className: 'notifier-holder' });
    this.quantOverlay = makeElement('canvas', null, { width: '50', height: "56",
        className: 'quant-overlay' });

    this.removeButton = makeElement('i', null, { className: 'fa fa-times' });
    this.bumpButton = makeElement('i', null, { className: 'fa fa-plus-circle' });
    this.loaderButton = browser.makeLoader(16);
    this.loaderButton.style.display = 'none';
    this.infoElement = makeElement('div', this.dasSource.desc, { className: 'track-label-info' });
    this.nameButton = makeElement('div', [], { className: 'tier-tab' });
    this.nameButton.appendChild(this.removeButton);
    if (source.pennant) {
        this.nameButton.appendChild(makeElement('img', null, { src: source.pennant, width: '16', height: '16' }));
    } else if (source.mapping) {
        var version = null;
        if (this.browser.chains[source.mapping]) version = this.browser.chains[source.mapping].coords.version;
        if (version) this.nameButton.appendChild(makeElement('span', '' + version, null, { fontSize: '8pt', background: 'black', color: 'white', paddingLeft: '3px', paddingRight: '3px', paddingTop: '1px', paddingBottom: '1px', marginLeft: '2px', borderRadius: '10px' }));
    }
    this.nameElement = makeElement('span', source.name);
    this.nameButton.appendChild(makeElement('span', [this.nameElement, this.infoElement], { className: 'track-name-holder' }));
    this.nameButton.appendChild(this.bumpButton);
    this.nameButton.appendChild(this.loaderButton);

    this.label = makeElement('span', [this.nameButton], { className: 'btn-group track-label' });

    var classes = 'tier' + (source.className ? ' ' + source.className : '');
    this.row = makeElement('div', [this.viewportHolder, this.overlay, this.quantOverlay], { className: classes });

    if (!background) {
        this.row.style.background = 'none';
    }

    if (!browser.noDefaultLabels) this.row.appendChild(this.label);
    this.row.appendChild(this.notifierHolder);

    this.layoutHeight = 25;
    this.bumped = true;
    this.styleIdSeed = 0;
    if (source.quantLeapThreshold) {
        this.quantLeapThreshold = source.quantLeapThreshold;
    }
    if (this.dasSource.collapseSuperGroups) {
        this.bumped = false;
    }
    this.layoutWasDone = false;

    if (source.featureInfoPlugin) {
        this.addFeatureInfoPlugin(source.featureInfoPlugin);
    }

    this.initSources();

    var thisB = this;
    if (this.featureSource && this.featureSource.getDefaultFIPs && !source.noSourceFeatureInfo) {
        this.featureSource.getDefaultFIPs(function (fip) {
            if (fip) thisB.addFeatureInfoPlugin(fip);
        });
    }

    if (this.featureSource && this.featureSource.addReadinessListener) {
        this.readinessListener = function (ready) {
            thisB.notify(ready, -1);
        };
        this.featureSource.addReadinessListener(this.readinessListener);
    }

    if (this.featureSource && this.featureSource.addActivityListener) {
        this.activityListener = function (busy) {
            if (busy > 0) {
                thisB.loaderButton.style.display = 'inline-block';
            } else {
                thisB.loaderButton.style.display = 'none';
            }
            thisB.browser.pingActivity();
        };
        this.featureSource.addActivityListener(this.activityListener);
    }

    this.listeners = [];
    this.featuresLoadedListeners = [];
    this.firstRenderPromise = new Promise(function (resolve, reject) {
        return _this._resolveFirstRenderPromise = resolve;
    });
}

DasTier.prototype.destroy = function () {
    if (this.featureSource.removeReadinessListener) {
        this.featureSource.removeReadinessListener(this.readinessListener);
    }
    if (this.featureSource.removeActivityListener) {
        this.featureSource.removeActivityListener(this.activityListener);
    }
};

DasTier.prototype.setBackground = function (b) {
    this.background = b;
    this.viewportHolder.style.background = b;
};

DasTier.prototype.toString = function () {
    return this.id;
};

DasTier.prototype.addFeatureInfoPlugin = function (p) {
    if (!this.featureInfoPlugins) this.featureInfoPlugins = [];
    this.featureInfoPlugins.push(p);
};

DasTier.prototype.init = function () {
    var tier = this;
    return new Promise(function (resolve, reject) {

        if (tier.dasSource.style) {
            tier.setStylesheet({ styles: tier.dasSource.style });
            resolve(tier);
        } else {
            tier.status = 'Fetching stylesheet';
            tier.fetchStylesheet(function (ss, err) {
                if (err || !ss) {
                    tier.error = 'No stylesheet';
                    var ss = new DASStylesheet();
                    var defStyle = new DASStyle();
                    defStyle.glyph = 'BOX';
                    defStyle.BGCOLOR = 'blue';
                    defStyle.FGCOLOR = 'black';
                    ss.pushStyle({ type: 'default' }, null, defStyle);
                    tier.setStylesheet(ss);
                } else {
                    tier.setStylesheet(ss);
                    if (ss.geneHint) {
                        tier.dasSource.collapseSuperGroups = true;
                        tier.bumped = false;
                        tier.updateLabel();
                    }
                    tier._updateFromConfig();
                }
                resolve(tier);
            });
        }
    });
};

DasTier.prototype.setStylesheet = function (ss) {
    this.baseStylesheet = shallowCopy(ss);
    for (var si = 0; si < this.baseStylesheet.styles.length; ++si) {
        var sh = this.baseStylesheet.styles[si] = shallowCopy(this.baseStylesheet.styles[si]);
        sh._methodRE = sh._labelRE = sh._typeRE = null;
        sh.style = shallowCopy(sh.style);
        sh.style.id = 'style' + ++this.styleIdSeed;
    }
    this.baseStylesheetValidity = b64_sha1(miniJSONify(this.baseStylesheet));
    this._updateFromConfig();
};

DasTier.prototype.getSource = function () {
    return this.featureSource;
};

DasTier.prototype.getDesiredTypes = function (scale) {
    var sfs = this.getActiveStyleFilters(scale);
    if (sfs) return sfs.typeList();
};

DasTier.prototype.getActiveStyleFilters = function (scale) {
    var ssScale = this.browser.zoomForCurrentScale();

    if (this.stylesheet) {
        var styles = new StyleFilterSet();
        var ss = this.stylesheet.styles;
        for (var si = 0; si < ss.length; ++si) {
            var sh = ss[si];
            if (!sh.zoom || sh.zoom == ssScale) {
                styles.add(new StyleFilter(sh.type, sh.method, sh.label));
            }
        }
        return styles;
    }
};

DasTier.prototype.needsSequence = function (scale) {
    if (this.sequenceSource && scale < 5) {
        return true;
    } else if ((this.dasSource.bamURI || this.dasSource.bamBlob || this.dasSource.bwgURI || this.dasSource.bwgBlob) && scale < 20) {
        return true;
    }
    return false;
};

DasTier.prototype.setFeatures = function (chr, coverage, scale, features, sequence) {
    this.currentFeatures = features;
    this.currentSequence = sequence;
    this.knownChr = chr;
    this.knownCoverage = coverage;

    // only notify features loaded, if they are valid
    if (features) {
        sortFeatures(this);
        this.notifyFeaturesLoaded();
    }
};

DasTier.prototype.draw = function () {
    console.log("Use browser.getTierRenderer(tier).drawTier(tier)");
};

DasTier.prototype.findNextFeature = function (chr, pos, dir, fedge, callback) {
    if (this.quantLeapThreshold) {
        var width = this.browser.viewEnd - this.browser.viewStart + 1;
        pos = pos + width * dir / 2 | 0;
        this.featureSource.quantFindNextFeature(chr, pos, dir, this.quantLeapThreshold, callback);
    } else {
        if (this.knownCoverage && pos >= this.knownCoverage.min() && pos <= this.knownCoverage.max()) {
            if (this.currentFeatures) {
                var bestFeature = null;
                for (var fi = 0; fi < this.currentFeatures.length; ++fi) {
                    var f = this.currentFeatures[fi];
                    if (!f.min || !f.max) {
                        continue;
                    }
                    if (f.parents && f.parents.length > 0) {
                        continue;
                    }
                    if (dir < 0) {
                        if (fedge == 1 && f.max >= pos && f.min < pos) {
                            if (!bestFeature || f.min > bestFeature.min || f.min == bestFeature.min && f.max < bestFeature.max) {
                                bestFeature = f;
                            }
                        } else if (f.max < pos) {
                            if (!bestFeature || f.max > bestFeature.max || f.max == bestFeature.max && f.min < bestFeature.min || f.min == bestFeature.mmin && bestFeature.max >= pos) {
                                bestFeature = f;
                            }
                        }
                    } else {
                        if (fedge == 1 && f.min <= pos && f.max > pos) {
                            if (!bestFeature || f.max < bestFeature.max || f.max == bestFeature.max && f.min > bestFeature.min) {
                                bestFeature = f;
                            }
                        } else if (f.min > pos) {
                            if (!bestFeature || f.min < bestFeature.min || f.min == bestFeature.min && f.max > bestFeature.max || f.max == bestFeature.max && bestFeature.min <= pos) {
                                bestFeature = f;
                            }
                        }
                    }
                }
                if (bestFeature) {
                    return callback(bestFeature);
                }
                if (dir < 0) {
                    pos = this.browser.knownSpace.min;
                } else {
                    pos = this.browser.knownSpace.max;
                }
            }
        }

        this.trySourceFNF(chr, pos, dir, callback);
    }
};

DasTier.prototype.trySourceFNF = function (chr, pos, dir, callback) {
    var self = this;
    this.featureSource.findNextFeature(chr, pos, dir, function (feature) {
        if (!feature) callback(feature);

        var ss = self.browser.getSequenceSource();
        if (!ss) // We're probably in trouble, but return anyway.
            callback(feature);

        ss.getSeqInfo(feature.segment, function (si) {
            if (si) callback(feature);else self.trySourceFNF(feature.segment, dir > 0 ? 10000000000 : 0, dir, callback);
        });
    });
};

DasTier.prototype.updateLabel = function () {
    this.bumpButton.className = this.bumped ? 'fa fa-minus-circle' : 'fa fa-plus-circle';
    if (this.dasSource.collapseSuperGroups) {
        this.bumpButton.style.display = 'inline-block';
    } else {
        this.bumpButton.style.display = 'none';
    }
};

DasTier.prototype.updateHeight = function () {
    this.currentHeight = Math.max(Math.max(this.layoutHeight, this.label.clientHeight + 2), this.browser.minTierHeight);
    this.row.style.height = '' + this.currentHeight + 'px';
    this.browser.updateHeight();
};

DasTier.prototype.drawOverlay = function () {
    var t = this;
    var b = this.browser;
    var retina = b.retina && window.devicePixelRatio > 1;

    t.overlay.height = t.viewport.height;
    t.overlay.width = retina ? b.featurePanelWidth * 2 : b.featurePanelWidth;

    var g = t.overlay.getContext('2d');
    if (retina) {
        g.scale(2, 2);
    }

    var origin = b.viewStart;
    var visStart = b.viewStart;
    var visEnd = b.viewEnd;

    if (this.overlayLabelCanvas) {
        var offset = (this.glyphCacheOrigin - this.browser.viewStart) * this.browser.scale;
        g.save();
        g.translate(offset, 0);
        var drawStart = -offset + 2;
        if (this.dasSource.tierGroup) drawStart += 15;
        this.overlayLabelCanvas.draw(g, drawStart, b.featurePanelWidth - offset);
        g.restore();
    }

    for (var hi = 0; hi < b.highlights.length; ++hi) {
        var h = b.highlights[hi];
        if ((h.chr === b.chr || h.chr === 'chr' + b.chr) && h.min < visEnd && h.max > visStart) {
            g.globalAlpha = b.defaultHighlightAlpha;
            g.fillStyle = b.defaultHighlightFill;
            g.fillRect((h.min - origin) * b.scale, 0, (h.max - h.min) * b.scale, t.overlay.height);
        }
    }

    // t.oorigin = b.viewStart;
    t.overlay.style.width = b.featurePanelWidth;
    t.overlay.style.height = t.viewport.style.height;
    t.overlay.style.left = '0px';
};

DasTier.prototype.updateStatus = function (status) {
    var self = this;
    if (status) {
        this.status = status;
        this._notifierToStatus();
        var sd = sourceDataURI(this.dasSource);
        if (window.location.protocol === 'https:' && sourceDataURI(this.dasSource).indexOf('http:') == 0 && !this.checkedHTTP) {
            this.checkedHTTP = true;
            this.browser.canFetchPlainHTTP().then(function (can) {
                if (!can) {
                    self.warnHTTP = true;
                    self._notifierToStatus();
                }
            });
        }
    } else {
        if (this.status) {
            this.status = null;
            this._notifierToStatus();
        }
    }
};

DasTier.prototype.notify = function (message, timeout) {
    if (typeof timeout !== 'number') timeout = 2000;

    if (this.notifierFadeTimeout) {
        clearTimeout(this.notifierFadeTimeout);
        this.notifierFadeTimeout = null;
    }

    if (message) {
        this._notifierOn(message);
        if (timeout > 0) {
            var thisB = this;
            this.notifierFadeTimeout = setTimeout(function () {
                thisB._notifierToStatus();
            }, timeout);
        }
    } else {
        this._notifierToStatus();
    }
};

DasTier.prototype._notifierOn = function (message, warnHTTP) {
    removeChildren(this.notifier);
    if (warnHTTP) {
        this.notifier.appendChild(makeElement('span', [makeElement('a', '[HTTP Warning] ', { href: this.browser.httpWarningURL, target: "_blank" }), message]));
    } else {
        this.notifier.textContent = message;
    }
    this.notifier.style.opacity = 0.8;
};

DasTier.prototype._notifierOff = function () {
    this.notifier.style.opacity = 0;
};

DasTier.prototype._notifierToStatus = function () {
    if (this.status) {
        this._notifierOn(this.status, this.warnHTTP);
    } else {
        this._notifierOff();
    }
};

DasTier.prototype.setConfig = function (config) {
    this.config = config || {};
    this._updateFromConfig();
    this.notifyTierListeners();
};

DasTier.prototype.mergeStylesheet = function (newStyle) {
    this.mergeConfig({
        stylesheet: newStyle,
        stylesheetValidity: this.baseStylesheetValidity
    });
};

DasTier.prototype.mergeConfig = function (newConfig) {
    for (var k in newConfig) {
        this.config[k] = newConfig[k];
    }
    this._updateFromConfig();
    this.notifyTierListeners();
};

DasTier.prototype._updateFromConfig = function () {
    var needsRefresh = false;
    var needsReorder = false;

    if (typeof this.config.name === 'string') this.nameElement.textContent = this.config.name;else this.nameElement.textContent = this.dasSource.name;

    var wantedHeight = this.config.height || this.dasSource.forceHeight;
    if (wantedHeight != this.forceHeight) {
        this.forceHeight = wantedHeight;
        needsRefresh = true;
    }

    if (this.forceMinDynamic != this.config.forceMinDynamic) {
        this.forceMinDynamic = this.config.forceMinDynamic;
        needsRefresh = true;
    }

    var forceMin = this.config.forceMin != undefined ? this.config.forceMin : this.dasSource.forceMin;
    if (this.forceMin != forceMin) {
        this.forceMin = forceMin;
        needsRefresh = true;
    }

    if (this.forceMaxDynamic != this.config.forceMaxDynamic) {
        this.forceMaxDynamic = this.config.forceMaxDynamic;
        needsRefresh = true;
    }

    var forceMax = this.config.forceMax != undefined ? this.config.forceMax : this.dasSource.forceMax;
    if (this.forceMax != forceMax) {
        this.forceMax = forceMax;
        needsRefresh = true;
    }

    var quantLeapThreshold = null;
    if (this.config.quantLeapThreshold !== undefined) quantLeapThreshold = this.config.quantLeapThreshold;else if (this.dasSource.quantLeapThreshold !== undefined) quantLeapThreshold = this.dasSource.quantLeapThreshold;
    if (quantLeapThreshold != this.quantLeapThreshold) {
        this.quantLeapThreshold = quantLeapThreshold;
        needsRefresh = true;
    }

    // Possible FIXME -- are there cases where style IDs need to be reassigned?
    var stylesheet = null;
    if (this.config.stylesheetValidity == this.baseStylesheetValidity) stylesheet = this.config.stylesheet;
    stylesheet = stylesheet || this.baseStylesheet;
    if (this.stylesheet !== stylesheet) {
        this.stylesheet = stylesheet;
        needsRefresh = true;
    }

    var wantedPinned = this.config.pinned !== undefined ? this.config.pinned : this.dasSource.pinned;
    if (wantedPinned !== this.pinned) {
        this.pinned = wantedPinned;
        needsReorder = true;
    }

    var wantedSubtierMax = _typeof(this.config.subtierMax === 'number') ? this.config.subtierMax : this.dasSource.subtierMax || this.browser.defaultSubtierMax;
    if (wantedSubtierMax != this.subtierMax) {
        this.subtierMax = wantedSubtierMax;
        needsRefresh = true;
    }

    var wantedBumped;
    if (this.config.bumped !== undefined) {
        wantedBumped = this.config.bumped;
    } else if (this.dasSource.bumped !== undefined) {
        wantedBumped = this.dasSource.bumped;
    } else {
        wantedBumped = this.dasSource.collapseSuperGroups ? false : true;
    }
    if (wantedBumped !== this.bumped) {
        this.bumped = wantedBumped;
        needsRefresh = true;
        this.updateLabel();
    }

    if (needsRefresh) this.scheduleRedraw();

    if (needsReorder) this.browser.reorderTiers();
};

DasTier.prototype.scheduleRedraw = function () {
    if (!this.currentFeatures) return;

    var tier = this;

    if (!this.redrawTimeout) {
        this.redrawTimeout = setTimeout(function () {
            sortFeatures(tier); // Some render actions mutate the results of this,
            // => need to re-run before refreshing.
            var renderer = tier.browser.getTierRenderer(tier);
            renderer.drawTier(tier);
            tier.redrawTimeout = null;
        }, 10);
    }
};
DasTier.prototype.clearTierListeners = function () {
    this.listeners = [];
};

DasTier.prototype.addTierListener = function (l) {
    this.listeners.push(l);
};

DasTier.prototype.removeTierListener = function (l) {
    var idx = arrayIndexOf(this.listeners, l);
    if (idx >= 0) {
        this.listeners.splice(idx, 1);
    }
};

DasTier.prototype.notifyTierListeners = function (change) {
    for (var li = 0; li < this.listeners.length; ++li) {
        try {
            this.listeners[li](change);
        } catch (e) {
            console.log(e);
        }
    }
    this.browser.notifyTier();
};

DasTier.prototype.clearFeaturesLoadedListeners = function () {
    this.featuresLoadedListeners = [];
};

DasTier.prototype.addFeaturesLoadedListener = function (handler) {
    this.featuresLoadedListeners.push(handler);
};

DasTier.prototype.removeFeaturesLoadedListener = function (handler) {
    var idx = arrayIndexOf(this.featuresLoadedListeners, handler);
    if (idx >= 0) {
        this.featuresLoadedListeners.splice(idx, 1);
    }
};

DasTier.prototype.notifyFeaturesLoaded = function () {
    for (var li = 0; li < this.featuresLoadedListeners.length; ++li) {
        try {
            this.featuresLoadedListeners[li].call(this);
        } catch (e) {
            console.log(e);
        }
    }
};

DasTier.prototype.wasRendered = function () {
    this._resolveFirstRenderPromise();
};

if (typeof module !== 'undefined') {
    module.exports = {
        DasTier: DasTier
    };

    // Imported for side effects
    var fd = require('./feature-draw');
}

},{"./das":11,"./feature-draw":21,"./features":23,"./sha1":40,"./sourcecompare":42,"./style":44,"./utils":58,"es6-promise":63}],55:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// track-adder.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var sc = require('./sourcecompare');
    var sourcesAreEqual = sc.sourcesAreEqual;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var Observed = utils.Observed;

    var thub = require('./thub');
    var THUB_COMPARE = thub.THUB_COMPARE;
    var connectTrackHub = thub.connectTrackHub;

    var domui = require('./domui');
    var makeTreeTableSection = domui.makeTreeTableSection;

    var probeResource = require('./probe').probeResource;

    // Most of this could disappear if we leave all probing to the probe module...
    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;
    var readInt = bin.readInt;

    var lh3utils = require('./lh3utils');
    var unbgzf = lh3utils.unbgzf;

    var bam = require('./bam');
    var BAM_MAGIC = bam.BAM_MAGIC;
    var BAI_MAGIC = bam.BAI_MAGIC;

    var tbi = require('./tabix');
    var TABIX_MAGIC = tbi.TABIX_MAGIC;

    var das = require('./das');
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;
    var DASRegistry = das.DASRegistry;
    var coordsMatch = das.coordsMatch;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

Browser.prototype.currentlyActive = function (source) {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (sourcesAreEqual(this.tiers[ti].dasSource, source)) return this.tiers[ti];
    }
    return false;
};

Browser.prototype.makeButton = function (name, tooltip) {
    var regButton = makeElement('a', name, { href: '#' });
    if (tooltip) {
        this.makeTooltip(regButton, tooltip);
    }
    return makeElement('li', regButton);
};

function activateButton(addModeButtons, which) {
    for (var i = 0; i < addModeButtons.length; ++i) {
        var b = addModeButtons[i];
        if (b === which) {
            b.classList.add('active');
        } else {
            b.classList.remove('active');
        }
    }
}

Browser.prototype.showTrackAdder = function (ev) {
    if (this.uiMode === 'add') {
        this.hideToolPanel();
        this.setUiMode('none');
        return;
    }

    var thisB = this;

    var popup = makeElement('div', null, { className: 'dalliance' }, { width: '100%', display: 'inline-block', boxSizing: 'border-box', MozBoxSizing: 'border-box', verticalAlign: 'top', paddingRight: '15px' });

    var addModeButtons = [];
    var makeStab, makeStabObserver;

    if (!this.noRegistryTabs) {
        var regButton = this.makeButton('Registry', 'Browse compatible datasources from the DAS registry');
        addModeButtons.push(regButton);

        for (var m in this.mappableSources) {
            var mf = function mf(mm) {
                var mapButton = thisB.makeButton(thisB.chains[mm].srcTag, 'Browse datasources mapped from ' + thisB.chains[mm].srcTag);
                addModeButtons.push(mapButton);
                mapButton.addEventListener('click', function (ev) {
                    ev.preventDefault();ev.stopPropagation();
                    activateButton(addModeButtons, mapButton);
                    makeStab(thisB.mappableSources[mm], mm);
                }, false);
            };mf(m);
        }
    }

    var groupedDefaults = {};
    for (var si = 0; si < this.defaultSources.length; ++si) {
        var s = this.defaultSources[si];
        var g = s.group || 'Defaults';
        if (groupedDefaults[g]) {
            groupedDefaults[g].push(s);
        } else {
            groupedDefaults[g] = [s];
        }
    }

    var makeHubButton = function makeHubButton(tdb) {
        var hub = tdb.hub;
        var hubMenuButton = makeElement('i', null, { className: 'fa fa-list-alt' }, { cursor: 'context-menu' });
        var label = hub.altLabel || hub.shortLabel || 'Unknown';
        if (tdb.mapping) label = label + ' (' + tdb.genome + ')';
        var hbContent = makeElement('span', [label, ' ', hubMenuButton]);
        var hubButton = thisB.makeButton(hbContent, hub.longLabel);
        hubButton.hub = tdb;
        addModeButtons.push(hubButton);

        hubButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();
            activateButton(addModeButtons, hubButton);
            removeChildren(stabHolder);
            var loader = thisB.makeLoader(24);
            loader.style.marginLeft = 'auto';
            loader.style.marginRight = 'auto';
            loader.style.marginTop = '100px';
            stabHolder.appendChild(makeElement('div', loader, null, { textAlign: 'center' }));

            refreshButton.style.display = 'none';
            addButton.style.display = 'none';
            canButton.style.display = 'none';

            tdb.getTracks(function (tracks, err) {
                if (err) {
                    console.log(err);
                }

                makeHubStab(tracks);
            });
        }, false);

        hubMenuButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();

            var removeHubItem = makeElement('li', makeElement('a', 'Remove hub'));
            var allOnItem = makeElement('li', makeElement('a', 'Enable all'));
            var allOffItem = makeElement('li', makeElement('a', 'Disable all'));
            var hubMenu = makeElement('ul', [removeHubItem, allOnItem, allOffItem], { className: 'dropdown-menu' }, { display: 'block' });

            var mx = ev.clientX,
                my = ev.clientY;
            mx += document.documentElement.scrollLeft || document.body.scrollLeft;
            my += document.documentElement.scrollTop || document.body.scrollTop;

            hubMenu.style.position = 'absolute';
            hubMenu.style.top = '' + (my + 10) + 'px';
            hubMenu.style.left = '' + (mx - 30) + 'px';
            thisB.hPopupHolder.appendChild(hubMenu);

            var clickCatcher = function clickCatcher(ev) {
                console.log('cc');
                document.body.removeEventListener('click', clickCatcher, true);
                thisB.hPopupHolder.removeChild(hubMenu);
            };
            document.body.addEventListener('click', clickCatcher, true);

            removeHubItem.addEventListener('click', function (ev) {
                for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {
                    if (thisB.hubObjects[hi].absURL == tdb.absURL) {
                        thisB.hubObjects.splice(hi, 1);
                        break;
                    }
                }
                for (var hi = 0; hi < thisB.hubs.length; ++hi) {
                    var hc = thisB.hubs[hi];
                    if (typeof hc === 'string') hc = { url: hc };
                    if (hc.url == tdb.hub.url && !hc.genome || hc.genome == tdb.genome) {
                        thisB.hubs.splice(hi, 1);
                        break;
                    }
                }

                thisB.notifyTier();

                modeButtonHolder.removeChild(hubButton);
                activateButton(addModeButtons, addHubButton);
                switchToHubConnectMode();
            }, false);

            allOnItem.addEventListener('click', function (ev) {
                tdb.getTracks(function (tracks, err) {
                    if (err) {
                        console.log(err);
                    }

                    for (var ti = 0; ti < tracks.length; ++ti) {
                        var ds = tracks[ti].toDallianceSource();
                        if (!thisB.currentlyActive(ds)) {
                            thisB.addTier(ds);
                        }
                    }
                });
            }, false);

            allOffItem.addEventListener('click', function (ev) {
                tdb.getTracks(function (tracks, err) {
                    if (err) {
                        console.log(err);
                    }

                    for (var ti = 0; ti < tracks.length; ++ti) {
                        var ds = tracks[ti].toDallianceSource();
                        if (thisB.currentlyActive(ds)) {
                            thisB.removeTier(ds);
                        }
                    }
                });
            }, false);
        }, false);

        return hubButton;
    };

    var firstDefButton = null;
    var firstDefSources = null;
    for (var g in groupedDefaults) {
        (function (g, ds) {
            var defButton = thisB.makeButton(g, 'Browse the default set of data for this browser');
            defButton.addEventListener('click', function (ev) {
                ev.preventDefault();ev.stopPropagation();
                activateButton(addModeButtons, defButton);
                makeStab(new Observed(ds));
            }, false);
            addModeButtons.push(defButton);

            if (!firstDefButton) {
                firstDefButton = defButton;
                firstDefSources = ds;
            }
        })(g, groupedDefaults[g]);
    }
    var custButton = this.makeButton('DAS', 'Add arbitrary DAS data');
    addModeButtons.push(custButton);
    var binButton = this.makeButton('Binary', 'Add data in bigwig or bigbed format');
    addModeButtons.push(binButton);

    for (var hi = 0; hi < this.hubObjects.length; ++hi) {
        var hub = this.hubObjects[hi];
        makeHubButton(hub);
    }

    var addHubButton = this.makeButton('+', 'Connect to a new track-hub');
    addModeButtons.push(addHubButton);

    var modeButtonHolder = makeElement('ul', addModeButtons, { className: 'nav nav-tabs' }, { marginBottom: '0px' });
    popup.appendChild(modeButtonHolder);

    var custURL, custName, custCS, custQuant, custFile, custUser, custPass;
    var customMode = false;
    var dataToFinalize = null;

    var asform = makeElement('form', null, {}, { display: 'inline-block', width: '100%' });
    asform.addEventListener('submit', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        doAdd();
        return false;
    }, true);
    var stabHolder = makeElement('div');
    stabHolder.style.position = 'relative';
    stabHolder.style.overflow = 'scroll';
    // stabHolder.style.height = '500px';
    asform.appendChild(stabHolder);

    var __mapping;
    var __sourceHolder;

    makeStab = function makeStab(msources, mapping) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'none';
        canButton.style.display = 'none';
        if (__sourceHolder) {
            __sourceHolder.removeListener(makeStabObserver);
        }
        __mapping = mapping;
        __sourceHolder = msources;
        __sourceHolder.addListenerAndFire(makeStabObserver);
    };

    makeStabObserver = function makeStabObserver(msources) {
        customMode = false;
        var buttons = [];
        removeChildren(stabHolder);
        if (!msources) {
            stabHolder.appendChild(makeElement('p', 'Dalliance was unable to retrieve data source information from the DAS registry, please try again later'));
            return;
        }

        var stabBody = makeElement('tbody', null, { className: 'table table-striped table-condensed' }, { width: '100%' });
        var stab = makeElement('table', stabBody, { className: 'table table-striped table-condensed' }, { width: '100%', tableLayout: 'fixed' });
        var idx = 0;

        var sources = [];
        for (var i = 0; i < msources.length; ++i) {
            sources.push(msources[i]);
        }

        sources.sort(function (a, b) {
            return a.name.toLowerCase().trim().localeCompare(b.name.toLowerCase().trim());
        });

        for (var i = 0; i < sources.length; ++i) {
            var source = sources[i];
            var r = makeElement('tr');

            var bd = makeElement('td', null, {}, { width: '30px' });
            bd.style.textAlign = 'center';
            if (!source.props || source.props.cors) {
                var b = makeElement('input');
                b.type = 'checkbox';
                b.dalliance_source = source;
                if (__mapping) {
                    b.dalliance_mapping = __mapping;
                }
                // b.checked = thisB.currentlyActive(source);
                bd.appendChild(b);
                buttons.push(b);
                b.addEventListener('change', function (ev) {
                    if (ev.target.checked) {
                        thisB.addTier(ev.target.dalliance_source);
                    } else {
                        thisB.removeTier(ev.target.dalliance_source);
                    }
                });
            } else {
                bd.appendChild(document.createTextNode('!'));
                thisB.makeTooltip(bd, makeElement('span', ["This data source isn't accessible because it doesn't support ", makeElement('a', "CORS", { href: 'http://www.w3.org/TR/cors/' }), "."]));
            }
            r.appendChild(bd);
            var ld = makeElement('td');
            ld.appendChild(document.createTextNode(source.name));
            if (source.desc && source.desc.length > 0) {
                thisB.makeTooltip(ld, source.desc);
            }
            r.appendChild(ld);
            stabBody.appendChild(r);
            ++idx;
        }

        var setChecks = function setChecks() {
            for (var bi = 0; bi < buttons.length; ++bi) {
                var b = buttons[bi];
                var t = thisB.currentlyActive(b.dalliance_source);
                if (t) {
                    b.checked = true;
                } else {
                    b.checked = false;
                }
            }
        };
        setChecks();
        thisB.addTierListener(function (l) {
            setChecks();
        });

        stabHolder.appendChild(stab);
    };

    function makeHubStab(tracks) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'none';
        canButton.style.display = 'none';

        customMode = false;
        removeChildren(stabHolder);

        var ttab = makeElement('div', null, {}, { width: '100%' });
        var sources = [];
        for (var i = 0; i < tracks.length; ++i) {
            sources.push(tracks[i]);
        }

        sources.sort(function (a, b) {
            return a.shortLabel.toLowerCase().trim().localeCompare(b.shortLabel.toLowerCase().trim());
        });

        var groups = [];
        var tops = [];

        for (var ti = 0; ti < sources.length; ++ti) {
            var track = sources[ti];
            if (track.children && track.children.length > 0 && track.container != 'multiWig') {
                groups.push(track);
            } else {
                tops.push(track);
            }
        }
        if (tops.length > 0) {
            groups.push({
                shortLabel: 'Others',
                priority: -100000000,
                children: tops });
        }

        groups.sort(THUB_COMPARE);

        var buttons = [];
        for (var gi = 0; gi < groups.length; ++gi) {
            var group = groups[gi];
            var dg = group;
            if (!dg.dimensions && dg._parent && dg._parent.dimensions) dg = dg._parent;

            var dprops = {};
            if (dg.dimensions) {
                var dtoks = dg.dimensions.split(/(\w+)=(\w+)/);
                for (var dti = 0; dti < dtoks.length - 2; dti += 3) {
                    dprops[dtoks[dti + 1]] = dtoks[dti + 2];
                }
            }

            if (dprops.dimX && dprops.dimY) {
                var dimX = dprops.dimX,
                    dimY = dprops.dimY;
                var sgX = dg.subgroups[dimX];
                var sgY = dg.subgroups[dimY];

                var trks = {};
                for (var ci = 0; ci < group.children.length; ++ci) {
                    var child = group.children[ci];
                    var vX = child.sgm[dimX],
                        vY = child.sgm[dimY];
                    if (!trks[vX]) trks[vX] = {};
                    trks[vX][vY] = child;
                }

                var matrix = makeElement('table', null, { className: 'table table-striped table-condensed' }, { tableLayout: 'fixed' });
                {
                    var header = makeElement('tr');
                    header.appendChild(makeElement('th', null, {}, { width: '150px', height: '100px' })); // blank corner element
                    for (var si = 0; si < sgX.titles.length; ++si) {
                        var h = makeElement('th', makeElement('div', sgX.titles[si], {}, { transform: 'rotate(-60deg)',
                            transformOrigin: '0% 100%',
                            webkitTransform: 'rotate(-60deg) translate(20px,10px)',
                            webkitTransformOrigin: '0% 100%',
                            textAlign: 'left' }), {}, { width: '35px',
                            height: '100px',
                            verticalAlign: 'bottom' });
                        header.appendChild(h);
                    }
                    matrix.appendChild(header);
                }

                var mbody = makeElement('tbody', null, { className: 'table table-striped table-condensed' });
                for (var yi = 0; yi < sgY.titles.length; ++yi) {
                    var vY = sgY.tags[yi];
                    var row = makeElement('tr');
                    row.appendChild(makeElement('th', sgY.titles[yi]), {});

                    for (var xi = 0; xi < sgX.titles.length; ++xi) {
                        var vX = sgX.tags[xi];
                        var cell = makeElement('td');
                        if (trks[vX] && trks[vX][vY]) {
                            var track = trks[vX][vY];
                            var ds = track.toDallianceSource();
                            if (!ds) continue;

                            var r = makeElement('tr');
                            var bd = makeElement('td');
                            bd.style.textAlign = 'center';

                            var b = makeElement('input');
                            b.type = 'checkbox';
                            b.dalliance_source = ds;
                            if (__mapping) {
                                b.dalliance_mapping = __mapping;
                            }
                            buttons.push(b);
                            cell.appendChild(b);
                            b.addEventListener('change', function (ev) {
                                if (ev.target.checked) {
                                    thisB.addTier(ev.target.dalliance_source);
                                } else {
                                    thisB.removeTier(ev.target.dalliance_source);
                                }
                            });
                        }
                        row.appendChild(cell);
                    }
                    mbody.appendChild(row);
                }
                matrix.appendChild(mbody);
                ttab.appendChild(makeTreeTableSection(group.shortLabel, matrix, gi == 0));
            } else {
                var stabBody = makeElement('tbody', null, { className: 'table table-striped table-condensed' });
                var stab = makeElement('table', stabBody, { className: 'table table-striped table-condensed' }, { width: '100%', tableLayout: 'fixed' });
                var idx = 0;

                group.children.sort(THUB_COMPARE);
                for (var i = 0; i < group.children.length; ++i) {
                    var track = group.children[i];
                    var ds = track.toDallianceSource();
                    if (!ds) continue;

                    var r = makeElement('tr');
                    var bd = makeElement('td', null, {}, { width: '30px' });
                    bd.style.textAlign = 'center';

                    var b = makeElement('input');
                    b.type = 'checkbox';
                    b.dalliance_source = ds;
                    if (__mapping) {
                        b.dalliance_mapping = __mapping;
                    }
                    buttons.push(b);
                    bd.appendChild(b);
                    b.addEventListener('change', function (ev) {
                        if (ev.target.checked) {
                            thisB.addTier(ev.target.dalliance_source);
                        } else {
                            thisB.removeTier(ev.target.dalliance_source);
                        }
                    });

                    r.appendChild(bd);
                    var ld = makeElement('td');
                    ld.appendChild(document.createTextNode(track.shortLabel));
                    if (track.longLabel && track.longLabel.length > 0) {
                        thisB.makeTooltip(ld, track.longLabel);
                    }
                    r.appendChild(ld);
                    stabBody.appendChild(r);
                    ++idx;
                }

                if (groups.length > 1 || group.shortLabel !== 'Others') {
                    ttab.appendChild(makeTreeTableSection(group.shortLabel, stab, gi == 0));
                } else {
                    ttab.appendChild(stab);
                }
            }
        }

        var setChecks = function setChecks() {
            for (var bi = 0; bi < buttons.length; ++bi) {
                var b = buttons[bi];
                var t = thisB.currentlyActive(b.dalliance_source);
                if (t) {
                    b.checked = true;
                    b.disabled = t.sequenceSource != null;
                } else {
                    b.checked = false;
                }
            }
        };
        setChecks();
        thisB.addTierListener(function (l) {
            setChecks();
        });

        stabHolder.appendChild(ttab);
    }

    if (regButton) {
        regButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();
            activateButton(addModeButtons, regButton);
            makeStab(thisB.availableSources);
        }, false);
    }

    binButton.addEventListener('click', function (ev) {
        ev.preventDefault();ev.stopPropagation();
        switchToBinMode();
    }, false);
    addHubButton.addEventListener('click', function (ev) {
        ev.preventDefault();ev.stopPropagation();
        switchToHubConnectMode();
    }, false);

    function switchToBinMode() {
        activateButton(addModeButtons, binButton);
        customMode = 'bin';

        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        removeChildren(stabHolder);
        var pageHolder = makeElement('div', null, {}, { paddingLeft: '10px', paddingRight: '10px' });
        pageHolder.appendChild(makeElement('h3', 'Add custom URL-based data'));
        pageHolder.appendChild(makeElement('p', ['You can add indexed binary data hosted on an web server that supports CORS (', makeElement('a', 'full details', { href: 'http://www.biodalliance.org/bin.html' }), ').  Currently supported formats are bigwig, bigbed, and indexed BAM.']));

        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(document.createTextNode('URL: '));
        custURL = makeElement('input', '', { size: 80, value: 'http://www.biodalliance.org/datasets/ensGene.bb' }, { width: '100%' });
        pageHolder.appendChild(custURL);

        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(makeElement('b', '- or -'));
        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(document.createTextNode('File: '));
        custFile = makeElement('input', null, { type: 'file', multiple: 'multiple' });
        pageHolder.appendChild(custFile);

        pageHolder.appendChild(makeElement('p', 'Clicking the "Add" button below will initiate a series of test queries.'));

        stabHolder.appendChild(pageHolder);
        custURL.focus();
    }

    function switchToHubConnectMode() {
        activateButton(addModeButtons, addHubButton);
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        customMode = 'hub-connect';
        refreshButton.style.visibility = 'hidden';

        removeChildren(stabHolder);

        var pageHolder = makeElement('div', null, {}, { paddingLeft: '10px', paddingRight: '10px' });
        pageHolder.appendChild(makeElement('h3', 'Connect to a track hub.'));
        pageHolder.appendChild(makeElement('p', ['Enter the top-level URL (usually points to a file called "hub.txt") of a UCSC-style track hub']));

        custURL = makeElement('input', '', { size: 120, value: 'http://www.biodalliance.org/datasets/testhub/hub.txt' }, { width: '100%' });
        pageHolder.appendChild(custURL);

        stabHolder.appendChild(pageHolder);

        custURL.focus();
    }

    custButton.addEventListener('click', function (ev) {
        ev.preventDefault();ev.stopPropagation();
        switchToCustomMode();
    }, false);

    function switchToCustomMode() {
        activateButton(addModeButtons, custButton);
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        customMode = 'das';

        removeChildren(stabHolder);

        var customForm = makeElement('div', null, {}, { paddingLeft: '10px', paddingRight: '10px' });
        customForm.appendChild(makeElement('h3', 'Add custom DAS data'));
        customForm.appendChild(makeElement('p', 'This interface is intended for adding custom or lab-specific data.  Public data can be added more easily via the registry interface.'));

        customForm.appendChild(document.createTextNode('URL: '));
        customForm.appendChild(makeElement('br'));
        custURL = makeElement('input', '', { size: 80, value: 'http://www.derkholm.net:8080/das/medipseq_reads/' }, { width: '100%' });
        customForm.appendChild(custURL);

        customForm.appendChild(makeElement('p', 'Clicking the "Add" button below will initiate a series of test queries.  If the source is password-protected, you may be prompted to enter credentials.'));
        stabHolder.appendChild(customForm);

        custURL.focus();
    }

    var addButton = makeElement('button', 'Add', { className: 'btn btn-primary' });
    addButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        doAdd();
    }, false);

    function doAdd() {
        if (customMode) {
            if (customMode === 'das') {
                var curi = custURL.value.trim();
                if (!/^.+:\/\//.exec(curi)) {
                    curi = 'http://' + curi;
                }
                var nds = new DASSource({ name: 'temporary', uri: curi });
                tryAddDAS(nds);
            } else if (customMode === 'bin') {
                var fileList = custFile.files;

                if (fileList && fileList.length > 0) {
                    tryAddMultiple(fileList);
                } else {
                    var curi = custURL.value.trim();
                    if (!/^.+:\/\//.exec(curi)) {
                        curi = 'http://' + curi;
                    }
                    var source = { uri: curi };
                    var lcuri = curi.toLowerCase();
                    if (lcuri.indexOf("https://www.encodeproject.org/") == 0 && lcuri.indexOf("@@download") >= 0) {
                        source.transport = 'encode';
                    }
                    tryAddBin(source);
                }
            } else if (customMode === 'reset') {
                switchToCustomMode();
            } else if (customMode === 'reset-bin') {
                switchToBinMode();
            } else if (customMode === 'reset-hub') {
                switchToHubConnectMode();
            } else if (customMode === 'prompt-bai') {
                var fileList = custFile.files;
                if (fileList && fileList.length > 0 && fileList[0]) {
                    dataToFinalize.baiBlob = fileList[0];
                    completeBAM(dataToFinalize);
                } else {
                    promptForBAI(dataToFinalize);
                }
            } else if (customMode === 'prompt-tbi') {
                var fileList = custFile.files;
                if (fileList && fileList.length > 0 && fileList[0]) {
                    dataToFinalize.indexBlob = fileList[0];
                    completeTabixVCF(dataToFinalize);
                } else {
                    promptForTabix(dataToFinalize);
                }
            } else if (customMode === 'finalize' || customMode === 'finalize-bin') {
                dataToFinalize.name = custName.value;
                var m = custCS.value;
                if (m != '__default__') {
                    dataToFinalize.mapping = m;
                } else {
                    dataToFinalize.mapping = undefined;
                }
                if (custQuant) {
                    dataToFinalize.maxbins = custQuant.checked;
                }

                if (custUser.value.length > 1 && custPass.value.length > 1) {
                    dataToFinalize.xUser = custUser.value;
                    dataToFinalize.xPass = custPass.value;
                }

                thisB.addTier(dataToFinalize);

                if (customMode == 'finalize-bin') switchToBinMode();else switchToCustomMode();
            } else if (customMode === 'hub-connect') {
                var curi = custURL.value.trim();
                if (!/^.+:\/\//.exec(curi)) {
                    curi = 'http://' + curi;
                }

                tryAddHub(curi);
            } else if (customMode === 'multiple') {
                for (var mi = 0; mi < multipleSet.length; ++mi) {
                    var s = multipleSet[mi];
                    if (s.hidden) continue;

                    if (s.tier_type == 'bam' && !s.indexBlob && !s.indexUri) continue;
                    if (s.tier_type == 'tabix' && !s.indexBlob && !s.indexUri) continue;

                    var nds = makeSourceConfig(s);
                    if (nds) {
                        nds.noPersist = true;
                        thisB.addTier(nds);
                    }
                }

                switchToBinMode();
            }
        } else {
            thisB.removeAllPopups();
        }
    };

    function tryAddHub(curi, opts, retry) {
        opts = opts || {};
        for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {
            var h = thisB.hubObjects[hi];
            if (h.hub.url == curi) {
                for (var bi = 0; bi < addModeButtons.length; ++bi) {
                    if (addModeButtons[bi].hub == h) {
                        activateButton(addModeButtons, addModeButtons[bi]);
                    }
                }
                h.getTracks(function (tracks, err) {
                    if (err) {
                        console.log(err);
                    }
                    makeHubStab(tracks);
                });
                return;
            }
        }

        connectTrackHub(curi, function (hub, err) {
            if (err) {
                if (!retry) {
                    return tryAddHub(curi, { credentials: true }, true);
                }
                removeChildren(stabHolder);
                stabHolder.appendChild(makeElement('h2', 'Error connecting to track hub'));
                stabHolder.appendChild(makeElement('p', err));
                customMode = 'reset-hub';
                return;
            } else {
                var bestHub = null;
                var bestHubButton = null;
                for (var genome in hub.genomes) {
                    var mapping = null;
                    var okay = false;

                    if (genome == thisB.coordSystem.ucscName) {
                        okay = true;
                    } else {
                        for (var mid in thisB.chains) {
                            var m = thisB.chains[mid];
                            if (genome == m.coords.ucscName) {
                                mapping = mid;
                                okay = true;
                            }
                        }
                    }

                    if (okay) {
                        var hc = { url: curi, genome: genome };
                        if (opts.credentials) hc.credentials = true;
                        if (mapping) {
                            hc.mapping = mapping;
                            hub.genomes[genome].mapping = mapping;
                        }
                        thisB.hubs.push(hc);
                        thisB.hubObjects.push(hub.genomes[genome]);

                        var hubButton = makeHubButton(hub.genomes[genome]);
                        modeButtonHolder.appendChild(hubButton);

                        if (!mapping || !bestHub) {
                            bestHub = hub.genomes[genome];
                            bestHubButton = hubButton;
                        }
                    }
                }

                if (bestHub) {
                    thisB.notifyTier();
                    activateButton(addModeButtons, bestHubButton);
                    bestHub.getTracks(function (tracks, err) {
                        makeHubStab(tracks);
                    });
                } else {
                    removeChildren(stabHolder);
                    stabHolder.appendChild(makeElement('h2', 'No data for this genome'));
                    stabHolder.appendChild(makeElement('p', 'This URL appears to be a valid track-hub, but it doesn\'t contain any data for the coordinate system of this browser'));
                    stabHolder.appendChild(makeElement('p', 'coordSystem.ucscName = ' + thisB.coordSystem.ucscName));
                    customMode = 'reset-hub';
                    return;
                }
            }
        }, opts);
    }

    var tryAddDAS = function tryAddDAS(nds, retry) {
        var knownSpace = thisB.knownSpace;
        if (!knownSpace) {
            alert("Can't confirm track-addition to an uninit browser.");
            return;
        }
        var tsm = Math.max(knownSpace.min, (knownSpace.min + knownSpace.max - 100) / 2) | 0;
        var testSegment = new DASSegment(knownSpace.chr, tsm, Math.min(tsm + 99, knownSpace.max));
        nds.features(testSegment, {}, function (features, status) {
            if (status) {
                if (!retry) {
                    nds.credentials = true;
                    tryAddDAS(nds, true);
                } else {
                    removeChildren(stabHolder);
                    stabHolder.appendChild(makeElement('h2', 'Custom data not found'));
                    stabHolder.appendChild(makeElement('p', 'DAS uri: ' + nds.uri + ' is not answering features requests'));
                    customMode = 'reset';
                    return;
                }
            } else {
                var nameExtractPattern = new RegExp('/([^/]+)/?$');
                var match = nameExtractPattern.exec(nds.uri);
                if (match) {
                    nds.name = match[1];
                }

                tryAddDASxSources(nds);
                return;
            }
        });
    };

    function tryAddDASxSources(nds, retry) {
        var uri = nds.uri;
        if (retry) {
            var match = /(.+)\/[^\/]+\/?/.exec(uri);
            if (match) {
                uri = match[1] + '/sources';
            }
        }
        function sqfail() {
            if (!retry) {
                return tryAddDASxSources(nds, true);
            } else {
                return addDasCompletionPage(nds);
            }
        }
        new DASRegistry(uri, { credentials: nds.credentials }).sources(function (sources) {
            if (!sources || sources.length == 0) {
                return sqfail();
            }

            var fs = null;
            if (sources.length == 1) {
                fs = sources[0];
            } else {
                for (var i = 0; i < sources.length; ++i) {
                    if (sources[i].uri === nds.uri) {
                        fs = sources[i];
                        break;
                    }
                }
            }

            var coordsDetermined = false,
                quantDetermined = false;
            if (fs) {
                nds.name = fs.name;
                nds.desc = fs.desc;
                if (fs.maxbins) {
                    nds.maxbins = true;
                } else {
                    nds.maxbins = false;
                }
                if (fs.capabilities) {
                    nds.capabilities = fs.capabilities;
                }
                quantDetermined = true;

                if (fs.coords && fs.coords.length == 1) {
                    var coords = fs.coords[0];
                    if (coordsMatch(coords, thisB.coordSystem)) {
                        coordsDetermined = true;
                    } else if (thisB.chains) {
                        for (var k in thisB.chains) {
                            if (coordsMatch(coords, thisB.chains[k].coords)) {
                                nds.mapping = k;
                                coordsDetermined = true;
                            }
                        }
                    }
                }
            }
            return addDasCompletionPage(nds, coordsDetermined, quantDetermined);
        }, function () {
            return sqfail();
        });
    }

    var makeSourceConfig = function makeSourceConfig(s) {
        var nds = { name: s.name };
        if (s.credentials) nds.credentials = s.credentials;

        if (s.mapping && s.mapping != '__default__') nds.mapping = s.mapping;

        if (s.transport) nds.transport = s.transport;

        if (s.tier_type == 'bwg') {
            if (s.blob) nds.bwgBlob = s.blob;else if (s.uri) nds.bwgURI = s.uri;
            return nds;
        } else if (s.tier_type == 'bam') {
            if (s.blob) {
                nds.bamBlob = s.blob;
                nds.baiBlob = s.indexBlob;
            } else {
                nds.bamURI = s.uri;
                nds.baiURI = s.indexUri;
            }
            return nds;
        } else if (s.tier_type == 'tabix') {
            nds.tier_type = 'tabix';
            nds.payload = s.payload;
            if (s.blob) {
                nds.blob = s.blob;
                nds.indexBlob = s.indexBlob;
            } else {
                nds.uri = s.uri;
                nds.indexUri = s.indexUri;
            }
            return nds;
        } else if (s.tier_type == 'memstore') {
            nds.tier_type = 'memstore';
            nds.payload = s.payload;
            if (s.blob) nds.blob = s.blob;else nds.uri = s.uri;
            return nds;
        }
    };

    var tryAddBin = function tryAddBin(source) {
        probeResource(source, function (source, err) {
            if (err) {
                removeChildren(stabHolder);
                var tabError = makeElement('div');
                tabError.appendChild(makeElement('h2', "Couldn't access custom data"));
                tabError.appendChild(makeElement('p', '' + err));
                stabHolder.appendChild(tabError);
                console.log(source);
                if (window.location.protocol === 'https:' && source.uri.indexOf('http:') == 0) {
                    thisB.canFetchPlainHTTP().then(function (can) {
                        if (!can) {
                            tabError.appendChild(makeElement('p', [makeElement('strong', 'HTTP warning: '), 'you may not be able to access HTTP resources from an instance of Biodalliance which you are accessing via HTTPS.', makeElement('a', '[More info]', { href: thisB.httpWarningURL, target: "_blank" })]));
                        }
                    });
                }
                customMode = 'reset-bin';
            } else {
                var nds = makeSourceConfig(source);
                if (source.tier_type == 'bam') {
                    return completeBAM(nds);
                } else if (source.tier_type == 'tabix') {
                    return completeTabixVCF(nds);
                } else {
                    return addDasCompletionPage(nds, false, false, true);
                }
            }
        });
    };

    function promptForBAI(nds) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        customMode = 'prompt-bai';
        stabHolder.appendChild(makeElement('h2', 'Select an index file'));
        stabHolder.appendChild(makeElement('p', 'Dalliance requires a BAM index (.bai) file when displaying BAM data.  These normally accompany BAM files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));

        stabHolder.appendChild(document.createTextNode('Index file: '));
        custFile = makeElement('input', null, { type: 'file' });
        stabHolder.appendChild(custFile);
        dataToFinalize = nds;
    }

    function promptForTabix(nds) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        customMode = 'prompt-tbi';
        stabHolder.appendChild(makeElement('h2', 'Select an index file'));
        stabHolder.appendChild(makeElement('p', 'Dalliance requires a Tabix index (.tbi) file when displaying VCF data.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));

        stabHolder.appendChild(document.createTextNode('Index file: '));
        custFile = makeElement('input', null, { type: 'file' });
        stabHolder.appendChild(custFile);
        dataToFinalize = nds;
    }

    function completeBAM(nds) {
        var indexF;
        if (nds.baiBlob) indexF = new BlobFetchable(nds.baiBlob);else if (nds.transport == 'encode') indexF = new EncodeFetchable(nds.bamURI + '.bai');else indexF = new URLFetchable(nds.bamURI + '.bai', { credentials: nds.credentials });

        indexF.slice(0, 256).fetch(function (r) {
            var hasBAI = false;
            if (r) {
                var ba = new Uint8Array(r);
                var magic2 = readInt(ba, 0);
                hasBAI = magic2 == BAI_MAGIC;
            }
            if (hasBAI) {
                return addDasCompletionPage(nds, false, false, true);
            } else {
                return binFormatErrorPage('You have selected a valid BAM file, but a corresponding index (.bai) file was not found.  Please index your BAM (samtools index) and place the BAI file in the same directory');
            }
        });
    }

    function completeTabixVCF(nds) {
        var indexF;
        if (nds.indexBlob) {
            indexF = new BlobFetchable(nds.indexBlob);
        } else {
            indexF = new URLFetchable(nds.uri + '.tbi');
        }
        indexF.slice(0, 1 << 16).fetch(function (r) {
            var hasTabix = false;
            if (r) {
                var ba = new Uint8Array(r);
                if (ba[0] == 31 || ba[1] == 139) {
                    var unc = unbgzf(r);
                    ba = new Uint8Array(unc);
                    var m2 = readInt(ba, 0);
                    hasTabix = m2 == TABIX_MAGIC;
                }
            }
            if (hasTabix) {
                return addDasCompletionPage(nds, false, false, true);
            } else {
                return binFormatErrorPage('You have selected a valid VCF file, but a corresponding index (.tbi) file was not found.  Please index your VCF ("tabix -p vcf -f myfile.vcf.gz") and place the .tbi file in the same directory');
            }
        });
    }

    function binFormatErrorPage(message) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        message = message || 'Custom data format not recognized';
        stabHolder.appendChild(makeElement('h2', 'Error adding custom data'));
        stabHolder.appendChild(makeElement('p', message));
        stabHolder.appendChild(makeElement('p', 'Currently supported formats are bigBed, bigWig, and BAM.'));
        customMode = 'reset-bin';
        return;
    }

    var addDasCompletionPage = function addDasCompletionPage(nds, coordsDetermined, quantDetermined, quantIrrelevant) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        stabHolder.appendChild(makeElement('h2', 'Add custom data: step 2'));
        stabHolder.appendChild(document.createTextNode('Label: '));
        custName = makeElement('input', '', { value: nds.name });
        stabHolder.appendChild(custName);

        // stabHolder.appendChild(document.createTextNode('User: '));
        custUser = makeElement('input', '');
        // stabHolder.appendChild(custUser);
        //stabHolder.appendChild(document.createTextNode('Pass: '));
        custPass = makeElement('input', '');
        // stabHolder.appendChild(custPass);


        stabHolder.appendChild(makeElement('br'));
        stabHolder.appendChild(makeElement('br'));
        stabHolder.appendChild(makeElement('h4', 'Coordinate system: '));
        custCS = makeElement('select', null);
        custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), { value: '__default__' }));
        if (thisB.chains) {
            for (var csk in thisB.chains) {
                var cs = thisB.chains[csk].coords;
                custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), { value: csk }));
            }
        }
        custCS.value = nds.mapping || '__default__';
        stabHolder.appendChild(custCS);

        if (coordsDetermined) {
            stabHolder.appendChild(makeElement('p', "(Based on server response, probably doesn't need changing.)"));
        } else {
            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), "unable to determine the correct value from server responses.  Please check carefully."]));
            stabHolder.appendChild(makeElement('p', "If you don't see the mapping you're looking for, please contact thomas@biodalliance.org"));
        }

        if (!quantIrrelevant) {
            stabHolder.appendChild(document.createTextNode('Quantitative: '));
            custQuant = makeElement('input', null, { type: 'checkbox', checked: true });
            if (typeof nds.maxbins !== 'undefined') {
                custQuant.checked = nds.maxbins;
            }
            stabHolder.appendChild(custQuant);
            if (quantDetermined) {
                stabHolder.appendChild(makeElement('p', "(Based on server response, probably doesn't need changing.)"));
            } else {
                stabHolder.appendChild(makeElement('p', [makeElement('b', "Warning: "), "unable to determine correct value.  If in doubt, leave checked."]));
            }
        }

        if (nds.bwgBlob) {
            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), 'data added from local file.  Due to the browser security model, the track will disappear if you reload Dalliance.']));
        }

        custName.focus();

        if (customMode === 'bin' || customMode === 'prompt-bai' || customMode === 'prompt-tbi') customMode = 'finalize-bin';else customMode = 'finalize';
        dataToFinalize = nds;
    };

    var multipleSet = null;
    var tryAddMultiple = function tryAddMultiple(fileList) {
        var newSources = multipleSet = [];
        customMode = 'multiple';
        for (var fi = 0; fi < fileList.length; ++fi) {
            var f = fileList[fi];
            if (f) {
                newSources.push({ blob: f });
            }
        }

        for (var fi = 0; fi < newSources.length; ++fi) {
            probeMultiple(newSources[fi]);
        }
        updateMultipleStatus();
    };

    var probeMultiple = function probeMultiple(ns) {
        probeResource(ns, function (source, err) {
            if (err) {
                source.error = err;
            }

            var usedIndices = [];
            var bams = {},
                tabixes = {};
            for (var si = 0; si < multipleSet.length; ++si) {
                var s = multipleSet[si];
                if (s.tier_type == 'bam' && !s.indexBlob) {
                    bams[s.blob.name] = s;
                }
                if (s.tier_type == 'tabix' && !s.indexBlob) {
                    tabixes[s.blob.name] = s;
                }
            }

            for (var si = 0; si < multipleSet.length; ++si) {
                var s = multipleSet[si];
                if (s.tier_type === 'bai') {
                    var baiPattern = new RegExp('(.+)\\.bai$');
                    var match = baiPattern.exec(s.blob.name);
                    if (match && bams[match[1]]) {
                        bams[match[1]].indexBlob = s.blob;
                        usedIndices.push(si);
                    }
                } else if (s.tier_type === 'tabix-index') {
                    var tbiPattern = new RegExp('(.+)\\.tbi$');
                    var match = tbiPattern.exec(s.blob.name);
                    if (match && tabixes[match[1]]) {
                        tabixes[match[1]].indexBlob = s.blob;
                        usedIndices.push(si);
                    }
                }
            }

            for (var bi = usedIndices.length - 1; bi >= 0; --bi) {
                multipleSet.splice(usedIndices[bi], 1);
            }

            updateMultipleStatus();
        });
    };

    var updateMultipleStatus = function updateMultipleStatus() {
        removeChildren(stabHolder);
        var needsIndex = false;
        var multTable = makeElement('table', multipleSet.filter(function (s) {
            return !s.hidden;
        }).map(function (s) {
            var row = makeElement('tr');
            row.appendChild(makeElement('td', s.name || s.blob.name));
            var typeContent;
            if (s.error) {
                typeContent = makeElement('span', 'Error', null, { color: 'red' });
            } else if (s.tier_type) {
                typeContent = s.payload || s.tier_type;
            } else {
                typeContent = thisB.makeLoader(16);
            }

            var ccs;
            var state = 'unknown';
            if (s.tier_type == 'bwg' || s.tier_type == 'memstore') {
                state = 'okay';
            } else if (s.tier_type == 'bam') {
                state = s.indexBlob ? 'okay' : 'needs-index';
            } else if (s.tier_type == 'tabix') {
                state = s.indexBlob ? 'okay' : 'needs-index';
            }

            if (state == 'okay') {
                ccs = makeElement('select', null, null, { width: '150px' });
                ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), { value: '__default__' }));
                if (thisB.chains) {
                    for (var csk in thisB.chains) {
                        var cs = thisB.chains[csk].coords;
                        ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), { value: csk }));
                    }
                }
                ccs.value = s.mapping || '__default__';

                ccs.addEventListener('change', function (ev) {
                    s.mapping = ccs.value;
                    console.log(s);
                }, false);
            } else if (state == 'needs-index') {
                ccs = makeElement('span', 'Needs index', {}, { color: 'red' });
                needsIndex = true;
            }

            return makeElement('tr', [makeElement('td', s.name || s.blob.name), makeElement('td', typeContent), makeElement('td', ccs)]);
        }), { className: 'table table-striped table-condensed' });
        stabHolder.appendChild(multTable);

        if (needsIndex) {
            stabHolder.appendChild(makeElement('p', 'Some of these files are missing required index (.bai or .tbi) files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate index file'));
            stabHolder.appendChild(document.createTextNode('Index file(s): '));
            var indexFile = makeElement('input', null, { type: 'file', multiple: 'multiple' });
            stabHolder.appendChild(indexFile);
            indexFile.addEventListener('change', function (ev) {
                console.log('fileset changed');
                var fileList = indexFile.files || [];
                for (var fi = 0; fi < fileList.length; ++fi) {
                    var f = fileList[fi];
                    if (f) {
                        var ns = { blob: f, hidden: true };
                        multipleSet.push(ns);
                        probeMultiple(ns);
                    }
                }
            }, false);
        }
    };

    var canButton = makeElement('button', 'Cancel', { className: 'btn' });
    canButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        if (customMode === 'finalize-bin') switchToBinMode();else switchToCustomMode();
    }, false);

    var refreshButton = makeElement('button', 'Refresh', { className: 'btn' });
    refreshButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        thisB.queryRegistry(__mapping);
    }, false);
    this.makeTooltip(refreshButton, 'Click to re-fetch data from the DAS registry');

    var buttonHolder = makeElement('div', [addButton, ' ', canButton, ' ', refreshButton]);
    buttonHolder.style.margin = '10px';
    asform.appendChild(buttonHolder);

    popup.appendChild(asform);
    makeStab(thisB.availableSources);

    this.showToolPanel(popup);
    this.setUiMode('add');

    if (firstDefButton) {
        activateButton(addModeButtons, firstDefButton);
        makeStab(new Observed(firstDefSources));
    }
};

},{"./bam":1,"./bin":4,"./cbrowser":6,"./das":11,"./domui":13,"./encode":15,"./lh3utils":27,"./probe":32,"./sourcecompare":42,"./tabix":49,"./thub":51,"./utils":58}],56:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// trix.js: UCSC-style free text indices
//

"use strict";

function connectTrix(ix, ixx, callback) {
    ixx.fetchAsText(function (ixxData) {
        if (!ixxData) return callback(null, "Couldn't fetch index-index");

        var toks = ixxData.split(/(.+)([0-9A-F]{10})\n/);

        var keys = [];
        var offsets = [];
        for (var ti = 1; ti < toks.length; ti += 3) {
            keys.push(toks[ti]);
            offsets.push(parseInt(toks[ti + 1], 16));
        }

        return callback(new TrixIndex(keys, offsets, ix));
    });
}

function TrixIndex(keys, offsets, ix) {
    this.keys = keys;
    this.offsets = offsets;
    this.ix = ix;
}

TrixIndex.prototype.lookup = function (query, callback) {
    var ixslice;

    var qtag = (query + '     ').substring(0, 5).toLowerCase();
    for (var i = 0; i < this.keys.length; ++i) {
        if (qtag.localeCompare(this.keys[i]) < 0) {
            ixslice = this.ix.slice(this.offsets[i - 1], this.offsets[i] - this.offsets[i - 1]);
            break;
        }
    }

    if (!ixslice) {
        ixslice = this.ix.slice(this.offsets[this.offsets.length - 1]);
    }

    ixslice.fetchAsText(function (ist) {
        var lines = ist.split('\n');
        for (var li = 0; li < lines.length; ++li) {
            if (lines[li].indexOf(query.toLowerCase() + ' ') == 0) {
                return callback(lines[li].split(' '));
            }
        }
        return callback(null);
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        connectTrix: connectTrix
    };
}

},{}],57:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// twoBit.js: packed-binary reference sequences
//

"use strict";

if (typeof require !== 'undefined') {
    var bin = require('./bin');
    var readInt = bin.readInt;
    var readIntBE = bin.readIntBE;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;
}

var TWOBIT_MAGIC = 0x1a412743;
var TWOBIT_MAGIC_BE = 0x4327411a;
var HEADER_BLOCK_SIZE = 12500;

function TwoBitFile() {}

function makeTwoBit(fetchable, cnt) {
    var tb = new TwoBitFile();
    tb.data = fetchable;
    var headerBlockSize = HEADER_BLOCK_SIZE;
    var headerBlocksFetched = 0;

    tb.data.slice(0, headerBlockSize).fetch(function (r) {
        if (!r) {
            return cnt(null, "Couldn't access data");
        }
        var ba = new Uint8Array(r);
        var magic = readInt(ba, 0);
        if (magic == TWOBIT_MAGIC) {
            tb.readInt = readInt;
        } else if (magic == TWOBIT_MAGIC_BE) {
            tb.readInt = readIntBE;
        } else {
            return cnt(null, "Not a .2bit file, magic=0x" + magic.toString(16));
        }

        var version = tb.readInt(ba, 4);
        if (version != 0) {
            return cnt(null, 'Unsupported version ' + version);
        }

        tb.seqCount = tb.readInt(ba, 8);
        tb.seqDict = {};

        var p = 16,
            i = 0;
        var o = 0; // Offset of the current block if we need to fetch multiple header blocks.

        var parseSeqInfo = function parseSeqInfo() {
            while (i < tb.seqCount) {
                var ns = ba[p];
                if (p + ns + 6 >= ba.length) {
                    headerBlocksFetched += headerBlockSize;
                    headerBlockSize = Math.max(HEADER_BLOCK_SIZE, Math.floor(headerBlocksFetched * tb.seqCount / i));
                    return tb.data.slice(o + p, headerBlockSize).fetch(function (r) {
                        o += p;
                        p = 0;
                        ba = new Uint8Array(r);
                        parseSeqInfo();
                    });
                } else {
                    ++p;
                    var name = '';
                    for (var j = 1; j <= ns; ++j) {
                        name += String.fromCharCode(ba[p++]);
                    }
                    var offset = tb.readInt(ba, p);
                    p += 4;
                    tb.seqDict[name] = new TwoBitSeq(tb, offset);
                    ++i;
                }
            }
            return cnt(tb);
        };

        parseSeqInfo();
    });
}

TwoBitFile.prototype.getSeq = function (chr) {
    var seq = this.seqDict[chr];
    if (!seq) {
        seq = this.seqDict['chr' + chr];
    }
    return seq;
};

TwoBitFile.prototype.fetch = function (chr, min, max, cnt) {
    var seq = this.getSeq(chr);
    if (!seq) {
        return cnt(null, "Couldn't find " + chr);
    } else if (max <= min) {
        return cnt('');
    } else {
        seq.fetch(min, max, cnt);
    }
};

function TwoBitSeq(tbf, offset) {
    this.tbf = tbf;
    this.offset = offset;
}

TwoBitSeq.prototype.init = function (cnt) {
    if (this.seqOffset) {
        return cnt();
    }

    var thisB = this;
    thisB.tbf.data.slice(thisB.offset, 8).fetch(function (r1) {
        if (!r1) {
            return cnt('Fetch failed');
        }
        var ba = new Uint8Array(r1);
        thisB._length = thisB.tbf.readInt(ba, 0);
        thisB.nBlockCnt = thisB.tbf.readInt(ba, 4);
        thisB.tbf.data.slice(thisB.offset + 8, thisB.nBlockCnt * 8 + 4).fetch(function (r2) {
            if (!r2) {
                return cnt('Fetch failed');
            }
            var ba = new Uint8Array(r2);
            var nbs = null;
            for (var b = 0; b < thisB.nBlockCnt; ++b) {
                var nbMin = thisB.tbf.readInt(ba, b * 4);
                var nbLen = thisB.tbf.readInt(ba, (b + thisB.nBlockCnt) * 4);
                var nb = new Range(nbMin, nbMin + nbLen - 1);
                if (!nbs) {
                    nbs = nb;
                } else {
                    nbs = union(nbs, nb);
                }
            }
            thisB.nBlocks = nbs;
            thisB.mBlockCnt = thisB.tbf.readInt(ba, thisB.nBlockCnt * 8);
            thisB.seqLength = (thisB._length + 3) / 4 | 0;
            thisB.seqOffset = thisB.offset + 16 + (thisB.nBlockCnt + thisB.mBlockCnt) * 8;
            return cnt();
        });
    });
};

var TWOBIT_TABLE = ['T', 'C', 'A', 'G'];

TwoBitSeq.prototype.fetch = function (min, max, cnt) {
    --min;--max; // Switch to zero-based.
    var thisB = this;
    this.init(function (error) {
        if (error) {
            return cnt(null, error);
        }

        var fetchMin = min >> 2;
        var fetchMax = max + 3 >> 2;
        if (fetchMin < 0 || fetchMax > thisB.seqLength) {
            return cnt('Coordinates out of bounds: ' + min + ':' + max);
        }

        thisB.tbf.data.slice(thisB.seqOffset + fetchMin, fetchMax - fetchMin).salted().fetch(function (r) {
            if (r == null) {
                return cnt('SeqFetch failed');
            }
            var seqData = new Uint8Array(r);

            var nSpans = [];
            if (thisB.nBlocks) {
                var intr = intersection(new Range(min, max), thisB.nBlocks);
                if (intr) {
                    nSpans = intr.ranges();
                }
            }

            var seqstr = '';
            var ptr = min;
            function fillSeq(fsm) {
                while (ptr <= fsm) {
                    var bb = (ptr >> 2) - fetchMin;
                    var ni = ptr & 0x3;
                    var bv = seqData[bb];
                    var n;
                    if (ni == 0) {
                        n = bv >> 6 & 0x3;
                    } else if (ni == 1) {
                        n = bv >> 4 & 0x3;
                    } else if (ni == 2) {
                        n = bv >> 2 & 0x3;
                    } else {
                        n = bv & 0x3;
                    }
                    seqstr += TWOBIT_TABLE[n];
                    ++ptr;
                }
            }

            for (var b = 0; b < nSpans.length; ++b) {
                var nb = nSpans[b];
                if (ptr > nb.min()) {
                    throw 'N mismatch...';
                }
                if (ptr < nb.min()) {
                    fillSeq(nb.min() - 1);
                }
                while (ptr <= nb.max()) {
                    seqstr += 'N';
                    ++ptr;
                }
            }
            if (ptr <= max) {
                fillSeq(max);
            }
            return cnt(seqstr);
        });
    });
};

TwoBitSeq.prototype.length = function (cnt) {
    var thisB = this;
    this.init(function (error) {
        if (error) {
            return cnt(null, error);
        } else {
            return cnt(thisB._length);
        }
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        makeTwoBit: makeTwoBit
    };
}

},{"./bin":4,"./spans":43}],58:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// utils.js: odds, sods, and ends.
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;
}

var NUM_REGEXP = new RegExp('[0-9]+');

function stringToNumbersArray(str) {
    var nums = new Array();
    var m;
    while (m = NUM_REGEXP.exec(str)) {
        nums.push(m[0]);
        str = str.substring(m.index + m[0].length);
    }
    return nums;
}

var STRICT_NUM_REGEXP = new RegExp('^[0-9]+$');

function stringToInt(str) {
    str = str.replace(new RegExp(',', 'g'), '');
    if (!STRICT_NUM_REGEXP.test(str)) {
        return null;
    }
    return str | 0;
}

function pushnew(a, v) {
    for (var i = 0; i < a.length; ++i) {
        if (a[i] == v) {
            return;
        }
    }
    a.push(v);
}

function pusho(obj, k, v) {
    if (obj[k]) {
        obj[k].push(v);
    } else {
        obj[k] = [v];
    }
}

function pushnewo(obj, k, v) {
    var a = obj[k];
    if (a) {
        for (var i = 0; i < a.length; ++i) {
            // indexOf requires JS16 :-(.
            if (a[i] == v) {
                return;
            }
        }
        a.push(v);
    } else {
        obj[k] = [v];
    }
}

function pick(a, b, c, d) {
    if (a) {
        return a;
    } else if (b) {
        return b;
    } else if (c) {
        return c;
    } else if (d) {
        return d;
    }
}

function pushnew(l, o) {
    for (var i = 0; i < l.length; ++i) {
        if (l[i] == o) {
            return;
        }
    }
    l.push(o);
}

function arrayIndexOf(a, x) {
    if (!a) {
        return -1;
    }

    for (var i = 0; i < a.length; ++i) {
        if (a[i] === x) {
            return i;
        }
    }
    return -1;
}

function arrayRemove(a, x) {
    var i = arrayIndexOf(a, x);
    if (i >= 0) {
        a.splice(i, 1);
        return true;
    }
    return false;
}

//
// DOM utilities
//


function makeElement(tag, children, attribs, styles) {
    var ele = document.createElement(tag);
    if (children) {
        if (!(children instanceof Array)) {
            children = [children];
        }
        for (var i = 0; i < children.length; ++i) {
            var c = children[i];
            if (c) {
                if (typeof c == 'string') {
                    c = document.createTextNode(c);
                } else if (typeof c == 'number') {
                    c = document.createTextNode('' + c);
                }
                ele.appendChild(c);
            }
        }
    }

    if (attribs) {
        for (var l in attribs) {
            try {
                ele[l] = attribs[l];
            } catch (e) {
                console.log('error setting ' + l);
                throw e;
            }
        }
    }
    if (styles) {
        for (var l in styles) {
            ele.style[l] = styles[l];
        }
    }
    return ele;
}

function makeElementNS(namespace, tag, children, attribs) {
    var ele = document.createElementNS(namespace, tag);
    if (children) {
        if (!(children instanceof Array)) {
            children = [children];
        }
        for (var i = 0; i < children.length; ++i) {
            var c = children[i];
            if (typeof c == 'string') {
                c = document.createTextNode(c);
            }
            ele.appendChild(c);
        }
    }

    setAttrs(ele, attribs);
    return ele;
}

var attr_name_cache = {};

function setAttr(node, key, value) {
    var attr = attr_name_cache[key];
    if (!attr) {
        var _attr = '';
        for (var c = 0; c < key.length; ++c) {
            var cc = key.substring(c, c + 1);
            var lcc = cc.toLowerCase();
            if (lcc != cc) {
                _attr = _attr + '-' + lcc;
            } else {
                _attr = _attr + cc;
            }
        }
        attr_name_cache[key] = _attr;
        attr = _attr;
    }
    node.setAttribute(attr, value);
}

function setAttrs(node, attribs) {
    if (attribs) {
        for (var l in attribs) {
            setAttr(node, l, attribs[l]);
        }
    }
}

function removeChildren(node) {
    if (!node || !node.childNodes) {
        return;
    }

    while (node.childNodes.length > 0) {
        node.removeChild(node.firstChild);
    }
}

//
// WARNING: not for general use!
//

function miniJSONify(o, exc) {
    if (typeof o === 'undefined') {
        return 'undefined';
    } else if (o == null) {
        return 'null';
    } else if (typeof o == 'string') {
        return "'" + o + "'";
    } else if (typeof o == 'number') {
        return "" + o;
    } else if (typeof o == 'boolean') {
        return "" + o;
    } else if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) == 'object') {
        if (o instanceof Array) {
            var s = null;
            for (var i = 0; i < o.length; ++i) {
                s = (s == null ? '' : s + ', ') + miniJSONify(o[i], exc);
            }
            return '[' + (s ? s : '') + ']';
        } else {
            exc = exc || {};
            var s = null;
            for (var k in o) {
                if (exc[k]) continue;
                if (k != undefined && typeof o[k] != 'function') {
                    s = (s == null ? '' : s + ', ') + k + ': ' + miniJSONify(o[k], exc);
                }
            }
            return '{' + (s ? s : '') + '}';
        }
    } else {
        return typeof o === 'undefined' ? 'undefined' : _typeof(o);
    }
}

function shallowCopy(o) {
    var n = {};
    for (var k in o) {
        n[k] = o[k];
    }
    return n;
}

function Observed(x) {
    this.value = x;
    this.listeners = [];
}

Observed.prototype.addListener = function (f) {
    this.listeners.push(f);
};

Observed.prototype.addListenerAndFire = function (f) {
    this.listeners.push(f);
    f(this.value);
};

Observed.prototype.removeListener = function (f) {
    arrayRemove(this.listeners, f);
};

Observed.prototype.get = function () {
    return this.value;
};

Observed.prototype.set = function (x) {
    this.value = x;
    for (var i = 0; i < this.listeners.length; ++i) {
        this.listeners[i](x);
    }
};

function Awaited() {
    this.queue = [];
}

Awaited.prototype.provide = function (x) {
    if (this.res !== undefined) {
        throw "Resource has already been provided.";
    }

    this.res = x;
    for (var i = 0; i < this.queue.length; ++i) {
        this.queue[i](x);
    }
    this.queue = null; // avoid leaking closures.
};

Awaited.prototype.await = function (f) {
    if (this.res !== undefined) {
        f(this.res);
        return this.res;
    } else {
        this.queue.push(f);
    }
};

var __dalliance_saltSeed = 0;

function saltURL(url) {
    return url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++__dalliance_saltSeed);
}

function textXHR(url, callback, opts) {
    if (opts && opts.salt) url = saltURL(url);

    try {
        var timeout;
        if (opts && opts.timeout) {
            timeout = setTimeout(function () {
                console.log('timing out ' + url);
                req.abort();
                return callback(null, 'Timeout');
            }, opts.timeout);
        }

        var req = new XMLHttpRequest();
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (timeout) clearTimeout(timeout);
                if (req.status < 200 || req.status >= 300) {
                    callback(null, 'Error code ' + req.status);
                } else {
                    callback(req.responseText);
                }
            }
        };

        req.open('GET', url, true);
        req.responseType = 'text';

        if (opts && opts.credentials) {
            req.withCredentials = true;
        }
        req.send();
    } catch (e) {
        callback(null, 'Exception ' + e);
    }
}

function relativeURL(base, rel) {
    // FIXME quite naive -- good enough for trackhubs?

    if (rel.indexOf('http:') == 0 || rel.indexOf('https:') == 0) {
        return rel;
    }

    var li = base.lastIndexOf('/');
    if (li >= 0) {
        return base.substr(0, li + 1) + rel;
    } else {
        return rel;
    }
}

var AMINO_ACID_TRANSLATION = {
    'TTT': 'F',
    'TTC': 'F',
    'TTA': 'L',
    'TTG': 'L',
    'CTT': 'L',
    'CTC': 'L',
    'CTA': 'L',
    'CTG': 'L',
    'ATT': 'I',
    'ATC': 'I',
    'ATA': 'I',
    'ATG': 'M',
    'GTT': 'V',
    'GTC': 'V',
    'GTA': 'V',
    'GTG': 'V',
    'TCT': 'S',
    'TCC': 'S',
    'TCA': 'S',
    'TCG': 'S',
    'CCT': 'P',
    'CCC': 'P',
    'CCA': 'P',
    'CCG': 'P',
    'ACT': 'T',
    'ACC': 'T',
    'ACA': 'T',
    'ACG': 'T',
    'GCT': 'A',
    'GCC': 'A',
    'GCA': 'A',
    'GCG': 'A',
    'TAT': 'Y',
    'TAC': 'Y',
    'TAA': '*', // stop
    'TAG': '*', // stop
    'CAT': 'H',
    'CAC': 'H',
    'CAA': 'Q',
    'CAG': 'Q',
    'AAT': 'N',
    'AAC': 'N',
    'AAA': 'K',
    'AAG': 'K',
    'GAT': 'D',
    'GAC': 'D',
    'GAA': 'E',
    'GAG': 'E',
    'TGT': 'C',
    'TGC': 'C',
    'TGA': '*', // stop
    'TGG': 'W',
    'CGT': 'R',
    'CGC': 'R',
    'CGA': 'R',
    'CGG': 'R',
    'AGT': 'S',
    'AGC': 'S',
    'AGA': 'R',
    'AGG': 'R',
    'GGT': 'G',
    'GGC': 'G',
    'GGA': 'G',
    'GGG': 'G'
};

function resolveUrlToPage(rel) {
    return makeElement('a', null, { href: rel }).href;
}

//
// Missing APIs
// 

if (!('trim' in String.prototype)) {
    String.prototype.trim = function () {
        return this.replace(/^\s+/, '').replace(/\s+$/, '');
    };
}

if (typeof module !== 'undefined') {
    module.exports = {
        textXHR: textXHR,
        relativeURL: relativeURL,
        resolveUrlToPage: resolveUrlToPage,
        shallowCopy: shallowCopy,
        pusho: pusho,
        pushnew: pushnew,
        pushnewo: pushnewo,
        arrayIndexOf: arrayIndexOf,
        pick: pick,

        makeElement: makeElement,
        makeElementNS: makeElementNS,
        removeChildren: removeChildren,

        miniJSONify: miniJSONify,

        Observed: Observed,
        Awaited: Awaited,

        AMINO_ACID_TRANSLATION: AMINO_ACID_TRANSLATION
    };
}

},{"./sha1":40}],59:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// vcf.js
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerParserFactory = sa.registerParserFactory;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;
}

function VCFParser() {
    this.info = [];
}

var VCF_INFO_RE = /([^;=]+)(=([^;]+))?;?/;
var VCF_INFO_HEADER = /##INFO=<([^>]+)>/;
var VCF_INFO_HEADER_TOK = /([^,=]+)=([^,]+|"[^"]+"),?/;

VCFParser.prototype.createSession = function (sink) {
    return new VCFParseSession(this, sink);
};

function VCFParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
}

VCFParseSession.prototype.parse = function (line) {
    if (line.length == 0) return;
    if (line[0] == '#') {
        if (line.length > 1 && line[1] == '#') {
            var m = VCF_INFO_HEADER.exec(line);
            if (m) {
                var toks = m[1].split(VCF_INFO_HEADER_TOK);
                var id = null,
                    desc = null;
                for (var ti = 0; ti < toks.length - 1; ti += 3) {
                    var key = toks[ti + 1];
                    var value = toks[ti + 2].replace(/"/g, '');
                    if (key == 'ID') {
                        id = value;
                    } else if (key == 'Description') {
                        desc = value;
                    }
                }
                if (id && desc) {
                    this.parser.info.push({ id: id,
                        desc: desc });
                }
            }
            return;
        } else {
            return;
        }
    }

    var toks = line.split('\t');
    var f = new DASFeature();
    f.segment = toks[0];
    f.id = toks[2];
    f.refAllele = toks[3];
    f.altAlleles = toks[4].split(',');
    f.min = parseInt(toks[1]);
    f.max = f.min + f.refAllele.length - 1;

    var infoToks = toks[7].split(VCF_INFO_RE);
    f.info = {};
    for (var ti = 0; ti < infoToks.length; ti += 4) {
        f.info[infoToks[ti + 1]] = infoToks[ti + 3];
    }

    var alt = f.altAlleles[0];
    var ref = f.refAllele;
    if (alt.length > ref.length) {
        f.type = "insertion";
        if (alt.indexOf(ref) == 0) {
            f.insertion = alt.substr(ref.length);
            f.min += ref.length;
            f.max = f.min - 1; // Effectively "between" bases.
        } else {
            f.insertion = alt;
        }
    } else if (alt.length < ref.length) {
        f.type = "deletion";
    } else {
        f.type = 'substitution';
    }

    this.sink(f);
};

VCFParseSession.prototype.flush = function () {};

VCFParser.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();

    {
        var varStyle = new DASStyle();
        varStyle.glyph = '__INSERTION';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'insertion' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(255, 60, 60)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'deletion' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'default' }, null, varStyle);
    }

    return callback(stylesheet);
};

VCFParser.prototype.getDefaultFIPs = function (callback) {
    var self = this;
    var fip = function fip(feature, featureInfo) {
        featureInfo.add("Ref. allele", feature.refAllele);
        featureInfo.add("Alt. alleles", feature.altAlleles.join(','));

        if (feature.info) {
            for (var ii = 0; ii < self.info.length; ++ii) {
                var info = self.info[ii];
                var val = feature.info[info.id];
                if (val !== undefined) {
                    featureInfo.add(info.desc, val);
                }
            }
        }
    };
    callback(fip);
};

dalliance_registerParserFactory('vcf', function () {
    return new VCFParser();
});

},{"./das":11,"./sourceadapters":41}],60:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// version.js
//

"use strict";

var VERSION = {
    CONFIG: 5,
    MAJOR: 0,
    MINOR: 13,
    MICRO: 7,
    BRANCH: 'dev'
};

VERSION.toString = function () {
    var vs = '' + this.MAJOR + '.' + this.MINOR + '.' + this.MICRO;
    if (this.PATCH) {
        vs = vs + this.PATCH;
    }
    if (this.BRANCH && this.BRANCH != '') {
        vs = vs + '-' + this.BRANCH;
    }
    return vs;
};

if (typeof module !== 'undefined') {
    module.exports = VERSION;
}

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapRenderer = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* jshint esversion: 6 */

// renderer that wraps a purescript renderer to add rulers, quant stuff, etc.

var _defaultRenderer = require("./default-renderer.es6");

var DefaultRenderer = _interopRequireWildcard(_defaultRenderer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.wrapRenderer = wrapRenderer;


function wrapRenderer(glyphifyFeatures, canvasHeight) {

    var prepareSubtiers = function prepareSubtiers(tier) {

        var view = { viewStart: tier.browser.viewStart,
            scale: tier.browser.scale,
            height: canvasHeight,
            chr: tier.knownChr
        };

        var features = tier.currentFeatures;

        tier.padding = 3;
        tier.subtiers = [];

        var results = glyphifyFeatures(view)(features);

        // If all the results are a string, we want to show it on screen - something went wrong.
        if (typeof results === "string") {
            tier.updateStatus(results);
        } else {
            // Otherwise we want to print the errors to console, while telling the user something went wrong.
            var status = "";
            results.glyphs.forEach(function (r) {
                if (typeof r === "string") {
                    if (status === "") {
                        status = "Error when parsing features - see browser console";
                    }
                    console.log(r);
                }
            });
            if (status !== "") {
                tier.updateStatus(status);
            }

            tier.subtiers[0] = { glyphs: results.glyphs.filter(function (r) {
                    return typeof r !== "string";
                }),
                height: canvasHeight
            };
        }

        if (results.quant) {
            console.log(results.quant);
            tier.subtiers[0].quant = results.quant;
        }

        tier.glyphCacheOrigin = tier.browser.viewStart;
    };

    var drawTier = function drawTier(tier) {

        // if the source has a sub config, this track is treated as a subtrack
        if (_typeof(tier.dasSource.sub) === "object") {
            var browser = tier.browser;

            var multiTier = browser.tiers.filter(function (t) {
                return t.dasSource.renderer === 'multi' && t.dasSource.multi.multi_id === tier.dasSource.sub.multi_id;
            });

            multiTier.forEach(function (t) {
                return browser.refreshTier(t);
            });
        } else {
            prepareSubtiers(tier);

            var ctx = tier.viewport.getContext("2d");
            var retina = tier.browser.retina && window.devicePixelRatio > 1;

            DefaultRenderer.prepareViewport(tier, ctx, retina);
            DefaultRenderer.paint(tier, ctx);

            tier.drawOverlay();
            tier.paintQuant();

            if (typeof tier.dasSource.drawCallback === "function") {
                tier.dasSource.drawCallback(ctx, tier);
            }

            tier.originHaxx = 0;
            tier.browser.arrangeTiers();
        }
    };

    var renderTier = function renderTier(status, tier) {
        drawTier(tier);
        tier.updateStatus(status);
    };

    return { prepareSubtiers: prepareSubtiers,
        drawTier: drawTier,
        renderTier: renderTier
    };
}

},{"./default-renderer.es6":12}],62:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// zoomslider.js: custom slider component
//


"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var makeElement = utils.makeElement;
}

function makeZoomSlider(opts) {
    opts = opts || {};

    var minPos = 0,
        maxPos = opts.width || 200;
    var min = 0,
        max = 200;
    var pos = 50,
        pos2 = 100;
    var labels = [];
    var track = makeElement('hr', null, { className: 'slider-track' }, { width: '' + (maxPos | 0) + 'px' });
    var thumb = makeElement('hr', null, { className: 'slider-thumb active' });
    var thumb2 = makeElement('hr', null, { className: 'slider-thumb' });
    var slider = makeElement('div', [track, thumb, thumb2], { className: 'slider' }, { width: '' + ((maxPos | 0) + 10) + 'px' });

    slider.removeLabels = function () {
        for (var li = 0; li < labels.length; ++li) {
            slider.removeChild(labels[li]);
        }
        labels = [];
    };

    slider.addLabel = function (val, txt) {
        var pos = minPos + (val - min) * (maxPos - minPos) / (max - min) | 0;
        var label = makeElement('div', txt, { className: 'slider-label' }, {
            left: '' + (minPos + (val - min) * (maxPos - minPos) / (max - min) | 0) + 'px'
        });
        slider.appendChild(label);
        labels.push(label);
    };

    var onChange = document.createEvent('HTMLEvents');
    onChange.initEvent('change', true, false);

    function setPos(np) {
        np = Math.min(np, maxPos);
        np = Math.max(np, minPos);
        pos = np;
        thumb.style.left = '' + pos + 'px';
    }

    function setPos2(np) {
        np = Math.min(np, maxPos);
        np = Math.max(np, minPos);
        pos2 = np;
        thumb2.style.left = '' + pos2 + 'px';
    }

    Object.defineProperty(slider, 'value', {
        get: function get() {
            return min + (pos - minPos) * (max - min) / (maxPos - minPos);
        },
        set: function set(v) {
            var np = minPos + (v - min) * (maxPos - minPos) / (max - min);
            setPos(np);
        }
    });

    Object.defineProperty(slider, 'value2', {
        get: function get() {
            return min + (pos2 - minPos) * (max - min) / (maxPos - minPos);
        },
        set: function set(v) {
            var np = minPos + (v - min) * (maxPos - minPos) / (max - min);
            setPos2(np);
        }
    });

    Object.defineProperty(slider, 'active', {
        get: function get() {
            return thumb.classList.contains('active') ? 1 : 2;
        },
        set: function set(x) {
            if (x == 1) {
                thumb.classList.add('active');
                thumb2.classList.remove('active');
            } else {
                thumb2.classList.add('active');
                thumb.classList.remove('active');
            }
        }
    });

    Object.defineProperty(slider, 'min', {
        get: function get() {
            return min;
        },
        set: function set(v) {
            min = v;
        }
    });

    Object.defineProperty(slider, 'max', {
        get: function get() {
            return max;
        },
        set: function set(v) {
            max = v;
        }
    });

    var offset;
    var which;

    var thumbMouseDown = function thumbMouseDown(ev) {
        which = this == thumb ? 1 : 2;
        if (which != slider.active) {
            slider.active = which;
            slider.dispatchEvent(onChange);
        }
        ev.stopPropagation();ev.preventDefault();
        window.addEventListener('mousemove', thumbDragHandler, false);
        window.addEventListener('mouseup', thumbDragEndHandler, false);
        offset = ev.clientX - (which == 1 ? pos : pos2);
    };

    thumb.addEventListener('mousedown', thumbMouseDown, false);
    thumb2.addEventListener('mousedown', thumbMouseDown, false);

    var thumbDragHandler = function thumbDragHandler(ev) {
        if (which == 1) setPos(ev.clientX - offset);else setPos2(ev.clientX - offset);
        slider.dispatchEvent(onChange);
    };

    var thumbDragEndHandler = function thumbDragEndHandler(ev) {
        window.removeEventListener('mousemove', thumbDragHandler, false);
        window.removeEventListener('mouseup', thumbDragEndHandler, false);
    };

    return slider;
}

if (typeof module !== 'undefined') {
    module.exports = makeZoomSlider;
}

},{"./utils":58}],63:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":66}],64:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Javascript ZLib
// By Thomas Down 2010-2011
//
// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in
// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.
//
// inflate.js: ZLib inflate code
//

//
// Shared constants
//

var MAX_WBITS=15; // 32K LZ77 window
var DEF_WBITS=MAX_WBITS;
var MAX_MEM_LEVEL=9;
var MANY=1440;
var BMAX = 15;

// preset dictionary flag in zlib header
var PRESET_DICT=0x20;

var Z_NO_FLUSH=0;
var Z_PARTIAL_FLUSH=1;
var Z_SYNC_FLUSH=2;
var Z_FULL_FLUSH=3;
var Z_FINISH=4;

var Z_DEFLATED=8;

var Z_OK=0;
var Z_STREAM_END=1;
var Z_NEED_DICT=2;
var Z_ERRNO=-1;
var Z_STREAM_ERROR=-2;
var Z_DATA_ERROR=-3;
var Z_MEM_ERROR=-4;
var Z_BUF_ERROR=-5;
var Z_VERSION_ERROR=-6;

var METHOD=0;   // waiting for method byte
var FLAG=1;     // waiting for flag byte
var DICT4=2;    // four dictionary check bytes to go
var DICT3=3;    // three dictionary check bytes to go
var DICT2=4;    // two dictionary check bytes to go
var DICT1=5;    // one dictionary check byte to go
var DICT0=6;    // waiting for inflateSetDictionary
var BLOCKS=7;   // decompressing blocks
var CHECK4=8;   // four check bytes to go
var CHECK3=9;   // three check bytes to go
var CHECK2=10;  // two check bytes to go
var CHECK1=11;  // one check byte to go
var DONE=12;    // finished check, done
var BAD=13;     // got an error--stay here

var inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];

var IB_TYPE=0;  // get type bits (3, including end bit)
var IB_LENS=1;  // get lengths for stored
var IB_STORED=2;// processing stored block
var IB_TABLE=3; // get table lengths
var IB_BTREE=4; // get bit lengths tree for a dynamic block
var IB_DTREE=5; // get length, distance trees for a dynamic block
var IB_CODES=6; // processing fixed or dynamic block
var IB_DRY=7;   // output remaining window bytes
var IB_DONE=8;  // finished last block, done
var IB_BAD=9;   // ot a data error--stuck here

var fixed_bl = 9;
var fixed_bd = 5;

var fixed_tl = [
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,192,
    80,7,10, 0,8,96, 0,8,32, 0,9,160,
    0,8,0, 0,8,128, 0,8,64, 0,9,224,
    80,7,6, 0,8,88, 0,8,24, 0,9,144,
    83,7,59, 0,8,120, 0,8,56, 0,9,208,
    81,7,17, 0,8,104, 0,8,40, 0,9,176,
    0,8,8, 0,8,136, 0,8,72, 0,9,240,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,200,
    81,7,13, 0,8,100, 0,8,36, 0,9,168,
    0,8,4, 0,8,132, 0,8,68, 0,9,232,
    80,7,8, 0,8,92, 0,8,28, 0,9,152,
    84,7,83, 0,8,124, 0,8,60, 0,9,216,
    82,7,23, 0,8,108, 0,8,44, 0,9,184,
    0,8,12, 0,8,140, 0,8,76, 0,9,248,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,196,
    81,7,11, 0,8,98, 0,8,34, 0,9,164,
    0,8,2, 0,8,130, 0,8,66, 0,9,228,
    80,7,7, 0,8,90, 0,8,26, 0,9,148,
    84,7,67, 0,8,122, 0,8,58, 0,9,212,
    82,7,19, 0,8,106, 0,8,42, 0,9,180,
    0,8,10, 0,8,138, 0,8,74, 0,9,244,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,204,
    81,7,15, 0,8,102, 0,8,38, 0,9,172,
    0,8,6, 0,8,134, 0,8,70, 0,9,236,
    80,7,9, 0,8,94, 0,8,30, 0,9,156,
    84,7,99, 0,8,126, 0,8,62, 0,9,220,
    82,7,27, 0,8,110, 0,8,46, 0,9,188,
    0,8,14, 0,8,142, 0,8,78, 0,9,252,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,194,
    80,7,10, 0,8,97, 0,8,33, 0,9,162,
    0,8,1, 0,8,129, 0,8,65, 0,9,226,
    80,7,6, 0,8,89, 0,8,25, 0,9,146,
    83,7,59, 0,8,121, 0,8,57, 0,9,210,
    81,7,17, 0,8,105, 0,8,41, 0,9,178,
    0,8,9, 0,8,137, 0,8,73, 0,9,242,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,202,
    81,7,13, 0,8,101, 0,8,37, 0,9,170,
    0,8,5, 0,8,133, 0,8,69, 0,9,234,
    80,7,8, 0,8,93, 0,8,29, 0,9,154,
    84,7,83, 0,8,125, 0,8,61, 0,9,218,
    82,7,23, 0,8,109, 0,8,45, 0,9,186,
    0,8,13, 0,8,141, 0,8,77, 0,9,250,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,198,
    81,7,11, 0,8,99, 0,8,35, 0,9,166,
    0,8,3, 0,8,131, 0,8,67, 0,9,230,
    80,7,7, 0,8,91, 0,8,27, 0,9,150,
    84,7,67, 0,8,123, 0,8,59, 0,9,214,
    82,7,19, 0,8,107, 0,8,43, 0,9,182,
    0,8,11, 0,8,139, 0,8,75, 0,9,246,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,206,
    81,7,15, 0,8,103, 0,8,39, 0,9,174,
    0,8,7, 0,8,135, 0,8,71, 0,9,238,
    80,7,9, 0,8,95, 0,8,31, 0,9,158,
    84,7,99, 0,8,127, 0,8,63, 0,9,222,
    82,7,27, 0,8,111, 0,8,47, 0,9,190,
    0,8,15, 0,8,143, 0,8,79, 0,9,254,
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,193,

    80,7,10, 0,8,96, 0,8,32, 0,9,161,
    0,8,0, 0,8,128, 0,8,64, 0,9,225,
    80,7,6, 0,8,88, 0,8,24, 0,9,145,
    83,7,59, 0,8,120, 0,8,56, 0,9,209,
    81,7,17, 0,8,104, 0,8,40, 0,9,177,
    0,8,8, 0,8,136, 0,8,72, 0,9,241,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,201,
    81,7,13, 0,8,100, 0,8,36, 0,9,169,
    0,8,4, 0,8,132, 0,8,68, 0,9,233,
    80,7,8, 0,8,92, 0,8,28, 0,9,153,
    84,7,83, 0,8,124, 0,8,60, 0,9,217,
    82,7,23, 0,8,108, 0,8,44, 0,9,185,
    0,8,12, 0,8,140, 0,8,76, 0,9,249,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,197,
    81,7,11, 0,8,98, 0,8,34, 0,9,165,
    0,8,2, 0,8,130, 0,8,66, 0,9,229,
    80,7,7, 0,8,90, 0,8,26, 0,9,149,
    84,7,67, 0,8,122, 0,8,58, 0,9,213,
    82,7,19, 0,8,106, 0,8,42, 0,9,181,
    0,8,10, 0,8,138, 0,8,74, 0,9,245,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,205,
    81,7,15, 0,8,102, 0,8,38, 0,9,173,
    0,8,6, 0,8,134, 0,8,70, 0,9,237,
    80,7,9, 0,8,94, 0,8,30, 0,9,157,
    84,7,99, 0,8,126, 0,8,62, 0,9,221,
    82,7,27, 0,8,110, 0,8,46, 0,9,189,
    0,8,14, 0,8,142, 0,8,78, 0,9,253,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,195,
    80,7,10, 0,8,97, 0,8,33, 0,9,163,
    0,8,1, 0,8,129, 0,8,65, 0,9,227,
    80,7,6, 0,8,89, 0,8,25, 0,9,147,
    83,7,59, 0,8,121, 0,8,57, 0,9,211,
    81,7,17, 0,8,105, 0,8,41, 0,9,179,
    0,8,9, 0,8,137, 0,8,73, 0,9,243,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,203,
    81,7,13, 0,8,101, 0,8,37, 0,9,171,
    0,8,5, 0,8,133, 0,8,69, 0,9,235,
    80,7,8, 0,8,93, 0,8,29, 0,9,155,
    84,7,83, 0,8,125, 0,8,61, 0,9,219,
    82,7,23, 0,8,109, 0,8,45, 0,9,187,
    0,8,13, 0,8,141, 0,8,77, 0,9,251,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,199,
    81,7,11, 0,8,99, 0,8,35, 0,9,167,
    0,8,3, 0,8,131, 0,8,67, 0,9,231,
    80,7,7, 0,8,91, 0,8,27, 0,9,151,
    84,7,67, 0,8,123, 0,8,59, 0,9,215,
    82,7,19, 0,8,107, 0,8,43, 0,9,183,
    0,8,11, 0,8,139, 0,8,75, 0,9,247,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,207,
    81,7,15, 0,8,103, 0,8,39, 0,9,175,
    0,8,7, 0,8,135, 0,8,71, 0,9,239,
    80,7,9, 0,8,95, 0,8,31, 0,9,159,
    84,7,99, 0,8,127, 0,8,63, 0,9,223,
    82,7,27, 0,8,111, 0,8,47, 0,9,191,
    0,8,15, 0,8,143, 0,8,79, 0,9,255
];
var fixed_td = [
    80,5,1, 87,5,257, 83,5,17, 91,5,4097,
    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,
    80,5,3, 88,5,513, 84,5,33, 92,5,8193,
    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,
    80,5,2, 87,5,385, 83,5,25, 91,5,6145,
    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,
    80,5,4, 88,5,769, 84,5,49, 92,5,12289,
    82,5,13, 90,5,3073, 86,5,193, 192,5,24577
];

  // Tables for deflate from PKZIP's appnote.txt.
  var cplens = [ // Copy lengths for literal codes 257..285
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  ];

  // see note #13 above about 258
  var cplext = [ // Extra bits for literal codes 257..285
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid
  ];

 var cpdist = [ // Copy offsets for distance codes 0..29
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577
  ];

  var cpdext = [ // Extra bits for distance codes
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13];

//
// ZStream.java
//

function ZStream() {
}


ZStream.prototype.inflateInit = function(w, nowrap) {
    if (!w) {
	w = DEF_WBITS;
    }
    if (nowrap) {
	nowrap = false;
    }
    this.istate = new Inflate();
    return this.istate.inflateInit(this, nowrap?-w:w);
}

ZStream.prototype.inflate = function(f) {
    if(this.istate==null) return Z_STREAM_ERROR;
    return this.istate.inflate(this, f);
}

ZStream.prototype.inflateEnd = function(){
    if(this.istate==null) return Z_STREAM_ERROR;
    var ret=istate.inflateEnd(this);
    this.istate = null;
    return ret;
}
ZStream.prototype.inflateSync = function(){
    // if(istate == null) return Z_STREAM_ERROR;
    return istate.inflateSync(this);
}
ZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){
    // if(istate == null) return Z_STREAM_ERROR;
    return istate.inflateSetDictionary(this, dictionary, dictLength);
}

/*

  public int deflateInit(int level){
    return deflateInit(level, MAX_WBITS);
  }
  public int deflateInit(int level, boolean nowrap){
    return deflateInit(level, MAX_WBITS, nowrap);
  }
  public int deflateInit(int level, int bits){
    return deflateInit(level, bits, false);
  }
  public int deflateInit(int level, int bits, boolean nowrap){
    dstate=new Deflate();
    return dstate.deflateInit(this, level, nowrap?-bits:bits);
  }
  public int deflate(int flush){
    if(dstate==null){
      return Z_STREAM_ERROR;
    }
    return dstate.deflate(this, flush);
  }
  public int deflateEnd(){
    if(dstate==null) return Z_STREAM_ERROR;
    int ret=dstate.deflateEnd();
    dstate=null;
    return ret;
  }
  public int deflateParams(int level, int strategy){
    if(dstate==null) return Z_STREAM_ERROR;
    return dstate.deflateParams(this, level, strategy);
  }
  public int deflateSetDictionary (byte[] dictionary, int dictLength){
    if(dstate == null)
      return Z_STREAM_ERROR;
    return dstate.deflateSetDictionary(this, dictionary, dictLength);
  }

*/

/*
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  void flush_pending(){
    int len=dstate.pending;

    if(len>avail_out) len=avail_out;
    if(len==0) return;

    if(dstate.pending_buf.length<=dstate.pending_out ||
       next_out.length<=next_out_index ||
       dstate.pending_buf.length<(dstate.pending_out+len) ||
       next_out.length<(next_out_index+len)){
      System.out.println(dstate.pending_buf.length+", "+dstate.pending_out+
			 ", "+next_out.length+", "+next_out_index+", "+len);
      System.out.println("avail_out="+avail_out);
    }

    System.arraycopy(dstate.pending_buf, dstate.pending_out,
		     next_out, next_out_index, len);

    next_out_index+=len;
    dstate.pending_out+=len;
    total_out+=len;
    avail_out-=len;
    dstate.pending-=len;
    if(dstate.pending==0){
      dstate.pending_out=0;
    }
  }

  // Read a new buffer from the current input stream, update the adler32
  // and total number of bytes read.  All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  int read_buf(byte[] buf, int start, int size) {
    int len=avail_in;

    if(len>size) len=size;
    if(len==0) return 0;

    avail_in-=len;

    if(dstate.noheader==0) {
      adler=_adler.adler32(adler, next_in, next_in_index, len);
    }
    System.arraycopy(next_in, next_in_index, buf, start, len);
    next_in_index  += len;
    total_in += len;
    return len;
  }

  public void free(){
    next_in=null;
    next_out=null;
    msg=null;
    _adler=null;
  }
}
*/


//
// Inflate.java
//

function Inflate() {
    this.was = [0];
}

Inflate.prototype.inflateReset = function(z) {
    if(z == null || z.istate == null) return Z_STREAM_ERROR;
    
    z.total_in = z.total_out = 0;
    z.msg = null;
    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;
    z.istate.blocks.reset(z, null);
    return Z_OK;
}

Inflate.prototype.inflateEnd = function(z){
    if(this.blocks != null)
      this.blocks.free(z);
    this.blocks=null;
    return Z_OK;
}

Inflate.prototype.inflateInit = function(z, w){
    z.msg = null;
    this.blocks = null;

    // handle undocumented nowrap option (no zlib header or check)
    nowrap = 0;
    if(w < 0){
      w = - w;
      nowrap = 1;
    }

    // set window size
    if(w<8 ||w>15){
      this.inflateEnd(z);
      return Z_STREAM_ERROR;
    }
    this.wbits=w;

    z.istate.blocks=new InfBlocks(z, 
				  z.istate.nowrap!=0 ? null : this,
				  1<<w);

    // reset state
    this.inflateReset(z);
    return Z_OK;
  }

Inflate.prototype.inflate = function(z, f){
    var r, b;

    if(z == null || z.istate == null || z.next_in == null)
      return Z_STREAM_ERROR;
    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
    r = Z_BUF_ERROR;
    while (true){
      switch (z.istate.mode){
      case METHOD:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){
          z.istate.mode = BAD;
          z.msg="unknown compression method";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        if((z.istate.method>>4)+8>z.istate.wbits){
          z.istate.mode = BAD;
          z.msg="invalid window size";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        z.istate.mode=FLAG;
      case FLAG:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        b = (z.next_in[z.next_in_index++])&0xff;

        if((((z.istate.method << 8)+b) % 31)!=0){
          z.istate.mode = BAD;
          z.msg = "incorrect header check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        if((b&PRESET_DICT)==0){
          z.istate.mode = BLOCKS;
          break;
        }
        z.istate.mode = DICT4;
      case DICT4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;
        z.istate.mode=DICT3;
      case DICT3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;
        z.istate.mode=DICT2;
      case DICT2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;
        z.istate.mode=DICT1;
      case DICT1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need += (z.next_in[z.next_in_index++]&0xff);
        z.adler = z.istate.need;
        z.istate.mode = DICT0;
        return Z_NEED_DICT;
      case DICT0:
        z.istate.mode = BAD;
        z.msg = "need dictionary";
        z.istate.marker = 0;       // can try inflateSync
        return Z_STREAM_ERROR;
      case BLOCKS:

        r = z.istate.blocks.proc(z, r);
        if(r == Z_DATA_ERROR){
          z.istate.mode = BAD;
          z.istate.marker = 0;     // can try inflateSync
          break;
        }
        if(r == Z_OK){
          r = f;
        }
        if(r != Z_STREAM_END){
          return r;
        }
        r = f;
        z.istate.blocks.reset(z, z.istate.was);
        if(z.istate.nowrap!=0){
          z.istate.mode=DONE;
          break;
        }
        z.istate.mode=CHECK4;
      case CHECK4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;
        z.istate.mode=CHECK3;
      case CHECK3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;
        z.istate.mode = CHECK2;
      case CHECK2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;
        z.istate.mode = CHECK1;
      case CHECK1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);

        if(((z.istate.was[0])) != ((z.istate.need))){
          z.istate.mode = BAD;
          z.msg = "incorrect data check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        z.istate.mode = DONE;
      case DONE:
        return Z_STREAM_END;
      case BAD:
        return Z_DATA_ERROR;
      default:
        return Z_STREAM_ERROR;
      }
    }
  }


Inflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {
    var index=0;
    var length = dictLength;
    if(z==null || z.istate == null|| z.istate.mode != DICT0)
      return Z_STREAM_ERROR;

    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){
      return Z_DATA_ERROR;
    }

    z.adler = z._adler.adler32(0, null, 0, 0);

    if(length >= (1<<z.istate.wbits)){
      length = (1<<z.istate.wbits)-1;
      index=dictLength - length;
    }
    z.istate.blocks.set_dictionary(dictionary, index, length);
    z.istate.mode = BLOCKS;
    return Z_OK;
  }

//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};
var mark = [0, 0, 255, 255]

Inflate.prototype.inflateSync = function(z){
    var n;       // number of bytes to look at
    var p;       // pointer to bytes
    var m;       // number of marker bytes found in a row
    var r, w;   // temporaries to save total_in and total_out

    // set up
    if(z == null || z.istate == null)
      return Z_STREAM_ERROR;
    if(z.istate.mode != BAD){
      z.istate.mode = BAD;
      z.istate.marker = 0;
    }
    if((n=z.avail_in)==0)
      return Z_BUF_ERROR;
    p=z.next_in_index;
    m=z.istate.marker;

    // search
    while (n!=0 && m < 4){
      if(z.next_in[p] == mark[m]){
        m++;
      }
      else if(z.next_in[p]!=0){
        m = 0;
      }
      else{
        m = 4 - m;
      }
      p++; n--;
    }

    // restore
    z.total_in += p-z.next_in_index;
    z.next_in_index = p;
    z.avail_in = n;
    z.istate.marker = m;

    // return no joy or set up to restart on a new block
    if(m != 4){
      return Z_DATA_ERROR;
    }
    r=z.total_in;  w=z.total_out;
    this.inflateReset(z);
    z.total_in=r;  z.total_out = w;
    z.istate.mode = BLOCKS;
    return Z_OK;
}

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
  // but removes the length bytes of the resulting empty stored block. When
  // decompressing, PPP checks that at the end of input packet, inflate is
  // waiting for these length bytes.
Inflate.prototype.inflateSyncPoint = function(z){
    if(z == null || z.istate == null || z.istate.blocks == null)
      return Z_STREAM_ERROR;
    return z.istate.blocks.sync_point();
}


//
// InfBlocks.java
//

var INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

function InfBlocks(z, checkfn, w) {
    this.hufts=new Int32Array(MANY*3);
    this.window=new Uint8Array(w);
    this.end=w;
    this.checkfn = checkfn;
    this.mode = IB_TYPE;
    this.reset(z, null);

    this.left = 0;            // if STORED, bytes left to copy 

    this.table = 0;           // table lengths (14 bits) 
    this.index = 0;           // index into blens (or border) 
    this.blens = null;         // bit lengths of codes 
    this.bb=new Int32Array(1); // bit length tree depth 
    this.tb=new Int32Array(1); // bit length decoding tree 

    this.codes = new InfCodes();

    this.last = 0;            // true if this block is the last block 

  // mode independent information 
    this.bitk = 0;            // bits in bit buffer 
    this.bitb = 0;            // bit buffer 
    this.read = 0;            // window read pointer 
    this.write = 0;           // window write pointer 
    this.check = 0;          // check on output 

    this.inftree=new InfTree();
}




InfBlocks.prototype.reset = function(z, c){
    if(c) c[0]=this.check;
    if(this.mode==IB_CODES){
      this.codes.free(z);
    }
    this.mode=IB_TYPE;
    this.bitk=0;
    this.bitb=0;
    this.read=this.write=0;

    if(this.checkfn)
      z.adler=this.check=z._adler.adler32(0, null, 0, 0);
  }

 InfBlocks.prototype.proc = function(z, r){
    var t;              // temporary storage
    var b;              // bit buffer
    var k;              // bits in bit buffer
    var p;              // input data pointer
    var n;              // bytes available there
    var q;              // output window write pointer
    var m;              // bytes to end of window or read pointer

    // copy input/output information to locals (UPDATE macro restores)
    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}
    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}

    // process input based on current state
    while(true){
      switch (this.mode){
      case IB_TYPE:

	while(k<(3)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}
	t = (b & 7);
	this.last = t & 1;

	switch (t >>> 1){
        case 0:                         // stored 
          {b>>>=(3);k-=(3);}
          t = k & 7;                    // go to byte boundary

          {b>>>=(t);k-=(t);}
          this.mode = IB_LENS;                  // get length of stored block
          break;
        case 1:                         // fixed
          {
              var bl=new Int32Array(1);
	      var bd=new Int32Array(1);
              var tl=[];
	      var td=[];

	      inflate_trees_fixed(bl, bd, tl, td, z);
              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);
          }

          {b>>>=(3);k-=(3);}

          this.mode = IB_CODES;
          break;
        case 2:                         // dynamic

          {b>>>=(3);k-=(3);}

          this.mode = IB_TABLE;
          break;
        case 3:                         // illegal

          {b>>>=(3);k-=(3);}
          this.mode = BAD;
          z.msg = "invalid block type";
          r = Z_DATA_ERROR;

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z,r);
	}
	break;
      case IB_LENS:
	while(k<(32)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){
	  this.mode = BAD;
	  z.msg = "invalid stored block lengths";
	  r = Z_DATA_ERROR;

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z,r);
	}
	this.left = (b & 0xffff);
	b = k = 0;                       // dump bits
	this.mode = this.left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);
	break;
      case IB_STORED:
	if (n == 0){
	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return this.inflate_flush(z,r);
	}

	if(m==0){
	  if(q==end&&read!=0){
	    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);
	  }
	  if(m==0){
	    this.write=q; 
	    r=this.inflate_flush(z,r);
	    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);
	    if(q==this.end && this.read != 0){
	      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);
	    }
	    if(m==0){
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	t = this.left;
	if(t>n) t = n;
	if(t>m) t = m;
	arrayCopy(z.next_in, p, this.window, q, t);
	p += t;  n -= t;
	q += t;  m -= t;
	if ((this.left -= t) != 0)
	  break;
	this.mode = (this.last != 0 ? IB_DRY : IB_TYPE);
	break;
      case IB_TABLE:

	while(k<(14)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.table = t = (b & 0x3fff);
	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
	  {
	    this.mode = IB_BAD;
	    z.msg = "too many length or distance symbols";
	    r = Z_DATA_ERROR;

	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  }
	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
	if(this.blens==null || this.blens.length<t){
	    this.blens=new Int32Array(t);
	}
	else{
	  for(var i=0; i<t; i++){
              this.blens[i]=0;
          }
	}

	{b>>>=(14);k-=(14);}

	this.index = 0;
	mode = IB_BTREE;
      case IB_BTREE:
	while (this.index < 4 + (this.table >>> 10)){
	  while(k<(3)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

	  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;

	  {b>>>=(3);k-=(3);}
	}

	while(this.index < 19){
	  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;
	}

	this.bb[0] = 7;
	t = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);
	if (t != Z_OK){
	  r = t;
	  if (r == Z_DATA_ERROR){
	    this.blens=null;
	    this.mode = IB_BAD;
	  }

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return this.inflate_flush(z,r);
	}

	this.index = 0;
	this.mode = IB_DTREE;
      case IB_DTREE:
	while (true){
	  t = this.table;
	  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){
	    break;
	  }

	  var h; //int[]
	  var i, j, c;

	  t = this.bb[0];

	  while(k<(t)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

//	  if (this.tb[0]==-1){
//            dlog("null...");
//	  }

	  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];
	  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];

	  if (c < 16){
	    b>>>=(t);k-=(t);
	    this.blens[this.index++] = c;
	  }
	  else { // c == 16..18
	    i = c == 18 ? 7 : c - 14;
	    j = c == 18 ? 11 : 3;

	    while(k<(t+i)){
	      if(n!=0){
		r=Z_OK;
	      }
	      else{
		this.bitb=b; this.bitk=k; 
		z.avail_in=n;
		z.total_in+=p-z.next_in_index;z.next_in_index=p;
		this.write=q;
		return this.inflate_flush(z,r);
	      };
	      n--;
	      b|=(z.next_in[p++]&0xff)<<k;
	      k+=8;
	    }

	    b>>>=(t);k-=(t);

	    j += (b & inflate_mask[i]);

	    b>>>=(i);k-=(i);

	    i = this.index;
	    t = this.table;
	    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
		(c == 16 && i < 1)){
	      this.blens=null;
	      this.mode = IB_BAD;
	      z.msg = "invalid bit length repeat";
	      r = Z_DATA_ERROR;

	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    }

	    c = c == 16 ? this.blens[i-1] : 0;
	    do{
	      this.blens[i++] = c;
	    }
	    while (--j!=0);
	    this.index = i;
	  }
	}

	this.tb[0]=-1;
	{
	    var bl=new Int32Array(1);
	    var bd=new Int32Array(1);
	    var tl=new Int32Array(1);
	    var td=new Int32Array(1);
	    bl[0] = 9;         // must be <= 9 for lookahead assumptions
	    bd[0] = 6;         // must be <= 9 for lookahead assumptions

	    t = this.table;
	    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), 
					      1 + ((t >> 5) & 0x1f),
					      this.blens, bl, bd, tl, td, this.hufts, z);

	    if (t != Z_OK){
	        if (t == Z_DATA_ERROR){
	            this.blens=null;
	            this.mode = BAD;
	        }
	        r = t;

	        this.bitb=b; this.bitk=k; 
	        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	        this.write=q;
	        return this.inflate_flush(z,r);
	    }
	    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);
	}
	this.mode = IB_CODES;
      case IB_CODES:
	this.bitb=b; this.bitk=k;
	z.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;

	if ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){
	  return this.inflate_flush(z, r);
	}
	r = Z_OK;
	this.codes.free(z);

	p=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;
	q=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);

	if (this.last==0){
	  this.mode = IB_TYPE;
	  break;
	}
	this.mode = IB_DRY;
      case IB_DRY:
	this.write=q; 
	r = this.inflate_flush(z, r); 
	q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);
	if (this.read != this.write){
	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z, r);
	}
	mode = DONE;
      case IB_DONE:
	r = Z_STREAM_END;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);
      case IB_BAD:
	r = Z_DATA_ERROR;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);

      default:
	r = Z_STREAM_ERROR;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);
      }
    }
  }

InfBlocks.prototype.free = function(z){
    this.reset(z, null);
    this.window=null;
    this.hufts=null;
}

InfBlocks.prototype.set_dictionary = function(d, start, n){
    arrayCopy(d, start, window, 0, n);
    this.read = this.write = n;
}

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
InfBlocks.prototype.sync_point = function(){
    return this.mode == IB_LENS;
}

  // copy as much as possible from the sliding window to the output area
InfBlocks.prototype.inflate_flush = function(z, r){
    var n;
    var p;
    var q;

    // local copies of source and destination pointers
    p = z.next_out_index;
    q = this.read;

    // compute number of bytes to copy as far as end of window
    n = ((q <= this.write ? this.write : this.end) - q);
    if (n > z.avail_out) n = z.avail_out;
    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

    // update counters
    z.avail_out -= n;
    z.total_out += n;

    // update check information
    if(this.checkfn != null)
      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);

    // copy as far as end of window
    arrayCopy(this.window, q, z.next_out, p, n);
    p += n;
    q += n;

    // see if more to copy at beginning of window
    if (q == this.end){
      // wrap pointers
      q = 0;
      if (this.write == this.end)
        this.write = 0;

      // compute bytes to copy
      n = this.write - q;
      if (n > z.avail_out) n = z.avail_out;
      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

      // update counters
      z.avail_out -= n;
      z.total_out += n;

      // update check information
      if(this.checkfn != null)
	z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);

      // copy
      arrayCopy(this.window, q, z.next_out, p, n);
      p += n;
      q += n;
    }

    // update pointers
    z.next_out_index = p;
    this.read = q;

    // done
    return r;
  }

//
// InfCodes.java
//

var IC_START=0;  // x: set up for LEN
var IC_LEN=1;    // i: get length/literal/eob next
var IC_LENEXT=2; // i: getting length extra (have base)
var IC_DIST=3;   // i: get distance next
var IC_DISTEXT=4;// i: getting distance extra
var IC_COPY=5;   // o: copying bytes in window, waiting for space
var IC_LIT=6;    // o: got literal, waiting for output space
var IC_WASH=7;   // o: got eob, possibly still output waiting
var IC_END=8;    // x: got eob and all data flushed
var IC_BADCODE=9;// x: got error

function InfCodes() {
}

InfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {
    this.mode=IC_START;
    this.lbits=bl;
    this.dbits=bd;
    this.ltree=tl;
    this.ltree_index=tl_index;
    this.dtree = td;
    this.dtree_index=td_index;
    this.tree=null;
}

InfCodes.prototype.proc = function(s, z, r){ 
    var j;              // temporary storage
    var t;              // temporary pointer (int[])
    var tindex;         // temporary pointer
    var e;              // extra bits or operation
    var b=0;            // bit buffer
    var k=0;            // bits in bit buffer
    var p=0;            // input data pointer
    var n;              // bytes available there
    var q;              // output window write pointer
    var m;              // bytes to end of window or read pointer
    var f;              // pointer to copy strings from

    // copy input/output information to locals (UPDATE macro restores)
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // process input and output based on current state
    while (true){
      switch (this.mode){
	// waiting for "i:"=input, "o:"=output, "x:"=nothing
      case IC_START:         // x: set up for LEN
	if (m >= 258 && n >= 10){

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  r = this.inflate_fast(this.lbits, this.dbits, 
			   this.ltree, this.ltree_index, 
			   this.dtree, this.dtree_index,
			   s, z);

	  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
	  q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	  if (r != Z_OK){
	    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;
	    break;
	  }
	}
	this.need = this.lbits;
	this.tree = this.ltree;
	this.tree_index=this.ltree_index;

	this.mode = IC_LEN;
      case IC_LEN:           // i: get length/literal/eob next
	j = this.need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(this.tree_index+(b&inflate_mask[j]))*3;

	b>>>=(this.tree[tindex+1]);
	k-=(this.tree[tindex+1]);

	e=this.tree[tindex];

	if(e == 0){               // literal
	  this.lit = this.tree[tindex+2];
	  this.mode = IC_LIT;
	  break;
	}
	if((e & 16)!=0 ){          // length
	  this.get = e & 15;
	  this.len = this.tree[tindex+2];
	  this.mode = IC_LENEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  this.need = e;
	  this.tree_index = tindex/3 + this.tree[tindex+2];
	  break;
	}
	if ((e & 32)!=0){               // end of block
	  this.mode = IC_WASH;
	  break;
	}
	this.mode = IC_BADCODE;        // invalid code
	z.msg = "invalid literal/length code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_LENEXT:        // i: getting length extra (have base)
	j = this.get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.len += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	this.need = this.dbits;
	this.tree = this.dtree;
	this.tree_index = this.dtree_index;
	this.mode = IC_DIST;
      case IC_DIST:          // i: get distance next
	j = this.need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(this.tree_index+(b & inflate_mask[j]))*3;

	b>>=this.tree[tindex+1];
	k-=this.tree[tindex+1];

	e = (this.tree[tindex]);
	if((e & 16)!=0){               // distance
	  this.get = e & 15;
	  this.dist = this.tree[tindex+2];
	  this.mode = IC_DISTEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  this.need = e;
	  this.tree_index = tindex/3 + this.tree[tindex+2];
	  break;
	}
	this.mode = IC_BADCODE;        // invalid code
	z.msg = "invalid distance code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_DISTEXT:       // i: getting distance extra
	j = this.get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.dist += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	this.mode = IC_COPY;
      case IC_COPY:          // o: copying bytes in window, waiting for space
        f = q - this.dist;
        while(f < 0){     // modulo window size-"while" instead
          f += s.end;     // of "if" handles invalid distances
	}
	while (this.len!=0){

	  if(m==0){
	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.write=q; r=s.inflate_flush(z,r);
	      q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}

	      if(m==0){
		s.bitb=b;s.bitk=k;
		z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
		s.write=q;
		return s.inflate_flush(z,r);
	      }  
	    }
	  }

	  s.window[q++]=s.window[f++]; m--;

	  if (f == s.end)
            f = 0;
	  this.len--;
	}
	this.mode = IC_START;
	break;
      case IC_LIT:           // o: got literal, waiting for output space
	if(m==0){
	  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	  if(m==0){
	    s.write=q; r=s.inflate_flush(z,r);
	    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;
	      return s.inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	s.window[q++]=this.lit; m--;

	this.mode = IC_START;
	break;
      case IC_WASH:           // o: got eob, possibly more output
	if (k > 7){        // return unused byte, if any
	  k -= 8;
	  n++;
	  p--;             // can always return one
	}

	s.write=q; r=s.inflate_flush(z,r);
	q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	if (s.read != s.write){
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  return s.inflate_flush(z,r);
	}
	this.mode = IC_END;
      case IC_END:
	r = Z_STREAM_END;
	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_BADCODE:       // x: got error

	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      default:
	r = Z_STREAM_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);
      }
    }
  }

InfCodes.prototype.free = function(z){
    //  ZFREE(z, c);
}

  // Called with number of bytes left to write in window at least 258
  // (the maximum string length) and number of input bytes available
  // at least ten.  The ten bytes are six bytes for the longest length/
  // distance pair plus four bytes for overloading the bit buffer.

InfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {
    var t;                // temporary pointer
    var   tp;             // temporary pointer (int[])
    var tp_index;         // temporary pointer
    var e;                // extra bits or operation
    var b;                // bit buffer
    var k;                // bits in bit buffer
    var p;                // input data pointer
    var n;                // bytes available there
    var q;                // output window write pointer
    var m;                // bytes to end of window or read pointer
    var ml;               // mask for literal/length tree
    var md;               // mask for distance tree
    var c;                // bytes to copy
    var d;                // distance back to copy from
    var r;                // copy source pointer

    var tp_index_t_3;     // (tp_index+t)*3

    // load input, output, bit values
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // initialize masks
    ml = inflate_mask[bl];
    md = inflate_mask[bd];

    // do until not enough input or output space for fast loop
    do {                          // assume called with m >= 258 && n >= 10
      // get literal/length code
      while(k<(20)){              // max bits for literal/length code
	n--;
	b|=(z.next_in[p++]&0xff)<<k;k+=8;
      }

      t= b&ml;
      tp=tl; 
      tp_index=tl_index;
      tp_index_t_3=(tp_index+t)*3;
      if ((e = tp[tp_index_t_3]) == 0){
	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	s.window[q++] = tp[tp_index_t_3+2];
	m--;
	continue;
      }
      do {

	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	if((e&16)!=0){
	  e &= 15;
	  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);

	  b>>=e; k-=e;

	  // decode distance base of block to copy
	  while(k<(15)){           // max bits for distance code
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;k+=8;
	  }

	  t= b&md;
	  tp=td;
	  tp_index=td_index;
          tp_index_t_3=(tp_index+t)*3;
	  e = tp[tp_index_t_3];

	  do {

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    if((e&16)!=0){
	      // get extra bits to add to distance base
	      e &= 15;
	      while(k<(e)){         // get extra bits (up to 13)
		n--;
		b|=(z.next_in[p++]&0xff)<<k;k+=8;
	      }

	      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);

	      b>>=(e); k-=(e);

	      // do the copy
	      m -= c;
	      if (q >= d){                // offset before dest
		//  just copy
		r=q-d;
		if(q-r>0 && 2>(q-r)){           
		  s.window[q++]=s.window[r++]; // minimum count is three,
		  s.window[q++]=s.window[r++]; // so unroll loop a little
		  c-=2;
		}
		else{
		  s.window[q++]=s.window[r++]; // minimum count is three,
		  s.window[q++]=s.window[r++]; // so unroll loop a little
		  c-=2;
		}
	      }
	      else{                  // else offset after destination
                r=q-d;
                do{
                  r+=s.end;          // force pointer in window
                }while(r<0);         // covers invalid distances
		e=s.end-r;
		if(c>e){             // if source crosses,
		  c-=e;              // wrapped copy
		  if(q-r>0 && e>(q-r)){           
		    do{s.window[q++] = s.window[r++];}
		    while(--e!=0);
		  }
		  else{
		    arrayCopy(s.window, r, s.window, q, e);
		    q+=e; r+=e; e=0;
		  }
		  r = 0;                  // copy rest from start of window
		}

	      }

	      // copy all or what's left
              do{s.window[q++] = s.window[r++];}
		while(--c!=0);
	      break;
	    }
	    else if((e&64)==0){
	      t+=tp[tp_index_t_3+2];
	      t+=(b&inflate_mask[e]);
	      tp_index_t_3=(tp_index+t)*3;
	      e=tp[tp_index_t_3];
	    }
	    else{
	      z.msg = "invalid distance code";

	      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;

	      return Z_DATA_ERROR;
	    }
	  }
	  while(true);
	  break;
	}

	if((e&64)==0){
	  t+=tp[tp_index_t_3+2];
	  t+=(b&inflate_mask[e]);
	  tp_index_t_3=(tp_index+t)*3;
	  if((e=tp[tp_index_t_3])==0){

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    s.window[q++]=tp[tp_index_t_3+2];
	    m--;
	    break;
	  }
	}
	else if((e&32)!=0){

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;
 
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_STREAM_END;
	}
	else{
	  z.msg="invalid literal/length code";

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_DATA_ERROR;
	}
      } 
      while(true);
    } 
    while(m>=258 && n>= 10);

    // not enough input or output--restore pointers and return
    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

    s.bitb=b;s.bitk=k;
    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
    s.write=q;

    return Z_OK;
}

//
// InfTree.java
//

function InfTree() {
}

InfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {

    // Given a list of code lengths and a maximum table size, make a set of
    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
    // if the given code set is incomplete (the tables are still built in this
    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
    // lengths), or Z_MEM_ERROR if not enough memory.

    var a;                       // counter for codes of length k
    var f;                       // i repeats in table every f entries
    var g;                       // maximum code length
    var h;                       // table level
    var i;                       // counter, current code
    var j;                       // counter
    var k;                       // number of bits in current code
    var l;                       // bits per table (returned in m)
    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP
    var p;                       // pointer into c[], b[], or v[]
    var q;                       // points to current table
    var w;                       // bits before this table == (l * h)
    var xp;                      // pointer into x
    var y;                       // number of dummy codes added
    var z;                       // number of entries in current table

    // Generate counts for each bit length

    p = 0; i = n;
    do {
      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX
    }while(i!=0);

    if(this.c[0] == n){                // null input--all zero length codes
      t[0] = -1;
      m[0] = 0;
      return Z_OK;
    }

    // Find minimum and maximum length, bound *m by those
    l = m[0];
    for (j = 1; j <= BMAX; j++)
      if(this.c[j]!=0) break;
    k = j;                        // minimum code length
    if(l < j){
      l = j;
    }
    for (i = BMAX; i!=0; i--){
      if(this.c[i]!=0) break;
    }
    g = i;                        // maximum code length
    if(l > i){
      l = i;
    }
    m[0] = l;

    // Adjust last length count to fill out codes, if needed
    for (y = 1 << j; j < i; j++, y <<= 1){
      if ((y -= this.c[j]) < 0){
        return Z_DATA_ERROR;
      }
    }
    if ((y -= this.c[i]) < 0){
      return Z_DATA_ERROR;
    }
    this.c[i] += y;

    // Generate starting offsets into the value table for each length
    this.x[1] = j = 0;
    p = 1;  xp = 2;
    while (--i!=0) {                 // note that i == g from above
      this.x[xp] = (j += this.c[p]);
      xp++;
      p++;
    }

    // Make a table of values in order of bit lengths
    i = 0; p = 0;
    do {
      if ((j = b[bindex+p]) != 0){
        this.v[this.x[j]++] = i;
      }
      p++;
    }
    while (++i < n);
    n = this.x[g];                     // set n to length of v

    // Generate the Huffman codes and for each, make the table entries
    this.x[0] = i = 0;                 // first Huffman code is zero
    p = 0;                        // grab values in bit order
    h = -1;                       // no tables yet--level -1
    w = -l;                       // bits decoded == (l * h)
    this.u[0] = 0;                     // just to keep compilers happy
    q = 0;                        // ditto
    z = 0;                        // ditto

    // go through the bit lengths (k already is bits in shortest code)
    for (; k <= g; k++){
      a = this.c[k];
      while (a--!=0){
	// here i is the Huffman code of length k bits for value *p
	// make tables up to required level
        while (k > w + l){
          h++;
          w += l;                 // previous table always l bits
	  // compute minimum size table less than or equal to l bits
          z = g - w;
          z = (z > l) ? l : z;        // table size upper limit
          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table
                                      // too few codes for k-w bit table
            f -= a + 1;               // deduct codes from patterns left
            xp = k;
            if(j < z){
              while (++j < z){        // try smaller tables up to z bits
                if((f <<= 1) <= this.c[++xp])
                  break;              // enough codes to use up j bits
                f -= this.c[xp];           // else deduct codes from patterns
              }
	    }
          }
          z = 1 << j;                 // table entries for j-bit table

	  // allocate new table
          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)
            return Z_DATA_ERROR;       // overflow of MANY
          }
          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG
          this.hn[0] += z;
 
	  // connect to last table, if there is one
	  if(h!=0){
            this.x[h]=i;           // save pattern for backing up
            this.r[0]=j;     // bits in this table
            this.r[1]=l;     // bits to dump before this table
            j=i>>>(w - l);
            this.r[2] = (q - this.u[h-1] - j);               // offset to this table
            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table
          }
          else{
            t[0] = q;               // first table is returned result
	  }
        }

	// set up table entry in r
        this.r[1] = (k - w);
        if (p >= n){
          this.r[0] = 128 + 64;      // out of values--invalid code
	}
        else if (v[p] < s){
          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block
          this.r[2] = this.v[p++];          // simple code is just the value
        }
        else{
          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists
          this.r[2]=d[this.v[p++] - s];
        }

        // fill code-like entries with r
        f=1<<(k-w);
        for (j=i>>>w;j<z;j+=f){
          arrayCopy(this.r, 0, hp, (q+j)*3, 3);
	}

	// backwards increment the k-bit code i
        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){
          i ^= j;
	}
        i ^= j;

	// backup over finished tables
        mask = (1 << w) - 1;      // needed on HP, cc -O bug
        while ((i & mask) != this.x[h]){
          h--;                    // don't need to update q
          w -= l;
          mask = (1 << w) - 1;
        }
      }
    }
    // Return Z_BUF_ERROR if we were given an incomplete table
    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}

InfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {
    var result;
    this.initWorkArea(19);
    this.hn[0]=0;
    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);

    if(result == Z_DATA_ERROR){
      z.msg = "oversubscribed dynamic bit lengths tree";
    }
    else if(result == Z_BUF_ERROR || bb[0] == 0){
      z.msg = "incomplete dynamic bit lengths tree";
      result = Z_DATA_ERROR;
    }
    return result;
}

InfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {
    var result;

    // build literal/length tree
    this.initWorkArea(288);
    this.hn[0]=0;
    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);
    if (result != Z_OK || bl[0] == 0){
      if(result == Z_DATA_ERROR){
        z.msg = "oversubscribed literal/length tree";
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "incomplete literal/length tree";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    // build distance tree
    this.initWorkArea(288);
    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);

    if (result != Z_OK || (bd[0] == 0 && nl > 257)){
      if (result == Z_DATA_ERROR){
        z.msg = "oversubscribed distance tree";
      }
      else if (result == Z_BUF_ERROR) {
        z.msg = "incomplete distance tree";
        result = Z_DATA_ERROR;
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "empty distance tree with lengths";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    return Z_OK;
}
/*
  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth
                                 int[] bd,  //distance desired/actual bit depth
                                 int[][] tl,//literal/length tree result
                                 int[][] td,//distance tree result 
                                 ZStream z  //for memory allocation
				 ){

*/

function inflate_trees_fixed(bl, bd, tl, td, z) {
    bl[0]=fixed_bl;
    bd[0]=fixed_bd;
    tl[0]=fixed_tl;
    td[0]=fixed_td;
    return Z_OK;
}

InfTree.prototype.initWorkArea = function(vsize){
    if(this.hn==null){
        this.hn=new Int32Array(1);
        this.v=new Int32Array(vsize);
        this.c=new Int32Array(BMAX+1);
        this.r=new Int32Array(3);
        this.u=new Int32Array(BMAX);
        this.x=new Int32Array(BMAX+1);
    }
    if(this.v.length<vsize){ 
        this.v=new Int32Array(vsize); 
    }
    for(var i=0; i<vsize; i++){this.v[i]=0;}
    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}
    for(var i=0; i<3; i++){this.r[i]=0;}
//  for(int i=0; i<BMAX; i++){u[i]=0;}
    arrayCopy(this.c, 0, this.u, 0, BMAX);
//  for(int i=0; i<BMAX+1; i++){x[i]=0;}
    arrayCopy(this.c, 0, this.x, 0, BMAX+1);
}

var testArray = new Uint8Array(1);
var hasSubarray = (typeof testArray.subarray === 'function');
var hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...

function arrayCopy(src, srcOffset, dest, destOffset, count) {
    if (count == 0) {
        return;
    } 
    if (!src) {
        throw "Undef src";
    } else if (!dest) {
        throw "Undef dest";
    }

    if (srcOffset == 0 && count == src.length) {
        arrayCopy_fast(src, dest, destOffset);
    } else if (hasSubarray) {
        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); 
    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {
        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);
    } else { 
        arrayCopy_slow(src, srcOffset, dest, destOffset, count);
    }

}

function arrayCopy_slow(src, srcOffset, dest, destOffset, count) {

    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);

     for (var i = 0; i < count; ++i) {
        dest[destOffset + i] = src[srcOffset + i];
    }
}

function arrayCopy_fast(src, dest, destOffset) {
    dest.set(src, destOffset);
}


  // largest prime smaller than 65536
var ADLER_BASE=65521; 
  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
var ADLER_NMAX=5552;

function adler32(adler, /* byte[] */ buf,  index, len){
    if(buf == null){ return 1; }

    var s1=adler&0xffff;
    var s2=(adler>>16)&0xffff;
    var k;

    while(len > 0) {
      k=len<ADLER_NMAX?len:ADLER_NMAX;
      len-=k;
      while(k>=16){
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        k-=16;
      }
      if(k!=0){
        do{
          s1+=buf[index++]&0xff; s2+=s1;
        }
        while(--k!=0);
      }
      s1%=ADLER_BASE;
      s2%=ADLER_BASE;
    }
    return (s2<<16)|s1;
}



function jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {
    if (!start) {
        buffer = new Uint8Array(buffer);
    } else if (!length) {
        buffer = new Uint8Array(buffer, start, buffer.byteLength - start);
    } else {
        buffer = new Uint8Array(buffer, start, length);
    }

    var z = new ZStream();
    z.inflateInit(DEF_WBITS, true);
    z.next_in = buffer;
    z.next_in_index = 0;
    z.avail_in = buffer.length;

    var oBlockList = [];
    var totalSize = 0;
    while (true) {
        var obuf = new Uint8Array(32000);
        z.next_out = obuf;
        z.next_out_index = 0;
        z.avail_out = obuf.length;
        var status = z.inflate(Z_NO_FLUSH);
        if (status != Z_OK && status != Z_STREAM_END && status != Z_BUF_ERROR) {
            throw z.msg;
        }
        if (z.avail_out != 0) {
            var newob = new Uint8Array(obuf.length - z.avail_out);
            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));
            obuf = newob;
        }
        oBlockList.push(obuf);
        totalSize += obuf.length;
        if (status == Z_STREAM_END || status == Z_BUF_ERROR) {
            break;
        }
    }

    if (afterUncOffset) {
        afterUncOffset[0] = (start || 0) + z.next_in_index;
    }

    if (oBlockList.length == 1) {
        return oBlockList[0].buffer;
    } else {
        var out = new Uint8Array(totalSize);
        var cursor = 0;
        for (var i = 0; i < oBlockList.length; ++i) {
            var b = oBlockList[i];
            arrayCopy(b, 0, out, cursor, b.length);
            cursor += b.length;
        }
        return out.buffer;
    }
}

if (typeof(module) !== 'undefined') {
  module.exports = {
    inflateBuffer: jszlib_inflate_buffer,
    arrayCopy: arrayCopy
  };
}

},{}],65:[function(require,module,exports){
/*!
	Papa Parse
	v4.1.4
	https://github.com/mholt/PapaParse
*/
(function(root, factory)
{
	if (typeof define === 'function' && define.amd)
	{
		// AMD. Register as an anonymous module.
		define([], factory);
	}
	else if (typeof module === 'object' && module.exports)
	{
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	}
	else
	{
		// Browser globals (root is window)
		root.Papa = factory();
	}
}(this, function()
{
	'use strict';

	var global = (function () {
		// alternative method, similar to `Function('return this')()`
		// but without using `eval` (which is disabled when
		// using Content Security Policy).

		if (typeof self !== 'undefined') { return self; }
		if (typeof window !== 'undefined') { return window; }
		if (typeof global !== 'undefined') { return global; }

        // When running tests none of the above have been defined
        return {};
	})();


	var IS_WORKER = !global.document && !!global.postMessage,
		IS_PAPA_WORKER = IS_WORKER && /(\?|&)papaworker(=|&|$)/.test(global.location.search),
		LOADED_SYNC = false, AUTO_SCRIPT_PATH;
	var workers = {}, workerIdCounter = 0;

	var Papa = {};

	Papa.parse = CsvToJson;
	Papa.unparse = JsonToCsv;

	Papa.RECORD_SEP = String.fromCharCode(30);
	Papa.UNIT_SEP = String.fromCharCode(31);
	Papa.BYTE_ORDER_MARK = '\ufeff';
	Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
	Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
	Papa.SCRIPT_PATH = null;	// Must be set by your code if you use workers and this lib is loaded asynchronously

	// Configurable chunk sizes for local and remote files, respectively
	Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
	Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
	Papa.DefaultDelimiter = ',';			// Used if not specified and detection fails

	// Exposed for testing and development only
	Papa.Parser = Parser;
	Papa.ParserHandle = ParserHandle;
	Papa.NetworkStreamer = NetworkStreamer;
	Papa.FileStreamer = FileStreamer;
	Papa.StringStreamer = StringStreamer;

	if (global.jQuery)
	{
		var $ = global.jQuery;
		$.fn.parse = function(options)
		{
			var config = options.config || {};
			var queue = [];

			this.each(function(idx)
			{
				var supported = $(this).prop('tagName').toUpperCase() === 'INPUT'
								&& $(this).attr('type').toLowerCase() === 'file'
								&& global.FileReader;

				if (!supported || !this.files || this.files.length === 0)
					return true;	// continue to next input element

				for (var i = 0; i < this.files.length; i++)
				{
					queue.push({
						file: this.files[i],
						inputElem: this,
						instanceConfig: $.extend({}, config)
					});
				}
			});

			parseNextFile();	// begin parsing
			return this;		// maintains chainability


			function parseNextFile()
			{
				if (queue.length === 0)
				{
					if (isFunction(options.complete))
						options.complete();
					return;
				}

				var f = queue[0];

				if (isFunction(options.before))
				{
					var returned = options.before(f.file, f.inputElem);

					if (typeof returned === 'object')
					{
						if (returned.action === 'abort')
						{
							error('AbortError', f.file, f.inputElem, returned.reason);
							return;	// Aborts all queued files immediately
						}
						else if (returned.action === 'skip')
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
						else if (typeof returned.config === 'object')
							f.instanceConfig = $.extend(f.instanceConfig, returned.config);
					}
					else if (returned === 'skip')
					{
						fileComplete();	// parse the next file in the queue, if any
						return;
					}
				}

				// Wrap up the user's complete callback, if any, so that ours also gets executed
				var userCompleteFunc = f.instanceConfig.complete;
				f.instanceConfig.complete = function(results)
				{
					if (isFunction(userCompleteFunc))
						userCompleteFunc(results, f.file, f.inputElem);
					fileComplete();
				};

				Papa.parse(f.file, f.instanceConfig);
			}

			function error(name, file, elem, reason)
			{
				if (isFunction(options.error))
					options.error({name: name}, file, elem, reason);
			}

			function fileComplete()
			{
				queue.splice(0, 1);
				parseNextFile();
			}
		}
	}


	if (IS_PAPA_WORKER)
	{
		global.onmessage = workerThreadReceivedMessage;
	}
	else if (Papa.WORKERS_SUPPORTED)
	{
		AUTO_SCRIPT_PATH = getScriptPath();

		// Check if the script was loaded synchronously
		if (!document.body)
		{
			// Body doesn't exist yet, must be synchronous
			LOADED_SYNC = true;
		}
		else
		{
			document.addEventListener('DOMContentLoaded', function () {
				LOADED_SYNC = true;
			}, true);
		}
	}




	function CsvToJson(_input, _config)
	{
		_config = _config || {};
		_config.dynamicTyping = _config.dynamicTyping || false;

		if (_config.worker && Papa.WORKERS_SUPPORTED)
		{
			var w = newWorker();

			w.userStep = _config.step;
			w.userChunk = _config.chunk;
			w.userComplete = _config.complete;
			w.userError = _config.error;

			_config.step = isFunction(_config.step);
			_config.chunk = isFunction(_config.chunk);
			_config.complete = isFunction(_config.complete);
			_config.error = isFunction(_config.error);
			delete _config.worker;	// prevent infinite loop

			w.postMessage({
				input: _input,
				config: _config,
				workerId: w.id
			});

			return;
		}

		var streamer = null;
		if (typeof _input === 'string')
		{
			if (_config.download)
				streamer = new NetworkStreamer(_config);
			else
				streamer = new StringStreamer(_config);
		}
		else if ((global.File && _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
			streamer = new FileStreamer(_config);

		return streamer.stream(_input);
	}






	function JsonToCsv(_input, _config)
	{
		var _output = '';
		var _fields = [];

		// Default configuration

		/** whether to surround every datum with quotes */
		var _quotes = false;

		/** whether to write headers */
		var _writeHeader = true;

		/** delimiting character */
		var _delimiter = ',';

		/** newline character(s) */
		var _newline = '\r\n';

		/** quote character */
		var _quoteChar = '"';

		unpackConfig();

		var quoteCharRegex = new RegExp(_quoteChar, 'g');

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields =  _input.meta && _input.meta.fields;

				if (!_input.fields)
					_input.fields =  _input.data[0] instanceof Array
									? _input.fields
									: objectKeys(_input.data[0]);

				if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ['asdf']
			}

			return serialize(_input.fields || [], _input.data || []);
		}

		// Default (any valid paths should return before this)
		throw 'exception: Unable to serialize unrecognized input';


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
				&& _config.delimiter.length === 1
				&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;

			if (typeof _config.quoteChar === 'string')
				_quoteChar = _config.quoteChar;

			if (typeof _config.header === 'boolean')
				_writeHeader = _config.header;
		}


		/** Turns an object's keys into an array */
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		/** The double for loop that iterates the data and writes out a CSV string including header row */
		function serialize(fields, data)
		{
			var csv = '';

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = fields instanceof Array && fields.length > 0;
			var dataKeyedByField = !(data[0] instanceof Array);

			// If there a header row, write it first
			if (hasHeader && _writeHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				for (var col = 0; col < maxCol; col++)
				{
					if (col > 0)
						csv += _delimiter;
					var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}

				if (row < data.length - 1)
					csv += _newline;
			}

			return csv;
		}

		/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
		function safe(str, col)
		{
			if (typeof str === 'undefined' || str === null)
				return '';

			str = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (_quotes instanceof Array && _quotes[col])
							|| hasAny(str, Papa.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) === ' '
							|| str.charAt(str.length - 1) === ' ';

			return needsQuotes ? _quoteChar + str + _quoteChar : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}

	/** ChunkStreamer is the base prototype for various streamer implementations. */
	function ChunkStreamer(config)
	{
		this._handle = null;
		this._paused = false;
		this._finished = false;
		this._input = null;
		this._baseIndex = 0;
		this._partialLine = '';
		this._rowCount = 0;
		this._start = 0;
		this._nextChunk = null;
		this.isFirstChunk = true;
		this._completeResults = {
			data: [],
			errors: [],
			meta: {}
		};
		replaceConfig.call(this, config);

		this.parseChunk = function(chunk)
		{
			// First chunk pre-processing
			if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))
			{
				var modifiedChunk = this._config.beforeFirstChunk(chunk);
				if (modifiedChunk !== undefined)
					chunk = modifiedChunk;
			}
			this.isFirstChunk = false;

			// Rejoin the line we likely just split in two by chunking the file
			var aggregate = this._partialLine + chunk;
			this._partialLine = '';

			var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

			if (this._handle.paused() || this._handle.aborted())
				return;

			var lastIndex = results.meta.cursor;

			if (!this._finished)
			{
				this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
				this._baseIndex = lastIndex;
			}

			if (results && results.data)
				this._rowCount += results.data.length;

			var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);

			if (IS_PAPA_WORKER)
			{
				global.postMessage({
					results: results,
					workerId: Papa.WORKER_ID,
					finished: finishedIncludingPreview
				});
			}
			else if (isFunction(this._config.chunk))
			{
				this._config.chunk(results, this._handle);
				if (this._paused)
					return;
				results = undefined;
				this._completeResults = undefined;
			}

			if (!this._config.step && !this._config.chunk) {
				this._completeResults.data = this._completeResults.data.concat(results.data);
				this._completeResults.errors = this._completeResults.errors.concat(results.errors);
				this._completeResults.meta = results.meta;
			}

			if (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))
				this._config.complete(this._completeResults, this._input);

			if (!finishedIncludingPreview && (!results || !results.meta.paused))
				this._nextChunk();

			return results;
		};

		this._sendError = function(error)
		{
			if (isFunction(this._config.error))
				this._config.error(error);
			else if (IS_PAPA_WORKER && this._config.error)
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					error: error,
					finished: false
				});
			}
		};

		function replaceConfig(config)
		{
			// Deep-copy the config so we can edit it
			var configCopy = copy(config);
			configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
			if (!config.step && !config.chunk)
				configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
			this._handle = new ParserHandle(configCopy);
			this._handle.streamer = this;
			this._config = configCopy;	// persist the copy to the caller
		}
	}


	function NetworkStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.RemoteChunkSize;
		ChunkStreamer.call(this, config);

		var xhr;

		if (IS_WORKER)
		{
			this._nextChunk = function()
			{
				this._readChunk();
				this._chunkLoaded();
			};
		}
		else
		{
			this._nextChunk = function()
			{
				this._readChunk();
			};
		}

		this.stream = function(url)
		{
			this._input = url;
			this._nextChunk();	// Starts streaming
		};

		this._readChunk = function()
		{
			if (this._finished)
			{
				this._chunkLoaded();
				return;
			}

			xhr = new XMLHttpRequest();

			if (this._config.withCredentials)
			{
				xhr.withCredentials = this._config.withCredentials;
			}

			if (!IS_WORKER)
			{
				xhr.onload = bindFunction(this._chunkLoaded, this);
				xhr.onerror = bindFunction(this._chunkError, this);
			}

			xhr.open('GET', this._input, !IS_WORKER);

			if (this._config.chunkSize)
			{
				var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
				xhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);
				xhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672
			}

			try {
				xhr.send();
			}
			catch (err) {
				this._chunkError(err.message);
			}

			if (IS_WORKER && xhr.status === 0)
				this._chunkError();
			else
				this._start += this._config.chunkSize;
		}

		this._chunkLoaded = function()
		{
			if (xhr.readyState != 4)
				return;

			if (xhr.status < 200 || xhr.status >= 400)
			{
				this._chunkError();
				return;
			}

			this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
			this.parseChunk(xhr.responseText);
		}

		this._chunkError = function(errorMessage)
		{
			var errorText = xhr.statusText || errorMessage;
			this._sendError(errorText);
		}

		function getFileSize(xhr)
		{
			var contentRange = xhr.getResponseHeader('Content-Range');
			if (contentRange === null) { // no content range, then finish!
        			return -1;
            		}
			return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
		}
	}
	NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
	NetworkStreamer.prototype.constructor = NetworkStreamer;


	function FileStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.LocalChunkSize;
		ChunkStreamer.call(this, config);

		var reader, slice;

		// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
		// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
		var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105

		this.stream = function(file)
		{
			this._input = file;
			slice = file.slice || file.webkitSlice || file.mozSlice;

			if (usingAsyncReader)
			{
				reader = new FileReader();		// Preferred method of reading files, even in workers
				reader.onload = bindFunction(this._chunkLoaded, this);
				reader.onerror = bindFunction(this._chunkError, this);
			}
			else
				reader = new FileReaderSync();	// Hack for running in a web worker in Firefox

			this._nextChunk();	// Starts streaming
		};

		this._nextChunk = function()
		{
			if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
				this._readChunk();
		}

		this._readChunk = function()
		{
			var input = this._input;
			if (this._config.chunkSize)
			{
				var end = Math.min(this._start + this._config.chunkSize, this._input.size);
				input = slice.call(input, this._start, end);
			}
			var txt = reader.readAsText(input, this._config.encoding);
			if (!usingAsyncReader)
				this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
		}

		this._chunkLoaded = function(event)
		{
			// Very important to increment start each time before handling results
			this._start += this._config.chunkSize;
			this._finished = !this._config.chunkSize || this._start >= this._input.size;
			this.parseChunk(event.target.result);
		}

		this._chunkError = function()
		{
			this._sendError(reader.error);
		}

	}
	FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
	FileStreamer.prototype.constructor = FileStreamer;


	function StringStreamer(config)
	{
		config = config || {};
		ChunkStreamer.call(this, config);

		var string;
		var remaining;
		this.stream = function(s)
		{
			string = s;
			remaining = s;
			return this._nextChunk();
		}
		this._nextChunk = function()
		{
			if (this._finished) return;
			var size = this._config.chunkSize;
			var chunk = size ? remaining.substr(0, size) : remaining;
			remaining = size ? remaining.substr(size) : '';
			this._finished = !remaining;
			return this.parseChunk(chunk);
		}
	}
	StringStreamer.prototype = Object.create(StringStreamer.prototype);
	StringStreamer.prototype.constructor = StringStreamer;



	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

		var self = this;
		var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
		var _input;				// The input being parsed
		var _parser;			// The core parser being used
		var _paused = false;	// Whether we are paused or not
		var _aborted = false;   // Whether the parser has aborted or not
		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};

		if (isFunction(_config.step))
		{
			var userStep = _config.step;
			_config.step = function(results)
			{
				_results = results;

				if (needsHeaderRow())
					processResults();
				else	// only call user's step function after header row
				{
					processResults();

					// It's possbile that this line was empty and there's no row here after all
					if (_results.data.length === 0)
						return;

					_stepCounter += results.data.length;
					if (_config.preview && _stepCounter > _config.preview)
						_parser.abort();
					else
						userStep(_results, self);
				}
			};
		}

		/**
		 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
		 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
		 * when an input comes in multiple chunks, like from a file.
		 */
		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			if (!_config.newline)
				_config.newline = guessLineEndings(input);

			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input, _config.newline);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = Papa.DefaultDelimiter;
				}
				_results.meta.delimiter = _config.delimiter;
			}
			else if(typeof _config.delimiter === 'function')
			{
				_config.delimiter = _config.delimiter(input);
				_results.meta.delimiter = _config.delimiter;
			}

			var parserConfig = copy(_config);
			if (_config.preview && _config.header)
				parserConfig.preview++;	// to compensate for header row

			_input = input;
			_parser = new Parser(parserConfig);
			_results = _parser.parse(_input, baseIndex, ignoreLastRow);
			processResults();
			return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
		};

		this.paused = function()
		{
			return _paused;
		};

		this.pause = function()
		{
			_paused = true;
			_parser.abort();
			_input = _input.substr(_parser.getCharIndex());
		};

		this.resume = function()
		{
			_paused = false;
			self.streamer.parseChunk(_input);
		};

		this.aborted = function ()
		{
			return _aborted;
		};

		this.abort = function()
		{
			_aborted = true;
			_parser.abort();
			_results.meta.aborted = true;
			if (isFunction(_config.complete))
				_config.complete(_results);
			_input = '';
		};

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \''+Papa.DefaultDelimiter+'\'');
				_delimiterError = false;
			}

			if (_config.skipEmptyLines)
			{
				for (var i = 0; i < _results.data.length; i++)
					if (_results.data[i].length === 1 && _results.data[i][0] === '')
						_results.data.splice(i--, 1);
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTyping();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length === 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
				for (var j = 0; j < _results.data[i].length; j++)
					_fields.push(_results.data[i][j]);
			_results.data.splice(0, 1);
		}

		function parseDynamic(field, value)
		{
			if ((_config.dynamicTyping[field] || _config.dynamicTyping) === true)
			{
				if (value === 'true' || value === 'TRUE')
					return true;
				else if (value === 'false' || value === 'FALSE')
					return false;
				else
					return tryParseFloat(value);
			}
			return value;
		}

		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping))
				return _results;

			for (var i = 0; i < _results.data.length; i++)
			{
				var row = _config.header ? {} : [];

				for (var j = 0; j < _results.data[i].length; j++)
				{
					var field = j;
					var value = _results.data[i][j];

					if (_config.header)
						field = j >= _fields.length ? '__parsed_extra' : _fields[j];

					value = parseDynamic(field, value);

					if (field === '__parsed_extra')
					{
						row[field] = row[field] || [];
						row[field].push(value);
					}
					else
						row[field] = value;
				}

				_results.data[i] = row;

				if (_config.header)
				{
					if (j > _fields.length)
						addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
					else if (j < _fields.length)
						addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
				}
			}

			if (_config.header && _results.meta)
				_results.meta.fields = _fields;
			return _results;
		}

		function guessDelimiter(input, newline)
		{
			var delimChoices = [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;

			for (var i = 0; i < delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					delimiter: delim,
					newline: newline,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++)
				{
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				if (preview.data.length > 0)
					avgFieldCount /= preview.data.length;

				if ((typeof bestDelta === 'undefined' || delta < bestDelta)
					&& avgFieldCount > 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			}
		}

		function guessLineEndings(input)
		{
			input = input.substr(0, 1024*1024);	// max length 1 MB

			var r = input.split('\r');

			var n = input.split('\n');

			var nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);

			if (r.length === 1 || nAppearsFirst)
				return '\n';

			var numWithN = 0;
			for (var i = 0; i < r.length; i++)
			{
				if (r[i][0] === '\n')
					numWithN++;
			}

			return numWithN >= r.length / 2 ? '\r\n' : '\r';
		}

		function tryParseFloat(val)
		{
			var isNumber = FLOAT.test(val);
			return isNumber ? parseFloat(val) : val;
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}





	/** The core parser implements speedy and correct CSV parsing */
	function Parser(config)
	{
		// Unpack the config object
		config = config || {};
		var delim = config.delimiter;
		var newline = config.newline;
		var comments = config.comments;
		var step = config.step;
		var preview = config.preview;
		var fastMode = config.fastMode;
		var quoteChar = config.quoteChar || '"';

		// Delimiter must be valid
		if (typeof delim !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)
			delim = ',';

		// Comment character must be valid
		if (comments === delim)
			throw 'Comment character same as delimiter';
		else if (comments === true)
			comments = '#';
		else if (typeof comments !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)
			comments = false;

		// Newline must be valid: \r, \n, or \r\n
		if (newline != '\n' && newline != '\r' && newline != '\r\n')
			newline = '\n';

		// We're gonna need these at the Parser scope
		var cursor = 0;
		var aborted = false;

		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			// For some reason, in Chrome, this speeds things up (!?)
			if (typeof input !== 'string')
				throw 'Input must be a string';

			// We don't need to compute some of these every time parse() is called,
			// but having them in a more local scope seems to perform better
			var inputLen = input.length,
				delimLen = delim.length,
				newlineLen = newline.length,
				commentsLen = comments.length;
			var stepIsFunction = typeof step === 'function';

			// Establish starting state
			cursor = 0;
			var data = [], errors = [], row = [], lastCursor = 0;

			if (!input)
				return returnable();

			if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))
			{
				var rows = input.split(newline);
				for (var i = 0; i < rows.length; i++)
				{
					var row = rows[i];
					cursor += row.length;
					if (i !== rows.length - 1)
						cursor += newline.length;
					else if (ignoreLastRow)
						return returnable();
					if (comments && row.substr(0, commentsLen) === comments)
						continue;
					if (stepIsFunction)
					{
						data = [];
						pushRow(row.split(delim));
						doStep();
						if (aborted)
							return returnable();
					}
					else
						pushRow(row.split(delim));
					if (preview && i >= preview)
					{
						data = data.slice(0, preview);
						return returnable(true);
					}
				}
				return returnable();
			}

			var nextDelim = input.indexOf(delim, cursor);
			var nextNewline = input.indexOf(newline, cursor);
			var quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');

			// Parser loop
			for (;;)
			{
				// Field has opening quote
				if (input[cursor] === quoteChar)
				{
					// Start our search for the closing quote where the cursor is
					var quoteSearch = cursor;

					// Skip the opening quote
					cursor++;

					for (;;)
					{
						// Find closing quote
						var quoteSearch = input.indexOf(quoteChar, quoteSearch+1);

						if (quoteSearch === -1)
						{
							if (!ignoreLastRow) {
								// No closing quote... what a pity
								errors.push({
									type: 'Quotes',
									code: 'MissingQuotes',
									message: 'Quoted field unterminated',
									row: data.length,	// row has yet to be inserted
									index: cursor
								});
							}
							return finish();
						}

						if (quoteSearch === inputLen-1)
						{
							// Closing quote at EOF
							var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
							return finish(value);
						}

						// If this quote is escaped, it's part of the data; skip it
						if (input[quoteSearch+1] === quoteChar)
						{
							quoteSearch++;
							continue;
						}

						if (input[quoteSearch+1] === delim)
						{
							// Closing quote followed by delimiter
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							cursor = quoteSearch + 1 + delimLen;
							nextDelim = input.indexOf(delim, cursor);
							nextNewline = input.indexOf(newline, cursor);
							break;
						}

						if (input.substr(quoteSearch+1, newlineLen) === newline)
						{
							// Closing quote followed by newline
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							saveRow(quoteSearch + 1 + newlineLen);
							nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field

							if (stepIsFunction)
							{
								doStep();
								if (aborted)
									return returnable();
							}

							if (preview && data.length >= preview)
								return returnable(true);

							break;
						}
					}

					continue;
				}

				// Comment found at start of new line
				if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)
				{
					if (nextNewline === -1)	// Comment ends at EOF
						return returnable();
					cursor = nextNewline + newlineLen;
					nextNewline = input.indexOf(newline, cursor);
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// Next delimiter comes before next newline, so we've reached end of field
				if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))
				{
					row.push(input.substring(cursor, nextDelim));
					cursor = nextDelim + delimLen;
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// End of row
				if (nextNewline !== -1)
				{
					row.push(input.substring(cursor, nextNewline));
					saveRow(nextNewline + newlineLen);

					if (stepIsFunction)
					{
						doStep();
						if (aborted)
							return returnable();
					}

					if (preview && data.length >= preview)
						return returnable(true);

					continue;
				}

				break;
			}


			return finish();


			function pushRow(row)
			{
				data.push(row);
				lastCursor = cursor;
			}

			/**
			 * Appends the remaining input from cursor to the end into
			 * row, saves the row, calls step, and returns the results.
			 */
			function finish(value)
			{
				if (ignoreLastRow)
					return returnable();
				if (typeof value === 'undefined')
					value = input.substr(cursor);
				row.push(value);
				cursor = inputLen;	// important in case parsing is paused
				pushRow(row);
				if (stepIsFunction)
					doStep();
				return returnable();
			}

			/**
			 * Appends the current row to the results. It sets the cursor
			 * to newCursor and finds the nextNewline. The caller should
			 * take care to execute user's step function and check for
			 * preview and end parsing if necessary.
			 */
			function saveRow(newCursor)
			{
				cursor = newCursor;
				pushRow(row);
				row = [];
				nextNewline = input.indexOf(newline, cursor);
			}

			/** Returns an object with the results, errors, and meta. */
			function returnable(stopped)
			{
				return {
					data: data,
					errors: errors,
					meta: {
						delimiter: delim,
						linebreak: newline,
						aborted: aborted,
						truncated: !!stopped,
						cursor: lastCursor + (baseIndex || 0)
					}
				};
			}

			/** Executes the user's step function and resets data & errors. */
			function doStep()
			{
				step(returnable());
				data = [], errors = [];
			}
		};

		/** Sets the abort flag */
		this.abort = function()
		{
			aborted = true;
		};

		/** Gets the cursor position */
		this.getCharIndex = function()
		{
			return cursor;
		};
	}


	// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code
	// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358
	function getScriptPath()
	{
		var scripts = document.getElementsByTagName('script');
		return scripts.length ? scripts[scripts.length - 1].src : '';
	}

	function newWorker()
	{
		if (!Papa.WORKERS_SUPPORTED)
			return false;
		if (!LOADED_SYNC && Papa.SCRIPT_PATH === null)
			throw new Error(
				'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
				'You need to set Papa.SCRIPT_PATH manually.'
			);
		var workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;
		// Append 'papaworker' to the search string to tell papaparse that this is our worker.
		workerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';
		var w = new global.Worker(workerUrl);
		w.onmessage = mainThreadReceivedMessage;
		w.id = workerIdCounter++;
		workers[w.id] = w;
		return w;
	}

	/** Callback when main thread receives a message */
	function mainThreadReceivedMessage(e)
	{
		var msg = e.data;
		var worker = workers[msg.workerId];
		var aborted = false;

		if (msg.error)
			worker.userError(msg.error, msg.file);
		else if (msg.results && msg.results.data)
		{
			var abort = function() {
				aborted = true;
				completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
			};

			var handle = {
				abort: abort,
				pause: notImplemented,
				resume: notImplemented
			};

			if (isFunction(worker.userStep))
			{
				for (var i = 0; i < msg.results.data.length; i++)
				{
					worker.userStep({
						data: [msg.results.data[i]],
						errors: msg.results.errors,
						meta: msg.results.meta
					}, handle);
					if (aborted)
						break;
				}
				delete msg.results;	// free memory ASAP
			}
			else if (isFunction(worker.userChunk))
			{
				worker.userChunk(msg.results, handle, msg.file);
				delete msg.results;
			}
		}

		if (msg.finished && !aborted)
			completeWorker(msg.workerId, msg.results);
	}

	function completeWorker(workerId, results) {
		var worker = workers[workerId];
		if (isFunction(worker.userComplete))
			worker.userComplete(results);
		worker.terminate();
		delete workers[workerId];
	}

	function notImplemented() {
		throw 'Not implemented.';
	}

	/** Callback when worker thread receives a message */
	function workerThreadReceivedMessage(e)
	{
		var msg = e.data;

		if (typeof Papa.WORKER_ID === 'undefined' && msg)
			Papa.WORKER_ID = msg.workerId;

		if (typeof msg.input === 'string')
		{
			global.postMessage({
				workerId: Papa.WORKER_ID,
				results: Papa.parse(msg.input, msg.config),
				finished: true
			});
		}
		else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
		{
			var results = Papa.parse(msg.input, msg.config);
			if (results)
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: results,
					finished: true
				});
		}
	}

	/** Makes a deep copy of an array or object (mostly) */
	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function bindFunction(f, self)
	{
		return function() { f.apply(self, arguments); };
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}

	return Papa;
}));

},{}],66:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],67:[function(require,module,exports){
//  Ramda v0.21.0
//  https://github.com/ramda/ramda
//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function() {

  'use strict';

  /**
     * A special placeholder value used to specify "gaps" within curried functions,
     * allowing partial application of any combination of arguments, regardless of
     * their positions.
     *
     * If `g` is a curried ternary function and `_` is `R.__`, the following are
     * equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2, _)(1, 3)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @constant
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @example
     *
     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
     *      greet('Alice'); //=> 'Hello, Alice!'
     */
    var __ = { '@@functional/placeholder': true };

    /* eslint-disable no-unused-vars */
    var _arity = function _arity(n, fn) {
        /* eslint-disable no-unused-vars */
        switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };
        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };
        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };
        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _arrayFromIterator = function _arrayFromIterator(iter) {
        var list = [];
        var next;
        while (!(next = iter.next()).done) {
            list.push(next.value);
        }
        return list;
    };

    var _arrayOf = function _arrayOf() {
        return Array.prototype.slice.call(arguments);
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    var _filter = function _filter(fn, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var _functionName = function _functionName(f) {
        // String(x => x) evaluates to "x => x", so the pattern may not match.
        var match = String(f).match(/^function (\w*)/);
        return match == null ? '' : match[1];
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    var _isArguments = function () {
        var toString = Object.prototype.toString;
        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
            return toString.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
            return _has('callee', x);
        };
    }();

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    var _isFunction = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Function]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isObject = function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
    };

    var _isPlaceholder = function _isPlaceholder(a) {
        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
    };

    var _isRegExp = function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
            result[idx] = fn(functor[idx]);
            idx += 1;
        }
        return result;
    };

    // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    var _objectAssign = function _objectAssign(target) {
        if (target == null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        var idx = 1;
        var length = arguments.length;
        while (idx < length) {
            var source = arguments[idx];
            if (source != null) {
                for (var nextKey in source) {
                    if (_has(nextKey, source)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
            idx += 1;
        }
        return output;
    };

    var _of = function _of(x) {
        return [x];
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    // \b matches word boundary; [\b] matches backspace
    var _quote = function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
        case 1:
            return _slice(args, 0, args.length);
        case 2:
            return _slice(args, from, args.length);
        default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
                list[idx] = args[from + idx];
                idx += 1;
            }
            return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xfBase = {
        init: function () {
            return this.xf['@@transducer/init']();
        },
        result: function (result) {
            return this.xf['@@transducer/result'](result);
        }
    };

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    var _aperture = function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    };

    var _assign = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it
     * will default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0 || _isPlaceholder(a)) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            switch (arguments.length) {
            case 0:
                return f2;
            case 1:
                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
                    return fn(a, _b);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b);
                }) : fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            switch (arguments.length) {
            case 0:
                return f3;
            case 1:
                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                });
            case 2:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _curry1(function (_c) {
                    return fn(a, b, _c);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
                    return fn(_a, _b, c);
                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b, c);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b, c);
                }) : _isPlaceholder(c) ? _curry1(function (_c) {
                    return fn(a, b, _c);
                }) : fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (!_isPlaceholder(result)) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    var _dropLastWhile = function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    };

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xaperture = function () {
        function XAperture(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XAperture.prototype['@@transducer/init'] = _xfBase.init;
        XAperture.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XAperture.prototype['@@transducer/step'] = function (result, input) {
            this.store(input);
            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        XAperture.prototype.getCopy = function () {
            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry2(function _xaperture(n, xf) {
            return new XAperture(n, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropLast = function () {
        function XDropLast(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
        XDropLast.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.full) {
                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
            }
            this.store(input);
            return result;
        };
        XDropLast.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        return _curry2(function _xdropLast(n, xf) {
            return new XDropLast(n, xf);
        });
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    /**
     * Adds two values.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return Number(a) + Number(b);
    });

    /**
     * Applies a function to the value at the given index of an array, returning a
     * new copy of the array with the element at the given index replaced with the
     * result of the function application.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @see R.update
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if
     * there are any that don't.
     *
     * Dispatches to the `all` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none, R.transduce
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator) in
     * other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns `true` if both arguments are `true`; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
     * @see R.both
     * @example
     *
     *      R.and(true, true); //=> true
     *      R.and(true, false); //=> false
     *      R.and(false, true); //=> false
     *      R.and(false, false); //=> false
     */
    var and = _curry2(function and(a, b) {
        return a && b;
    });

    /**
     * Returns `true` if at least one of elements of the list match the predicate,
     * `false` otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none, R.transduce
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
     * greater than the length of the list, an empty list is returned.
     *
     * Dispatches to the `aperture` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @see R.transduce
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

    /**
     * Returns a new list containing the contents of the given list, followed by
     * the given element.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should be a
     * bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value. Note that this copies and flattens prototype
     * properties onto the new object as well. All non-primitive properties are
     * copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes required
     * to create the given path, and placing the specific value at the tail end of
     * that path. Note that this copies and flattens prototype properties onto the
     * new object as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
        case 0:
            return val;
        case 1:
            return assoc(path[0], val, obj);
        default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     * @see R.partial
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * Restricts a number to be within a range.
     *
     * Also works for other ordered types such as Strings and Dates.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Relation
     * @sig Ord a => a -> a -> a -> a
     * @param {Number} minimum number
     * @param {Number} maximum number
     * @param {Number} value to be clamped
     * @return {Number} Returns the clamped value
     * @example
     *
     *      R.clamp(1, 10, -1) // => 1
     *      R.clamp(1, 10, 11) // => 10
     *      R.clamp(1, 10, 4)  // => 4
     */
    var clamp = _curry3(function clamp(min, max, value) {
        if (min > max) {
            throw new Error('min must not be greater than max in clamp(min, max, value)');
        }
        return value < min ? min : value > max ? max : value;
    });

    /**
     * Makes a comparator function out of a function that reports whether the first
     * element is less than the second.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator((a, b) => a.age < b.age);
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var sumArgs = (...args) => R.sum(args);
     *
     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not `null`, `undefined` or `NaN`
     * otherwise the first argument is returned.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = R.defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     *      defaultTo42(parseInt('string')); //=> 42
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.difference
     * @example
     *
     *      var cmp = (x, y) => x.a === y.a;
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
                out.push(first[idx]);
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the given path.
     * Note that this copies and flattens prototype properties onto the new object
     * as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return dissoc(path[0], obj);
        default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, skipping elements while the
     * predicate function returns `true`. The predicate function is passed one
     * argument: *(value)*.
     *
     * Dispatches to the `dropWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile, R.transduce, R.addIndex
     * @example
     *
     *      var lteTwo = x => x <= 2;
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
     * types are supported if they define `<Type>.empty` and/or
     * `<Type>.prototype.empty`.
     *
     * Dispatches to the `empty` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    // else
    var empty = _curry1(function empty(x) {
        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
            return arguments;
        }() : // else
        void 0;
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`,
     * according to the `transformation` functions. All non-primitive properties
     * are copied by reference.
     *
     * A `transformation` function will not be invoked if its corresponding key
     * does not exist in the evolved object.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var result = {};
        var transformation, key, type;
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation;
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Returns the first element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `find` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `findLast` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findLastIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each
     * element in the list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.forEach` method. For more
     * details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
     * the original array. In some libraries this function is named `each`.
     *
     * Dispatches to the `forEach` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @see R.addIndex
     * @example
     *
     *      var printXPlusFive = x => console.log(x + 5);
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs, R.pair
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0;
        var len = pairs.length;
        var out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Takes a list and returns a list of lists where each sublist's elements are
     * all "equal" according to the provided equality function.
     *
     * @func
     * @memberOf R
     * @since v0.21.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [[a]]
     * @param {Function} fn Function for determining whether two given (adjacent)
     *        elements should be in the same group
     * @param {Array} list The array to group. Also accepts a string, which will be
     *        treated as a list of characters.
     * @return {List} A list that contains sublists of equal elements,
     *         whose concatenations is equal to the original list.
     * @example
     *
     *    groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2, 3, 5, 8, 13, 21]]
     *
     *    groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
     *
     *    R.groupWith(R.eqBy(isVowel), 'aestiou')
     *    // ['ae', 'st', 'iou']
     */
    var groupWith = _curry2(function (fn, list) {
        var res = [];
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            var nextidx = idx + 1;
            while (nextidx < len && fn(list[idx], list[nextidx])) {
                nextidx += 1;
            }
            res.push(list.slice(idx, nextidx));
            idx = nextidx;
        }
        return res;
    });

    /**
     * Returns `true` if the first argument is greater than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has a property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good
     * as a default or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse`
     * function depending upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @see R.unless, R.when
     * @example
     *
     *      var incCount = R.ifElse(
     *        R.has('count'),
     *        R.over(R.lensProp('count'), R.inc),
     *        R.assoc('count', 1)
     *      );
     *      incCount({});           //=> { count: 1 }
     *      incCount({ count: 1 }); //=> { count: 2 }
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`. _Note that
     * this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`. _Note that this is not
     * destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * Dispatches to the `intersperse` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * See if an object (`val`) is an instance of the supplied constructor. This
     * function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if (typeof x !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    // Safari bug
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'constructor',
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
        ];
        // Safari bug
        var hasArgsEnumBug = function () {
            'use strict';
            return arguments.propertyIsEnumerable('length');
        }();
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop, nIdx;
            var ks = [];
            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
            for (prop in obj) {
                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the properties of the supplied
     * object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop;
        var ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from left to right, and returning a final value of this
     * accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var appender = (a, b) => [a + b, a + b];
     *
     *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from right to left, and returning a final value of this
     * accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = (a, b) => [a + b, a + b];
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1;
        var result = [];
        var tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * Tests a regular expression against a String. Note that this function will
     * return an empty array when there are no matches. This differs from
     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @see R.test
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the
     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.maxBy(square, -3, 2); //=> -3
     *
     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
     *      R.reduce(R.maxBy(square), 0, []); //=> 0
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of the first object merged with
     * the own properties of the second object. If a key exists in both objects,
     * the value from the second object will be used.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.mergeWith, R.mergeWithKey
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(l, r) {
        return _assign({}, l, r);
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return _assign.apply(null, [{}].concat(list));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the key
     * and the values associated with the key in each object, with the result being
     * used as the value associated with the key in the returned object. The key
     * will be excluded from the returned object if the resulting value is
     * `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWith
     * @example
     *
     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
     *      R.mergeWithKey(concatValues,
     *                     { a: true, thing: 'foo', values: [10, 20] },
     *                     { b: true, thing: 'bar', values: [15, 35] });
     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
     */
    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
        var result = {};
        var k;
        for (k in l) {
            if (_has(k, l)) {
                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
            }
        }
        for (k in r) {
            if (_has(k, r) && !_has(k, result)) {
                result[k] = r[k];
            }
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.minBy(square, -3, 2); //=> 2
     *
     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder. Note
     * that this function preserves the JavaScript-style behavior for modulo. For
     * mathematical modulo see `mathMod`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly `n` parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = (a, b) => [a, b];
     *
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
        case 0:
            return function () {
                return fn.call(this);
            };
        case 1:
            return function (a0) {
                return fn.call(this, a0);
            };
        case 2:
            return function (a0, a1) {
                return fn.call(this, a0, a1);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.call(this, a0, a1, a2);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.call(this, a0, a1, a2, a3);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.call(this, a0, a1, a2, a3, a4);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
        default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * Returns `true` if no elements of the list match the predicate, `false`
     * otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string. If n is negative the
     * element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth(2, 'abc'); //=> 'c'
     *      R.nth(3, 'abc'); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @see R.pair
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.objOf('must'),
     *        R.map(R.objOf('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var objOf = _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(_of);

    /**
     * Accepts a function `fn` and returns a function that guards invocation of
     * `fn` such that `fn` can only ever be called once, no matter how many times
     * the returned function is invoked. The first value calculated is returned in
     * subsequent invocations.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(x => x + 1);
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false;
        var result;
        return _arity(fn.length, function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        });
    });

    /**
     * Returns `true` if one or both of its arguments are `true`. Returns `false`
     * if both arguments are `false`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
     * @see R.either
     * @example
     *
     *      R.or(true, true); //=> true
     *      R.or(true, false); //=> true
     *      R.or(false, true); //=> true
     *      R.or(false, false); //=> false
     */
    var or = _curry2(function or(a, b) {
        return a || b;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the result of applying the given function to
     * the focused value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    // `Identity` is a functor that holds a single value, where `map` simply
    // transforms the held value with the provided function.
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    var over = function () {
        // `Identity` is a functor that holds a single value, where `map` simply
        // transforms the held value with the provided function.
        var Identity = function (x) {
            return {
                value: x,
                map: function (f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            // The value returned by the getter function is first transformed with `f`,
            // then set as the value of an `Identity`. This is then mapped over with the
            // setter function of the lens.
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig a -> b -> (a,b)
     * @param {*} fst
     * @param {*} snd
     * @return {Array}
     * @see R.objOf, R.of
     * @example
     *
     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
     */
    var pair = _curry2(function pair(fst, snd) {
        return [
            fst,
            snd
        ];
    });

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        var val = obj;
        var idx = 0;
        while (idx < paths.length) {
            if (val == null) {
                return;
            }
            val = val[paths[idx]];
            idx += 1;
        }
        return val;
    });

    /**
     * If the given, non-null object has a value at the given path, returns the
     * value at that path. Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig a -> [String] -> Object -> a
     * @param {*} d The default value.
     * @param {Array} p The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path` of the supplied object or the default value.
     * @example
     *
     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
     */
    var pathOr = _curry3(function pathOr(d, p, obj) {
        return defaultTo(d, path(p, obj));
    });

    /**
     * Returns `true` if the specified object property at given path satisfies the
     * given predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Logic
     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
     * @param {Function} pred
     * @param {Array} propPath
     * @param {*} obj
     * @return {Boolean}
     * @see R.propSatisfies, R.path
     * @example
     *
     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
     */
    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
        return propPath.length > 0 && pred(path(propPath, obj));
    });

    /**
     * Returns a partial copy of an object containing only the keys specified. If
     * the key does not exist, the property is ignored.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit, R.props
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for
     * properties that don't exist.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that satisfy
     * the supplied predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick, R.filter
     * @example
     *
     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the
     * contents of the list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated
     * property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property. Otherwise returns the provided default
     * value.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq, R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = (acc, pair) => acc.concat(pair);
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the reduce
     * and transduce functions. The returned value should be considered a black
     * box: the internal structure is not guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above. For instance, it is not currently supported by reduceRight.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category List
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @see R.reduce, R.transduce
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements. _Note that this is not destructive_: it returns a copy of
     * the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list or string with the elements or characters in reverse
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {Array|String} list
     * @return {Array|String}
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     *
     *      R.reverse('abc');      //=> 'cba'
     *      R.reverse('ab');       //=> 'ba'
     *      R.reverse('a');        //=> 'a'
     *      R.reverse('');         //=> ''
     */
    var reverse = _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values
     * from the left
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Returns a copy of the list, sorted according to the comparator function,
     * which should accept two values at a time and return a negative number if the
     * first value is smaller, a positive number if it's larger, and zero if they
     * are equal. Please note that this is a **copy** of the list. It does not
     * modify the original.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(R.prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Splits a given list or string at a given index.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig Number -> [a] -> [[a], [a]]
     * @sig Number -> String -> [String, String]
     * @param {Number} index The index where the array/string is split.
     * @param {Array|String} array The array/string to be split.
     * @return {Array}
     * @example
     *
     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
     */
    var splitAt = _curry2(function splitAt(index, array) {
        return [
            slice(0, index, array),
            slice(index, length(array), array)
        ];
    });

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Takes a list and a predicate and returns a pair of lists with the following properties:
     *
     *  - the result of concatenating the two output lists is equivalent to the input list;
     *  - none of the elements of the first output list satisfies the predicate; and
     *  - if the second output list is non-empty, its first element satisfies the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
     * @param {Function} pred The predicate that determines where the array is split.
     * @param {Array} list The array to be split.
     * @return {Array}
     * @example
     *
     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
     */
    var splitWhen = _curry2(function splitWhen(pred, list) {
        var idx = 0;
        var len = list.length;
        var prefix = [];
        while (idx < len && !pred(list[idx])) {
            prefix.push(list[idx]);
            idx += 1;
        }
        return [
            prefix,
            _slice(list, idx)
        ];
    });

    /**
     * Subtracts its second argument from its first argument.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return Number(a) - Number(b);
    });

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.head, R.init, R.last
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * Dispatches to the `take` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, and terminating when the
     * predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile, R.addIndex
     * @example
     *
     *      var isNotOne = x => x !== 1;
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Returns a new list containing the first `n` elements of a given list,
     * passing each value to the supplied predicate function, and terminating when
     * the predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * Dispatches to the `takeWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile, R.transduce, R.addIndex
     * @example
     *
     *      var isNotFour = x => x !== 4;
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = x => console.log('x is ' + x);
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Calls an input function `n` times, returning an array containing the results
     * of those function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0`
     * and is gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @since v0.2.3
     * @category List
     * @sig (Number -> a) -> Number -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list;
        if (len < 0 || isNaN(len)) {
            throw new RangeError('n must be a non-negative number');
        }
        list = new Array(len);
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays. Only the object's
     * own properties are used.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [
                    prop,
                    obj[prop]
                ];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays. The object's own
     * properties and prototype properties are used. Note that the order of the
     * output array is not guaranteed to be consistent across different JS
     * platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [
                prop,
                obj[prop]
            ];
        }
        return pairs;
    });

    /**
     * Transposes the rows and columns of a 2D list.
     * When passed a list of `n` lists of length `x`,
     * returns a list of `x` lists of length `n`.
     *
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [[a]] -> [[a]]
     * @param {Array} list A 2D list
     * @return {Array} A 2D list
     * @example
     *
     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * If some of the rows are shorter than the following rows, their elements are skipped:
     *
     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
     */
    var transpose = _curry1(function transpose(outerlist) {
        var i = 0;
        var result = [];
        while (i < outerlist.length) {
            var innerlist = outerlist[i];
            var j = 0;
            while (j < innerlist.length) {
                if (typeof result[j] === 'undefined') {
                    result[j] = [];
                }
                result[j].push(innerlist[j]);
                j += 1;
            }
            i += 1;
        }
        return result;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
     * function evaluates the `tryer`; if it does not throw, it simply returns the
     * result. If the `tryer` *does* throw, the returned function evaluates the
     * `catcher` function and returns its result. Note that for effective
     * composition with this function, both the `tryer` and `catcher` functions
     * must return the same type of results.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
     * @param {Function} tryer The function that may throw.
     * @param {Function} catcher The function that will be evaluated if `tryer` throws.
     * @return {Function} A new function that will catch exceptions and send then to the catcher.
     * @example
     *
     *      R.tryCatch(R.prop('x'), R.F, {x: true}); //=> true
     *      R.tryCatch(R.prop('x'), R.F, null);      //=> false
     */
    var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
        return _arity(tryer.length, function () {
            try {
                return tryer.apply(this, arguments);
            } catch (e) {
                return catcher.apply(this, _concat([e], arguments));
            }
        });
    });

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns a
     * function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function which
     * takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 1 parameter. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = a => b => c => d => a + b + c + d;
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns
     * either false to stop iteration or an array of length 2 containing the value
     * to add to the resulting list and the seed to be used in the next call to the
     * iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = n => n > 50 ? false : [-n, n + 10];
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied predicate to
     * two list elements. Prefers the first item if two items compare equal based
     * on the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = R.eqBy(String);
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is not satisfied, the function will return the result of
     * calling the `whenFalseFn` function with the same argument. If the predicate
     * is satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred        A predicate function
     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
     *                               to a falsy value.
     * @param {*}        x           An object to test with the `pred` function and
     *                               pass to `whenFalseFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
     * @see R.ifElse, R.when
     * @example
     *
     *      // coerceArray :: (a|[a]) -> [a]
     *      var coerceArray = R.unless(R.isArrayLike, R.of);
     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
     *      coerceArray(1);         //=> [1]
     */
    var unless = _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
    });

    /**
     * Takes a predicate, a transformation function, and an initial value,
     * and returns a value of the same type as the initial value.
     * It does so by applying the transformation until the predicate is satisfied,
     * at which point it returns the satisfactory value.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred A predicate function
     * @param {Function} fn The iterator function
     * @param {*} init Initial value
     * @return {*} Final value that satisfies predicate
     * @example
     *
     *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
     */
    var until = _curry3(function until(pred, fn, init) {
        var val = init;
        while (!pred(val)) {
            val = fn(val);
        }
        return val;
    });

    /**
     * Returns a new copy of the array with the element at the provided index
     * replaced with the given value.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @see R.adjust
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Accepts a function `fn` and a list of transformer functions and returns a
     * new curried function. When the new function is invoked, it calls the
     * function `fn` with parameters consisting of the result of calling each
     * supplied handler on successive arguments to the new function.
     *
     * If more arguments are passed to the returned function than transformer
     * functions, those arguments are passed directly to `fn` as additional
     * parameters. If you expect additional arguments that don't need to be
     * transformed, although you can ignore them, it's best to pass an identity
     * function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {Array} transformers A list of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
     */
    var useWith = _curry2(function useWith(fn, transformers) {
        return curryN(transformers.length, function () {
            var args = [];
            var idx = 0;
            while (idx < transformers.length) {
                args.push(transformers[idx].call(this, arguments[idx]));
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        });
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across different
     * JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties, of the
     * supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop;
        var vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    // `Const` is a functor that effectively ignores the function given to `map`.
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    var view = function () {
        // `Const` is a functor that effectively ignores the function given to `map`.
        var Const = function (x) {
            return {
                value: x,
                map: function () {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            // Using `Const` effectively ignores the setter function of the `lens`,
            // leaving the value returned by the getter function unmodified.
            return lens(Const)(x).value;
        });
    }();

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is satisfied, the function will return the result of calling
     * the `whenTrueFn` function with the same argument. If the predicate is not
     * satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred       A predicate function
     * @param {Function} whenTrueFn A function to invoke when the `condition`
     *                              evaluates to a truthy value.
     * @param {*}        x          An object to test with the `pred` function and
     *                              pass to `whenTrueFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
     * @see R.ifElse, R.unless
     * @example
     *
     *      // truncate :: String -> String
     *      var truncate = R.when(
     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
     *        R.pipe(R.take(10), R.append(''), R.join(''))
     *      );
     *      truncate('12345');         //=> '12345'
     *      truncate('0123456789ABC'); //=> '0123456789'
     */
    var when = _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of the
     * test object. `where` returns true if all the predicates return true, false
     * otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the
     * parameters, or do other processing either before the internal function is
     * called or with its results.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = name => 'Hello ' + name;
     *
     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
     *
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible pair
     * from the lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [
                    a[idx],
                    b[j]
                ];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up equally-positioned
     * items from both lists. The returned list is truncated to the length of the
     * shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [
                a[idx],
                b[idx]
            ];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     * Key/value pairing is truncated to the length of the shorter of the two lists.
     * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0;
        var len = Math.min(keys.length, values.length);
        var out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to each
     * equally-positioned pair in the lists. The returned list is truncated to the
     * length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = (x, y) => {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @param {Boolean} deep Whether or not to perform deep cloning.
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo, deep) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
            }
            return copiedValue;
        };
        switch (type(value)) {
        case 'Object':
            return copy({});
        case 'Array':
            return copy([]);
        case 'Date':
            return new Date(value.valueOf());
        case 'RegExp':
            return _cloneRegExp(value);
        default:
            return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return _curry2(function (fn, args) {
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        });
    };

    var _dropLast = function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    };

    // Values of other types are only equal if identical.
    var _equals = function _equals(a, b, stackA, stackB) {
        if (identical(a, b)) {
            return true;
        }
        if (type(a) !== type(b)) {
            return false;
        }
        if (a == null || b == null) {
            return false;
        }
        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }
        switch (type(a)) {
        case 'Arguments':
        case 'Array':
        case 'Object':
            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
                return a === b;
            }
            break;
        case 'Boolean':
        case 'Number':
        case 'String':
            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
                return false;
            }
            break;
        case 'Date':
            if (!identical(a.valueOf(), b.valueOf())) {
                return false;
            }
            break;
        case 'Error':
            return a.name === b.name && a.message === b.message;
        case 'RegExp':
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
                return false;
            }
            break;
        case 'Map':
        case 'Set':
            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
                return false;
            }
            break;
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
            break;
        case 'ArrayBuffer':
            break;
        default:
            // Values of other types are only equal if identical.
            return false;
        }
        var keysA = keys(a);
        if (keysA.length !== keys(b).length) {
            return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
            if (stackA[idx] === a) {
                return stackB[idx] === b;
            }
            idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
            var key = keysA[idx];
            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
                return false;
            }
            idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive
     * function based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value, jlen, j;
            var result = [];
            var idx = 0;
            var ilen = list.length;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0;
            var len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function (xs, x) {
                xs.push(x);
                return xs;
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function (a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function (result, input) {
                return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if (typeof obj === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xdropLastWhile = function () {
        function XDropLastWhile(fn, xf) {
            this.f = fn;
            this.retained = [];
            this.xf = xf;
        }
        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
            this.retained = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };
        XDropLastWhile.prototype.flush = function (result, input) {
            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
            this.retained = [];
            return this.xf['@@transducer/step'](result, input);
        };
        XDropLastWhile.prototype.retain = function (result, input) {
            this.retained.push(input);
            return result;
        };
        return _curry2(function _xdropLastWhile(fn, xf) {
            return new XDropLastWhile(fn, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            this.inputs = null;
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [
                key,
                []
            ];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new
     * parameters to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that
     * more closely resembles `Array.prototype.map`. Note that this will only work
     * for functions in which the iteration callback function is the first
     * parameter, and where the list is the last parameter. (This latter might be
     * unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [
                    idx,
                    list
                ]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 2 parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and
     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
     * copied, but assigned by their reference.
     *
     * Dispatches to a `clone` method if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
    });

    /**
     * Returns a curried equivalent of the provided function. The curried function
     * has two unusual capabilities. First, its arguments needn't be provided one
     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * Dispatches to the `drop` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take, R.transduce
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function,
     * skipping elements while the predicate function returns `true`. The predicate
     * function is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile, R.addIndex
     * @example
     *
     *      var lteThree = x => x <= 3;
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
     */
    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
    });

    /**
     * Takes a predicate and a "filterable", and returns a new filterable of the
     * same type containing the members of the given filterable which satisfy the
     * given predicate.
     *
     * Dispatches to the `filter` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.reject, R.transduce, R.addIndex
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    // else
    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
        return _isObject(filterable) ? _reduce(function (acc, key) {
            if (pred(filterable[key])) {
                acc[key] = filterable[key];
            }
            return acc;
        }, {}, keys(filterable)) : // else
        _filter(pred, filterable);
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays)
     * and putting them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two
     * arguments' order is reversed.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {Array|String} list
     * @return {*}
     * @see R.tail, R.init, R.last
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.last, R.head, R.tail
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @return {Array} A new list containing those elements common to both lists.
     * @see R.intersection
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        var results = [];
        var idx = 0;
        while (idx < filteredList.length) {
            if (_containsWith(pred, filteredList[idx], lookupList)) {
                results[results.length] = filteredList[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Transforms the items of the list with the transducer and appends the
     * transformed items to the accumulator using an appropriate iterator function
     * based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated
     * items will be appended to arrays and concatenated to strings. Objects will
     * be merged directly or 2-item arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity
     * reducing iterator function, step, 0-arity initial value function, init, and
     * 1-arity result extraction function result. The step function is used as the
     * iterator function in reduce. The result function is used to convert the
     * final accumulator into the return type and in most cases is R.identity. The
     * init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
    });

    /**
     * Same as R.invertObj, however this accounts for objects with duplicate values
     * by putting the values into an array.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object as values, and the
     * values of the given object, which are coerced to strings, as keys. Note
     * that the last key found is preferred when handling the same value.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the given value is its type's empty value; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig a -> Boolean
     * @param {*} x
     * @return {Boolean}
     * @see R.empty
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty({});          //=> true
     *      R.isEmpty({length: 0}); //=> false
     */
    var isEmpty = _curry1(function isEmpty(x) {
        return x != null && equals(x, empty(x));
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.init, R.head, R.tail
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in an array, or -1 if
     * the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Takes a function and
     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
     * applies the function to each of the functor's values, and returns
     * a functor of the same shape.
     *
     * Ramda provides suitable `map` implementations for `Array` and `Object`,
     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
     *
     * Dispatches to the `map` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * Also treats functions as functors and will compose them together.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Functor f => (a -> b) -> f a -> f b
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @see R.transduce, R.addIndex
     * @example
     *
     *      var double = x => x * 2;
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     *
     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
     */
    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
        case '[object Function]':
            return curryN(functor.length, function () {
                return fn.call(this, functor.apply(this, arguments));
            });
        case '[object Object]':
            return _reduce(function (acc, key) {
                acc[key] = fn(functor[key]);
                return acc;
            }, {}, keys(functor));
        default:
            return _map(fn, functor);
        }
    }));

    /**
     * An Object-specific version of `map`. The function is applied to three
     * arguments: *(value, key, obj)*. If only the value is significant, use
     * `map` instead.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig ((*, String, Object) -> *) -> Object -> Object
     * @param {Function} fn
     * @param {Object} obj
     * @return {Object}
     * @see R.map
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the values
     * associated with the key in each object, with the result being used as the
     * value associated with the key in the returned object. The key will be
     * excluded from the returned object if the resulting value is `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWithKey
     * @example
     *
     *      R.mergeWith(R.concat,
     *                  { a: true, values: [10, 20] },
     *                  { b: true, values: [15, 35] });
     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
     */
    var mergeWith = _curry3(function mergeWith(fn, l, r) {
        return mergeWithKey(function (_, _l, _r) {
            return fn(_l, _r);
        }, l, r);
    });

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided initially followed by the arguments provided to `g`.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partialRight
     * @example
     *
     *      var multiply = (a, b) => a * b;
     *      var double = R.partial(multiply, [2]);
     *      double(2); //=> 4
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var sayHello = R.partial(greet, ['Hello']);
     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = _createPartialApplicator(_concat);

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided to `g` followed by the arguments provided initially.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partial
     * @example
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = _createPartialApplicator(flip(_concat));

    /**
     * Determines whether a nested path on an object has a specific value, in
     * `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in
     * the list supplied.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @see R.props
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, [
        pickAll,
        identity
    ]);

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is, R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It may use
     * `R.reduced` to shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     *
     * Dispatches to the `reduce` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig ((a, b) -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduced, R.addIndex
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = (a, b) => a + b;
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Groups the elements of the list according to the result of calling
     * the String-returning function `keyFn` on each element and reduces the elements
     * of each group to a single value via the reducer function `valueFn`.
     *
     * This function is basically a more general `groupBy` function.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category List
     * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
     * @param {Function} valueFn The function that reduces the elements of each group to a single
     *        value. Receives two values, accumulator for a particular group and the current element.
     * @param {*} acc The (initial) accumulator value for each group.
     * @param {Function} keyFn The function that maps the list's element into a key.
     * @param {Array} list The array to group.
     * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
     *         `valueFn` for elements which produced that key when passed to `keyFn`.
     * @see R.groupBy, R.reduce
     * @example
     *
     *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
     *      var namesByGrade = reduceToNamesBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Lucy', score: 92},
     *                      {name: 'Drew', score: 85},
     *                      // ...
     *                      {name: 'Bart', score: 62}];
     *      namesByGrade(students);
     *      // {
     *      //   'A': ['Lucy'],
     *      //   'B': ['Drew']
     *      //   // ...,
     *      //   'F': ['Bart']
     *      // }
     */
    var reduceBy = _curryN(4, [], function reduceBy(valueFn, valueAcc, keyFn, list) {
        return _reduce(function (acc, elt) {
            var key = keyFn(elt);
            acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
            return acc;
        }, {}, list);
    });

    /**
     * The complement of `filter`.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.filter, R.transduce, R.addIndex
     * @example
     *
     *      var isOdd = (n) => n % 2 === 1;
     *
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    var reject = _curry2(function reject(pred, filterable) {
        return filter(_complement(pred), filterable);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    /**
     * Initializes a transducer using supplied iterator function. Returns a single
     * item by iterating through the list, successively calling the transformed
     * iterator function and passing it an accumulator value and the current value
     * from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be
     * wrapped as a transformer to initialize the transducer. A transformer can be
     * passed directly in place of an iterator function. In both cases, iteration
     * may be stopped early with the `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a
     * transformer and can be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result
     * extraction function, result. The step function is used as the iterator
     * function in reduce. The result function is used to convert the final
     * accumulator into the return type and in most cases is R.identity. The init
     * function can be used to provide an initial accumulator, but is ignored by
     * transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduce, R.reduced, R.into
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list. Duplication is determined according to the value returned by
     * applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(map(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function (xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    // Array.prototype.indexOf doesn't exist below IE9
    // manually crawl the list to distinguish between +0 and -0
    // NaN
    // non-zero numbers can utilise Set
    // all these types can utilise Set
    // null can utilise Set
    // anything else not covered above, defer to R.equals
    var _indexOf = function _indexOf(list, a, idx) {
        var inf, item;
        // Array.prototype.indexOf doesn't exist below IE9
        if (typeof list.indexOf === 'function') {
            switch (typeof a) {
            case 'number':
                if (a === 0) {
                    // manually crawl the list to distinguish between +0 and -0
                    inf = 1 / a;
                    while (idx < list.length) {
                        item = list[idx];
                        if (item === 0 && 1 / item === inf) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                } else if (a !== a) {
                    // NaN
                    while (idx < list.length) {
                        item = list[idx];
                        if (typeof item === 'number' && item !== item) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                }
                // non-zero numbers can utilise Set
                return list.indexOf(a, idx);
            // all these types can utilise Set
            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
                return list.indexOf(a, idx);
            case 'object':
                if (a === null) {
                    // null can utilise Set
                    return list.indexOf(a, idx);
                }
            }
        }
        // anything else not covered above, defer to R.equals
        while (idx < list.length) {
            if (equals(list[idx], a)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if every one of the provided predicates is satisfied
     * by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.anyPass
     * @example
     *
     *      var isQueen = R.propEq('rank', 'Q');
     *      var isSpade = R.propEq('suit', '');
     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
     *
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
     */
    var allPass = _curry1(function allPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (!preds[idx].apply(this, arguments)) {
                    return false;
                }
                idx += 1;
            }
            return true;
        });
    });

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
     * `false`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @deprecated since v0.20.0
     * @example
     *
     *      R.allUniq(['1', 1]); //=> true
     *      R.allUniq([1, 1]);   //=> false
     *      R.allUniq([[42], [42]]); //=> false
     */
    var allUniq = _curry1(function allUniq(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if at least one of the provided predicates is
     * satisfied by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.allPass
     * @example
     *
     *      var gte = R.anyPass([R.gt, R.equals]);
     *
     *      gte(3, 2); //=> true
     *      gte(2, 2); //=> true
     *      gte(2, 3); //=> false
     */
    var anyPass = _curry1(function anyPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (preds[idx].apply(this, arguments)) {
                    return true;
                }
                idx += 1;
            }
            return false;
        });
    });

    /**
     * ap applies a list of functions to a list of values.
     *
     * Dispatches to the `ap` method of the second argument, if present. Also
     * treats functions as applicatives.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    // else
    var ap = _curry2(function ap(applicative, fn) {
        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
            return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : // else
        _reduce(function (acc, f) {
            return _concat(acc, map(f, fn));
        }, [], applicative);
    });

    /**
     * Given a spec object recursively mapping properties to functions, creates a
     * function producing an object of the same structure, by mapping each property
     * to the result of calling its associated function with the supplied arguments.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
     * @param {Object} spec an object recursively mapping properties to functions for
     *        producing the values for these properties.
     * @return {Function} A function that returns an object of the same structure
     * as `spec', with each property set to the value returned by calling its
     * associated function with the supplied arguments.
     * @see R.juxt
     * @example
     *
     *      var getMetrics = R.applySpec({
     *                                      sum: R.add,
     *                                      nested: { mul: R.multiply }
     *                                   });
     *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
     */
    var applySpec = _curry1(function applySpec(spec) {
        spec = map(function (v) {
            return typeof v == 'function' ? v : applySpec(v);
        }, spec);
        return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
            var args = arguments;
            return map(function (f) {
                return apply(f, args);
            }, spec);
        });
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right branch
     * produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call, [
     *                                  R.pipe(R.prop('indent'), indentN),
     *                                  R.prop('value')
     *                              ]);
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results. `chain`
     * is also known as `flatMap` in some libraries
     *
     * Dispatches to the `chain` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = n => [n, n];
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
        if (typeof monad === 'function') {
            return function () {
                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
            };
        }
        return _makeFlat(false)(map(fn, monad));
    }));

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
     * to `fn` are applied to each of the predicates in turn until one returns a
     * "truthy" value, at which point `fn` returns the result of applying its
     * arguments to the corresponding transformer. If none of the predicates
     * matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0C')],
     *        [R.equals(100), R.always('water boils at 100C')],
     *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
     *      ]);
     *      fn(0); //=> 'water freezes at 0C'
     *      fn(50); //=> 'nothing special happens at 50C'
     *      fn(100); //=> 'water boils at 100C'
     */
    var cond = _curry1(function cond(pairs) {
        var arity = reduce(max, 0, map(function (pair) {
            return pair[0].length;
        }, pairs));
        return _arity(arity, function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        });
    });

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type. The arity of the function
     * returned is specified to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = () => {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
            case 1:
                return new Fn($0);
            case 2:
                return new Fn($0, $1);
            case 3:
                return new Fn($0, $1, $2);
            case 4:
                return new Fn($0, $1, $2, $3);
            case 5:
                return new Fn($0, $1, $2, $3, $4);
            case 6:
                return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
                return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts a converging function and a list of branching functions and returns
     * a new function. When invoked, this new function is applied to some
     * arguments, each branching function is applied to those same arguments. The
     * results of each branching function are passed as arguments to the converging
     * function to produce the return value.
     *
     * @func
     * @memberOf R
     * @since v0.4.2
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {Array} functions A list of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = (a, b) => a + b;
     *      var multiply = (a, b) => a * b;
     *      var subtract = (a, b) => a - b;
     *
     *      // multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
     *
     *      var add3 = (a, b, c) => a + b + c;
     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
     */
    var converge = _curry2(function converge(after, fns) {
        return curryN(reduce(max, 0, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Counts the elements of a list according to how many match each value of a
     * key generated by the supplied function. Returns an object mapping the keys
     * produced by `fn` to the number of occurrences in the list. Note that all
     * keys are coerced to strings because of how JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = reduceBy(function (acc, elem) {
        return acc + 1;
    }, 0);

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements. The
     * first element in a series of equal element is the one being preserved.
     *
     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Takes a function and two values in its domain and returns `true` if the
     * values map to the same value in the codomain; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Relation
     * @sig (a -> b) -> a -> a -> Boolean
     * @param {Function} f
     * @param {*} x
     * @param {*} y
     * @return {Boolean}
     * @example
     *
     *      R.eqBy(Math.abs, 5, -5); //=> true
     */
    var eqBy = _curry3(function eqBy(f, x, y) {
        return equals(f(x), f(y));
    });

    /**
     * Reports whether two objects have the same value, in `R.equals` terms, for
     * the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Splits a list into sub-lists stored in an object, based on the result of
     * calling a String-returning function on each element, and grouping the
     * results according to values returned.
     *
     * Dispatches to the `groupBy` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @see R.transduce
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, reduceBy(function (acc, item) {
        if (acc == null) {
            acc = [];
        }
        acc.push(item);
        return acc;
    }, null)));

    /**
     * Given a function that generates a key, turns a list of objects into an
     * object indexing the objects by the given key. Note that if multiple
     * objects generate the same value for the indexing key only the last value
     * will be included in the generated object.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
     * @param {Function} fn Function :: a -> String
     * @param {Array} array The array of objects to index
     * @return {Object} An object indexing each array element by the given property.
     * @example
     *
     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
     *      R.indexBy(R.prop('id'), list);
     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
     */
    var indexBy = reduceBy(function (acc, elem) {
        return elem;
    }, null);

    /**
     * Returns the position of the first occurrence of an item in an array, or -1
     * if the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * juxt applies a list of functions to a list of values.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Function
     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
     * @param {Array} fns An array of functions
     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
     * @see R.applySpec
     * @example
     *
     *      var range = R.juxt([Math.min, Math.max]);
     *      range(3, 4, 9, -3); //=> [-3, 9]
     */
    var juxt = _curry1(function juxt(fns) {
        return converge(_arrayOf, fns);
    });

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (toFunctorFn) {
            return function (target) {
                return map(function (focus) {
                    return setter(focus, target);
                }, toFunctorFn(getter(target)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified path.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig [String] -> Lens s a
     * @param {Array} path The path to use.
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xyLens = R.lensPath(['x', 'y']);
     *
     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
     */
    var lensPath = _curry1(function lensPath(p) {
        return lens(path(p), assocPath(p));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that
     * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.lift, R.ap
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Takes a predicate and a list or other "filterable" object and returns the
     * pair of filterable objects of the same type of elements which do and do not
     * satisfy, the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
     * @param {Function} pred A predicate to determine which side the element belongs to.
     * @param {Array} filterable the list (or other filterable) to partition.
     * @return {Array} An array, containing first the subset of elements that satisfy the
     *         predicate, and second the subset of elements that do not satisfy.
     * @see R.filter, R.reject
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     *
     *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
     *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
     */
    var partition = juxt([
        filter,
        reject
    ]);

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * **Note:** The result of pipe is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining functions
     * must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
     * Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
     * @param {Function} of
     * @param {*} traversable
     * @return {*}
     * @see R.traverse
     * @example
     *
     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     *
     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
     */
    var sequence = _curry2(function sequence(of, traversable) {
        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
            return ap(map(prepend, x), acc);
        }, of([]), traversable);
    });

    /**
     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
     * into an Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
     * @param {Function} of
     * @param {Function} f
     * @param {*} traversable
     * @return {*}
     * @see R.sequence
     * @example
     *
     *      // Returns `Nothing` if the given divisor is `0`
     *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
     *
     *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
     *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
     */
    var traverse = _curry3(function traverse(of, f, traversable) {
        return sequence(of, map(f, traversable));
    });

    /**
     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig Chain c => c (c a) -> c a
     * @param {*} list
     * @return {*}
     * @see R.flatten, R.chain
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = chain(_identity);

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function (obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
        case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
                return /^\d+$/.test(k);
            }, keys(x)))).join(', ') + ']';
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            if (typeof x.toString === 'function') {
                var repr = x.toString();
                if (repr !== '[object Object]') {
                    return repr;
                }
            }
            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * **Note:** The result of compose is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.pipeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return compose.apply(this, prepend(identity, map(chain, arguments)));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = config => {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
     * least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     * @see R.any
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements. `R.equals`
     * is used to determine equality.
     *
     * Dispatches to the `dropRepeats` method of the first argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.liftN
     * @example
     *
     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
     *
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
     *
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.composeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Returns a new list without values in the first argument.
     * `R.equals` is used to determine equality.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The values to be removed from `list2`.
     * @param {Array} list2 The array to remove values from.
     * @return {Array} The new array without values in `list1`.
     * @see R.transduce
     * @example
     *
     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
     */
    var without = _curry2(function (xs, list) {
        return reject(flip(_contains)(xs), list);
    });

    // A simple Set type that honours R.equals semantics
    /* globals Set */
    /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
    // distinguish between +0 and -0
    // these types can all utilise Set
    // set._items['boolean'] holds a two element array
    // representing [ falseExists, trueExists ]
    // compare functions for reference equality
    /* falls through */
    // reduce the search size of heterogeneous sets by creating buckets
    // for each type.
    // scan through all previously applied items
    var _Set = function () {
        function _Set() {
            /* globals Set */
            this._nativeSet = typeof Set === 'function' ? new Set() : null;
            this._items = {};
        }
        _Set.prototype.add = function (item) {
            return hasOrAdd(item, true, this);
        };
        _Set.prototype.has = function (item) {
            return hasOrAdd(item, false, this);
        };
        /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
        function hasOrAdd(item, shouldAdd, set) {
            var type = typeof item;
            var prevSize, newSize;
            switch (type) {
            case 'string':
            case 'number':
                // distinguish between +0 and -0
                if (item === 0 && !set._items['-0'] && 1 / item === -Infinity) {
                    if (shouldAdd) {
                        set._items['-0'] = true;
                    }
                    return shouldAdd;
                }
                // these types can all utilise Set
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = {};
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    } else if (item in set._items[type]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    }
                }
            case 'boolean':
                // set._items['boolean'] holds a two element array
                // representing [ falseExists, trueExists ]
                if (type in set._items) {
                    var bIdx = item ? 1 : 0;
                    if (set._items[type][bIdx]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][bIdx] = true;
                        }
                        return shouldAdd;
                    }
                } else {
                    if (shouldAdd) {
                        set._items[type] = item ? [
                            false,
                            true
                        ] : [
                            true,
                            false
                        ];
                    }
                    return shouldAdd;
                }
            case 'function':
                // compare functions for reference equality
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = [item];
                        }
                        return shouldAdd;
                    }
                    if (!_contains(item, set._items[type])) {
                        if (shouldAdd) {
                            set._items[type].push(item);
                        }
                        return shouldAdd;
                    }
                }
                return !shouldAdd;
            case 'undefined':
                if (set._items[type]) {
                    return !shouldAdd;
                } else {
                    if (shouldAdd) {
                        set._items[type] = true;
                    }
                    return shouldAdd;
                }
            case 'object':
                if (item === null) {
                    if (!set._items['null']) {
                        if (shouldAdd) {
                            set._items['null'] = true;
                        }
                        return shouldAdd;
                    }
                    return !shouldAdd;
                }
            /* falls through */
            default:
                // reduce the search size of heterogeneous sets by creating buckets
                // for each type.
                type = Object.prototype.toString.call(item);
                if (!(type in set._items)) {
                    if (shouldAdd) {
                        set._items[type] = [item];
                    }
                    return shouldAdd;
                }
                // scan through all previously applied items
                if (!_contains(item, set._items[type])) {
                    if (shouldAdd) {
                        set._items[type].push(item);
                    }
                    return shouldAdd;
                }
                return !shouldAdd;
            }
        }
        return _Set;
    }();

    /**
     * A function wrapping calls to the two functions in an `&&` operation,
     * returning the result of the first function if it is false-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * false-y value.
     *
     * In addition to functions, `R.both` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = _curry2(function both(f, g) {
        return _isFunction(f) ? function _both() {
            return f.apply(this, arguments) && g.apply(this, arguments);
        } : lift(and)(f, g);
    });

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * `R.complement` will work on all other functors as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = lift(not);

    /**
     * A function wrapping calls to the two functions in an `||` operation,
     * returning the result of the first function if it is truth-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * truth-y value.
     *
     * In addition to functions, `R.either` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = _curry2(function either(f, g) {
        return _isFunction(f) ? function _either() {
            return f.apply(this, arguments) || g.apply(this, arguments);
        } : lift(or)(f, g);
    });

    /**
     * Turns a named method with a specified arity into a function that can be
     * called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {String} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each element and
     * concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn`
     * for a given argument set and returns the result. Subsequent calls to the
     * memoized `fn` with the same argument set will not result in an additional
     * call to `fn`; instead, the cached result for that set of arguments will be
     * returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(n => {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return _arity(fn.length, function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        });
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig (String | RegExp) -> String -> [String]
     * @param {String|RegExp} sep The pattern.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @see R.match
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
        }
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied function to
     * each list element. Prefers the first item if the supplied function produces
     * the same value on two items. `R.equals` is used for comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var set = new _Set();
        var result = [];
        var idx = 0;
        var appliedItem, item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (set.add(appliedItem)) {
                result.push(item);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of concatenating the given lists or strings.
     *
     * Dispatches to the `concat` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @sig String -> String -> String
     * @param {Array|String} a
     * @param {Array|String} b
     * @return {Array|String}
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = flip(invoker(1, 'concat'));

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifferenceWith
     * @example
     *
     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
     */
    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
        return concat(difference(list1, list2), difference(list2, list1));
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both. Duplication is determined according to the value
     * returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifference
     * @example
     *
     *      var eqA = R.eqBy(R.prop('a'));
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
     */
    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list. `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqBy(identity);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @see R.intersectionWith
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        return uniq(_filter(flip(_contains)(lookupList), filteredList));
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        allUniq: allUniq,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        applySpec: applySpec,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clamp: clamp,
        clone: clone,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        converge: converge,
        countBy: countBy,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqBy: eqBy,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        groupBy: groupBy,
        groupWith: groupWith,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexBy: indexBy,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        join: join,
        juxt: juxt,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensPath: lensPath,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        mergeWith: mergeWith,
        mergeWithKey: mergeWithKey,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        objOf: objOf,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        pair: pair,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pathOr: pathOr,
        pathSatisfies: pathSatisfies,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceBy: reduceBy,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        sequence: sequence,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitAt: splitAt,
        splitEvery: splitEvery,
        splitWhen: splitWhen,
        subtract: subtract,
        sum: sum,
        symmetricDifference: symmetricDifference,
        symmetricDifferenceWith: symmetricDifferenceWith,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        transpose: transpose,
        traverse: traverse,
        trim: trim,
        tryCatch: tryCatch,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unless: unless,
        unnest: unnest,
        until: until,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        when: when,
        where: where,
        whereEq: whereEq,
        without: without,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };
  /* eslint-env amd */

  /* TEST_ENTRY_POINT */

  if (typeof exports === 'object') {
    module.exports = R;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return R; });
  } else {
    this.R = R;
  }

}.call(this));

},{}]},{},[20])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9iYW0uanMiLCJqcy9iZWR3aWcuanMiLCJqcy9iaWd3aWcuanMiLCJqcy9iaW4uanMiLCJqcy9icm93c2VyLXVpLmpzIiwianMvY2Jyb3dzZXIuanMiLCJqcy9jaGFpbnNldC5qcyIsImpzL2NpZ2FyLmpzIiwianMvY29sb3IuanMiLCJqcy9jc3YuZXM2IiwianMvZGFzLmpzIiwianMvZGVmYXVsdC1yZW5kZXJlci5lczYiLCJqcy9kb211aS5qcyIsImpzL2R1bW15LXJlbmRlcmVyLmVzNiIsImpzL2VuY29kZS5qcyIsImpzL2Vuc2VtYmxqc29uLmpzIiwianMvZXhwb3J0LWNvbmZpZy5qcyIsImpzL2V4cG9ydC1pbWFnZS5qcyIsImpzL2V4cG9ydC11aS5qcyIsImpzL2V4cG9ydHMuanMiLCJqcy9mZWF0dXJlLWRyYXcuanMiLCJqcy9mZWF0dXJlLXBvcHVwLmpzIiwianMvZmVhdHVyZXMuanMiLCJqcy9nbHlwaHMuanMiLCJqcy9qYmpzb24uanMiLCJqcy9rc3BhY2UuanMiLCJqcy9saDN1dGlscy5qcyIsImpzL21lbXN0b3JlLmpzIiwianMvbXVsdGktcmVuZGVyZXIuZXM2IiwianMvbnVtZm9ybWF0cy5qcyIsImpzL292ZXJsYXkuanMiLCJqcy9wcm9iZS5qcyIsImpzL3F0bC1zb3VyY2UuZXM2IiwianMvcnF0bC1nZW5vdHlwZS1zb3VyY2UuZXM2IiwianMvcnVsZXJzLmVzNiIsImpzL3NhbXBsZS5qcyIsImpzL3NlYXJjaC5qcyIsImpzL3NlcXVlbmNlLWRyYXcuanMiLCJqcy9zZXNzaW9uLmpzIiwianMvc2hhMS5qcyIsImpzL3NvdXJjZWFkYXB0ZXJzLmpzIiwianMvc291cmNlY29tcGFyZS5qcyIsImpzL3NwYW5zLmpzIiwianMvc3R5bGUuanMiLCJqcy9zdWItcmVuZGVyZXIuZXM2IiwianMvc3ZnLWV4cG9ydC5qcyIsImpzL3N2Zy11dGlscy5qcyIsImpzL3RhYml4LXNvdXJjZS5qcyIsImpzL3RhYml4LmpzIiwianMvdGVzdC1zb3VyY2UuZXM2IiwianMvdGh1Yi5qcyIsImpzL3RpZXItYWN0aW9ucy5qcyIsImpzL3RpZXItZWRpdC5qcyIsImpzL3RpZXIuanMiLCJqcy90cmFjay1hZGRlci5qcyIsImpzL3RyaXguanMiLCJqcy90d29CaXQuanMiLCJqcy91dGlscy5qcyIsImpzL3ZjZi5qcyIsImpzL3ZlcnNpb24uanMiLCJqcy93cmFwcGVkLXJlbmRlcmVyLmVzNiIsImpzL3pvb21zbGlkZXIuanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3psaWIvanMvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYXBhcGFyc2UvcGFwYXBhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yYW1kYS9kaXN0L3JhbWRhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUksT0FBTyxPQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ2pDLFFBQUksUUFBUSxRQUFRLFNBQVIsQ0FBWjtBQUNBLFFBQUksUUFBUSxNQUFNLEtBQWxCO0FBQ0EsUUFBSSxRQUFRLE1BQU0sS0FBbEI7QUFDQSxRQUFJLGVBQWUsTUFBTSxZQUF6Qjs7QUFFQSxRQUFJLE1BQU0sUUFBUSxPQUFSLENBQVY7QUFDQSxRQUFJLFVBQVUsSUFBSSxPQUFsQjtBQUNBLFFBQUksWUFBWSxJQUFJLFNBQXBCO0FBQ0EsUUFBSSxXQUFXLElBQUksUUFBbkI7QUFDQSxRQUFJLFlBQVksSUFBSSxTQUFwQjtBQUNBLFFBQUksWUFBWSxJQUFJLFNBQXBCOztBQUVBLFFBQUksV0FBVyxRQUFRLFlBQVIsQ0FBZjtBQUNBLFFBQUksVUFBVSxTQUFTLE9BQXZCO0FBQ0EsUUFBSSxTQUFTLFNBQVMsTUFBdEI7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Y4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMVxuLy9cbi8vIGJhbS5qczogaW5kZXhlZCBiaW5hcnkgYWxpZ25tZW50c1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHNwYW5zID0gcmVxdWlyZSgnLi9zcGFucycpO1xuICAgIHZhciBSYW5nZSA9IHNwYW5zLlJhbmdlO1xuICAgIHZhciB1bmlvbiA9IHNwYW5zLnVuaW9uO1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBzcGFucy5pbnRlcnNlY3Rpb247XG5cbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgcmVhZEludCA9IGJpbi5yZWFkSW50O1xuICAgIHZhciByZWFkU2hvcnQgPSBiaW4ucmVhZFNob3J0O1xuICAgIHZhciByZWFkQnl0ZSA9IGJpbi5yZWFkQnl0ZTtcbiAgICB2YXIgcmVhZEludDY0ID0gYmluLnJlYWRJbnQ2NDtcbiAgICB2YXIgcmVhZEZsb2F0ID0gYmluLnJlYWRGbG9hdDtcblxuICAgIHZhciBsaDN1dGlscyA9IHJlcXVpcmUoJy4vbGgzdXRpbHMnKTtcbiAgICB2YXIgcmVhZFZvYiA9IGxoM3V0aWxzLnJlYWRWb2I7XG4gICAgdmFyIHVuYmd6ZiA9IGxoM3V0aWxzLnVuYmd6ZjtcbiAgICB2YXIgcmVnMmJpbnMgPSBsaDN1dGlscy5yZWcyYmlucztcbiAgICB2YXIgQ2h1bmsgPSBsaDN1dGlscy5DaHVuaztcbn1cblxuXG52YXIgQkFNX01BR0lDID0gMHgxNGQ0MTQyO1xudmFyIEJBSV9NQUdJQyA9IDB4MTQ5NDE0MjtcblxudmFyIEJhbUZsYWdzID0ge1xuICAgIE1VTFRJUExFX1NFR01FTlRTOiAgICAgICAweDEsXG4gICAgQUxMX1NFR01FTlRTX0FMSUdOOiAgICAgIDB4MixcbiAgICBTRUdNRU5UX1VOTUFQUEVEOiAgICAgICAgMHg0LFxuICAgIE5FWFRfU0VHTUVOVF9VTk1BUFBFRDogICAweDgsXG4gICAgUkVWRVJTRV9DT01QTEVNRU5UOiAgICAgIDB4MTAsXG4gICAgTkVYVF9SRVZFUlNFX0NPTVBMRU1FTlQ6IDB4MjAsXG4gICAgRklSU1RfU0VHTUVOVDogICAgICAgICAgIDB4NDAsXG4gICAgTEFTVF9TRUdNRU5UOiAgICAgICAgICAgIDB4ODAsXG4gICAgU0VDT05EQVJZX0FMSUdOTUVOVDogICAgIDB4MTAwLFxuICAgIFFDX0ZBSUw6ICAgICAgICAgICAgICAgICAweDIwMCxcbiAgICBEVVBMSUNBVEU6ICAgICAgICAgICAgICAgMHg0MDAsXG4gICAgU1VQUExFTUVOVEFSWTogICAgICAgICAgIDB4ODAwXG59O1xuXG5mdW5jdGlvbiBCYW1GaWxlKCkge1xufVxuXG5cbi8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIEJBSSByZWYgc3RhcnRpbmcgYXQgb2Zmc2V0LlxuLy8gUmV0dXJucyB7bmJpbiwgbGVuZ3RoLCBtaW5CbG9ja0luZGV4fVxuZnVuY3Rpb24gX2dldEJhaVJlZkxlbmd0aCh1bmNiYSwgb2Zmc2V0KSB7XG4gICAgdmFyIHAgPSBvZmZzZXQ7XG4gICAgdmFyIG5iaW4gPSByZWFkSW50KHVuY2JhLCBwKTsgcCArPSA0O1xuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgbmJpbjsgKytiKSB7XG4gICAgICAgIHZhciBiaW4gPSByZWFkSW50KHVuY2JhLCBwKTtcbiAgICAgICAgdmFyIG5jaG5rID0gcmVhZEludCh1bmNiYSwgcCs0KTtcbiAgICAgICAgcCArPSA4ICsgKG5jaG5rICogMTYpO1xuICAgIH1cbiAgICB2YXIgbmludHYgPSByZWFkSW50KHVuY2JhLCBwKTsgcCArPSA0O1xuXG4gICAgdmFyIG1pbkJsb2NrSW5kZXggPSAxMDAwMDAwMDAwO1xuICAgIHZhciBxID0gcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5pbnR2OyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSByZWFkVm9iKHVuY2JhLCBxKTsgcSArPSA4O1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgdmFyIGJpID0gdi5ibG9jaztcbiAgICAgICAgICAgIGlmICh2Lm9mZnNldCA+IDApXG4gICAgICAgICAgICAgICAgYmkgKz0gNjU1MzY7XG5cbiAgICAgICAgICAgIGlmIChiaSA8IG1pbkJsb2NrSW5kZXgpXG4gICAgICAgICAgICAgICAgbWluQmxvY2tJbmRleCA9IGJpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcCArPSAobmludHYgKiA4KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1pbkJsb2NrSW5kZXg6IG1pbkJsb2NrSW5kZXgsXG4gICAgICAgIG5iaW46IG5iaW4sXG4gICAgICAgIGxlbmd0aDogcCAtIG9mZnNldFxuICAgIH07XG59XG5cblxuZnVuY3Rpb24gbWFrZUJhbShkYXRhLCBiYWksIGluZGV4Q2h1bmtzLCBjYWxsYmFjaywgYXR0ZW1wdGVkKSB7XG4gICAgLy8gRG8gYW4gaW5pdGlhbCBwcm9iZSBvbiB0aGUgQkFNIGZpbGUgdG8gY2F0Y2ggYW55IG1peGVkLWNvbnRlbnQgZXJyb3JzLlxuICAgIGRhdGEuc2xpY2UoMCwgMTApLmZldGNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUJhbTIoZGF0YSwgYmFpLCBpbmRleENodW5rcywgY2FsbGJhY2ssIGF0dGVtcHRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJDb3VsZG4ndCBhY2Nlc3MgQkFNLlwiKTtcbiAgICAgICAgfVxuICAgIH0sIHt0aW1lb3V0OiA1MDAwfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VCYW0yKGRhdGEsIGJhaSwgaW5kZXhDaHVua3MsIGNhbGxiYWNrLCBhdHRlbXB0ZWQpIHtcbiAgICB2YXIgYmFtID0gbmV3IEJhbUZpbGUoKTtcbiAgICBiYW0uZGF0YSA9IGRhdGE7XG4gICAgYmFtLmJhaSA9IGJhaTtcbiAgICBiYW0uaW5kZXhDaHVua3MgPSBpbmRleENodW5rcztcblxuICAgIHZhciBtaW5CbG9ja0luZGV4ID0gYmFtLmluZGV4Q2h1bmtzID8gYmFtLmluZGV4Q2h1bmtzLm1pbkJsb2NrSW5kZXggOiAxMDAwMDAwMDAwO1xuXG4gICAgLy8gRmlsbHMgb3V0IGJhbS5jaHJUb0luZGV4IGFuZCBiYW0uaW5kZXhUb0NociBiYXNlZCBvbiB0aGUgZmlyc3QgZmV3IGJ5dGVzIG9mIHRoZSBCQU0uXG4gICAgZnVuY3Rpb24gcGFyc2VCYW1IZWFkZXIocikge1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkNvdWxkbid0IGFjY2VzcyBCQU1cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5jID0gdW5iZ3pmKHIsIHIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZhciB1bmNiYSA9IG5ldyBVaW50OEFycmF5KHVuYyk7XG5cbiAgICAgICAgdmFyIG1hZ2ljID0gcmVhZEludCh1bmNiYSwgMCk7XG4gICAgICAgIGlmIChtYWdpYyAhPSBCQU1fTUFHSUMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIk5vdCBhIEJBTSBmaWxlLCBtYWdpYz0weFwiICsgbWFnaWMudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZExlbiA9IHJlYWRJbnQodW5jYmEsIDQpO1xuICAgICAgICB2YXIgaGVhZGVyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZExlbjsgKytpKSB7XG4gICAgICAgICAgICBoZWFkZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmNiYVtpICsgOF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5SZWYgPSByZWFkSW50KHVuY2JhLCBoZWFkTGVuICsgOCk7XG4gICAgICAgIHZhciBwID0gaGVhZExlbiArIDEyO1xuXG4gICAgICAgIGJhbS5jaHJUb0luZGV4ID0ge307XG4gICAgICAgIGJhbS5pbmRleFRvQ2hyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJlZjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbE5hbWUgPSByZWFkSW50KHVuY2JhLCBwKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxOYW1lLTE7ICsraikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmNiYVtwICsgNCArIGpdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsUmVmID0gcmVhZEludCh1bmNiYSwgcCArIGxOYW1lICsgNCk7XG4gICAgICAgICAgICBiYW0uY2hyVG9JbmRleFtuYW1lXSA9IGk7XG4gICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdjaHInKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmFtLmNoclRvSW5kZXhbbmFtZS5zdWJzdHJpbmcoMyldID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFtLmNoclRvSW5kZXhbJ2NocicgKyBuYW1lXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYW0uaW5kZXhUb0Noci5wdXNoKG5hbWUpO1xuXG4gICAgICAgICAgICBwID0gcCArIDggKyBsTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYW0uaW5kaWNlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJhaShoZWFkZXIpIHtcbiAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkNvdWxkbid0IGFjY2VzcyBCQUlcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmNiYSA9IG5ldyBVaW50OEFycmF5KGhlYWRlcik7XG4gICAgICAgIHZhciBiYWlNYWdpYyA9IHJlYWRJbnQodW5jYmEsIDApO1xuICAgICAgICBpZiAoYmFpTWFnaWMgIT0gQkFJX01BR0lDKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ05vdCBhIEJBSSBmaWxlLCBtYWdpYz0weCcgKyBiYWlNYWdpYy50b1N0cmluZygxNikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5yZWYgPSByZWFkSW50KHVuY2JhLCA0KTtcblxuICAgICAgICBiYW0uaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIHZhciBwID0gODtcbiAgICAgICAgZm9yICh2YXIgcmVmID0gMDsgcmVmIDwgbnJlZjsgKytyZWYpIHtcbiAgICAgICAgICAgIHZhciBibG9ja1N0YXJ0ID0gcDtcbiAgICAgICAgICAgIHZhciBvID0gX2dldEJhaVJlZkxlbmd0aCh1bmNiYSwgYmxvY2tTdGFydCk7XG4gICAgICAgICAgICBwICs9IG8ubGVuZ3RoO1xuXG4gICAgICAgICAgICBtaW5CbG9ja0luZGV4ID0gTWF0aC5taW4oby5taW5CbG9ja0luZGV4LCBtaW5CbG9ja0luZGV4KTtcblxuICAgICAgICAgICAgdmFyIG5iaW4gPSBvLm5iaW47XG5cbiAgICAgICAgICAgIGlmIChuYmluID4gMCkge1xuICAgICAgICAgICAgICAgIGJhbS5pbmRpY2VzW3JlZl0gPSBuZXcgVWludDhBcnJheShoZWFkZXIsIGJsb2NrU3RhcnQsIHAgLSBibG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYmFtLmluZGV4Q2h1bmtzKSB7XG4gICAgICAgIGJhbS5iYWkuZmV0Y2goZnVuY3Rpb24oaGVhZGVyKSB7ICAgLy8gRG8gd2UgcmVhbGx5IG5lZWQgdG8gZmV0Y2ggdGhlIHdob2xlIHRoaW5nPyA6LShcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUJhaShoZWFkZXIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChiYW0uYmFpLnVybCAmJiB0eXBlb2YoYXR0ZW1wdGVkKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGF0dGVtcHRlZCB4LmJhbS5iYWkgbm90IHRoZXJlIHNvIG5vdyB0cnlpbmcgeC5iYWlcbiAgICAgICAgICAgICAgICAgICAgYmFtLmJhaS51cmwgPSBiYW0uZGF0YS51cmwucmVwbGFjZShuZXcgUmVnRXhwKCcuYmFtJCcpLCAnLmJhaScpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIC8vIFRydWUgbGV0cyB1cyBrbm93IHdlIGFyZSBtYWtpbmcgYSBzZWNvbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICBtYWtlQmFtMihkYXRhLCBiYW0uYmFpLCBpbmRleENodW5rcywgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgYXR0ZW1wdGVkIHguYmFtLmJhaSAmIHguYmFpIGFuZCBub3RoaW5nIHdvcmtlZFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJhbS5kYXRhLnNsaWNlKDAsIG1pbkJsb2NrSW5kZXgpLmZldGNoKHBhcnNlQmFtSGVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7ICAgLy8gVGltZW91dCBvbiBmaXJzdCByZXF1ZXN0IHRvIGNhdGNoIENocm9tZSBtaXhlZC1jb250ZW50IGVycm9yLlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaHVua3MgPSBiYW0uaW5kZXhDaHVua3MuY2h1bmtzO1xuICAgICAgICBiYW0uaW5kaWNlcyA9IFtdXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIGJhbS5pbmRpY2VzW2ldID0gbnVsbDsgIC8vIFRvIGJlIGZpbGxlZCBvdXQgbGF6aWx5IGFzIG5lZWRlZFxuICAgICAgICB9XG4gICAgICAgIGJhbS5kYXRhLnNsaWNlKDAsIG1pbkJsb2NrSW5kZXgpLmZldGNoKHBhcnNlQmFtSGVhZGVyKTtcbiAgICB9XG59XG5cblxuXG5CYW1GaWxlLnByb3RvdHlwZS5ibG9ja3NGb3JSYW5nZSA9IGZ1bmN0aW9uKHJlZklkLCBtaW4sIG1heCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kaWNlc1tyZWZJZF07XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGludEJpbnNMID0gcmVnMmJpbnMobWluLCBtYXgpO1xuICAgIHZhciBpbnRCaW5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRCaW5zTC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnRCaW5zW2ludEJpbnNMW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBsZWFmQ2h1bmtzID0gW10sIG90aGVyQ2h1bmtzID0gW107XG5cbiAgICB2YXIgbmJpbiA9IHJlYWRJbnQoaW5kZXgsIDApO1xuICAgIHZhciBwID0gNDtcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IG5iaW47ICsrYikge1xuICAgICAgICB2YXIgYmluID0gcmVhZEludChpbmRleCwgcCk7XG4gICAgICAgIHZhciBuY2huayA9IHJlYWRJbnQoaW5kZXgsIHArNCk7XG4vLyAgICAgICAgZGxvZygnYmluPScgKyBiaW4gKyAnOyBuY2huaz0nICsgbmNobmspO1xuICAgICAgICBwICs9IDg7XG4gICAgICAgIGlmIChpbnRCaW5zW2Jpbl0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbmNobms7ICsrYykge1xuICAgICAgICAgICAgICAgIHZhciBjcyA9IHJlYWRWb2IoaW5kZXgsIHApO1xuICAgICAgICAgICAgICAgIHZhciBjZSA9IHJlYWRWb2IoaW5kZXgsIHAgKyA4KTtcbiAgICAgICAgICAgICAgICAoYmluIDwgNDY4MSA/IG90aGVyQ2h1bmtzIDogbGVhZkNodW5rcykucHVzaChuZXcgQ2h1bmsoY3MsIGNlKSk7XG4gICAgICAgICAgICAgICAgcCArPSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gIChuY2huayAqIDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnbGVhZkNodW5rcyA9ICcgKyBKU09OLnN0cmluZ2lmeShsZWFmQ2h1bmtzKSk7XG4gICAgLy8gY29uc29sZS5sb2coJ290aGVyQ2h1bmtzID0gJyArIEpTT04uc3RyaW5naWZ5KG90aGVyQ2h1bmtzKSk7XG5cbiAgICB2YXIgbmludHYgPSByZWFkSW50KGluZGV4LCBwKTtcbiAgICAvLyBjb25zb2xlLmxvZygnbmludHY9JyArIG5pbnR2KTtcbiAgICB2YXIgbG93ZXN0ID0gbnVsbDtcbiAgICB2YXIgbWluTGluID0gTWF0aC5taW4obWluPj4xNCwgbmludHYgLSAxKSwgbWF4TGluID0gTWF0aC5taW4obWF4Pj4xNCwgbmludHYgLSAxKTtcbiAgICBmb3IgKHZhciBpID0gbWluTGluOyBpIDw9IG1heExpbjsgKytpKSB7XG4gICAgICAgIHZhciBsYiA9ICByZWFkVm9iKGluZGV4LCBwICsgNCArIChpICogOCkpO1xuICAgICAgICBpZiAoIWxiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxvd2VzdCB8fCBsYi5ibG9jayA8IGxvd2VzdC5ibG9jayB8fCAobGIuYmxvY2sgPT0gbG93ZXN0LmJsb2NrICYmIGxiLm9mZnNldCA8IGxvd2VzdC5vZmZzZXQpKSB7XG4gICAgICAgICAgICBsb3dlc3QgPSBsYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnTG93ZXN0IExCID0gJyArIGxvd2VzdCk7XG5cbiAgICB2YXIgcHJ1bmVkT3RoZXJDaHVua3MgPSBbXTtcbiAgICBpZiAobG93ZXN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlckNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNobmsgPSBvdGhlckNodW5rc1tpXTtcbiAgICAgICAgICAgIGlmIChjaG5rLm1heHYuYmxvY2sgPiBsb3dlc3QuYmxvY2sgfHwgKGNobmsubWF4di5ibG9jayA9PSBsb3dlc3QuYmxvY2sgJiYgY2huay5tYXh2Lm9mZnNldCA+PSBsb3dlc3Qub2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHBydW5lZE90aGVyQ2h1bmtzLnB1c2goY2huayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3BydW5lZE90aGVyQ2h1bmtzID0gJyArIEpTT04uc3RyaW5naWZ5KHBydW5lZE90aGVyQ2h1bmtzKSk7XG4gICAgb3RoZXJDaHVua3MgPSBwcnVuZWRPdGhlckNodW5rcztcblxuICAgIHZhciBpbnRDaHVua3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyQ2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGludENodW5rcy5wdXNoKG90aGVyQ2h1bmtzW2ldKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWFmQ2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGludENodW5rcy5wdXNoKGxlYWZDaHVua3NbaV0pO1xuICAgIH1cblxuICAgIGludENodW5rcy5zb3J0KGZ1bmN0aW9uKGMwLCBjMSkge1xuICAgICAgICB2YXIgZGlmID0gYzAubWludi5ibG9jayAtIGMxLm1pbnYuYmxvY2s7XG4gICAgICAgIGlmIChkaWYgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjMC5taW52Lm9mZnNldCAtIGMxLm1pbnYub2Zmc2V0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1lcmdlZENodW5rcyA9IFtdO1xuICAgIGlmIChpbnRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY3VyID0gaW50Q2h1bmtzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGludENodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5jID0gaW50Q2h1bmtzW2ldO1xuICAgICAgICAgICAgaWYgKG5jLm1pbnYuYmxvY2sgPT0gY3VyLm1heHYuYmxvY2sgLyogJiYgbmMubWludi5vZmZzZXQgPT0gY3VyLm1heHYub2Zmc2V0ICovKSB7IC8vIG5vIHBvaW50IHNwbGl0dGluZyBtaWQtYmxvY2tcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXcgQ2h1bmsoY3VyLm1pbnYsIG5jLm1heHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjdXIpO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGN1cik7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCdtZXJnZWRDaHVua3MgPSAnICsgSlNPTi5zdHJpbmdpZnkobWVyZ2VkQ2h1bmtzKSk7XG5cbiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzO1xufVxuXG5CYW1GaWxlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIGNhbGxiYWNrLCBvcHRzKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBjaHJJZCA9IHRoaXMuY2hyVG9JbmRleFtjaHJdO1xuICAgIHZhciBjaHVua3M7XG4gICAgaWYgKGNocklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2h1bmtzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhpcyBwb3J0aW9uIG9mIHRoZSBCQUkgaWYgaXQgaGFzbid0IGJlZW4gbG9hZGVkIHlldC5cbiAgICAgICAgaWYgKHRoaXMuaW5kaWNlc1tjaHJJZF0gPT09IG51bGwgJiYgdGhpcy5pbmRleENodW5rcy5jaHVua3NbY2hySWRdKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRfc3RvcCA9IHRoaXMuaW5kZXhDaHVua3MuY2h1bmtzW2NocklkXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhaS5zbGljZShzdGFydF9zdG9wWzBdLCBzdGFydF9zdG9wWzFdKS5mZXRjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc1tjaHJJZF0gPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goY2hyLCBtaW4sIG1heCwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rcyA9IHRoaXMuYmxvY2tzRm9yUmFuZ2UoY2hySWQsIG1pbiwgbWF4KTtcbiAgICAgICAgaWYgKCFjaHVua3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdFcnJvciBpbiBpbmRleCBmZXRjaCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciByZWNvcmRzID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZGF0YTtcblxuICAgIGZ1bmN0aW9uIHRyYW1wKCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlY29yZHMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNodW5rc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZmV0Y2hNaW4gPSBjLm1pbnYuYmxvY2s7XG4gICAgICAgICAgICB2YXIgZmV0Y2hNYXggPSBjLm1heHYuYmxvY2sgKyAoMTw8MTYpOyAvLyAqc2lnaCpcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmZXRjaGluZyAnICsgZmV0Y2hNaW4gKyAnOicgKyBmZXRjaE1heCk7XG4gICAgICAgICAgICB0aGlzQi5kYXRhLnNsaWNlKGZldGNoTWluLCBmZXRjaE1heCAtIGZldGNoTWluKS5mZXRjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuYmd6ZihyLCBjLm1heHYuYmxvY2sgLSBjLm1pbnYuYmxvY2sgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICB2YXIgZmluaXNoZWQgPSB0aGlzQi5yZWFkQmFtUmVjb3JkcyhiYSwgY2h1bmtzW2luZGV4XS5taW52Lm9mZnNldCwgcmVjb3JkcywgbWluLCBtYXgsIGNocklkLCBvcHRzKTtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVjb3Jkcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW1wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbXAoKTtcbn1cblxudmFyIFNFUVJFVF9ERUNPREVSID0gWyc9JywgJ0EnLCAnQycsICd4JywgJ0cnLCAneCcsICd4JywgJ3gnLCAnVCcsICd4JywgJ3gnLCAneCcsICd4JywgJ3gnLCAneCcsICdOJ107XG52YXIgQ0lHQVJfREVDT0RFUiA9IFsnTScsICdJJywgJ0QnLCAnTicsICdTJywgJ0gnLCAnUCcsICc9JywgJ1gnLCAnPycsICc/JywgJz8nLCAnPycsICc/JywgJz8nLCAnPyddO1xuXG5mdW5jdGlvbiBCYW1SZWNvcmQoKSB7XG59XG5cbkJhbUZpbGUucHJvdG90eXBlLnJlYWRCYW1SZWNvcmRzID0gZnVuY3Rpb24oYmEsIG9mZnNldCwgc2luaywgbWluLCBtYXgsIGNocklkLCBvcHRzKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHJlYWRJbnQoYmEsIG9mZnNldCk7XG4gICAgICAgIHZhciBibG9ja0VuZCA9IG9mZnNldCArIGJsb2NrU2l6ZSArIDQ7XG4gICAgICAgIGlmIChibG9ja0VuZCA+IGJhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBCYW1SZWNvcmQoKTtcblxuICAgICAgICB2YXIgcmVmSUQgPSByZWFkSW50KGJhLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgdmFyIHBvcyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGJtbiA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDEyKTtcbiAgICAgICAgdmFyIGJpbiA9IChibW4gJiAweGZmZmYwMDAwKSA+PiAxNjtcbiAgICAgICAgdmFyIG1xID0gKGJtbiAmIDB4ZmYwMCkgPj4gODtcbiAgICAgICAgdmFyIG5sID0gYm1uICYgMHhmZjtcblxuICAgICAgICB2YXIgZmxhZ19uYyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDE2KTtcbiAgICAgICAgdmFyIGZsYWcgPSAoZmxhZ19uYyAmIDB4ZmZmZjAwMDApID4+IDE2O1xuICAgICAgICB2YXIgbmMgPSBmbGFnX25jICYgMHhmZmZmO1xuICAgIFxuICAgICAgICB2YXIgbHNlcSA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDIwKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBuZXh0UmVmICA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDI0KTtcbiAgICAgICAgdmFyIG5leHRQb3MgPSByZWFkSW50KGJhLCBvZmZzZXQgKyAyOCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgdGxlbiA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDMyKTtcbiAgICBcbiAgICAgICAgcmVjb3JkLnNlZ21lbnQgPSB0aGlzLmluZGV4VG9DaHJbcmVmSURdO1xuICAgICAgICByZWNvcmQuZmxhZyA9IGZsYWc7XG4gICAgICAgIHJlY29yZC5wb3MgPSBwb3M7XG4gICAgICAgIHJlY29yZC5tcSA9IG1xO1xuICAgICAgICBpZiAob3B0cy5saWdodClcbiAgICAgICAgICAgIHJlY29yZC5zZXFMZW5ndGggPSBsc2VxO1xuXG4gICAgICAgIGlmICghb3B0cy5saWdodCB8fCBvcHRzLmluY2x1ZGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVhZE5hbWUgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmwtMTsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVhZE5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtvZmZzZXQgKyAzNiArIGpdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY29yZC5yZWFkTmFtZSA9IHJlYWROYW1lO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIW9wdHMubGlnaHQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0UmVmID49IDApIHtcbiAgICAgICAgICAgICAgICByZWNvcmQubmV4dFNlZ21lbnQgPSB0aGlzLmluZGV4VG9DaHJbbmV4dFJlZl07XG4gICAgICAgICAgICAgICAgcmVjb3JkLm5leHRQb3MgPSBuZXh0UG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHZhciBwID0gb2Zmc2V0ICsgMzYgKyBubDtcblxuICAgICAgICAgICAgdmFyIGNpZ2FyID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5jOyArK2MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2lnb3AgPSByZWFkSW50KGJhLCBwKTtcbiAgICAgICAgICAgICAgICBjaWdhciA9IGNpZ2FyICsgKGNpZ29wPj40KSArIENJR0FSX0RFQ09ERVJbY2lnb3AgJiAweGZdO1xuICAgICAgICAgICAgICAgIHAgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY29yZC5jaWdhciA9IGNpZ2FyO1xuICAgICAgICBcbiAgICAgICAgICAgIHZhciBzZXEgPSAnJztcbiAgICAgICAgICAgIHZhciBzZXFCeXRlcyA9IChsc2VxICsgMSkgPj4gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VxQnl0ZXM7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBzYiA9IGJhW3AgKyBqXTtcbiAgICAgICAgICAgICAgICBzZXEgKz0gU0VRUkVUX0RFQ09ERVJbKHNiICYgMHhmMCkgPj4gNF07XG4gICAgICAgICAgICAgICAgaWYgKHNlcS5sZW5ndGggPCBsc2VxKVxuICAgICAgICAgICAgICAgICAgICBzZXEgKz0gU0VRUkVUX0RFQ09ERVJbKHNiICYgMHgwZildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCArPSBzZXFCeXRlcztcbiAgICAgICAgICAgIHJlY29yZC5zZXEgPSBzZXE7XG5cbiAgICAgICAgICAgIHZhciBxc2VxID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxzZXE7ICsraikge1xuICAgICAgICAgICAgICAgIHFzZXEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgal0gKyAzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwICs9IGxzZXE7XG4gICAgICAgICAgICByZWNvcmQucXVhbHMgPSBxc2VxO1xuXG4gICAgICAgICAgICB3aGlsZSAocCA8IGJsb2NrRW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcF0sIGJhW3AgKyAxXSk7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyAyXSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ0EnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgM10pO1xuICAgICAgICAgICAgICAgICAgICBwICs9IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdpJyB8fCB0eXBlID09ICdJJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRJbnQoYmEsIHAgKyAzKTtcbiAgICAgICAgICAgICAgICAgICAgcCArPSA3O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnYycgfHwgdHlwZSA9PSAnQycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiYVtwICsgM107XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3MnIHx8IHR5cGUgPT0gJ1MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZFNob3J0KGJhLCBwICsgMyk7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2YnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZEZsb2F0KGJhLCBwICsgMyk7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ1onIHx8IHR5cGUgPT0gJ0gnKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNjID0gYmFbcCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdCJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyAzXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGVuID0gcmVhZEludChiYSwgcCArIDQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0eXBlID09ICdpJyB8fCBhdHlwZSA9PSAnSScgfHwgYXR5cGUgPT0gJ2YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVuID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHlwZSA9PSAnZicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZEZsb2F0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRJbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR5cGUgPT0gJ3MnIHx8IGF0eXBlID09ICdTJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkU2hvcnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR5cGUgPT0gJ2MnIHx8IGF0eXBlID09ICdDJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkQnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdVbmtub3duIGFycmF5IHR5cGUgJyArIGF0eXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcCArPSA4O1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChyZWFkZXIoYmEsIHApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgKz0gZWxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdVbmtub3duIHR5cGUgJysgdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjb3JkW3RhZ10gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWluIHx8IHJlY29yZC5wb3MgPD0gbWF4ICYmIHJlY29yZC5wb3MgKyBsc2VxID49IG1pbikge1xuICAgICAgICAgICAgaWYgKGNocklkID09PSB1bmRlZmluZWQgfHwgcmVmSUQgPT0gY2hySWQpIHtcbiAgICAgICAgICAgICAgICBzaW5rLnB1c2gocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb3JkLnBvcyA+IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gYmxvY2tFbmQ7XG4gICAgfVxuXG4gICAgLy8gRXhpdHMgdmlhIHRvcCBvZiBsb29wLlxufTtcblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBtYWtlQmFtOiBtYWtlQmFtLFxuICAgICAgICBCQU1fTUFHSUM6IEJBTV9NQUdJQyxcbiAgICAgICAgQkFJX01BR0lDOiBCQUlfTUFHSUMsXG4gICAgICAgIEJhbUZsYWdzOiBCYW1GbGFnc1xuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gYmVkd2lnLmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgc3BhbnMgPSByZXF1aXJlKCcuL3NwYW5zJyk7XG4gICAgdmFyIFJhbmdlID0gc3BhbnMuUmFuZ2U7XG4gICAgdmFyIHVuaW9uID0gc3BhbnMudW5pb247XG4gICAgdmFyIGludGVyc2VjdGlvbiA9IHNwYW5zLmludGVyc2VjdGlvbjtcblxuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgZGFsbGlhbmNlX3JlZ2lzdGVyUGFyc2VyRmFjdG9yeSA9IHNhLnJlZ2lzdGVyUGFyc2VyRmFjdG9yeTtcblxuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNTdHlsZXNoZWV0ID0gZGFzLkRBU1N0eWxlc2hlZXQ7XG4gICAgdmFyIERBU1N0eWxlID0gZGFzLkRBU1N0eWxlO1xuICAgIHZhciBEQVNGZWF0dXJlID0gZGFzLkRBU0ZlYXR1cmU7XG4gICAgdmFyIERBU0dyb3VwID0gZGFzLkRBU0dyb3VwO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xufVxuXG5cbmZ1bmN0aW9uIEJlZFdpZ1BhcnNlcih0eXBlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuQmVkV2lnUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVTZXNzaW9uID0gZnVuY3Rpb24oc2luaykge1xuICAgIGlmICh0aGlzLnR5cGUgPT0gJ3dpZycpXG4gICAgICAgIHJldHVybiBuZXcgV2lnUGFyc2VTZXNzaW9uKHRoaXMsIHNpbmspO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIG5ldyBCZWRQYXJzZVNlc3Npb24odGhpcywgc2luayk7XG59XG5cbnZhciBfX0tWX1JFR0VYUD0vKFtePV0rKT0oLispLztcbnZhciBfX1NQQUNFX1JFR0VYUD0vXFxzLztcbnZhciBCRURfQ09MT1JfUkVHRVhQID0gbmV3IFJlZ0V4cChcIl5bMC05XSssWzAtOV0rLFswLTldK1wiKTtcblxuZnVuY3Rpb24gQmVkUGFyc2VTZXNzaW9uKHBhcnNlciwgc2luaykge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMuc2luayA9IHNpbms7XG59XG5cbkJlZFBhcnNlU2Vzc2lvbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgdmFyIHRva3MgPSBsaW5lLnNwbGl0KF9fU1BBQ0VfUkVHRVhQKTtcbiAgICBpZiAodG9rcy5sZW5ndGggPCAzKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgc3RhcnQgPSBwYXJzZUludCh0b2tzWzFdKSArIDE7XG4gICAgdmFyIGVuZCA9IHBhcnNlSW50KHRva3NbMl0pO1xuXG4gICAgdmFyIGYgPSB7c2VnbWVudDogdG9rc1swXSwgXG4gICAgICAgICAgICAgbWluOiBzdGFydCxcbiAgICAgICAgICAgICBtYXg6IGVuZH07XG5cbiAgICBpZiAodG9rcy5sZW5ndGggPiAzICYmIHRva3NbM10gIT09ICcuJykge1xuICAgICAgICBmLmxhYmVsID0gdG9rc1szXTtcbiAgICB9XG5cbiAgICBpZiAodG9rcy5sZW5ndGggPiA0KSB7XG4gICAgICAgIGYuc2NvcmUgPSBwYXJzZUZsb2F0KHRva3NbNF0pXG4gICAgfVxuXG4gICAgaWYgKHRva3MubGVuZ3RoID4gNSkge1xuICAgICAgICBmLm9yaWVudGF0aW9uID0gdG9rc1s1XTtcbiAgICB9XG5cbiAgICBpZiAodG9rcy5sZW5ndGggPiA4KSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRva3NbOF07XG4gICAgICAgIGlmIChCRURfQ09MT1JfUkVHRVhQLnRlc3QoY29sb3IpKSB7XG4gICAgICAgICAgICBmLml0ZW1SZ2IgPSAncmdiKCcgKyBjb2xvciArICcpJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tzLmxlbmd0aCA+PSAxMikge1xuICAgICAgICB2YXIgdGhpY2tTdGFydCA9IHBhcnNlSW50KHRva3NbNl0pO1xuICAgICAgICB2YXIgdGhpY2tFbmQgICA9IHBhcnNlSW50KHRva3NbN10pO1xuICAgICAgICB2YXIgYmxvY2tDb3VudCA9IHBhcnNlSW50KHRva3NbOV0pO1xuICAgICAgICB2YXIgYmxvY2tTaXplcyA9IHRva3NbMTBdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKHgpIHtyZXR1cm4gcGFyc2VJbnQoeCl9KTtcbiAgICAgICAgdmFyIGJsb2NrU3RhcnRzID0gdG9rc1sxMV0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24oeCkge3JldHVybiBwYXJzZUludCh4KX0pO1xuXG4gICAgICAgIGYudHlwZSA9ICd0cmFuc2NyaXB0J1xuICAgICAgICB2YXIgZ3JwID0gbmV3IERBU0dyb3VwKCk7XG4gICAgICAgIGdycC5pZCA9IHRva3NbM107XG4gICAgICAgIGdycC50eXBlID0gJ3RyYW5zY3JpcHQnXG4gICAgICAgIGdycC5ub3RlcyA9IFtdO1xuICAgICAgICBmLmdyb3VwcyA9IFtncnBdO1xuXG4gICAgICAgIGlmICh0b2tzLmxlbmd0aCA+IDEyKSB7XG4gICAgICAgICAgICB2YXIgZ2VuZUlkID0gdG9rc1sxMl07XG4gICAgICAgICAgICB2YXIgZ2VuZU5hbWUgPSBnZW5lSWQ7XG4gICAgICAgICAgICBpZiAodG9rcy5sZW5ndGggPiAxMykge1xuICAgICAgICAgICAgICAgIGdlbmVOYW1lID0gdG9rc1sxM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ2cgPSBuZXcgREFTR3JvdXAoKTtcbiAgICAgICAgICAgIGdnLmlkID0gZ2VuZUlkO1xuICAgICAgICAgICAgZ2cubGFiZWwgPSBnZW5lTmFtZTtcbiAgICAgICAgICAgIGdnLnR5cGUgPSAnZ2VuZSc7XG4gICAgICAgICAgICBmLmdyb3Vwcy5wdXNoKGdnKTtcbiAgICAgICAgfSAgXG5cbiAgICAgICAgdmFyIHNwYW5zID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBibG9ja0NvdW50OyArK2IpIHtcbiAgICAgICAgICAgIHZhciBibWluID0gYmxvY2tTdGFydHNbYl0gKyBzdGFydDtcbiAgICAgICAgICAgIHZhciBibWF4ID0gYm1pbiArIGJsb2NrU2l6ZXNbYl07XG4gICAgICAgICAgICB2YXIgc3BhbiA9IG5ldyBSYW5nZShibWluLCBibWF4KTtcbiAgICAgICAgICAgIGlmIChzcGFucykge1xuICAgICAgICAgICAgICAgIHNwYW5zID0gdW5pb24oc3BhbnMsIHNwYW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGFucyA9IHNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciB0c0xpc3QgPSBzcGFucy5yYW5nZXMoKTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB0c0xpc3QubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgICAgIHZhciB0cyA9IHRzTGlzdFtzXTtcbiAgICAgICAgICAgIHZhciBiZiA9IHNoYWxsb3dDb3B5KGYpO1xuICAgICAgICAgICAgYmYubWluID0gdHMubWluKCk7XG4gICAgICAgICAgICBiZi5tYXggPSB0cy5tYXgoKTtcbiAgICAgICAgICAgIHRoaXMuc2luayhiZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpY2tFbmQgPiB0aGlja1N0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgY29kaW5nUmVnaW9uID0gKGYub3JpZW50YXRpb24gPT0gJysnKSA/IFxuICAgICAgICAgICAgICAgIG5ldyBSYW5nZSh0aGlja1N0YXJ0LCB0aGlja0VuZCArIDMpIDogXG4gICAgICAgICAgICAgICAgbmV3IFJhbmdlKHRoaWNrU3RhcnQgLSAzLCB0aGlja0VuZCk7XG4gICAgICAgICAgICAgICAgLy8gKy8tIDMgdG8gYWNjb3VudCBmb3Igc3RvcCBjb2RvblxuXG4gICAgICAgICAgICB2YXIgdGwgPSBpbnRlcnNlY3Rpb24oc3BhbnMsIGNvZGluZ1JlZ2lvbik7XG4gICAgICAgICAgICBpZiAodGwpIHtcbiAgICAgICAgICAgICAgICBmLnR5cGUgPSAndHJhbnNsYXRpb24nO1xuICAgICAgICAgICAgICAgIHZhciB0bExpc3QgPSB0bC5yYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGluZ0ZyYW1lID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRsTGlzdC5sZW5ndGg7ICsrcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgcmVhZGluZyBmcmFtZSBmb3IgZXZlcnkgZXhvblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5vcmllbnRhdGlvbiA9PSAnLScpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRsTGlzdC5sZW5ndGggLSBzIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRzID0gdGxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJmID0gc2hhbGxvd0NvcHkoZik7XG4gICAgICAgICAgICAgICAgICAgIGJmLm1pbiA9IHRzLm1pbigpO1xuICAgICAgICAgICAgICAgICAgICBiZi5tYXggPSB0cy5tYXgoKTtcbiAgICAgICAgICAgICAgICAgICAgZi5yZWFkZnJhbWUgPSByZWFkaW5nRnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0cy5tYXgoKSAtIHRzLm1pbigpO1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nRnJhbWUgPSAocmVhZGluZ0ZyYW1lICsgbGVuZ3RoKSAlIDM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2luayhiZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaW5rKGYpO1xuICAgIH1cbn1cblxuQmVkUGFyc2VTZXNzaW9uLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIFdpZ1BhcnNlU2Vzc2lvbihwYXJzZXIsIHNpbmspIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLnNpbmsgPSBzaW5rO1xuICAgIHRoaXMud2lnU3RhdGUgPSBudWxsO1xufVxuXG5XaWdQYXJzZVNlc3Npb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24obGluZSkge1xuICAgIHZhciB0b2tzID0gbGluZS5zcGxpdChfX1NQQUNFX1JFR0VYUCk7XG5cbiAgICBpZiAodG9rc1swXSA9PSAnZml4ZWRTdGVwJykge1xuICAgICAgICB0aGlzLndpZ1N0YXRlID0gJ2ZpeGVkU3RlcCc7XG4gICAgICAgIHRoaXMuY2hyID0gdGhpcy5wb3MgPSB0aGlzLnN0ZXAgPSBudWxsO1xuICAgICAgICB0aGlzLnNwYW4gPSAxO1xuXG4gICAgICAgIGZvciAodmFyIHRpID0gMTsgdGkgPCB0b2tzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgdmFyIG0gPSBfX0tWX1JFR0VYUC5leGVjKHRva3NbdGldKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1bMV0gPT0gJ2Nocm9tJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNociA9IG1bMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtWzFdID09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBwYXJzZUludChtWzJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1bMV0gPT0gJ3N0ZXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcCA9IHBhcnNlSW50KG1bMl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobVsxXSA9PSAnc3BhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFuID0gcGFyc2VJbnQobVsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tzWzBdID09ICd2YXJpYWJsZVN0ZXAnKSB7XG4gICAgICAgIHRoaXMud2lnU3RhdGUgPSAndmFyaWFibGVTdGVwJztcbiAgICAgICAgdGhpcy5jaHIgPSBudWxsO1xuICAgICAgICB0aGlzLnNwYW4gPSAxO1xuXG4gICAgICAgIGZvciAodmFyIHRpID0gMTsgdGkgPCB0b2tzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgdmFyIG0gPSBfX0tWX1JFR0VYUC5leGVjKHRva3NbdGldKTtcbiAgICAgICAgICAgIGlmIChtWzFdID09ICdjaHJvbScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNociA9IG1bMl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1bMV0gPT0gJ3NwYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFuID0gcGFyc2VJbnQobVsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMud2lnU3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0b2tzLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgZiA9IHtzZWdtZW50OiB0b2tzWzBdLCBcbiAgICAgICAgICAgICAgICAgICAgIG1pbjogcGFyc2VJbnQodG9rc1sxXSkgKyAxLCBcbiAgICAgICAgICAgICAgICAgICAgIG1heDogcGFyc2VJbnQodG9rc1syXSksXG4gICAgICAgICAgICAgICAgICAgICBzY29yZTogcGFyc2VGbG9hdCh0b2tzWzNdKX07XG5cbiAgICAgICAgICAgIHRoaXMuc2luayhmKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLndpZ1N0YXRlID09ICdmaXhlZFN0ZXAnKSB7XG4gICAgICAgICAgICBpZiAodG9rcy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2NvcmUgPSBwYXJzZUZsb2F0KHRva3NbMF0pO1xuICAgICAgICAgICAgdmFyIGYgPSB7c2VnbWVudDogdGhpcy5jaHIsIG1pbjogdGhpcy5wb3MsIG1heDogdGhpcy5wb3MgKyB0aGlzLnNwYW4gLSAxLCBzY29yZTogc2NvcmV9O1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGhpcy5zdGVwO1xuICAgICAgICAgICAgdGhpcy5zaW5rKGYpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2lnU3RhdGUgPT0gJ3ZhcmlhYmxlU3RlcCcpIHtcbiAgICAgICAgICAgIGlmICh0b2tzLmxlbmd0aCAhPSAyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBwb3MgPSBwYXJzZUludCh0b2tzWzBdKTtcbiAgICAgICAgICAgIHZhciBzY29yZSA9IHBhcnNlRmxvYXQodG9rc1sxXSk7XG4gICAgICAgICAgICB2YXIgZiA9IHtzZWdtZW50OiB0aGlzLmNociwgbWluOiBwb3MsIG1heDogcG9zICsgdGhpcy5zcGFuIC0gMSwgc2NvcmU6IHNjb3JlfTtcbiAgICAgICAgICAgIHRoaXMuc2luayhmKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuV2lnUGFyc2VTZXNzaW9uLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge307XG5cbkJlZFdpZ1BhcnNlci5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgc3R5bGVzaGVldCA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG5cbiAgICBpZiAodGhpcy50eXBlID09ICd3aWcnKSB7XG4gICAgICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdISVNUT0dSQU0nO1xuICAgICAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ2JsdWUnO1xuICAgICAgICB3aWdTdHlsZS5IRUlHSFQ9MzA7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVmYXVsdCd9LCBudWxsLCB3aWdTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgICAgIHdpZ1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ2JsdWUnXG4gICAgICAgIHdpZ1N0eWxlLkhFSUdIVCA9IDg7XG4gICAgICAgIHdpZ1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgICAgICB3aWdTdHlsZS5MQUJFTCA9IHRydWU7XG4gICAgICAgIHdpZ1N0eWxlLlpJTkRFWCA9IDIwO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuXG4gICAgICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgd2lnU3R5bGUuQkdDT0xPUiA9ICdyZWQnXG4gICAgICAgIHdpZ1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICB3aWdTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICAgICAgd2lnU3R5bGUuWklOREVYID0gMjA7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNsYXRpb24nfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgdHNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB0c1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgICAgIHRzU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHRzU3R5bGUuQkdDT0xPUiA9ICd3aGl0ZSc7XG4gICAgICAgIHRzU3R5bGUuSEVJR0hUID0gMTA7XG4gICAgICAgIHRzU3R5bGUuWklOREVYID0gMTA7XG4gICAgICAgIHRzU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgIHRzU3R5bGUuTEFCRUwgPSB0cnVlO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3RyYW5zY3JpcHQnfSwgbnVsbCwgdHNTdHlsZSk7XG5cbiAgICAgICAgdmFyIGRlbnNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICBkZW5zU3R5bGUuZ2x5cGggPSAnSElTVE9HUkFNJztcbiAgICAgICAgZGVuc1N0eWxlLkNPTE9SMSA9ICd3aGl0ZSc7XG4gICAgICAgIGRlbnNTdHlsZS5DT0xPUjIgPSAnYmxhY2snO1xuICAgICAgICBkZW5zU3R5bGUuSEVJR0hUPTMwO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlbnNpdHknfSwgbnVsbCwgZGVuc1N0eWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2soc3R5bGVzaGVldCk7XG59XG5cbmRhbGxpYW5jZV9yZWdpc3RlclBhcnNlckZhY3RvcnkoJ2JlZCcsIGZ1bmN0aW9uKHQpIHtyZXR1cm4gbmV3IEJlZFdpZ1BhcnNlcih0KX0pO1xuZGFsbGlhbmNlX3JlZ2lzdGVyUGFyc2VyRmFjdG9yeSgnd2lnJywgZnVuY3Rpb24odCkge3JldHVybiBuZXcgQmVkV2lnUGFyc2VyKHQpfSk7IiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIGJpZ3dpZy5qczogaW5kZXhlZCBiaW5hcnkgV0lHIChhbmQgQkVEKSBmaWxlc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgc3BhbnMgPSByZXF1aXJlKCcuL3NwYW5zJyk7XG4gICAgdmFyIFJhbmdlID0gc3BhbnMuUmFuZ2U7XG4gICAgdmFyIHVuaW9uID0gc3BhbnMudW5pb247XG4gICAgdmFyIGludGVyc2VjdGlvbiA9IHNwYW5zLmludGVyc2VjdGlvbjtcblxuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNGZWF0dXJlID0gZGFzLkRBU0ZlYXR1cmU7XG4gICAgdmFyIERBU0dyb3VwID0gZGFzLkRBU0dyb3VwO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuXG4gICAgdmFyIGJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG4gICAgdmFyIHJlYWRJbnQgPSBiaW4ucmVhZEludDtcblxuICAgIHZhciBqc3psaWIgPSByZXF1aXJlKCdqc3psaWInKTtcbiAgICB2YXIganN6bGliX2luZmxhdGVfYnVmZmVyID0ganN6bGliLmluZmxhdGVCdWZmZXI7XG4gICAgdmFyIGFycmF5Q29weSA9IGpzemxpYi5hcnJheUNvcHk7XG59XG5cbnZhciBCSUdfV0lHX01BR0lDID0gMHg4ODhGRkMyNjtcbnZhciBCSUdfV0lHX01BR0lDX0JFID0gMHgyNkZDOEY4ODtcbnZhciBCSUdfQkVEX01BR0lDID0gMHg4Nzg5RjJFQjtcbnZhciBCSUdfQkVEX01BR0lDX0JFID0gMHhFQkYyODk4NztcblxuXG52YXIgQklHX1dJR19UWVBFX0dSQVBIID0gMTtcbnZhciBCSUdfV0lHX1RZUEVfVlNURVAgPSAyO1xudmFyIEJJR19XSUdfVFlQRV9GU1RFUCA9IDM7XG4gIFxudmFyIE0xID0gMjU2O1xudmFyIE0yID0gMjU2KjI1NjtcbnZhciBNMyA9IDI1NioyNTYqMjU2O1xudmFyIE00ID0gMjU2KjI1NioyNTYqMjU2O1xuXG52YXIgQkVEX0NPTE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoXCJeWzAtOV0rLFswLTldKyxbMC05XStcIik7XG5cbmZ1bmN0aW9uIGJ3Z19yZWFkT2Zmc2V0KGJhLCBvKSB7XG4gICAgdmFyIG9mZnNldCA9IGJhW29dICsgYmFbbysxXSpNMSArIGJhW28rMl0qTTIgKyBiYVtvKzNdKk0zICsgYmFbbys0XSpNNDtcbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBCaWdXaWcoKSB7XG59XG5cbkJpZ1dpZy5wcm90b3R5cGUucmVhZENocm9tVHJlZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmNocm9tc1RvSURzID0ge307XG4gICAgdGhpcy5pZHNUb0Nocm9tcyA9IHt9O1xuICAgIHRoaXMubWF4SUQgPSAwO1xuXG4gICAgdmFyIHVkbyA9IHRoaXMudW56b29tZWREYXRhT2Zmc2V0O1xuICAgIHZhciBlYiA9ICh1ZG8gLSB0aGlzLmNocm9tVHJlZU9mZnNldCkgJiAzO1xuICAgIHVkbyA9IHVkbyArIDQgLSBlYjtcblxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLmNocm9tVHJlZU9mZnNldCwgdWRvIC0gdGhpcy5jaHJvbVRyZWVPZmZzZXQpLmZldGNoKGZ1bmN0aW9uKGJwdCkge1xuICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShicHQpO1xuICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShicHQpO1xuICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShicHQpO1xuICAgICAgICB2YXIgYnB0TWFnaWMgPSBsYVswXTtcbiAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGxhWzFdO1xuICAgICAgICB2YXIga2V5U2l6ZSA9IGxhWzJdO1xuICAgICAgICB2YXIgdmFsU2l6ZSA9IGxhWzNdO1xuICAgICAgICB2YXIgaXRlbUNvdW50ID0gYndnX3JlYWRPZmZzZXQoYmEsIDE2KTtcbiAgICAgICAgdmFyIHJvb3ROb2RlT2Zmc2V0ID0gMzI7XG5cbiAgICAgICAgdmFyIGJwdFJlYWROb2RlID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBiYVtvZmZzZXRdO1xuICAgICAgICAgICAgdmFyIGNudCA9IHNhWyhvZmZzZXQvMikgKyAxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbnQ7ICsrbikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBrZXlTaXplO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkT2Zmc2V0IC09IHRoaXNCLmNocm9tVHJlZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgYnB0UmVhZE5vZGUoY2hpbGRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2kgPSAwOyBraSA8IGtleVNpemU7ICsra2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IGJhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHJvbUlkID0gKGJhW29mZnNldCszXTw8MjQpIHwgKGJhW29mZnNldCsyXTw8MTYpIHwgKGJhW29mZnNldCsxXTw8OCkgfCAoYmFbb2Zmc2V0KzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNocm9tU2l6ZSA9IChiYVtvZmZzZXQgKyA3XTw8MjQpIHwgKGJhW29mZnNldCs2XTw8MTYpIHwgKGJhW29mZnNldCs1XTw8OCkgfCAoYmFbb2Zmc2V0KzRdKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpc0IuY2hyb21zVG9JRHNba2V5XSA9IGNocm9tSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignY2hyJykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IuY2hyb21zVG9JRHNba2V5LnN1YnN0cigzKV0gPSBjaHJvbUlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLmlkc1RvQ2hyb21zW2Nocm9tSWRdID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5tYXhJRCA9IE1hdGgubWF4KHRoaXNCLm1heElELCBjaHJvbUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJwdFJlYWROb2RlKHJvb3ROb2RlT2Zmc2V0KTtcblxuICAgICAgICBjYWxsYmFjayh0aGlzQik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIEJpZ1dpZ1ZpZXcoYndnLCBjaXJUcmVlT2Zmc2V0LCBjaXJUcmVlTGVuZ3RoLCBpc1N1bW1hcnkpIHtcbiAgICB0aGlzLmJ3ZyA9IGJ3ZztcbiAgICB0aGlzLmNpclRyZWVPZmZzZXQgPSBjaXJUcmVlT2Zmc2V0O1xuICAgIHRoaXMuY2lyVHJlZUxlbmd0aCA9IGNpclRyZWVMZW5ndGg7XG4gICAgdGhpcy5pc1N1bW1hcnkgPSBpc1N1bW1hcnk7XG59XG5cblxuXG5CaWdXaWdWaWV3LnByb3RvdHlwZS5yZWFkV2lnRGF0YSA9IGZ1bmN0aW9uKGNock5hbWUsIG1pbiwgbWF4LCBjYWxsYmFjaykge1xuICAgIHZhciBjaHIgPSB0aGlzLmJ3Zy5jaHJvbXNUb0lEc1tjaHJOYW1lXTtcbiAgICBpZiAoY2hyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTm90IGFuIGVycm9yIGJlY2F1c2Ugc29tZSAuYndncyB3b24ndCBoYXZlIGRhdGEgZm9yIGFsbCBjaHJvbW9zb21lcy5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlYWRXaWdEYXRhQnlJZChjaHIsIG1pbiwgbWF4LCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG5CaWdXaWdWaWV3LnByb3RvdHlwZS5yZWFkV2lnRGF0YUJ5SWQgPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmNpckhlYWRlcikge1xuICAgICAgICB0aGlzLmJ3Zy5kYXRhLnNsaWNlKHRoaXMuY2lyVHJlZU9mZnNldCwgNDgpLmZldGNoKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpc0IuY2lySGVhZGVyID0gcmVzdWx0O1xuICAgICAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkodGhpc0IuY2lySGVhZGVyKTtcbiAgICAgICAgICAgIHRoaXNCLmNpckJsb2NrU2l6ZSA9IGxhWzFdO1xuICAgICAgICAgICAgdGhpc0IucmVhZFdpZ0RhdGFCeUlkKGNociwgbWluLCBtYXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2tzVG9GZXRjaCA9IFtdO1xuICAgIHZhciBvdXRzdGFuZGluZyA9IDA7XG5cbiAgICB2YXIgYmVmb3JlQldHID0gRGF0ZS5ub3coKTtcblxuICAgIHZhciBmaWx0ZXIgPSBmdW5jdGlvbihjaHJvbUlkLCBmbWluLCBmbWF4LCB0b2tzKSB7XG4gICAgICAgIHJldHVybiAoKGNociA8IDAgfHwgY2hyb21JZCA9PSBjaHIpICYmIGZtaW4gPD0gbWF4ICYmIGZtYXggPj0gbWluKTtcbiAgICB9XG5cbiAgICB2YXIgY2lyRm9iUmVjdXIgPSBmdW5jdGlvbihvZmZzZXQsIGxldmVsKSB7XG4gICAgICAgIGlmICh0aGlzQi5id2cuaW5zdHJ1bWVudClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdsZXZlbD0nICsgbGV2ZWwgKyAnOyBvZmZzZXQ9JyArIG9mZnNldCArICc7IHRpbWU9JyArIChEYXRlLm5vdygpfDApKTtcblxuICAgICAgICBvdXRzdGFuZGluZyArPSBvZmZzZXQubGVuZ3RoO1xuXG4gICAgICAgIGlmIChvZmZzZXQubGVuZ3RoID09IDEgJiYgb2Zmc2V0WzBdIC0gdGhpc0IuY2lyVHJlZU9mZnNldCA9PSA0OCAmJiB0aGlzQi5jYWNoZWRDaXJSb290KSB7XG4gICAgICAgICAgICBjaXJGb2JSZWN1cjIodGhpc0IuY2FjaGVkQ2lyUm9vdCwgMCwgbGV2ZWwpO1xuICAgICAgICAgICAgLS1vdXRzdGFuZGluZztcbiAgICAgICAgICAgIGlmIChvdXRzdGFuZGluZyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IuZmV0Y2hGZWF0dXJlcyhmaWx0ZXIsIGJsb2Nrc1RvRmV0Y2gsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXhDaXJCbG9ja1NwYW4gPSA0ICsgICh0aGlzQi5jaXJCbG9ja1NpemUgKiAzMik7ICAgLy8gVXBwZXIgYm91bmQgb24gc2l6ZSwgYmFzZWQgb24gYSBjb21wbGV0ZWx5IGZ1bGwgbGVhZiBub2RlLlxuICAgICAgICB2YXIgc3BhbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2Zmc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tTcGFuID0gbmV3IFJhbmdlKG9mZnNldFtpXSwgb2Zmc2V0W2ldICsgbWF4Q2lyQmxvY2tTcGFuKTtcbiAgICAgICAgICAgIHNwYW5zID0gc3BhbnMgPyB1bmlvbihzcGFucywgYmxvY2tTcGFuKSA6IGJsb2NrU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGZldGNoUmFuZ2VzID0gc3BhbnMucmFuZ2VzKCk7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZmV0Y2hSYW5nZXMubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgIHZhciBmciA9IGZldGNoUmFuZ2VzW3JdO1xuICAgICAgICAgICAgY2lyRm9iU3RhcnRGZXRjaChvZmZzZXQsIGZyLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2lyRm9iU3RhcnRGZXRjaCA9IGZ1bmN0aW9uKG9mZnNldCwgZnIsIGxldmVsLCBhdHRlbXB0cykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnIubWF4KCkgLSBmci5taW4oKTtcbiAgICAgICAgdGhpc0IuYndnLmRhdGEuc2xpY2UoZnIubWluKCksIGZyLm1heCgpIC0gZnIubWluKCkpLmZldGNoKGZ1bmN0aW9uKHJlc3VsdEJ1ZmZlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnIuY29udGFpbnMob2Zmc2V0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjaXJGb2JSZWN1cjIocmVzdWx0QnVmZmVyLCBvZmZzZXRbaV0gLSBmci5taW4oKSwgbGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRbaV0gLSB0aGlzQi5jaXJUcmVlT2Zmc2V0ID09IDQ4ICYmIG9mZnNldFtpXSAtIGZyLm1pbigpID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5jYWNoZWRDaXJSb290ID0gcmVzdWx0QnVmZmVyO1xuXG4gICAgICAgICAgICAgICAgICAgIC0tb3V0c3RhbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRzdGFuZGluZyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5mZXRjaEZlYXR1cmVzKGZpbHRlciwgYmxvY2tzVG9GZXRjaCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgY2lyRm9iUmVjdXIyID0gZnVuY3Rpb24oY2lyQmxvY2tEYXRhLCBvZmZzZXQsIGxldmVsKSB7XG4gICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KGNpckJsb2NrRGF0YSk7XG4gICAgICAgIHZhciBzYSA9IG5ldyBJbnQxNkFycmF5KGNpckJsb2NrRGF0YSk7XG4gICAgICAgIHZhciBsYSA9IG5ldyBJbnQzMkFycmF5KGNpckJsb2NrRGF0YSk7XG5cbiAgICAgICAgdmFyIGlzTGVhZiA9IGJhW29mZnNldF07XG4gICAgICAgIHZhciBjbnQgPSBzYVtvZmZzZXQvMiArIDFdO1xuICAgICAgICBvZmZzZXQgKz0gNDtcblxuICAgICAgICBpZiAoaXNMZWFmICE9IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY250OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG8gPSBvZmZzZXQvNDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDaHJvbSA9IGxhW2xvXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRCYXNlID0gbGFbbG8gKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ2hyb20gPSBsYVtsbyArIDJdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRCYXNlID0gbGFbbG8gKyAzXTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgb2Zmc2V0KzE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCsyNCk7XG4gICAgICAgICAgICAgICAgaWYgKCgoY2hyIDwgMCB8fCBzdGFydENocm9tIDwgY2hyKSB8fCAoc3RhcnRDaHJvbSA9PSBjaHIgJiYgc3RhcnRCYXNlIDw9IG1heCkpICYmXG4gICAgICAgICAgICAgICAgICAgICgoY2hyIDwgMCB8fCBlbmRDaHJvbSAgID4gY2hyKSB8fCAoZW5kQ2hyb20gPT0gY2hyICYmIGVuZEJhc2UgPj0gbWluKSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NUb0ZldGNoLnB1c2goe29mZnNldDogYmxvY2tPZmZzZXQsIHNpemU6IGJsb2NrU2l6ZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVjdXJPZmZzZXRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvID0gb2Zmc2V0LzQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2hyb20gPSBsYVtsb107XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0QmFzZSA9IGxhW2xvICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGVuZENocm9tID0gbGFbbG8gKyAyXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQmFzZSA9IGxhW2xvICsgM107XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCsxNik7XG4gICAgICAgICAgICAgICAgaWYgKChjaHIgPCAwIHx8IHN0YXJ0Q2hyb20gPCBjaHIgfHwgKHN0YXJ0Q2hyb20gPT0gY2hyICYmIHN0YXJ0QmFzZSA8PSBtYXgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoY2hyIDwgMCB8fCBlbmRDaHJvbSAgID4gY2hyIHx8IChlbmRDaHJvbSA9PSBjaHIgJiYgZW5kQmFzZSA+PSBtaW4pKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VyT2Zmc2V0cy5wdXNoKGJsb2NrT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY3VyT2Zmc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2lyRm9iUmVjdXIocmVjdXJPZmZzZXRzLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNpckZvYlJlY3VyKFt0aGlzQi5jaXJUcmVlT2Zmc2V0ICsgNDhdLCAxKTtcbn1cblxuXG5CaWdXaWdWaWV3LnByb3RvdHlwZS5mZXRjaEZlYXR1cmVzID0gZnVuY3Rpb24oZmlsdGVyLCBibG9ja3NUb0ZldGNoLCBjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cbiAgICBibG9ja3NUb0ZldGNoLnNvcnQoZnVuY3Rpb24oYjAsIGIxKSB7XG4gICAgICAgIHJldHVybiAoYjAub2Zmc2V0fDApIC0gKGIxLm9mZnNldHwwKTtcbiAgICB9KTtcblxuICAgIGlmIChibG9ja3NUb0ZldGNoLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgdmFyIGNyZWF0ZUZlYXR1cmUgPSBmdW5jdGlvbihjaHIsIGZtaW4sIGZtYXgsIG9wdHMpIHtcbiAgICAgICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgICAgICBmLl9jaHJvbUlkID0gY2hyO1xuICAgICAgICAgICAgZi5zZWdtZW50ID0gdGhpc0IuYndnLmlkc1RvQ2hyb21zW2Nocl07XG4gICAgICAgICAgICBmLm1pbiA9IGZtaW47XG4gICAgICAgICAgICBmLm1heCA9IGZtYXg7XG4gICAgICAgICAgICBmLnR5cGUgPSB0aGlzQi5id2cudHlwZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgZltrXSA9IG9wdHNba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRyYW1wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tzVG9GZXRjaC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBhZnRlckJXRyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgLy8gZGxvZygnQldHIGZldGNoIHRvb2sgJyArIChhZnRlckJXRyAtIGJlZm9yZUJXRykgKyAnbXMnKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgLy8ganVzdCBpbiBjYXNlLi4uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1RvRmV0Y2hbMF07XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IucGFyc2VGZWF0dXJlcyhibG9jay5kYXRhLCBjcmVhdGVGZWF0dXJlLCBmaWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NUb0ZldGNoLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbXAoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmV0Y2hTdGFydCA9IGJsb2NrLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZldGNoU2l6ZSA9IGJsb2NrLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaSA8IGJsb2Nrc1RvRmV0Y2gubGVuZ3RoICYmIGJsb2Nrc1RvRmV0Y2hbYmldLm9mZnNldCA9PSAoZmV0Y2hTdGFydCArIGZldGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoU2l6ZSArPSBibG9ja3NUb0ZldGNoW2JpXS5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgKytiaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLmJ3Zy5kYXRhLnNsaWNlKGZldGNoU3RhcnQsIGZldGNoU2l6ZSkuZmV0Y2goZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZmV0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZiID0gYmxvY2tzVG9GZXRjaFtiaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0IuYndnLnVuY29tcHJlc3NCdWZTaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0ganN6bGliX2luZmxhdGVfYnVmZmVyKHJlc3VsdCwgb2Zmc2V0ICsgMiwgZmIuc2l6ZSAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShmYi5zaXplKTsgICAgLy8gRklYTUUgaXMgdGhpcyByZWFsbHkgdGhlIGJlc3Qgd2UgY2FuIGRvP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUNvcHkobmV3IFVpbnQ4QXJyYXkocmVzdWx0LCBvZmZzZXQsIGZiLnNpemUpLCAwLCB0bXAsIDAsIGZiLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdG1wLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZiLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytiaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFtcCgpO1xuICAgIH1cbn1cblxuQmlnV2lnVmlldy5wcm90b3R5cGUucGFyc2VGZWF0dXJlcyA9IGZ1bmN0aW9uKGRhdGEsIGNyZWF0ZUZlYXR1cmUsIGZpbHRlcikge1xuICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuaXNTdW1tYXJ5KSB7XG4gICAgICAgIHZhciBzYSA9IG5ldyBJbnQxNkFycmF5KGRhdGEpO1xuICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShkYXRhKTtcbiAgICAgICAgdmFyIGZhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcblxuICAgICAgICB2YXIgaXRlbUNvdW50ID0gZGF0YS5ieXRlTGVuZ3RoLzMyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1Db3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hyb21JZCA9ICAgbGFbKGkqOCldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gICAgIGxhWyhpKjgpKzFdO1xuICAgICAgICAgICAgdmFyIGVuZCA9ICAgICAgIGxhWyhpKjgpKzJdO1xuICAgICAgICAgICAgdmFyIHZhbGlkQ250ID0gIGxhWyhpKjgpKzNdO1xuICAgICAgICAgICAgdmFyIG1pblZhbCAgICA9IGZhWyhpKjgpKzRdO1xuICAgICAgICAgICAgdmFyIG1heFZhbCAgICA9IGZhWyhpKjgpKzVdO1xuICAgICAgICAgICAgdmFyIHN1bURhdGEgICA9IGZhWyhpKjgpKzZdO1xuICAgICAgICAgICAgdmFyIHN1bVNxRGF0YSA9IGZhWyhpKjgpKzddO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZmlsdGVyKGNocm9tSWQsIHN0YXJ0ICsgMSwgZW5kKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5T3B0cyA9IHt0eXBlOiAnYmlnd2lnJywgc2NvcmU6IHN1bURhdGEvdmFsaWRDbnQsIG1heFNjb3JlOiBtYXhWYWx9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ3Zy50eXBlID09ICdiaWdiZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnlPcHRzLnR5cGUgPSAnZGVuc2l0eSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyZWF0ZUZlYXR1cmUoY2hyb21JZCwgc3RhcnQgKyAxLCBlbmQsIHN1bW1hcnlPcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5id2cudHlwZSA9PSAnYmlnd2lnJykge1xuICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShkYXRhKTtcbiAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkoZGF0YSk7XG4gICAgICAgIHZhciBmYSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG5cbiAgICAgICAgdmFyIGNocm9tSWQgPSBsYVswXTtcbiAgICAgICAgdmFyIGJsb2NrU3RhcnQgPSBsYVsxXTtcbiAgICAgICAgdmFyIGJsb2NrRW5kID0gbGFbMl07XG4gICAgICAgIHZhciBpdGVtU3RlcCA9IGxhWzNdO1xuICAgICAgICB2YXIgaXRlbVNwYW4gPSBsYVs0XTtcbiAgICAgICAgdmFyIGJsb2NrVHlwZSA9IGJhWzIwXTtcbiAgICAgICAgdmFyIGl0ZW1Db3VudCA9IHNhWzExXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChibG9ja1R5cGUgPT0gQklHX1dJR19UWVBFX0ZTVEVQKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1Db3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gZmFbaSArIDZdO1xuICAgICAgICAgICAgICAgIHZhciBmbWluID0gYmxvY2tTdGFydCArIChpKml0ZW1TdGVwKSArIDEsIGZtYXggPSBibG9ja1N0YXJ0ICsgKGkqaXRlbVN0ZXApICsgaXRlbVNwYW47XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcihjaHJvbUlkLCBmbWluLCBmbWF4KSlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmVhdHVyZShjaHJvbUlkLCBmbWluLCBmbWF4LCB7c2NvcmU6IHNjb3JlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYmxvY2tUeXBlID09IEJJR19XSUdfVFlQRV9WU1RFUCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGxhWyhpKjIpICsgNl0gKyAxO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIGl0ZW1TcGFuIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcmUgPSBmYVsoaSoyKSArIDddO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIoY2hyb21JZCwgc3RhcnQsIGVuZCkpXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZlYXR1cmUoY2hyb21JZCwgc3RhcnQsIGVuZCwge3Njb3JlOiBzY29yZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrVHlwZSA9PSBCSUdfV0lHX1RZUEVfR1JBUEgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBsYVsoaSozKSArIDZdICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kICAgPSBsYVsoaSozKSArIDddO1xuICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IGZhWyhpKjMpICsgOF07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKGNocm9tSWQsIHN0YXJ0LCBlbmQpKVxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGZWF0dXJlKGNocm9tSWQsIHN0YXJ0LCBlbmQsIHtzY29yZTogc2NvcmV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50bHkgbm90IGhhbmRsaW5nIGJ3Z1R5cGU9JyArIGJsb2NrVHlwZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYndnLnR5cGUgPT0gJ2JpZ2JlZCcpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBkZmMgPSB0aGlzLmJ3Zy5kZWZpbmVkRmllbGRDb3VudDtcbiAgICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuYndnLnNjaGVtYTtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgYmEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2hyb21JZCA9IChiYVtvZmZzZXQrM108PDI0KSB8IChiYVtvZmZzZXQrMl08PDE2KSB8IChiYVtvZmZzZXQrMV08PDgpIHwgKGJhW29mZnNldCswXSk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAoYmFbb2Zmc2V0KzddPDwyNCkgfCAoYmFbb2Zmc2V0KzZdPDwxNikgfCAoYmFbb2Zmc2V0KzVdPDw4KSB8IChiYVtvZmZzZXQrNF0pO1xuICAgICAgICAgICAgdmFyIGVuZCA9IChiYVtvZmZzZXQrMTFdPDwyNCkgfCAoYmFbb2Zmc2V0KzEwXTw8MTYpIHwgKGJhW29mZnNldCs5XTw8OCkgfCAoYmFbb2Zmc2V0KzhdKTtcbiAgICAgICAgICAgIG9mZnNldCArPSAxMjtcbiAgICAgICAgICAgIHZhciByZXN0ID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IGJhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZlYXR1cmVPcHRzID0ge307XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBiZWRDb2x1bW5zO1xuICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGJlZENvbHVtbnMgPSByZXN0LnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmVkQ29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZENvbHVtbnMubGVuZ3RoID4gMCAmJiBkZmMgPiAzKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZU9wdHMubGFiZWwgPSBiZWRDb2x1bW5zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZENvbHVtbnMubGVuZ3RoID4gMSAmJiBkZmMgPiA0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gcGFyc2VJbnQoYmVkQ29sdW1uc1sxXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihzY29yZSkpXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVkQ29sdW1ucy5sZW5ndGggPiAyICYmIGRmYyA+IDUpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy5vcmllbnRhdGlvbiA9IGJlZENvbHVtbnNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVkQ29sdW1ucy5sZW5ndGggPiA1ICYmIGRmYyA+IDgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBiZWRDb2x1bW5zWzVdO1xuICAgICAgICAgICAgICAgIGlmIChCRURfQ09MT1JfUkVHRVhQLnRlc3QoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLml0ZW1SZ2IgPSAncmdiKCcgKyBjb2xvciArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChiZWRDb2x1bW5zLmxlbmd0aCA+IGRmYy0zICYmIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IGRmYyAtIDM7IGNvbCA8IGJlZENvbHVtbnMubGVuZ3RoOyArK2NvbCkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0c1tzY2hlbWEuZmllbGRzW2NvbCszXS5uYW1lXSA9IGJlZENvbHVtbnNbY29sXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXIoY2hyb21JZCwgc3RhcnQgKyAxLCBlbmQsIGJlZENvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRmYyA8IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZlYXR1cmUoY2hyb21JZCwgc3RhcnQgKyAxLCBlbmQsIGZlYXR1cmVPcHRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpY2tTdGFydCA9IGJlZENvbHVtbnNbM118MDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaWNrRW5kICAgPSBiZWRDb2x1bW5zWzRdfDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0NvdW50ID0gYmVkQ29sdW1uc1s2XXwwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplcyA9IGJlZENvbHVtbnNbN10uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrU3RhcnRzID0gYmVkQ29sdW1uc1s4XS5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlT3B0cy5leG9uRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhvbkZyYW1lcyA9IGZlYXR1cmVPcHRzLmV4b25GcmFtZXMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLmV4b25GcmFtZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLnR5cGUgPSAndHJhbnNjcmlwdCdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdycCA9IG5ldyBEQVNHcm91cCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGZlYXR1cmVPcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncnBba10gPSBmZWF0dXJlT3B0c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncnAuaWQgPSBiZWRDb2x1bW5zWzBdO1xuICAgICAgICAgICAgICAgICAgICBncnAuc2VnbWVudCA9IHRoaXMuYndnLmlkc1RvQ2hyb21zW2Nocm9tSWRdO1xuICAgICAgICAgICAgICAgICAgICBncnAubWluID0gc3RhcnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBncnAubWF4ID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBncnAubm90ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU9wdHMuZ3JvdXBzID0gW2dycF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW92aW5nIHRvd2FyZHMgdXNpbmcgYmlnR2VuZVByZWQgbW9kZWwsIGJ1dCB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHN1cHBvcnQgb2xkIERhbGxpYW5jZS1zdHlsZSBCRUQxMitnZW5lLW5hbWUgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Jlc2VlYWJsZSBmdXR1cmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWRDb2x1bW5zLmxlbmd0aCA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZW5lSWQgPSBmZWF0dXJlT3B0cy5nZW5lTmFtZSB8fCBiZWRDb2x1bW5zWzldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdlbmVOYW1lID0gZ2VuZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZENvbHVtbnMubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lTmFtZSA9IGJlZENvbHVtbnNbMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVPcHRzLmdlbmVOYW1lMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lTmFtZSA9IGZlYXR1cmVPcHRzLmdlbmVOYW1lMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdnID0gc2hhbGxvd0NvcHkoZ3JwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdnLmlkID0gZ2VuZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2cubGFiZWwgPSBnZW5lTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdnLnR5cGUgPSAnZ2VuZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy5ncm91cHMucHVzaChnZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3Bhbkxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBibG9ja0NvdW50OyArK2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibWluID0gKGJsb2NrU3RhcnRzW2JdfDApICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm1heCA9IGJtaW4gKyAoYmxvY2tTaXplc1tiXXwwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFuID0gbmV3IFJhbmdlKGJtaW4sIGJtYXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbkxpc3QucHVzaChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhbnMgPSB1bmlvbihzcGFuTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgdHNMaXN0ID0gc3BhbnMucmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdHNMaXN0Lmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHMgPSB0c0xpc3Rbc107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVGZWF0dXJlKGNocm9tSWQsIHRzLm1pbigpICsgMSwgdHMubWF4KCksIGZlYXR1cmVPcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlja0VuZCA+IHRoaWNrU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RpbmdSZWdpb24gPSAoZmVhdHVyZU9wdHMub3JpZW50YXRpb24gPT0gJysnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJhbmdlKHRoaWNrU3RhcnQsIHRoaWNrRW5kICsgMykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZSh0aGlja1N0YXJ0IC0gMywgdGhpY2tFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICsvLSAzIHRvIGFjY291bnQgZm9yIHN0b3AgY29kb25cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRsID0gaW50ZXJzZWN0aW9uKHNwYW5zLCBjb2RpbmdSZWdpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU9wdHMudHlwZSA9ICd0cmFuc2xhdGlvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRsTGlzdCA9IHRsLnJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkaW5nRnJhbWUgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRsT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGxMaXN0WzBdLm1pbigpID4gdHNMaXN0W3RsT2Zmc2V0XS5tYXgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGxPZmZzZXQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdGxMaXN0Lmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCByZWFkaW5nIGZyYW1lIGZvciBldmVyeSBleG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlT3B0cy5vcmllbnRhdGlvbiA9PSAnLScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRsTGlzdC5sZW5ndGggLSBzIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRzID0gdGxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU9wdHMucmVhZGZyYW1lID0gcmVhZGluZ0ZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhvbkZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJyZiA9IHBhcnNlSW50KGV4b25GcmFtZXNbaW5kZXggKyB0bE9mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihicmYpID09PSAnbnVtYmVyJyAmJiBicmYgPj0gMCAmJiBicmYgPD0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLnJlYWRmcmFtZSA9IGJyZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy5yZWFkZnJhbWVFeHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRzLm1heCgpIC0gdHMubWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmdGcmFtZSA9IChyZWFkaW5nRnJhbWUgKyBsZW5ndGgpICUgMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmVhdHVyZShjaHJvbUlkLCB0cy5taW4oKSArIDEsIHRzLm1heCgpLCBmZWF0dXJlT3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJEb24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCBcIiArIHRoaXMuYndnLnR5cGUpO1xuICAgIH1cbn1cblxuLy9cbi8vIG5hc3R5IGN1dC9wYXN0ZSwgc2hvdWxkIHJvbGwgYmFjayBpbiFcbi8vXG5cbkJpZ1dpZ1ZpZXcucHJvdG90eXBlLmdldEZpcnN0QWRqYWNlbnQgPSBmdW5jdGlvbihjaHJOYW1lLCBwb3MsIGRpciwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2hyID0gdGhpcy5id2cuY2hyb21zVG9JRHNbY2hyTmFtZV07XG4gICAgaWYgKGNociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vdCBhbiBlcnJvciBiZWNhdXNlIHNvbWUgLmJ3Z3Mgd29uJ3QgaGF2ZSBkYXRhIGZvciBhbGwgY2hyb21vc29tZXMuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRGaXJzdEFkamFjZW50QnlJZChjaHIsIHBvcywgZGlyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG5CaWdXaWdWaWV3LnByb3RvdHlwZS5nZXRGaXJzdEFkamFjZW50QnlJZCA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICBpZiAoIXRoaXMuY2lySGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYndnLmRhdGEuc2xpY2UodGhpcy5jaXJUcmVlT2Zmc2V0LCA0OCkuZmV0Y2goZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzQi5jaXJIZWFkZXIgPSByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheSh0aGlzQi5jaXJIZWFkZXIpO1xuICAgICAgICAgICAgdGhpc0IuY2lyQmxvY2tTaXplID0gbGFbMV07XG4gICAgICAgICAgICB0aGlzQi5nZXRGaXJzdEFkamFjZW50QnlJZChjaHIsIHBvcywgZGlyLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJsb2NrVG9GZXRjaCA9IG51bGw7XG4gICAgdmFyIGJlc3RCbG9ja0NociA9IC0xO1xuICAgIHZhciBiZXN0QmxvY2tPZmZzZXQgPSAtMTtcblxuICAgIHZhciBvdXRzdGFuZGluZyA9IDA7XG5cbiAgICB2YXIgYmVmb3JlQldHID0gRGF0ZS5ub3coKTtcblxuICAgIHZhciBjaXJGb2JSZWN1ciA9IGZ1bmN0aW9uKG9mZnNldCwgbGV2ZWwpIHtcbiAgICAgICAgb3V0c3RhbmRpbmcgKz0gb2Zmc2V0Lmxlbmd0aDtcblxuICAgICAgICB2YXIgbWF4Q2lyQmxvY2tTcGFuID0gNCArICAodGhpc0IuY2lyQmxvY2tTaXplICogMzIpOyAgIC8vIFVwcGVyIGJvdW5kIG9uIHNpemUsIGJhc2VkIG9uIGEgY29tcGxldGVseSBmdWxsIGxlYWYgbm9kZS5cbiAgICAgICAgdmFyIHNwYW5zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGJsb2NrU3BhbiA9IG5ldyBSYW5nZShvZmZzZXRbaV0sIG9mZnNldFtpXSArIG1heENpckJsb2NrU3Bhbik7XG4gICAgICAgICAgICBzcGFucyA9IHNwYW5zID8gdW5pb24oc3BhbnMsIGJsb2NrU3BhbikgOiBibG9ja1NwYW47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBmZXRjaFJhbmdlcyA9IHNwYW5zLnJhbmdlcygpO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGZldGNoUmFuZ2VzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICB2YXIgZnIgPSBmZXRjaFJhbmdlc1tyXTtcbiAgICAgICAgICAgIGNpckZvYlN0YXJ0RmV0Y2gob2Zmc2V0LCBmciwgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNpckZvYlN0YXJ0RmV0Y2ggPSBmdW5jdGlvbihvZmZzZXQsIGZyLCBsZXZlbCwgYXR0ZW1wdHMpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZyLm1heCgpIC0gZnIubWluKCk7XG4gICAgICAgIHRoaXNCLmJ3Zy5kYXRhLnNsaWNlKGZyLm1pbigpLCBmci5tYXgoKSAtIGZyLm1pbigpKS5mZXRjaChmdW5jdGlvbihyZXN1bHRCdWZmZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2Zmc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyLmNvbnRhaW5zKG9mZnNldFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lyRm9iUmVjdXIyKHJlc3VsdEJ1ZmZlciwgb2Zmc2V0W2ldIC0gZnIubWluKCksIGxldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgLS1vdXRzdGFuZGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHN0YW5kaW5nID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmxvY2tUb0ZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA+IDAgJiYgKGNociAhPSAwIHx8IHBvcyA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5nZXRGaXJzdEFkamFjZW50QnlJZCgwLCAwLCBkaXIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpciA8IDAgJiYgKGNociAhPSB0aGlzQi5id2cubWF4SUQgfHwgcG9zIDwgMTAwMDAwMDAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLmdldEZpcnN0QWRqYWNlbnRCeUlkKHRoaXNCLmJ3Zy5tYXhJRCwgMTAwMDAwMDAwMCwgZGlyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmZldGNoRmVhdHVyZXMoZnVuY3Rpb24oY2hyeCwgZm1pbiwgZm1heCwgdG9rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZGlyIDwgMCAmJiAoY2hyeCA8IGNociB8fCBmbWF4IDwgcG9zKSkgfHwgKGRpciA+IDAgJiYgKGNocnggPiBjaHIgfHwgZm1pbiA+IHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW2Jsb2NrVG9GZXRjaF0sIGZ1bmN0aW9uKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlc3RGZWF0dXJlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmVzdENociA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZXN0UG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNocnggPSBmLl9jaHJvbUlkLCBmbWluID0gZi5taW4sIGZtYXggPSBmLm1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RGZWF0dXJlID09IG51bGwgfHwgKChkaXIgPCAwKSAmJiAoY2hyeCA+IGJlc3RDaHIgfHwgZm1heCA+IGJlc3RQb3MpKSB8fCAoKGRpciA+IDApICYmIChjaHJ4IDwgYmVzdENociB8fCBmbWluIDwgYmVzdFBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0RmVhdHVyZSA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0UG9zID0gKGRpciA8IDApID8gZm1heCA6IGZtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0Q2hyID0gY2hyeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZXN0RmVhdHVyZSAhPSBudWxsKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFtiZXN0RmVhdHVyZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgY2lyRm9iUmVjdXIyID0gZnVuY3Rpb24oY2lyQmxvY2tEYXRhLCBvZmZzZXQsIGxldmVsKSB7XG4gICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KGNpckJsb2NrRGF0YSk7XG4gICAgICAgIHZhciBzYSA9IG5ldyBJbnQxNkFycmF5KGNpckJsb2NrRGF0YSk7XG4gICAgICAgIHZhciBsYSA9IG5ldyBJbnQzMkFycmF5KGNpckJsb2NrRGF0YSk7XG5cbiAgICAgICAgdmFyIGlzTGVhZiA9IGJhW29mZnNldF07XG4gICAgICAgIHZhciBjbnQgPSBzYVtvZmZzZXQvMiArIDFdO1xuICAgICAgICBvZmZzZXQgKz0gNDtcblxuICAgICAgICBpZiAoaXNMZWFmICE9IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY250OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG8gPSBvZmZzZXQvNDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDaHJvbSA9IGxhW2xvXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRCYXNlID0gbGFbbG8gKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ2hyb20gPSBsYVtsbyArIDJdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRCYXNlID0gbGFbbG8gKyAzXTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgb2Zmc2V0KzE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCsyNCk7XG4gICAgICAgICAgICAgICAgaWYgKChkaXIgPCAwICYmICgoc3RhcnRDaHJvbSA8IGNociB8fCAoc3RhcnRDaHJvbSA9PSBjaHIgJiYgc3RhcnRCYXNlIDw9IHBvcykpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGRpciA+IDAgJiYgKChlbmRDaHJvbSA+IGNociB8fCAoZW5kQ2hyb20gPT0gY2hyICYmIGVuZEJhc2UgPj0gcG9zKSkpKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHb3QgYW4gaW50ZXJlc3RpbmcgYmxvY2s6IHN0YXJ0QmFzZT0nICsgc3RhcnRDaHJvbSArICc6JyArIHN0YXJ0QmFzZSArICc7IGVuZEJhc2U9JyArIGVuZENocm9tICsgJzonICsgZW5kQmFzZSArICc7IG9mZnNldD0nICsgYmxvY2tPZmZzZXQgKyAnOyBzaXplPScgKyBibG9ja1NpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL19yYW5kb20vLmV4ZWModGhpc0IuYndnLmlkc1RvQ2hyb21zW3N0YXJ0Q2hyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGxvZygnc2tpcHBpbmcgcmFuZG9tOiAnICsgdGhpc0IuYndnLmlkc1RvQ2hyb21zW3N0YXJ0Q2hyb21dKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9ja1RvRmV0Y2ggPT0gbnVsbCB8fCAoKGRpciA8IDApICYmIChlbmRDaHJvbSA+IGJlc3RCbG9ja0NociB8fCAoZW5kQ2hyb20gPT0gYmVzdEJsb2NrQ2hyICYmIGVuZEJhc2UgPiBiZXN0QmxvY2tPZmZzZXQpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaXIgPiAwKSAmJiAoc3RhcnRDaHJvbSA8IGJlc3RCbG9ja0NociB8fCAoc3RhcnRDaHJvbSA9PSBiZXN0QmxvY2tDaHIgJiYgc3RhcnRCYXNlIDwgYmVzdEJsb2NrT2Zmc2V0KSkpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIGRsb2coJ2Jlc3QgaXM6IHN0YXJ0QmFzZT0nICsgc3RhcnRDaHJvbSArICc6JyArIHN0YXJ0QmFzZSArICc7IGVuZEJhc2U9JyArIGVuZENocm9tICsgJzonICsgZW5kQmFzZSArICc7IG9mZnNldD0nICsgYmxvY2tPZmZzZXQgKyAnOyBzaXplPScgKyBibG9ja1NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUb0ZldGNoID0ge29mZnNldDogYmxvY2tPZmZzZXQsIHNpemU6IGJsb2NrU2l6ZX07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0QmxvY2tPZmZzZXQgPSAoZGlyIDwgMCkgPyBlbmRCYXNlIDogc3RhcnRCYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEJsb2NrQ2hyID0gKGRpciA8IDApID8gZW5kQ2hyb20gOiBzdGFydENocm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiZXN0UmVjdXIgPSAtMTtcbiAgICAgICAgICAgIHZhciBiZXN0UG9zID0gLTE7XG4gICAgICAgICAgICB2YXIgYmVzdENociA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsbyA9IG9mZnNldC80O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENocm9tID0gbGFbbG9dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEJhc2UgPSBsYVtsbyArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRDaHJvbSA9IGxhW2xvICsgMl07XG4gICAgICAgICAgICAgICAgdmFyIGVuZEJhc2UgPSBsYVtsbyArIDNdO1xuICAgICAgICAgICAgICAgIHZhciBibG9ja09mZnNldCA9IChsYVtsbyArIDRdPDwzMikgfCAobGFbbG8gKyA1XSk7XG4gICAgICAgICAgICAgICAgaWYgKChkaXIgPCAwICYmICgoc3RhcnRDaHJvbSA8IGNociB8fCAoc3RhcnRDaHJvbSA9PSBjaHIgJiYgc3RhcnRCYXNlIDw9IHBvcykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5kQ2hyb20gICA+PSBjaHIpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgIChkaXIgPiAwICYmICgoZW5kQ2hyb20gPiBjaHIgfHwgKGVuZENocm9tID09IGNociAmJiBlbmRCYXNlID49IHBvcykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXJ0Q2hyb20gPD0gY2hyKSkpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RSZWN1ciA8IDAgfHwgZW5kQmFzZSA+IGJlc3RQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RSZWN1ciA9IGJsb2NrT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFBvcyA9IChkaXIgPCAwKSA/IGVuZEJhc2UgOiBzdGFydEJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Q2hyID0gKGRpciA8IDApID8gZW5kQ2hyb20gOiBzdGFydENocm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZXN0UmVjdXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNpckZvYlJlY3VyKFtiZXN0UmVjdXJdLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcblxuICAgIGNpckZvYlJlY3VyKFt0aGlzQi5jaXJUcmVlT2Zmc2V0ICsgNDhdLCAxKTtcbn1cblxuQmlnV2lnLnByb3RvdHlwZS5yZWFkV2lnRGF0YSA9IGZ1bmN0aW9uKGNock5hbWUsIG1pbiwgbWF4LCBjYWxsYmFjaykge1xuICAgIHRoaXMuZ2V0VW56b29tZWRWaWV3KCkucmVhZFdpZ0RhdGEoY2hyTmFtZSwgbWluLCBtYXgsIGNhbGxiYWNrKTtcbn1cblxuQmlnV2lnLnByb3RvdHlwZS5nZXRVbnpvb21lZFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMudW56b29tZWRWaWV3KSB7XG4gICAgICAgIHZhciBjaXJMZW4gPSA0MDAwO1xuICAgICAgICB2YXIgbnpsID0gdGhpcy56b29tTGV2ZWxzWzBdO1xuICAgICAgICBpZiAobnpsKSB7XG4gICAgICAgICAgICBjaXJMZW4gPSB0aGlzLnpvb21MZXZlbHNbMF0uZGF0YU9mZnNldCAtIHRoaXMudW56b29tZWRJbmRleE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuem9vbWVkVmlldyA9IG5ldyBCaWdXaWdWaWV3KHRoaXMsIHRoaXMudW56b29tZWRJbmRleE9mZnNldCwgY2lyTGVuLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVuem9vbWVkVmlldztcbn1cblxuQmlnV2lnLnByb3RvdHlwZS5nZXRab29tZWRWaWV3ID0gZnVuY3Rpb24oeikge1xuICAgIHZhciB6aCA9IHRoaXMuem9vbUxldmVsc1t6XTtcbiAgICBpZiAoIXpoLnZpZXcpIHtcbiAgICAgICAgemgudmlldyA9IG5ldyBCaWdXaWdWaWV3KHRoaXMsIHpoLmluZGV4T2Zmc2V0LCAvKiB0aGlzLnpvb21MZXZlbHNbeiArIDFdLmRhdGFPZmZzZXQgLSB6aC5pbmRleE9mZnNldCAqLyA0MDAwLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHpoLnZpZXc7XG59XG5cbmZ1bmN0aW9uIG1ha2VCd2coZGF0YSwgY2FsbGJhY2ssIG5hbWUpIHtcbiAgICB2YXIgYndnID0gbmV3IEJpZ1dpZygpO1xuICAgIGJ3Zy5kYXRhID0gZGF0YTtcbiAgICBid2cubmFtZSA9IG5hbWU7XG4gICAgYndnLmRhdGEuc2xpY2UoMCwgNTEyKS5zYWx0ZWQoKS5mZXRjaChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkNvdWxkbid0IGZldGNoIGZpbGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVhZGVyID0gcmVzdWx0O1xuICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShoZWFkZXIpO1xuICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShoZWFkZXIpO1xuICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShoZWFkZXIpO1xuICAgICAgICB2YXIgbWFnaWMgPSBiYVswXSArIChNMSAqIGJhWzFdKSArIChNMiAqIGJhWzJdKSArIChNMyAqIGJhWzNdKTtcbiAgICAgICAgaWYgKG1hZ2ljID09IEJJR19XSUdfTUFHSUMpIHtcbiAgICAgICAgICAgIGJ3Zy50eXBlID0gJ2JpZ3dpZyc7XG4gICAgICAgIH0gZWxzZSBpZiAobWFnaWMgPT0gQklHX0JFRF9NQUdJQykge1xuICAgICAgICAgICAgYndnLnR5cGUgPSAnYmlnYmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChtYWdpYyA9PSBCSUdfV0lHX01BR0lDX0JFIHx8IG1hZ2ljID09IEJJR19CRURfTUFHSUNfQkUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkN1cnJlbnRseSBkb24ndCBzdXBwb3J0IGJpZy1lbmRpYW4gQkJJIGZpbGVzXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJOb3QgYSBzdXBwb3J0ZWQgZm9ybWF0LCBtYWdpYz0weFwiICsgbWFnaWMudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgYndnLnZlcnNpb24gPSBzYVsyXTsgICAgICAgICAgICAgLy8gNFxuICAgICAgICBid2cubnVtWm9vbUxldmVscyA9IHNhWzNdOyAgICAgICAvLyA2XG4gICAgICAgIGJ3Zy5jaHJvbVRyZWVPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgOCk7XG4gICAgICAgIGJ3Zy51bnpvb21lZERhdGFPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgMTYpO1xuICAgICAgICBid2cudW56b29tZWRJbmRleE9mZnNldCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCAyNCk7XG4gICAgICAgIGJ3Zy5maWVsZENvdW50ID0gc2FbMTZdOyAgICAgICAgIC8vIDMyXG4gICAgICAgIGJ3Zy5kZWZpbmVkRmllbGRDb3VudCA9IHNhWzE3XTsgIC8vIDM0XG4gICAgICAgIGJ3Zy5hc09mZnNldCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCAzNik7XG4gICAgICAgIGJ3Zy50b3RhbFN1bW1hcnlPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgNDQpO1xuICAgICAgICBid2cudW5jb21wcmVzc0J1ZlNpemUgPSBsYVsxM107ICAvLyA1MlxuICAgICAgICBid2cuZXh0SGVhZGVyT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIDU2KTtcblxuICAgICAgICBid2cuem9vbUxldmVscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB6bCA9IDA7IHpsIDwgYndnLm51bVpvb21MZXZlbHM7ICsremwpIHtcbiAgICAgICAgICAgIHZhciB6bFJlZHVjdGlvbiA9IGxhW3psKjYgKyAxNl1cbiAgICAgICAgICAgIHZhciB6bERhdGEgPSBid2dfcmVhZE9mZnNldChiYSwgemwqMjQgKyA3Mik7XG4gICAgICAgICAgICB2YXIgemxJbmRleCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCB6bCoyNCArIDgwKTtcbiAgICAgICAgICAgIGJ3Zy56b29tTGV2ZWxzLnB1c2goe3JlZHVjdGlvbjogemxSZWR1Y3Rpb24sIGRhdGFPZmZzZXQ6IHpsRGF0YSwgaW5kZXhPZmZzZXQ6IHpsSW5kZXh9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ3Zy5yZWFkQ2hyb21UcmVlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYndnLmdldEF1dG9TUUwoZnVuY3Rpb24oYXMpIHtcbiAgICAgICAgICAgICAgICBid2cuc2NoZW1hID0gYXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGJ3Zyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwge3RpbWVvdXQ6IDUwMDB9KTsgICAgLy8gUG90ZW50aWFsIHRpbWVvdXQgb24gZmlyc3QgcmVxdWVzdCB0byBjYXRjaCBtaXhlZC1jb250ZW50IGVycm9ycyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9taXVtLlxufVxuXG5cbkJpZ1dpZy5wcm90b3R5cGUuX3RzRmV0Y2ggPSBmdW5jdGlvbih6b29tLCBjaHIsIG1pbiwgbWF4LCBjYWxsYmFjaykge1xuICAgIHZhciBid2cgPSB0aGlzO1xuICAgIGlmICh6b29tID49IHRoaXMuem9vbUxldmVscy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICghdGhpcy50b3BMZXZlbFJlZHVjdGlvbkNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmdldFpvb21lZFZpZXcodGhpcy56b29tTGV2ZWxzLmxlbmd0aCAtIDEpLnJlYWRXaWdEYXRhQnlJZCgtMSwgMCwgMzAwMDAwMDAwLCBmdW5jdGlvbihmZWF0cykge1xuICAgICAgICAgICAgICAgIGJ3Zy50b3BMZXZlbFJlZHVjdGlvbkNhY2hlID0gZmVhdHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ3Zy5fdHNGZXRjaCh6b29tLCBjaHIsIG1pbiwgbWF4LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gW107XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMudG9wTGV2ZWxSZWR1Y3Rpb25DYWNoZTtcbiAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBjLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgIGlmIChjW2ZpXS5fY2hyb21JZCA9PSBjaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZi5wdXNoKGNbZmldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmlldztcbiAgICAgICAgaWYgKHpvb20gPCAwKSB7XG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5nZXRVbnpvb21lZFZpZXcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcgPSB0aGlzLmdldFpvb21lZFZpZXcoem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXcucmVhZFdpZ0RhdGFCeUlkKGNociwgbWluLCBtYXgsIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbkJpZ1dpZy5wcm90b3R5cGUudGhyZXNob2xkU2VhcmNoID0gZnVuY3Rpb24oY2hyTmFtZSwgcmVmZXJlbmNlUG9pbnQsIGRpciwgdGhyZXNob2xkLCBjYWxsYmFjaykge1xuICAgIGRpciA9IChkaXI8MCkgPyAtMSA6IDE7XG4gICAgdmFyIGJ3ZyA9IHRoaXM7XG4gICAgdmFyIGluaXRpYWxDaHIgPSB0aGlzLmNocm9tc1RvSURzW2Nock5hbWVdO1xuICAgIHZhciBjYW5kaWRhdGVzID0gW3tjaHJPcmQ6IDAsIGNocjogaW5pdGlhbENociwgem9vbTogYndnLnpvb21MZXZlbHMubGVuZ3RoIC0gNCwgbWluOiAwLCBtYXg6IDMwMDAwMDAwMCwgZnJvbVJlZjogdHJ1ZX1dXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5tYXhJRCArIDE7ICsraSkge1xuICAgICAgICB2YXIgY2hySWQgPSAoaW5pdGlhbENociArIChkaXIqaSkpICUgKHRoaXMubWF4SUQgKyAxKTtcbiAgICAgICAgaWYgKGNocklkIDwgMCkgXG4gICAgICAgICAgICBjaHJJZCArPSAodGhpcy5tYXhJRCArIDEpO1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe2Nock9yZDogaSwgY2hyOiBjaHJJZCwgem9vbTogYndnLnpvb21MZXZlbHMubGVuZ3RoIC0gMSwgbWluOiAwLCBtYXg6IDMwMDAwMDAwMH0pXG4gICAgfVxuICAgICAgIFxuICAgIGZ1bmN0aW9uIGZiVGhyZXNob2xkU2VhcmNoUmVjdXIoKSB7XG4gICAgXHRpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT0gMCkge1xuICAgIFx0ICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICBcdH1cbiAgICBcdGNhbmRpZGF0ZXMuc29ydChmdW5jdGlvbihjMSwgYzIpIHtcbiAgICBcdCAgICB2YXIgZCA9IGMxLnpvb20gLSBjMi56b29tO1xuICAgIFx0ICAgIGlmIChkICE9IDApXG4gICAgXHRcdCAgICByZXR1cm4gZDtcblxuICAgICAgICAgICAgZCA9IGMxLmNock9yZCAtIGMyLmNock9yZDtcbiAgICAgICAgICAgIGlmIChkICE9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgXHQgICAgZWxzZVxuICAgIFx0XHQgICAgcmV0dXJuIGMxLm1pbiAtIGMyLm1pbiAqIGRpcjtcbiAgICBcdH0pO1xuXG5cdCAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlcy5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgIGJ3Zy5fdHNGZXRjaChjYW5kaWRhdGUuem9vbSwgY2FuZGlkYXRlLmNociwgY2FuZGlkYXRlLm1pbiwgY2FuZGlkYXRlLm1heCwgZnVuY3Rpb24oZmVhdHMpIHtcbiAgICAgICAgICAgIHZhciBycCA9IGRpciA+IDAgPyAwIDogMzAwMDAwMDAwO1xuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5mcm9tUmVmKVxuICAgICAgICAgICAgICAgIHJwID0gcmVmZXJlbmNlUG9pbnQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmZWF0cy5sZW5ndGg7ICsrZmkpIHtcbiAgICBcdCAgICAgICAgdmFyIGYgPSBmZWF0c1tmaV07XG4gICAgICAgICAgICAgICAgdmFyIHNjb3JlO1xuICAgICAgICAgICAgICAgIGlmIChmLm1heFNjb3JlICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSBmLm1heFNjb3JlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSBmLnNjb3JlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICBcdCAgICAgICAgICAgIGlmIChzY29yZSA+IHRocmVzaG9sZCkge1xuICAgICAgICBcdFx0ICAgICAgICBpZiAoY2FuZGlkYXRlLnpvb20gPCAwKSB7XG4gICAgICAgIFx0XHQgICAgICAgICAgICBpZiAoZi5taW4gPiBycClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGYpO1xuICAgICAgICBcdFx0ICAgICAgICB9IGVsc2UgaWYgKGYubWF4ID4gcnApIHtcbiAgICAgICAgXHRcdCAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7Y2hyOiBjYW5kaWRhdGUuY2hyLCBjaHJPcmQ6IGNhbmRpZGF0ZS5jaHJPcmQsIHpvb206IGNhbmRpZGF0ZS56b29tIC0gMiwgbWluOiBmLm1pbiwgbWF4OiBmLm1heCwgZnJvbVJlZjogY2FuZGlkYXRlLmZyb21SZWZ9KTtcbiAgICAgICAgXHRcdCAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JlID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBcdFx0ICAgIGlmIChjYW5kaWRhdGUuem9vbSA8IDApIHtcbiAgICAgICAgICAgICAgICBcdCAgICAgICAgaWYgKGYubWF4IDwgcnApXG4gICAgICAgICAgICAgICAgXHRcdFx0ICAgIHJldHVybiBjYWxsYmFjayhmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZi5taW4gPCBycCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7Y2hyOiBjYW5kaWRhdGUuY2hyLCBjaHJPcmQ6IGNhbmRpZGF0ZS5jaHJPcmQsIHpvb206IGNhbmRpZGF0ZS56b29tIC0gMiwgbWluOiBmLm1pbiwgbWF4OiBmLm1heCwgZnJvbVJlZjogY2FuZGlkYXRlLmZyb21SZWZ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcdCAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXHQgICAgfVxuICAgICAgICAgICAgZmJUaHJlc2hvbGRTZWFyY2hSZWN1cigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgZmJUaHJlc2hvbGRTZWFyY2hSZWN1cigpO1xufVxuXG5CaWdXaWcucHJvdG90eXBlLmdldEF1dG9TUUwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmFzT2Zmc2V0KVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG5cblxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLmFzT2Zmc2V0LCAyMDQ4KS5mZXRjaChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgICAgICAgdmFyIHMgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGJhW2ldID09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvKiBcbiAgICAgICAgICogUXVpY2snbidkaXJ0eSBhdHRlbXB0IHRvIHBhcnNlIGF1dG9TcWwgZm9ybWF0LlxuICAgICAgICAgKiBTZWU6IGh0dHA6Ly93d3cubGludXhqb3VybmFsLmNvbS9maWxlcy9saW51eGpvdXJuYWwuY29tL2xpbnV4am91cm5hbC9hcnRpY2xlcy8wNTkvNTk0OS81OTQ5bDIuaHRtbFxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgaGVhZGVyX3JlID0gLyhcXHcrKVxccysoXFx3KylcXHMrKFwiKFteXCJdKylcIik/XFxzK1xcKFxccyovO1xuICAgICAgICB2YXIgZmllbGRfcmUgPSAvKFtcXHdcXFtcXF1dKylcXHMrKFxcdyspXFxzKjtcXHMqKFwiKFteXCJdKylcIik/XFxzKi9nO1xuXG4gICAgICAgIHZhciBoZWFkZXJNYXRjaCA9IGhlYWRlcl9yZS5leGVjKHMpO1xuICAgICAgICBpZiAoaGVhZGVyTWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBhcyA9IHtcbiAgICAgICAgICAgICAgICBkZWNsVHlwZTogaGVhZGVyTWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgbmFtZTogaGVhZGVyTWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgY29tbWVudDogaGVhZGVyTWF0Y2hbNF0sXG5cbiAgICAgICAgICAgICAgICBmaWVsZHM6IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcoaGVhZGVyTWF0Y2hbMF0pO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IGZpZWxkX3JlLmV4ZWMocyk7IG0gIT0gbnVsbDsgbSA9IGZpZWxkX3JlLmV4ZWMocykpIHtcbiAgICAgICAgICAgICAgICBhcy5maWVsZHMucHVzaCh7dHlwZTogbVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudDogbVs0XX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbkJpZ1dpZy5wcm90b3R5cGUuZ2V0RXh0cmFJbmRpY2VzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIGlmICh0aGlzLnZlcnNpb24gPCA0IHx8IHRoaXMuZXh0SGVhZGVyT2Zmc2V0ID09IDAgfHwgdGhpcy50eXBlICE9ICdiaWdiZWQnKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5leHRIZWFkZXJPZmZzZXQsIDY0KS5mZXRjaChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFwiQ291bGRuJ3QgZmV0Y2ggZXh0ZW5zaW9uIGhlYWRlclwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgICAgICAgICAgIHZhciBzYSA9IG5ldyBJbnQxNkFycmF5KHJlc3VsdCk7XG4gICAgICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShyZXN1bHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZXh0SGVhZGVyU2l6ZSA9IHNhWzBdO1xuICAgICAgICAgICAgdmFyIGV4dHJhSW5kZXhDb3VudCA9IHNhWzFdO1xuICAgICAgICAgICAgdmFyIGV4dHJhSW5kZXhMaXN0T2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIDQpO1xuXG4gICAgICAgICAgICBpZiAoZXh0cmFJbmRleENvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIDIwYnl0ZSByZWNvcmRzIG9ubHkgbWFrZSBzZW5zZSBmb3Igc2luZ2xlLWZpZWxkIGluZGljZXMuXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIHRoZXNlIHNlZW0gdG8gYmUgdGhlIG9ubHkgdGhpbmdzIGFyb3VuZCwgYnV0IHRoZSBmb3JtYXRcbiAgICAgICAgICAgIC8vIGlzIGFjdHVhbGx5IG1vcmUgZ2VuZXJhbC5cbiAgICAgICAgICAgIHRoaXNCLmRhdGEuc2xpY2UoZXh0cmFJbmRleExpc3RPZmZzZXQsIGV4dHJhSW5kZXhDb3VudCAqIDIwKS5mZXRjaChmdW5jdGlvbihlaWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVpbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJDb3VsZG4ndCBmZXRjaCBpbmRleCBpbmZvXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KGVpbCk7XG4gICAgICAgICAgICAgICAgdmFyIHNhID0gbmV3IEludDE2QXJyYXkoZWlsKTtcbiAgICAgICAgICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShlaWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZXh0cmFJbmRleENvdW50OyArK2lpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlaVR5cGUgPSBzYVtpaSoxMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBlaUZpZWxkQ291bnQgPSBzYVtpaSoxMCArIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWlPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgaWkqMjAgKyA0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVpRmllbGQgPSBzYVtpaSoxMCArIDhdXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG5ldyBCQklFeHRyYUluZGV4KHRoaXNCLCBlaVR5cGUsIGVpRmllbGRDb3VudCwgZWlPZmZzZXQsIGVpRmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbmRpY2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEJCSUV4dHJhSW5kZXgoYmJpLCB0eXBlLCBmaWVsZENvdW50LCBvZmZzZXQsIGZpZWxkKSB7XG4gICAgdGhpcy5iYmkgPSBiYmk7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmZpZWxkQ291bnQgPSBmaWVsZENvdW50O1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbn1cblxuQkJJRXh0cmFJbmRleC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgdGhpcy5iYmkuZGF0YS5zbGljZSh0aGlzLm9mZnNldCwgMzIpLmZldGNoKGZ1bmN0aW9uKGJwdCkge1xuICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShicHQpO1xuICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShicHQpO1xuICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShicHQpO1xuICAgICAgICB2YXIgYnB0TWFnaWMgPSBsYVswXTtcbiAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGxhWzFdO1xuICAgICAgICB2YXIga2V5U2l6ZSA9IGxhWzJdO1xuICAgICAgICB2YXIgdmFsU2l6ZSA9IGxhWzNdO1xuICAgICAgICB2YXIgaXRlbUNvdW50ID0gYndnX3JlYWRPZmZzZXQoYmEsIDE2KTtcbiAgICAgICAgdmFyIHJvb3ROb2RlT2Zmc2V0ID0gMzI7XG5cbiAgICAgICAgZnVuY3Rpb24gYnB0UmVhZE5vZGUobm9kZU9mZnNldCkge1xuICAgICAgICAgICAgdGhpc0IuYmJpLmRhdGEuc2xpY2Uobm9kZU9mZnNldCwgNCArIChibG9ja1NpemUgKiAoa2V5U2l6ZSArIHZhbFNpemUpKSkuZmV0Y2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KG5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBzYSA9IG5ldyBVaW50MTZBcnJheShub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGEgPSBuZXcgVWludDMyQXJyYXkobm9kZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBiYVswXTtcbiAgICAgICAgICAgICAgICB2YXIgY250ID0gc2FbMV07XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gNDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENoaWxkT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbnQ7ICsrbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2kgPSAwOyBraSA8IGtleVNpemU7ICsra2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBiYVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUubG9jYWxlQ29tcGFyZShrZXkpIDwgMCAmJiBsYXN0Q2hpbGRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicHRSZWFkTm9kZShsYXN0Q2hpbGRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGlsZE9mZnNldCA9IGNoaWxkT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJwdFJlYWROb2RlKGxhc3RDaGlsZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbnQ7ICsrbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2kgPSAwOyBraSA8IGtleVNpemU7ICsra2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBiYVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lmaWMgZm9yIEVJIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBid2dfcmVhZE9mZnNldChiYSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gcmVhZEludChiYSwgb2Zmc2V0ICsgOCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0IuYmJpLmdldFVuem9vbWVkVmlldygpLmZldGNoRmVhdHVyZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHRva3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tzICYmIHRva3MubGVuZ3RoID4gdGhpc0IuZmllbGQgLSAzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tzW3RoaXNCLmZpZWxkIC0gM10gPT0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt7b2Zmc2V0OiBzdGFydCwgc2l6ZTogbGVuZ3RofV0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdmFsU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnB0UmVhZE5vZGUodGhpc0Iub2Zmc2V0ICsgcm9vdE5vZGVPZmZzZXQpO1xuICAgIH0pO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIG1ha2VCd2c6IG1ha2VCd2csXG4gICAgICAgIEJJR19CRURfTUFHSUM6IEJJR19CRURfTUFHSUMsXG4gICAgICAgIEJJR19XSUdfTUFHSUM6IEJJR19XSUdfTUFHSUNcbiAgICB9XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDExXG4vL1xuLy8gYmluLmpzIGdlbmVyYWwgYmluYXJ5IGRhdGEgc3VwcG9ydFxuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuXG4gICAgdmFyIHNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKTtcbiAgICB2YXIgYjY0X3NoYTEgPSBzaGExLmI2NF9zaGExO1xuXG4gICAgdmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG59XG5cbmZ1bmN0aW9uIEJsb2JGZXRjaGFibGUoYikge1xuICAgIHRoaXMuYmxvYiA9IGI7XG59XG5cbkJsb2JGZXRjaGFibGUucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGxlbmd0aCkge1xuICAgIHZhciBiO1xuXG4gICAgaWYgKHRoaXMuYmxvYi5zbGljZSkge1xuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBiID0gdGhpcy5ibG9iLnNsaWNlKHN0YXJ0LCBzdGFydCArIGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiID0gdGhpcy5ibG9iLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLmJsb2Iud2Via2l0U2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLmJsb2Iud2Via2l0U2xpY2Uoc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmxvYkZldGNoYWJsZShiKTtcbn1cblxuQmxvYkZldGNoYWJsZS5wcm90b3R5cGUuc2FsdGVkID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fVxuXG5pZiAodHlwZW9mKEZpbGVSZWFkZXIpICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdkZWZpbmluZyBhc3luYyBCbG9iRmV0Y2hhYmxlLmZldGNoJyk7XG5cbiAgICBCbG9iRmV0Y2hhYmxlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGJzdHJpbmdUb0J1ZmZlcihyZWFkZXIucmVzdWx0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcodGhpcy5ibG9iKTtcbiAgICB9XG5cbn0gZWxzZSB7XG4gICAgLy8gaWYgKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpXG4gICAgLy8gICAgY29uc29sZS5sb2coJ2RlZmluaW5nIHN5bmMgQmxvYkZldGNoYWJsZS5mZXRjaCcpO1xuXG4gICAgQmxvYkZldGNoYWJsZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXJTeW5jKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHRoaXMuYmxvYik7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gVVJMRmV0Y2hhYmxlKHVybCwgc3RhcnQsIGVuZCwgb3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0cyA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xufVxuXG5VUkxGZXRjaGFibGUucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24ocywgbCkge1xuICAgIGlmIChzIDwgMCkge1xuICAgICAgICB0aHJvdyAnQmFkIHNsaWNlICcgKyBzO1xuICAgIH1cblxuICAgIHZhciBucyA9IHRoaXMuc3RhcnQsIG5lID0gdGhpcy5lbmQ7XG4gICAgaWYgKG5zICYmIHMpIHtcbiAgICAgICAgbnMgPSBucyArIHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbnMgPSBzIHx8IG5zO1xuICAgIH1cbiAgICBpZiAobCAmJiBucykge1xuICAgICAgICBuZSA9IG5zICsgbCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmUgPSBuZSB8fCBsIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVUkxGZXRjaGFibGUodGhpcy51cmwsIG5zLCBuZSwgdGhpcy5vcHRzKTtcbn1cblxudmFyIHNlZWQ9MDtcbnZhciBpc1NhZmFyaSA9IHR5cGVvZihuYXZpZ2F0b3IpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgPj0gMCAmJlxuICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPCAwIDtcblxuVVJMRmV0Y2hhYmxlLnByb3RvdHlwZS5mZXRjaEFzVGV4dCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXMuZ2V0VVJMKCkudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzU2FmYXJpIHx8IHRoaXNCLm9wdHMuc2FsdCkgJiYgdXJsLmluZGV4T2YoJz8nKSA8IDApIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyAnP3NhbHQ9JyArIGI2NF9zaGExKCcnICsgRGF0ZS5ub3coKSArICcsJyArICgrK3NlZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpc0IuZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLmVuZCAtIHRoaXNCLnN0YXJ0ID4gMTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdNb25zdGVyIGZldGNoISc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgdGhpc0Iuc3RhcnQgKyAnLScgKyB0aGlzQi5lbmQpO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXNCLmVuZCAtIHRoaXNCLnN0YXJ0ICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDIwMCB8fCByZXEuc3RhdHVzID09IDIwNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzQi5vcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGVycik7XG4gICAgfSk7XG59XG5cblVSTEZldGNoYWJsZS5wcm90b3R5cGUuc2FsdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBzaGFsbG93Q29weSh0aGlzLm9wdHMpO1xuICAgIG8uc2FsdCA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBVUkxGZXRjaGFibGUodGhpcy51cmwsIHRoaXMuc3RhcnQsIHRoaXMuZW5kLCBvKTtcbn1cblxuVVJMRmV0Y2hhYmxlLnByb3RvdHlwZS5nZXRVUkwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRzLnJlc29sdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdHMucmVzb2x2ZXIodGhpcy51cmwpLnRoZW4oZnVuY3Rpb24gKHVybE9yT2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybE9yT2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxPck9iajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE9yT2JqLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnVybCk7XG4gICAgfVxufVxuXG5VUkxGZXRjaGFibGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuIFxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBhdHRlbXB0ID0gb3B0cy5hdHRlbXB0IHx8IDE7XG4gICAgdmFyIHRydW5jYXRlZExlbmd0aCA9IG9wdHMudHJ1bmNhdGVkTGVuZ3RoO1xuICAgIGlmIChhdHRlbXB0ID4gMykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRVUkwoKS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAob3B0cy50aW1lb3V0ICYmICF0aGlzQi5vcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbWluZyBvdXQgJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnVGltZW91dCcpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvcHRzLnRpbWVvdXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc1NhZmFyaSB8fCB0aGlzQi5vcHRzLnNhbHQpICYmIHVybC5pbmRleE9mKCc/JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsICsgJz9zYWx0PScgKyBiNjRfc2hhMSgnJyArIERhdGUubm93KCkgKyAnLCcgKyAoKytzZWVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgIHJlcS5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG4gICAgICAgICAgICBpZiAodGhpc0IuZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLmVuZCAtIHRoaXNCLnN0YXJ0ID4gMTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdNb25zdGVyIGZldGNoISc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgdGhpc0Iuc3RhcnQgKyAnLScgKyB0aGlzQi5lbmQpO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXNCLmVuZCAtIHRoaXNCLnN0YXJ0ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDAgfHwgcmVxLnN0YXR1cyA9PSAyMDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmwgPSByZXEucmVzcG9uc2UuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoICYmIGxlbmd0aCAhPSBibCAmJiAoIXRydW5jYXRlZExlbmd0aCB8fCBibCAhPSB0cnVuY2F0ZWRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5mZXRjaChjYWxsYmFjaywge2F0dGVtcHQ6IGF0dGVtcHQgKyAxLCB0cnVuY2F0ZWRMZW5ndGg6IGJsfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXEubW96UmVzcG9uc2VBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXEubW96UmVzcG9uc2VBcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcmVxLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoICYmIGxlbmd0aCAhPSByLmxlbmd0aCAmJiAoIXRydW5jYXRlZExlbmd0aCB8fCByLmxlbmd0aCAhPSB0cnVuY2F0ZWRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5mZXRjaChjYWxsYmFjaywge2F0dGVtcHQ6IGF0dGVtcHQgKyAxLCB0cnVuY2F0ZWRMZW5ndGg6IHIubGVuZ3RofSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGJzdHJpbmdUb0J1ZmZlcihyZXEucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLmZldGNoKGNhbGxiYWNrLCB7YXR0ZW1wdDogYXR0ZW1wdCArIDF9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpc0Iub3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBlcnIpO1xuICAgIH0pO1xufVxuICAgICAgICAgICAgICAgICAgICAgICBcbmZ1bmN0aW9uIGJzdHJpbmdUb0J1ZmZlcihyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyZXN1bHQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJhW2ldID0gcmVzdWx0LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBiYS5idWZmZXI7XG59XG5cbi8vIFJlYWQgZnJvbSBVaW50OEFycmF5XG5cbnZhciBjb252ZXJ0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xudmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoY29udmVydEJ1ZmZlcik7XG52YXIgZmEgPSBuZXcgRmxvYXQzMkFycmF5KGNvbnZlcnRCdWZmZXIpO1xuXG5mdW5jdGlvbiByZWFkRmxvYXQoYnVmLCBvZmZzZXQpIHtcbiAgICBiYVswXSA9IGJ1ZltvZmZzZXRdO1xuICAgIGJhWzFdID0gYnVmW29mZnNldCsxXTtcbiAgICBiYVsyXSA9IGJ1ZltvZmZzZXQrMl07XG4gICAgICAgIGJhWzNdID0gYnVmW29mZnNldCszXTtcbiAgICByZXR1cm4gZmFbMF07XG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQ2NChiYSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChiYVtvZmZzZXQgKyA3XSA8PCAyNCkgfCAoYmFbb2Zmc2V0ICsgNl0gPDwgMTYpIHwgKGJhW29mZnNldCArIDVdIDw8IDgpIHwgKGJhW29mZnNldCArIDRdKTtcbn1cblxuZnVuY3Rpb24gcmVhZEludChiYSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChiYVtvZmZzZXQgKyAzXSA8PCAyNCkgfCAoYmFbb2Zmc2V0ICsgMl0gPDwgMTYpIHwgKGJhW29mZnNldCArIDFdIDw8IDgpIHwgKGJhW29mZnNldF0pO1xufVxuXG5mdW5jdGlvbiByZWFkU2hvcnQoYmEsIG9mZnNldCkge1xuICAgIHJldHVybiAoYmFbb2Zmc2V0ICsgMV0gPDwgOCkgfCAoYmFbb2Zmc2V0XSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCeXRlKGJhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYmFbb2Zmc2V0XTtcbn1cblxuZnVuY3Rpb24gcmVhZEludEJFKGJhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGJhW29mZnNldF0gPDwgMjQpIHwgKGJhW29mZnNldCArIDFdIDw8IDE2KSB8IChiYVtvZmZzZXQgKyAyXSA8PCA4KSB8IChiYVtvZmZzZXQgKyAzXSk7XG59XG5cbi8vIEV4cG9ydHMgaWYgd2UgYXJlIGJlaW5nIHVzZWQgYXMgYSBtb2R1bGVcblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBCbG9iRmV0Y2hhYmxlOiBCbG9iRmV0Y2hhYmxlLFxuICAgICAgICBVUkxGZXRjaGFibGU6IFVSTEZldGNoYWJsZSxcblxuICAgICAgICByZWFkSW50OiByZWFkSW50LFxuICAgICAgICByZWFkSW50QkU6IHJlYWRJbnRCRSxcbiAgICAgICAgcmVhZEludDY0OiByZWFkSW50NjQsXG4gICAgICAgIHJlYWRTaG9ydDogcmVhZFNob3J0LFxuICAgICAgICByZWFkQnl0ZTogcmVhZEJ5dGUsXG4gICAgICAgIHJlYWRGbG9hdDogcmVhZEZsb2F0XG4gICAgfVxufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gYnJvd3Nlci11cy5qczogc3RhbmRhcmQgVUkgd2lyaW5nXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbiAgICB2YXIgcmVtb3ZlQ2hpbGRyZW4gPSB1dGlscy5yZW1vdmVDaGlsZHJlbjtcblxuICAgIHZhciBuZiA9IHJlcXVpcmUoJy4vbnVtZm9ybWF0cycpO1xuICAgIHZhciBmb3JtYXRMb25nSW50ID0gbmYuZm9ybWF0TG9uZ0ludDtcblxuICAgIHZhciBtYWtlWm9vbVNsaWRlciA9IHJlcXVpcmUoJy4vem9vbXNsaWRlcicpO1xuXG4gICAgLy8gRm9yIHNpZGUgZWZmZWN0c1xuXG4gICAgcmVxdWlyZSgnLi90aWVyLWVkaXQnKTtcbiAgICByZXF1aXJlKCcuL2V4cG9ydC1jb25maWcnKTtcbiAgICByZXF1aXJlKCcuL2V4cG9ydC11aScpO1xuICAgIHJlcXVpcmUoJy4vZXhwb3J0LWltYWdlJyk7XG4gICAgcmVxdWlyZSgnLi9zdmctZXhwb3J0Jyk7XG4gICAgcmVxdWlyZSgnLi9zZXNzaW9uJyk7XG59XG5cbi8qXG4gKiBRdWl0ZSBhIGJpdCBvZiB0aGlzIG91Z2h0IHRvIGJlIGRvbmUgdXNpbmcgYSB0ZW1wbGF0aW5nIHN5c3RlbSwgYnV0XG4gKiBzaW5jZSB3ZWItY29tcG9uZW50cyBpc24ndCBxdWl0ZSByZWFkeSBmb3IgcHJpbWUgdGltZSB5ZXQgd2UnbGwgc3RpY2tcbiAqIHdpdGggY29uc3RydWN0aW5nIGl0IGFsbCBpbiBKYXZhc2NyaXB0IGZvciBub3cuLi5cbiAqL1xuXG5Ccm93c2VyLnByb3RvdHlwZS5pbml0VUkgPSBmdW5jdGlvbihob2xkZXIsIGdlbm9tZVBhbmVsKSB7XG4gICAgaWYgKCF0aGlzLm5vU291cmNlQ1NTKSB7XG4gICAgICBbJ2Jvb3RzdHJhcC1zY29wZWQuY3NzJywgJ2RhbGxpYW5jZS1zY29wZWQuY3NzJywgJ2ZvbnQtYXdlc29tZS5taW4uY3NzJ10uZm9yRWFjaChmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2xpbmsnLCAnJywge1xuICAgICAgICAgIHJlbDogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgIGhyZWY6IHRoaXMucmVzb2x2ZVVSTCgnJCRjc3MvJyArIHBhdGgpXG4gICAgICAgIH0pKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdmFyIGIgPSB0aGlzO1xuXG4gICAgaWYgKCFiLmRpc2FibGVEZWZhdWx0RmVhdHVyZVBvcHVwKSB7XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZUxpc3RlbmVyKGZ1bmN0aW9uKGV2LCBmZWF0dXJlLCBoaXQsIHRpZXIpIHtcbiAgICAgICAgICAgIGIuZmVhdHVyZVBvcHVwKGV2LCBmZWF0dXJlLCBoaXQsIHRpZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBob2xkZXIuY2xhc3NMaXN0LmFkZCgnZGFsbGlhbmNlJyk7XG4gICAgdmFyIHRvb2xiYXIgPSBiLnRvb2xiYXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ2J0bi10b29sYmFyIHRvb2xiYXInfSk7XG5cbiAgICB2YXIgdGl0bGUgPSBiLmNvb3JkU3lzdGVtLnNwZWNpZXNOYW1lICsgJyAnICsgYi5uYW1lRm9yQ29vcmRTeXN0ZW0oYi5jb29yZFN5c3RlbSk7XG4gICAgaWYgKHRoaXMuc2V0RG9jdW1lbnRUaXRsZSkge1xuICAgICAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlICsgJyA6OiBkYWxsaWFuY2UnO1xuICAgIH1cblxuICAgIHZhciBsb2NGaWVsZCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7Y2xhc3NOYW1lOiAnbG9jLWZpZWxkJ30pO1xuICAgIGIubWFrZVRvb2x0aXAobG9jRmllbGQsICdFbnRlciBhIGdlbm9taWMgbG9jYXRpb24gb3IgZ2VuZSBuYW1lJyk7XG4gICAgdmFyIGxvY1N0YXR1c0ZpZWxkID0gbWFrZUVsZW1lbnQoJ3AnLCAnJywge2NsYXNzTmFtZTogJ2xvYy1zdGF0dXMnfSk7XG5cbiAgICB2YXIgem9vbUluQnRuID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtc2VhcmNoLXBsdXMnfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30pO1xuICAgIHZhciB6b29tU2xpZGVyID0gbmV3IG1ha2Vab29tU2xpZGVyKHt3aWR0aDogYi56b29tU2xpZGVyV2lkdGh9KTtcbiAgICBiLm1ha2VUb29sdGlwKHpvb21TbGlkZXIsIFwiSGlnaGxpZ2h0ZWQgYnV0dG9uIHNob3dzIGN1cnJlbnQgem9vbSBsZXZlbCwgZ3JheSBidXR0b24gc2hvd3MgaW5hY3RpdmUgem9vbSBsZXZlbCAoY2xpY2sgb3IgdGFwIFNQQUNFIHRvIHRvZ2dsZSkuXCIpXG5cbiAgICB2YXIgem9vbU91dEJ0biA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXNlYXJjaC1taW51cyd9KV0sIHtjbGFzc05hbWU6ICdidG4nfSk7XG5cbiAgICB2YXIgY2xlYXJIaWdobGlnaHRzQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtZXJhc2VyJ30pXSwge2NsYXNzTmFtZTogJ2J0bid9KTtcblxuICAgIHZhciBhZGRUcmFja0J0biA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXBsdXMnfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30pO1xuICAgIHZhciBmYXZCdG4gPSBtYWtlRWxlbWVudCgnYScsIFttYWtlRWxlbWVudCgnaScsIG51bGwsIHtjbGFzc05hbWU6ICdmYSBmYS1ib29rbWFyayd9KV0sIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgdmFyIHN2Z0J0biA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXByaW50J30pXSwge2NsYXNzTmFtZTogJ2J0bid9KTtcbiAgICB2YXIgcmVzZXRCdG4gPSBtYWtlRWxlbWVudCgnYScsIFttYWtlRWxlbWVudCgnaScsIG51bGwsIHtjbGFzc05hbWU6ICdmYSBmYS1yZWZyZXNoJ30pXSwge2NsYXNzTmFtZTogJ2J0bid9KTtcbiAgICB2YXIgb3B0c0J1dHRvbiA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWNvZ3MnfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30pO1xuICAgIHZhciBoZWxwQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtcXVlc3Rpb24nfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30pO1xuXG4gICAgdmFyIHRpZXJFZGl0QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtcm9hZCd9KV0sIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgYi5tYWtlVG9vbHRpcCh0aWVyRWRpdEJ1dHRvbiwgJ0NvbmZpZ3VyZSBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2socykgKEUpJylcblxuICAgIHZhciBsZWFwTGVmdEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWFuZ2xlLWxlZnQnfSldLCB7Y2xhc3NOYW1lOiAnYnRuIHB1bGwtcmlnaHQnfSwge3dpZHRoOiAnNXB4J30pO1xuICAgIHZhciBsZWFwUmlnaHRCdXR0b24gPSBtYWtlRWxlbWVudCgnYScsIFttYWtlRWxlbWVudCgnaScsIG51bGwsIHtjbGFzc05hbWU6ICdmYSBmYS1hbmdsZS1yaWdodCd9KV0sIHtjbGFzc05hbWU6ICdidG4gcHVsbC1yaWdodCd9LCB7d2lkdGg6ICc1cHgnfSk7XG5cbiAgICB2YXIgbW9kZUJ1dHRvbnMgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ2J0bi1ncm91cCBwdWxsLXJpZ2h0J30pO1xuICAgIGlmICghdGhpcy5ub1RyYWNrQWRkZXIpXG4gICAgICAgIG1vZGVCdXR0b25zLmFwcGVuZENoaWxkKGFkZFRyYWNrQnRuKTtcbiAgICBpZiAoIXRoaXMubm9UcmFja0VkaXRvcilcbiAgICAgICAgbW9kZUJ1dHRvbnMuYXBwZW5kQ2hpbGQodGllckVkaXRCdXR0b24pO1xuICAgIGlmICghdGhpcy5ub0V4cG9ydClcbiAgICAgICAgbW9kZUJ1dHRvbnMuYXBwZW5kQ2hpbGQoc3ZnQnRuKTtcbiAgICBpZiAoIXRoaXMubm9PcHRpb25zKVxuICAgICAgICBtb2RlQnV0dG9ucy5hcHBlbmRDaGlsZChvcHRzQnV0dG9uKTtcbiAgICBpZiAoIXRoaXMubm9IZWxwKVxuICAgICAgICBtb2RlQnV0dG9ucy5hcHBlbmRDaGlsZChoZWxwQnV0dG9uKTtcblxuICAgIHRoaXMuc2V0VWlNb2RlID0gZnVuY3Rpb24obSkge1xuICAgICAgICB0aGlzLnVpTW9kZSA9IG07XG4gICAgICAgIHZhciBtYiA9IHtoZWxwOiBoZWxwQnV0dG9uLCBhZGQ6IGFkZFRyYWNrQnRuLCBvcHRzOiBvcHRzQnV0dG9uLCAnZXhwb3J0Jzogc3ZnQnRuLCB0aWVyOiB0aWVyRWRpdEJ1dHRvbn07XG4gICAgICAgIGZvciAodmFyIHggaW4gbWIpIHtcbiAgICAgICAgICAgIGlmICh4ID09IG0pXG4gICAgICAgICAgICAgICAgbWJbeF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWJbeF0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmIChtb2RlQnV0dG9ucy5maXJzdENoaWxkKVxuICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKG1vZGVCdXR0b25zKTtcblxuICAgIGlmICghdGhpcy5ub0xlYXBCdXR0b25zKVxuICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKGxlYXBSaWdodEJ1dHRvbik7XG4gICAgaWYgKCF0aGlzLm5vTGVhcEJ1dHRvbnMpXG4gICAgICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQobGVhcExlZnRCdXR0b24pO1xuICAgIGlmICghdGhpcy5ub1RpdGxlKSB7XG4gICAgICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2RpdicsIG1ha2VFbGVtZW50KCdoNCcsIHRpdGxlLCB7fSwge21hcmdpbjogJzBweCd9KSwge2NsYXNzTmFtZTogJ2J0bi1ncm91cCB0aXRsZSd9KSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5ub0xvY2F0aW9uRmllbGQpXG4gICAgICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2RpdicsIFtsb2NGaWVsZCwgbG9jU3RhdHVzRmllbGRdLCB7Y2xhc3NOYW1lOiAnYnRuLWdyb3VwIGxvYy1ncm91cCd9KSk7XG4gICAgaWYgKCF0aGlzLm5vQ2xlYXJIaWdobGlnaHRzQnV0dG9uKVxuICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKGNsZWFySGlnaGxpZ2h0c0J1dHRvbik7XG5cbiAgICBpZiAoIXRoaXMubm9ab29tU2xpZGVyKSB7XG4gICAgICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2RpdicsIFt6b29tSW5CdG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgnc3BhbicsIHpvb21TbGlkZXIsIHtjbGFzc05hbWU6ICdidG4nfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tT3V0QnRuXSwge2NsYXNzTmFtZTogJ2J0bi1ncm91cCd9KSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9vbGJhckJlbG93KSB7XG4gICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChnZW5vbWVQYW5lbCk7XG4gICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZCh0b29sYmFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBob2xkZXIuYXBwZW5kQ2hpbGQodG9vbGJhcik7XG4gICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChnZW5vbWVQYW5lbCk7XG4gICAgfVxuXG5cbiAgICB2YXIgbHQyID0gTWF0aC5sb2coMikgLyBNYXRoLmxvZygxMCk7XG4gICAgdmFyIGx0NSA9IE1hdGgubG9nKDUpIC8gTWF0aC5sb2coMTApO1xuICAgIHZhciByb3VuZFNsaWRlclZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgbHR4ID0gKHggLyBiLnpvb21FeHB0ICsgTWF0aC5sb2coYi56b29tQmFzZSkpIC8gTWF0aC5sb2coMTApO1xuXG4gICAgICAgIHZhciB3aG9sZSA9IGx0eHwwXG4gICAgICAgIHZhciBmcmFjID0gbHR4IC0gd2hvbGU7XG4gICAgICAgIHZhciByb3VuZGVkXG5cbiAgICAgICAgaWYgKGZyYWMgPCAwLjAxKVxuICAgICAgICAgICAgcm91bmRlZCA9IHdob2xlO1xuICAgICAgICBlbHNlIGlmIChmcmFjIDw9IChsdDIgKyAwLjAxKSlcbiAgICAgICAgICAgIHJvdW5kZWQgPSB3aG9sZSArIGx0MjtcbiAgICAgICAgZWxzZSBpZiAoZnJhYyA8PSAobHQ1ICsgMC4wMSkpXG4gICAgICAgICAgICByb3VuZGVkID0gd2hvbGUgKyBsdDU7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm91bmRlZCA9IHdob2xlICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAocm91bmRlZCAqIE1hdGgubG9nKDEwKSAtTWF0aC5sb2coYi56b29tQmFzZSkpICogYi56b29tRXhwdDtcbiAgICB9XG5cbiAgICB2YXIgbWFya1NsaWRlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgem9vbVNsaWRlci5hZGRMYWJlbCh4LCBodW1hblJlYWRhYmxlU2NhbGUoTWF0aC5leHAoeCAvIGIuem9vbUV4cHQpICogYi56b29tQmFzZSkpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkVmlld0xpc3RlbmVyKGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIF9vbGRab29tLCB6b29tKSB7XG4gICAgICAgIGxvY0ZpZWxkLnZhbHVlID0gKGNociArICc6JyArIGZvcm1hdExvbmdJbnQobWluKSArICcuLicgKyBmb3JtYXRMb25nSW50KG1heCkpO1xuICAgICAgICB6b29tU2xpZGVyLm1pbiA9IHpvb20ubWlufDA7XG4gICAgICAgIHpvb21TbGlkZXIubWF4ID0gem9vbS5tYXh8MDtcbiAgICAgICAgaWYgKHpvb20uaXNTbmFwWm9vbWluZykge1xuICAgICAgICAgICAgem9vbVNsaWRlci52YWx1ZSA9IHpvb20uYWx0ZXJuYXRlXG4gICAgICAgICAgICB6b29tU2xpZGVyLnZhbHVlMiA9IHpvb20uY3VycmVudDtcbiAgICAgICAgICAgIHpvb21TbGlkZXIuYWN0aXZlID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHpvb21TbGlkZXIudmFsdWUgPSB6b29tLmN1cnJlbnQ7XG4gICAgICAgICAgICB6b29tU2xpZGVyLnZhbHVlMiA9IHpvb20uYWx0ZXJuYXRlO1xuICAgICAgICAgICAgem9vbVNsaWRlci5hY3RpdmUgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvb20uY3VycmVudCA9PSB6b29tLm1pbilcbiAgICAgICAgICAgIHpvb21JbkJ0bi5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB6b29tSW5CdG4uY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKTtcblxuICAgICAgICBpZiAoem9vbS5jdXJyZW50ID09IHpvb20ubWF4KVxuICAgICAgICAgICAgem9vbU91dEJ0bi5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB6b29tT3V0QnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgem9vbVNsaWRlci5yZW1vdmVMYWJlbHMoKTtcbiAgICAgICAgdmFyIHptaW4gPSB6b29tLm1pbjtcbiAgICAgICAgdmFyIHptYXggPSB6b29tLm1heDtcbiAgICAgICAgdmFyIHpyYW5nZSA9IHptYXggLSB6bWluO1xuXG5cbiAgICAgICAgdmFyIG51bVNsaWRlclRpY2tzID0gNDtcbiAgICAgICAgaWYgKGIuem9vbVNsaWRlcldpZHRoICYmIGIuem9vbVNsaWRlcldpZHRoIDwgMTUwKVxuICAgICAgICAgICAgbnVtU2xpZGVyVGlja3MgPSAzO1xuICAgICAgICBtYXJrU2xpZGVyKHJvdW5kU2xpZGVyVmFsdWUoem1pbikpO1xuICAgICAgICBmb3IgKHZhciBzdGkgPSAxOyBzdGkgPCBudW1TbGlkZXJUaWNrcyAtIDE7ICsrc3RpKSB7XG4gICAgICAgICAgICBtYXJrU2xpZGVyKHJvdW5kU2xpZGVyVmFsdWUoem1pbiArICgxLjAgKiBzdGkgKiB6cmFuZ2UgLyAobnVtU2xpZGVyVGlja3MgLTEpKSkpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtTbGlkZXIocm91bmRTbGlkZXJWYWx1ZSh6bWF4KSk7XG5cbiAgICAgICAgaWYgKGIuc3RvcmVTdGF0dXMpIHtcbiAgICAgICAgICAgIGIuc3RvcmVWaWV3U3RhdHVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYi5oaWdobGlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNsZWFySGlnaGxpZ2h0c0J1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhckhpZ2hsaWdodHNCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRUaWVyTGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChiLnN0b3JlU3RhdHVzKSB7XG4gICAgICAgICAgICBiLnN0b3JlVGllclN0YXR1cygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsb2NGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gNDApIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYi5zZXRTZWxlY3RlZFRpZXIoMCk7XG4gICAgICAgIH0gaWYgKGV2LmtleUNvZGUgPT0gMTAgfHwgZXYua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcblxuXG4gICAgICAgICAgICB2YXIgZyA9IGxvY0ZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgYi5zZWFyY2goZywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2NTdGF0dXNGaWVsZC50ZXh0Q29udGVudCA9ICcnICsgZXJyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY1N0YXR1c0ZpZWxkLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgdHJhY2tBZGRQb3B1cDtcbiAgICBhZGRUcmFja0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICh0cmFja0FkZFBvcHVwICYmIHRyYWNrQWRkUG9wdXAuZGlzcGxheWVkKSB7XG4gICAgICAgICAgICBiLnJlbW92ZUFsbFBvcHVwcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tBZGRQb3B1cCA9IGIuc2hvd1RyYWNrQWRkZXIoZXYpO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIGIubWFrZVRvb2x0aXAoYWRkVHJhY2tCdG4sICdBZGQgYSBuZXcgdHJhY2sgZnJvbSB0aGUgcmVnaXN0cnkgb3IgYW4gaW5kZXhlZCBmaWxlLiAoQSknKTtcblxuICAgIHpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgYi56b29tU3RlcCgtMTApO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKHpvb21JbkJ0biwgJ1pvb20gaW4gKCspJyk7XG5cbiAgICB6b29tT3V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBiLnpvb21TdGVwKDEwKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcCh6b29tT3V0QnRuLCAnWm9vbSBvdXQgKC0pJyk7XG5cbiAgICB6b29tU2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciB3YW50U25hcCA9IHpvb21TbGlkZXIuYWN0aXZlID09IDI7XG4gICAgICAgIGlmICh3YW50U25hcCAhPSBiLmlzU25hcFpvb21pbmcpIHtcbiAgICAgICAgICAgIGIuc2F2ZWRab29tID0gYi56b29tU2xpZGVyVmFsdWUgIC0gYi56b29tTWluO1xuICAgICAgICAgICAgYi5pc1NuYXBab29taW5nID0gd2FudFNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2ZVpTViA9IHpvb21TbGlkZXIuYWN0aXZlID09IDEgPyB6b29tU2xpZGVyLnZhbHVlIDogem9vbVNsaWRlci52YWx1ZTI7XG5cbiAgICBcdGIuem9vbVNsaWRlclZhbHVlID0gKDEuMCAqIGFjdGl2ZVpTVik7XG4gICAgXHRiLnpvb20oTWF0aC5leHAoKDEuMCAqIGFjdGl2ZVpTVikgLyBiLnpvb21FeHB0KSk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgZmF2QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcChmYXZCdG4sICdGYXZvdXJpdGUgcmVnaW9ucycpO1xuXG4gICAgc3ZnQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYi5vcGVuRXhwb3J0UGFuZWwoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcChzdmdCdG4sICdFeHBvcnQgcHVibGljYXRpb24tcXVhbGl0eSBTVkcuIChYKScpO1xuXG4gICAgdmFyIG9wdHNQb3B1cDtcbiAgICBvcHRzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgYi50b2dnbGVPcHRzUG9wdXAoZXYpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKG9wdHNCdXR0b24sICdDb25maWd1cmUgb3B0aW9ucy4nKTtcblxuICAgIGhlbHBCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYi50b2dnbGVIZWxwUG9wdXAoZXYpO1xuICAgIH0pO1xuICAgIGIubWFrZVRvb2x0aXAoaGVscEJ1dHRvbiwgJ0hlbHA7IEtleWJvYXJkIHNob3J0Y3V0cy4gKEgpJyk7XG5cbiAgICB0aWVyRWRpdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoYi5zZWxlY3RlZFRpZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBiLm9wZW5UaWVyUGFuZWwoYi50aWVyc1tiLnNlbGVjdGVkVGllcnNbMF1dKTtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIGxlYXBMZWZ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgYi5sZWFwKGIucmV2ZXJzZUtleVNjcm9sbGluZyA/IC0xIDogMSwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKGxlYXBMZWZ0QnV0dG9uLCBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgc3QgPSBiLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICB2YXIgdGllcjtcbiAgICAgICAgaWYgKHN0ID49IDApXG4gICAgICAgICAgICB0aWVyID0gYi50aWVyc1tzdF07XG5cbiAgICAgICAgaWYgKHRpZXIgJiYgdGllci5mZWF0dXJlU291cmNlICYmIGIuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdxdWFudExlYXAnKSAmJiB0eXBlb2YodGllci5xdWFudExlYXBUaHJlc2hvbGQpID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0p1bXAgdG8gdGhlIG5leHQgcmVnaW9uIHdpdGggYSBzY29yZSBhYm92ZSB0aGUgdGhyZXNob2xkIGluIHRoZSBzZWxlY3RlZCB0cmFjayBcIicgKyAodGllci5jb25maWcubmFtZSB8fCB0aWVyLmRhc1NvdXJjZS5uYW1lKSArICdcIlwiIChjdHJsK0xFRlQpJztcbiAgICAgICAgfSBlbHNlIGlmICh0aWVyICYmIHRpZXIuZmVhdHVyZVNvdXJjZSAmJiBiLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGllci5mZWF0dXJlU291cmNlLCAnbGVhcCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0p1bXAgdG8gdGhlIG5leHQgZmVhdHVyZSBpbiB0aGUgc2VsZWN0ZWQgdHJhY2sgXCInICsgKHRpZXIuY29uZmlnLm5hbWUgfHwgdGllci5kYXNTb3VyY2UubmFtZSkgKyAnXCIgKGN0cmwrTEVGVCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdKdW1wIGxlZnQgKHNoaWZ0K0xFRlQpJztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGVhcFJpZ2h0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgYi5sZWFwKGIucmV2ZXJzZUtleVNjcm9sbGluZyA/IDEgOiAtMSwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKGxlYXBSaWdodEJ1dHRvbiwgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHN0ID0gYi5nZXRTZWxlY3RlZFRpZXIoKTtcbiAgICAgICAgdmFyIHRpZXI7XG4gICAgICAgIGlmIChzdCA+PSAwKVxuICAgICAgICAgICAgdGllciA9IGIudGllcnNbc3RdO1xuXG4gICAgICAgIGlmICh0aWVyICYmIHRpZXIuZmVhdHVyZVNvdXJjZSAmJiBiLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGllci5mZWF0dXJlU291cmNlLCAncXVhbnRMZWFwJykgJiYgdHlwZW9mKHRpZXIucXVhbnRMZWFwVGhyZXNob2xkKSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuICdKdW1wIHRvIHRoZSBuZXh0IHJlZ2lvbiB3aXRoIGEgc2NvcmUgYWJvdmUgdGhlIHRocmVzaG9sZCBpbiB0aGUgc2VsZWN0ZWQgdHJhY2sgXCInICsgKHRpZXIuY29uZmlnLm5hbWUgfHwgdGllci5kYXNTb3VyY2UubmFtZSkgKyAnXCJcIiAoY3RybCtSSUdIVCknO1xuICAgICAgICB9IGVsc2UgaWYgKHRpZXIgJiYgdGllci5mZWF0dXJlU291cmNlICYmIGIuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdsZWFwJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSnVtcCB0byB0aGUgbmV4dCBmZWF0dXJlIGluIHRoZSBzZWxlY3RlZCB0cmFjayBcIicgKyAodGllci5jb25maWcubmFtZSB8fCB0aWVyLmRhc1NvdXJjZS5uYW1lKSArICdcIiAoY3RybCtSSUdIVCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdKdW1wIHJpZ2h0IChzaGlmdCtSSUdIVCknO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgYi5hZGRUaWVyU2VsZWN0aW9uTGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdCA9IGIuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgICAgIHZhciB0aWVyO1xuICAgICAgICBpZiAoc3QgPj0gMClcbiAgICAgICAgICAgIHRpZXIgPSBiLnRpZXJzW3N0XTtcblxuICAgICAgICB2YXIgY2FuTGVhcCA9IGZhbHNlO1xuICAgICAgICBpZiAodGllciAmJiB0aWVyLmZlYXR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChiLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGllci5mZWF0dXJlU291cmNlLCAncXVhbnRMZWFwJykgJiYgdHlwZW9mKHRpZXIucXVhbnRMZWFwVGhyZXNob2xkKSA9PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBjYW5MZWFwID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGIuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdsZWFwJykpXG4gICAgICAgICAgICAgICAgY2FuTGVhcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZWFwTGVmdEJ1dHRvbi5maXJzdENoaWxkLmNsYXNzTmFtZSA9IGNhbkxlYXAgPyAnZmEgZmEtYW5nbGUtZG91YmxlLWxlZnQnIDogJ2ZhIGZhLWFuZ2xlLWxlZnQnO1xuICAgICAgICBsZWFwUmlnaHRCdXR0b24uZmlyc3RDaGlsZC5jbGFzc05hbWUgPSBjYW5MZWFwID8gJ2ZhIGZhLWFuZ2xlLWRvdWJsZS1yaWdodCcgOiAnZmEgZmEtYW5nbGUtcmlnaHQnO1xuICAgIH0pO1xuXG4gICAgY2xlYXJIaWdobGlnaHRzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgYi5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcChjbGVhckhpZ2hsaWdodHNCdXR0b24sICdDbGVhciBoaWdobGlnaHRzIChDKScpO1xuXG4gICAgYi5hZGRUaWVyU2VsZWN0aW9uV3JhcExpc3RlbmVyKGZ1bmN0aW9uKGRpcikge1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgYi5zZXRTZWxlY3RlZFRpZXIobnVsbCk7XG4gICAgICAgICAgICBsb2NGaWVsZC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBiLmFkZFRpZXJTZWxlY3Rpb25MaXN0ZW5lcihmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgaWYgKGIudWlNb2RlID09PSAndGllcicpIHtcbiAgICAgICAgICAgIGlmIChzZWwubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBiLmhpZGVUb29sUGFuZWwoKTtcbiAgICAgICAgICAgICAgICBiLm1hbmlwdWxhdGluZ1RpZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGIudWlNb2RlID0gJ25vbmUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnQgPSBiLnRpZXJzW3NlbFswXV07XG4gICAgICAgICAgICAgICAgaWYgKGZ0ICE9IGIubWFuaXB1bGF0aW5nVGllcikge1xuICAgICAgICAgICAgICAgICAgICBiLm9wZW5UaWVyUGFuZWwoZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVpS2V5SGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdidWtoOiAnICsgZXYua2V5Q29kZSk7XG4gICAgICAgIGlmIChldi5rZXlDb2RlID09IDY1IHx8IGV2LmtleUNvZGUgPT0gOTcpIHsgIC8vIGFcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYi5zaG93VHJhY2tBZGRlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gNzIgfHwgZXYua2V5Q29kZSA9PSAxMDQpIHsgLy8gaFxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBiLnRvZ2dsZUhlbHBQb3B1cChldik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSA2OSB8fCBldi5rZXlDb2RlID09IDEwMSkgeyAvL2VcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGIuc2VsZWN0ZWRUaWVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGIub3BlblRpZXJQYW5lbChiLnRpZXJzW2Iuc2VsZWN0ZWRUaWVyc1swXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gODggfHwgZXYua2V5Q29kZSA9PSAxMjApIHsgLy8geFxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBiLm9wZW5FeHBvcnRQYW5lbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gNjcgfHwgZXYua2V5Q29kZSA9PSA5OSkgeyAvLyBjXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGIuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB1aUtleUhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgaG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbihldikge1xuICAgICAgICBob2xkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHVpS2V5SGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIGhvbGRlci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGV2LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICBpZiAoYi51aU1vZGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY29uc3VtZSBldmVudCBpZiB0b29sIHBhbmVsIGlzIG9wZW4uXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBiLnNldFVpTW9kZSgnbm9uZScpO1xuICAgICAgICAgICAgICAgIGIuaGlkZVRvb2xQYW5lbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGIuc2VsZWN0ZWRUaWVycyAmJiBiLnNlbGVjdGVkVGllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBiLmJyb3dzZXJIb2xkZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNob3dUb29sUGFuZWwgPSBmdW5jdGlvbihwYW5lbCwgbm93cmFwKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIGlmICh0aGlzLmFjdGl2ZVRvb2xQYW5lbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRvb2xQYW5lbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuYWN0aXZlVG9vbFBhbmVsKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudDtcbiAgICBpZiAobm93cmFwKVxuICAgICAgICBjb250ZW50ID0gcGFuZWw7XG4gICAgZWxzZVxuICAgICAgICBjb250ZW50ID0gbWFrZUVsZW1lbnQoJ2RpdicsIHBhbmVsLCB7fSwge292ZXJmbG93WTogJ2F1dG8nLCB3aWR0aDogJzEwMCUnfSk7XG5cblxuICAgIHZhciBkaXZpZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWNhcmV0LXJpZ2h0J30pLCB7Y2xhc3NOYW1lOiAndG9vbC1kaXZpZGVyJ30pO1xuICAgIGRpdmlkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICB0aGlzQi5oaWRlVG9vbFBhbmVsKCk7XG4gICAgICAgIHRoaXNCLnNldFVpTW9kZSgnbm9uZScpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB0aGlzLm1ha2VUb29sdGlwKGRpdmlkZXIsICdDbG9zZSB0b29sIHBhbmVsIChFU0MpJyk7XG4gICAgdGhpcy5hY3RpdmVUb29sUGFuZWwgPSBtYWtlRWxlbWVudCgnZGl2JywgW2RpdmlkZXIsIGNvbnRlbnRdLCB7Y2xhc3NOYW1lOiAndG9vbC1ob2xkZXInfSk7XG4gICAgdGhpcy5zdmdIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5hY3RpdmVUb29sUGFuZWwpO1xuICAgIHRoaXMucmVzaXplVmlld2VyKCk7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5oaWRlVG9vbFBhbmVsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlVG9vbFBhbmVsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVG9vbFBhbmVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5hY3RpdmVUb29sUGFuZWwpO1xuICAgIH1cbiAgICB0aGlzLnN2Z0hvbGRlci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmFjdGl2ZVRvb2xQYW5lbCA9IG51bGw7XG4gICAgdGhpcy5yZXNpemVWaWV3ZXIoKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUudG9nZ2xlSGVscFBvcHVwID0gZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAodGhpcy51aU1vZGUgPT09ICdoZWxwJykge1xuICAgICAgICB0aGlzLmhpZGVUb29sUGFuZWwoKTtcbiAgICAgICAgdGhpcy5zZXRVaU1vZGUoJ25vbmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGVscEZyYW1lID0gbWFrZUVsZW1lbnQoJ2lmcmFtZScsIG51bGwsIHtzY3JvbGxpbmc6ICd5ZXMnLCBzZWFtbGVzczogJ3NlYW1sZXNzJywgc3JjOiB0aGlzLnJlc29sdmVVUkwoJyQkaGVscC9pbmRleC5odG1sJyksIGNsYXNzTmFtZTogJ2hlbHAtcGFuZWwnfSk7XG4gICAgICAgIHRoaXMuc2hvd1Rvb2xQYW5lbChoZWxwRnJhbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRVaU1vZGUoJ2hlbHAnKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnRvZ2dsZU9wdHNQb3B1cCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgdmFyIGIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMudWlNb2RlID09PSAnb3B0cycpIHtcbiAgICAgICAgdGhpcy5oaWRlVG9vbFBhbmVsKCk7XG4gICAgICAgIHRoaXMuc2V0VWlNb2RlKCdub25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9wdHNGb3JtID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICdmb3JtLWhvcml6b250YWwnfSwge2JveFNpemluZzogJ2JvcmRlci1ib3gnLCBNb3pCb3hTaXppbmc6ICdib3JkZXItYm94JywgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIHZlcnRpY2FsQWxpZ246ICd0b3AnfSk7XG4gICAgICAgIHZhciBvcHRzVGFibGUgPSBtYWtlRWxlbWVudCgndGFibGUnKTtcbiAgICAgICAgb3B0c1RhYmxlLmNlbGxQYWRkaW5nID0gNTtcblxuICAgICAgICB2YXIgc2Nyb2xsTW9kZUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogYi5yZXZlcnNlU2Nyb2xsaW5nfSk7XG4gICAgICAgIHNjcm9sbE1vZGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIucmV2ZXJzZVNjcm9sbGluZyA9IHNjcm9sbE1vZGVCdXR0b24uY2hlY2tlZDtcbiAgICAgICAgICAgIGIuc3RvcmVTdGF0dXMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBvcHRzVGFibGUuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3RyJywgW21ha2VFbGVtZW50KCd0ZCcsICdSZXZlcnNlIHRyYWNrcGFkIHNjcm9sbGluZycsIHthbGlnbjogJ3JpZ2h0J30pLCBtYWtlRWxlbWVudCgndGQnLCBzY3JvbGxNb2RlQnV0dG9uKV0pKTtcblxuICAgICAgICB2YXIgc2Nyb2xsS2V5QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgJycsIHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiBiLnJldmVyc2VLZXlTY3JvbGxpbmd9KTtcbiAgICAgICAgc2Nyb2xsS2V5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBiLnJldmVyc2VLZXlTY3JvbGxpbmcgPSBzY3JvbGxLZXlCdXR0b24uY2hlY2tlZDtcbiAgICAgICAgICAgIGIuc3RvcmVTdGF0dXMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBvcHRzVGFibGUuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3RyJywgW21ha2VFbGVtZW50KCd0ZCcsICdSZXZlcnNlIHNjcm9sbGluZyBidXR0b25zIGFuZCBrZXlzJywge2FsaWduOiAncmlnaHQnfSksIG1ha2VFbGVtZW50KCd0ZCcsIHNjcm9sbEtleUJ1dHRvbildKSk7XG5cblxuICAgICAgICB2YXIgcnVsZXJTZWxlY3QgPSBtYWtlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIHJ1bGVyU2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnTGVmdCcsIHt2YWx1ZTogJ2xlZnQnfSkpO1xuICAgICAgICBydWxlclNlbGVjdC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnb3B0aW9uJywgJ0NlbnRlcicsIHt2YWx1ZTogJ2NlbnRlcid9KSk7XG4gICAgICAgIHJ1bGVyU2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnUmlnaHQnLCB7dmFsdWU6ICdyaWdodCd9KSk7XG4gICAgICAgIHJ1bGVyU2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnTm9uZScsIHt2YWx1ZTogJ25vbmUnfSkpO1xuICAgICAgICBydWxlclNlbGVjdC52YWx1ZSA9IGIucnVsZXJMb2NhdGlvbjtcbiAgICAgICAgcnVsZXJTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIucnVsZXJMb2NhdGlvbiA9IHJ1bGVyU2VsZWN0LnZhbHVlO1xuICAgICAgICAgICAgYi5wb3NpdGlvblJ1bGVyKCk7XG4gICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgYi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICBiLnRpZXJzW3RpXS5wYWludFF1YW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLnN0b3JlU3RhdHVzKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgb3B0c1RhYmxlLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCd0cicsIFttYWtlRWxlbWVudCgndGQnLCAnVmVydGljYWwgZ3VpZGVsaW5lJywge2FsaWduOiAncmlnaHQnfSksIG1ha2VFbGVtZW50KCd0ZCcsIHJ1bGVyU2VsZWN0KV0pKTtcblxuICAgICAgICB2YXIgc2luZ2xlQmFzZUhpZ2hsaWdodEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogYi5zaW5nbGVCYXNlSGlnaGxpZ2h0fSk7XG4gICAgICAgIHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIuc2luZ2xlQmFzZUhpZ2hsaWdodCA9IHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24uY2hlY2tlZDtcbiAgICAgICAgICAgIGIucG9zaXRpb25SdWxlcigpO1xuICAgICAgICAgICAgYi5zdG9yZVN0YXR1cygpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24uc2V0QXR0cmlidXRlKCdpZCcsJ3NpbmdsZUJhc2VIaWdodGxpZ2h0QnV0dG9uJyk7IC8vIG1ha2luZyB0aGlzIGJlY2F1c2UgYWNjZXNzIGlzIHJlcXVpcmVkIHdoZW4gdGhlIGtleSAndScgaXMgcHJlc3NlZCBhbmQgdGhlIG9wdGlvbnMgYXJlIHZpc2libGVcbiAgICAgICAgb3B0c1RhYmxlLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCd0cicsIFttYWtlRWxlbWVudCgndGQnLCAnRGlzcGxheSBhbmQgaGlnaGxpZ2h0IGN1cnJlbnQgZ2Vub21lIGxvY2F0aW9uJywge2FsaWduOiAncmlnaHQnfSksIG1ha2VFbGVtZW50KCd0ZCcsIHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24pXSkpO1xuXG4gICAgICAgIG9wdHNGb3JtLmFwcGVuZENoaWxkKG9wdHNUYWJsZSk7XG5cbiAgICAgICAgdmFyIHJlc2V0QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2J1dHRvbicsICdSZXNldCBicm93c2VyJywge2NsYXNzTmFtZTogJ2J0bid9LCB7bWFyZ2luTGVmdDogJ2F1dG8nLCBtYXJnaW5SaWdodDogJ2F1dG8nLCBkaXNwbGF5OiAnYmxvY2snfSk7XG4gICAgICAgIHJlc2V0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIucmVzZXQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBvcHRzRm9ybS5hcHBlbmRDaGlsZChyZXNldEJ1dHRvbik7XG5cbiAgICAgICAgdGhpcy5zaG93VG9vbFBhbmVsKG9wdHNGb3JtKTtcbiAgICAgICAgdGhpcy5zZXRVaU1vZGUoJ29wdHMnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGh1bWFuUmVhZGFibGVTY2FsZSh4KSB7XG4gICAgdmFyIHN1ZmZpeCA9ICdicCc7XG4gICAgaWYgKHggPiAxMDAwMDAwMDAwKSB7XG4gICAgICAgIHggLz0gMTAwMDAwMDAwMDtcbiAgICAgICAgc3VmZml4ID0gJ0diJztcbiAgICB9IGVsc2UgaWYgKHggPiAxMDAwMDAwKSB7XG4gICAgICAgIHggLz0gMTAwMDAwMFxuICAgICAgICBzdWZmaXggPSAnTWInO1xuICAgIH0gZWxzZSBpZiAoeCA+IDEwMDApIHtcbiAgICAgICAgeCAvPSAxMDAwO1xuICAgICAgICBzdWZmaXggPSAna2InO1xuICAgIH1cbiAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHgpICsgc3VmZml4O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDExXG4vL1xuLy8gY2Jyb3dzZXIuanM6IGNhbnZhcyBicm93c2VyIGNvbnRhaW5lclxuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBPYnNlcnZlZCA9IHV0aWxzLk9ic2VydmVkO1xuICAgIHZhciBBd2FpdGVkID0gdXRpbHMuQXdhaXRlZDtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbiAgICB2YXIgcmVtb3ZlQ2hpbGRyZW4gPSB1dGlscy5yZW1vdmVDaGlsZHJlbjtcbiAgICB2YXIgbWluaUpTT05pZnkgPSB1dGlscy5taW5pSlNPTmlmeTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcbiAgICB2YXIgdGV4dFhIUiA9IHV0aWxzLnRleHRYSFI7XG5cbiAgICB2YXIgdGllciA9IHJlcXVpcmUoJy4vdGllcicpO1xuICAgIHZhciBEYXNUaWVyID0gdGllci5EYXNUaWVyO1xuXG4gICAgdmFyIHNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKTtcbiAgICB2YXIgaGV4X3NoYTEgPSBzaGExLmhleF9zaGExO1xuXG4gICAgdmFyIHRodWIgPSByZXF1aXJlKCcuL3RodWInKTtcbiAgICB2YXIgY29ubmVjdFRyYWNrSHViID0gdGh1Yi5jb25uZWN0VHJhY2tIdWI7XG5cbiAgICB2YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdFF1YW50TGFiZWwgPSBuZi5mb3JtYXRRdWFudExhYmVsO1xuICAgIHZhciBmb3JtYXRMb25nSW50ID0gbmYuZm9ybWF0TG9uZ0ludDtcblxuICAgIHZhciBDaGFpbnNldCA9IHJlcXVpcmUoJy4vY2hhaW5zZXQnKS5DaGFpbnNldDtcblxuICAgIHZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuXG4gICAgdmFyIHNvdXJjZWNvbXBhcmUgPSByZXF1aXJlKCcuL3NvdXJjZWNvbXBhcmUnKTtcbiAgICB2YXIgc291cmNlc0FyZUVxdWFsID0gc291cmNlY29tcGFyZS5zb3VyY2VzQXJlRXF1YWw7XG4gICAgdmFyIHNvdXJjZXNBcmVFcXVhbE1vZHVsb1N0eWxlID0gc291cmNlY29tcGFyZS5zb3VyY2VzQXJlRXF1YWxNb2R1bG9TdHlsZTtcbiAgICB2YXIgc291cmNlRGF0YVVSSSA9IHNvdXJjZWNvbXBhcmUuc291cmNlRGF0YVVSSTtcbiAgICB2YXIgc291cmNlU3R5bGVVUkkgPSBzb3VyY2Vjb21wYXJlLnNvdXJjZVN0eWxlVVJJO1xuXG4gICAgdmFyIERlZmF1bHRSZW5kZXJlciA9IHJlcXVpcmUoJy4vZGVmYXVsdC1yZW5kZXJlcicpO1xuXG4gICAgdmFyIE11bHRpUmVuZGVyZXIgPSByZXF1aXJlKCcuL211bHRpLXJlbmRlcmVyJyk7XG4gICAgdmFyIFN1YlJlbmRlcmVyID0gcmVxdWlyZSgnLi9zdWItcmVuZGVyZXInKTtcblxuICAgIHZhciBEdW1teVJlbmRlcmVyID0gcmVxdWlyZSgnLi9kdW1teS1yZW5kZXJlcicpO1xufVxuXG5mdW5jdGlvbiBSZWdpb24oY2hyLCBtaW4sIG1heCkge1xuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIHRoaXMuY2hyID0gY2hyO1xufVxuXG5mdW5jdGlvbiBCcm93c2VyKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZXJzID1cbiAgICAgICAgeyAnZGVmYXVsdCc6IERlZmF1bHRSZW5kZXJlcixcbiAgICAgICAgICAnZHVtbXknOiBEdW1teVJlbmRlcmVyLFxuICAgICAgICAgICdtdWx0aSc6IE11bHRpUmVuZGVyZXIsXG4gICAgICAgICAgJ3N1Yic6IFN1YlJlbmRlcmVyXG4gICAgICAgIH07XG5cbiAgICBpZiAob3B0cy5leHRlcm5hbFJlbmRlcmVycyAmJiB0eXBlb2Ygb3B0cy5leHRlcm5hbFJlbmRlcmVycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9wdHMuZXh0ZXJuYWxSZW5kZXJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2tdID0gb3B0cy5leHRlcm5hbFJlbmRlcmVyc1trXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGVmYXVsdFJlbmRlcmVyID0gb3B0cy5yZW5kZXJlciB8fCBEZWZhdWx0UmVuZGVyZXI7XG5cbiAgICB0aGlzLnByZWZpeCA9ICcvL3d3dy5iaW9kYWxsaWFuY2Uub3JnL3JlbGVhc2UtMC4xNC8nO1xuICAgIHRoaXMud29ya2VyUHJlZml4ID0gb3B0cy53b3JrZXJQcmVmaXggfHwgJyc7XG5cbiAgICB0aGlzLnNvdXJjZXMgPSBbXTtcbiAgICB0aGlzLnRpZXJzID0gW107XG4gICAgdGhpcy50aWVyR3JvdXBzID0ge307XG5cbiAgICB0aGlzLmZlYXR1cmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmZlYXR1cmVIb3Zlckxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMudmlld0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMucmVnaW9uU2VsZWN0TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy50aWVyTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy50aWVyU2VsZWN0aW9uTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy50aWVyU2VsZWN0aW9uV3JhcExpc3RlbmVycyA9IFtdO1xuXG4gICAgdGhpcy5jb29raWVLZXkgPSAnYnJvd3Nlcic7XG5cbiAgICB0aGlzLmNoYWlucyA9IHt9O1xuXG4gICAgdGhpcy5wYWdlTmFtZSA9ICdzdmdIb2xkZXInXG4gICAgdGhpcy56b29tRmFjdG9yID0gMS4wO1xuICAgIHRoaXMubWF4UGl4ZWxzUGVyQmFzZSA9IDEwO1xuICAgIHRoaXMub3JpZ2luID0gMDtcbiAgICB0aGlzLnRhcmdldFF1YW50UmVzID0gMS4wO1xuICAgIHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggPSA3NTA7XG4gICAgdGhpcy56b29tQmFzZSA9IDEwMDtcbiAgICB0aGlzLnpvb21FeHB0ID0gMzAuMDsgLy8gQmFjayB0byBiZWluZyBmaXhlZC4uLi5cbiAgICB0aGlzLnpvb21TbGlkZXJWYWx1ZSA9IDEwMDtcbiAgICB0aGlzLmVudHJ5UG9pbnRzID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRTZXFNYXggPSAtMTsgLy8gaW5pdCBvbmNlIEVQcyBhcmUgZmV0Y2hlZC5cblxuICAgIHRoaXMuaGlnaGxpZ2h0cyA9IFtdO1xuICAgIHRoaXMuc2VsZWN0ZWRUaWVycyA9IFsxXTtcblxuICAgIHRoaXMubWF4Vmlld1dpZHRoID0gNTAwMDAwO1xuICAgIHRoaXMuZGVmYXVsdFN1YnRpZXJNYXggPSAxMDA7XG5cbiAgICB0aGlzLmhpZ2hab29tVGhyZXNob2xkID0gMC4yO1xuICAgIHRoaXMubWVkaXVtWm9vbVRocmVzaG9sZCA9IDAuMDFcblxuICAgIHRoaXMubWluRXh0cmFXaWR0aCA9IDEwMC4wO1xuICAgIHRoaXMubWF4RXh0cmFXaWR0aCA9IDEwMDAuMDtcblxuICAgIC8vIE9wdGlvbnMuXG5cbiAgICB0aGlzLnJldmVyc2VTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJ1bGVyTG9jYXRpb24gPSAnY2VudGVyJztcbiAgICB0aGlzLmRlZmF1bHRIaWdobGlnaHRGaWxsID0gJ3JlZCc7XG4gICAgdGhpcy5kZWZhdWx0SGlnaGxpZ2h0QWxwaGEgPSAwLjM7XG4gICAgdGhpcy5leHBvcnRIaWdobGlnaHRzID0gdHJ1ZTtcbiAgICB0aGlzLmV4cG9ydFJ1bGVyID0gdHJ1ZTtcbiAgICB0aGlzLmV4cG9ydEJhbm5lciA9IHRydWU7XG4gICAgdGhpcy5leHBvcnRSZWdpb24gPSB0cnVlO1xuICAgIHRoaXMuc2luZ2xlQmFzZUhpZ2hsaWdodCA9IHRydWU7XG5cbiAgICAvLyBWaXN1YWwgY29uZmlnLlxuXG4gICAgLy8gdGhpcy50aWVyQmFja2dyb3VuZENvbG9ycyA9IFtcInJnYigyNDUsMjQ1LDI0NSlcIiwgXCJyZ2IoMjMwLDIzMCwyNTApXCIgLyogJ3doaXRlJyAqL107XG4gICAgdGhpcy50aWVyQmFja2dyb3VuZENvbG9ycyA9IFtcInJnYigyNDUsMjQ1LDI0NSlcIiwgJ3doaXRlJ107XG4gICAgdGhpcy5taW5UaWVySGVpZ2h0ID0gMjA7XG4gICAgdGhpcy5ub0RlZmF1bHRMYWJlbHMgPSBmYWxzZTtcblxuICAgIC8vIFJlZ2lzdHJ5XG5cbiAgICB0aGlzLmF2YWlsYWJsZVNvdXJjZXMgPSBuZXcgT2JzZXJ2ZWQoKTtcbiAgICB0aGlzLmRlZmF1bHRTb3VyY2VzID0gW107XG4gICAgdGhpcy5tYXBwYWJsZVNvdXJjZXMgPSB7fTtcblxuICAgIC8vIENlbnRyYWwgREFTIFJlZ2lzdHJ5IG5vIGxvbmdlciBhdmFpbGFibGUgMjAxNS0wNVxuXG4gICAgdGhpcy5yZWdpc3RyeSA9IG51bGw7IC8vICcvL3d3dy5kYXNyZWdpc3RyeS5vcmcvZGFzL3NvdXJjZXMnO1xuICAgIHRoaXMubm9SZWdpc3RyeVRhYnMgPSB0cnVlO1xuXG4gICAgdGhpcy5odWJzID0gW107XG4gICAgdGhpcy5odWJPYmplY3RzID0gW107XG5cbiAgICB0aGlzLnNvdXJjZUNhY2hlID0gbmV3IFNvdXJjZUNhY2hlKCk7XG5cbiAgICB0aGlzLnJldGluYSA9IHRydWU7XG5cbiAgICB0aGlzLnVzZUZldGNoV29ya2VycyA9IHRydWU7XG4gICAgdGhpcy5tYXhXb3JrZXJzID0gMjtcbiAgICB0aGlzLndvcmtlclBhdGggPSAnJCQnKyB0aGlzLndvcmtlclByZWZpeCArJ3dvcmtlci1hbGwuanMnO1xuICAgIHRoaXMucmVzb2x2ZXJzID0ge307XG4gICAgdGhpcy5yZXNvbHZlclNlZWQgPSAxO1xuXG4gICAgdGhpcy5hc3NlbWJseU5hbWVQcmltYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLmFzc2VtYmx5TmFtZVVjc2MgPSB0cnVlO1xuXG4gICAgdGhpcy5kZWZhdWx0U2VhcmNoUmVnaW9uUGFkZGluZyA9IDEwMDAwO1xuXG4gICAgLy8gSFRUUCB3YXJuaW5nIHN1cHBvcnRcblxuICAgIHRoaXMuaHR0cENhbmFyeVVSTCA9ICdodHRwOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvaHR0cC1jYW5hcnkudHh0JztcbiAgICB0aGlzLmh0dHBXYXJuaW5nVVJMID0gJy8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvaHR0cHMuaHRtbCc7XG5cbiAgICB0aGlzLmluaXRMaXN0ZW5lcnMgPSBbXTtcblxuICAgIGlmIChvcHRzLmJhc2VDb2xvcnMpIHtcbiAgICAgICAgdGhpcy5iYXNlQ29sb3JzID0gb3B0cy5iYXNlQ29sb3JzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXNlQ29sb3JzID0ge1xuICAgICAgICAgICAgQTogJ2dyZWVuJyxcbiAgICAgICAgICAgIEM6ICdibHVlJyxcbiAgICAgICAgICAgIEc6ICdvcmFuZ2UnLFxuICAgICAgICAgICAgVDogJ3JlZCcsXG4gICAgICAgICAgICAnLScgOiAnaG90cGluaycsIC8vIGRlbGV0aW9uXG4gICAgICAgICAgICAnSScgOiAncmVkJyAvLyBpbnNlcnRpb25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy52aWV3U3RhcnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Yob3B0cy52aWV3U3RhcnQpICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcigndmlld1N0YXJ0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cbiAgICBpZiAob3B0cy52aWV3RW5kICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mKG9wdHMudmlld0VuZCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IEVycm9yKCd2aWV3RW5kIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cbiAgICBpZiAob3B0cy5vZmZzY3JlZW5Jbml0V2lkdGggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Yob3B0cy5vZmZzY3JlZW5Jbml0V2lkdGgpICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignb2Zmc2NyZWVuSW5pdFdpZHRoIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gb3B0cykge1xuICAgICAgICB0aGlzW2tdID0gb3B0c1trXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKG9wdHMudWlQcmVmaXgpID09PSAnc3RyaW5nJyAmJiB0eXBlb2Yob3B0cy5wcmVmaXgpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnByZWZpeCA9IG9wdHMudWlQcmVmaXg7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwcmVmaXggb25seSBzdGFydHMgd2l0aCBhIHNpbmdsZSAnLycgdGhpcyBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgIC8vIHNpdGUsIHNvIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBwcmVmaXggd2l0aCAvL3tob3N0bmFtZX1cbiAgICBpZiAodGhpcy5wcmVmaXguaW5kZXhPZignLy8nKSA8IDAgJiYgdGhpcy5wcmVmaXguaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wb3J0KSB7XG4gICAgICAgICAgICBsb2NhdGlvbiArPSAnOicgKyB3aW5kb3cubG9jYXRpb24ucG9ydFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByZWZpeCA9ICcvLycgKyBsb2NhdGlvbiArIHRoaXMucHJlZml4O1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmVmaXguaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgICB2YXIgcHJvdG8gPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgIGlmIChwcm90byA9PSAnaHR0cDonIHx8IHByb3RvID09ICdodHRwczonKSB7XG4gICAgICAgICAgICAvLyBQcm90b2NvbC1yZWxhdGl2ZSBVUkxzIG9rYXkuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IHByZWZpeCBpcyBzZXQgdG8gYSBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKCcgKyB0aGlzLnByZWZpeCArICcgd2hlbiBsb2FkaW5nIGZyb20gYSBub24tSFRUUCBzb3VyY2UnKTtcbiAgICAgICAgICAgIHRoaXMucHJlZml4ID0gJ2h0dHA6JyArIHRoaXMucHJlZml4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvb3JkU3lzdGVtKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdDb29yZGluYXRlIHN5c3RlbSBtdXN0IGJlIGNvbmZpZ3VyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jaHIgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZpZXdTdGFydCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmlld0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdWaWV3ZWQgcmVnaW9uIChjaHI6c3RhcnQuLmVuZCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIHRoaXNCLnJlYWxJbml0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpc0IucmVhbEluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVzb2x2ZVVSTCA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgnJCQnLCB0aGlzLnByZWZpeCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVMaXN0ZW5lciwgZmFsc2UpO1xuICAgIGlmICh0aGlzLmZldGNoV29ya2Vycykge1xuICAgICAgICBmb3IgKGNvbnN0IHdvcmtlciBvZiB0aGlzLmZldGNoV29ya2Vycykge1xuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZWFsSW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMud2FzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcGluZyB0byBjYWxsIHJlYWxJbml0IG9uIGFuIGFscmVhZHktaW5pdGlhbGl6ZWQgRGFsbGlhbmNlIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndhc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YobmF2aWdhdG9yKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnZHVtbXknO1xuICAgICAgICBpZiAodWEuaW5kZXhPZignVHJpZGVudCcpID49IDAgJiYgdWEuaW5kZXhPZigncnY6MTEnKSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRGV0ZWN0ZWQgSUUxMSwgZGlzYWJsaW5nIHRpZXIgcGlubmluZy4nKTtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZVBpbm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kZWZhdWx0Q2hyID0gdGhpcy5jaHI7XG4gICAgdGhpcy5kZWZhdWx0U3RhcnQgPSB0aGlzLnZpZXdTdGFydDtcbiAgICB0aGlzLmRlZmF1bHRFbmQgPSB0aGlzLnZpZXdFbmQ7XG4gICAgdGhpcy5kZWZhdWx0U291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zb3VyY2VzW2ldO1xuICAgICAgICBpZiAocylcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNvdXJjZXMucHVzaChzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXN0b3JlU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzUmVzdG9yZWQgPSB0aGlzLnJlc3RvcmVTdGF0dXMoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmplY3Rpb25Qb2ludCAmJiB0aGlzLmluamVjdGlvblBvaW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB0aGlzLmJyb3dzZXJIb2xkZXJIb2xkZXIgPSB0aGlzLmluamVjdGlvblBvaW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbmplY3Rpb25Qb2ludCkge1xuICAgICAgICB0aGlzLmJyb3dzZXJIb2xkZXJIb2xkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmluamVjdGlvblBvaW50KTtcbiAgICAgICAgaWYgKCF0aGlzLmJyb3dzZXJIb2xkZXJIb2xkZXIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdpbmplY3Rpb25Qb2ludCBtdXN0IHBvaW50IHRvIGEgdmFsaWQgRE9NIGVsZW1lbnQgb2YgZWxlbWVudCBJRCcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5icm93c2VySG9sZGVySG9sZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5wYWdlTmFtZSk7XG4gICAgICAgIGlmICghdGhpcy5icm93c2VySG9sZGVySG9sZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigncGFnZU5hbWUgbXVzdCBiZSBhIHZhbGlkIGVsZW1lbnQgSUQgKG9yIHVzZSB0aGUgaW5qZWN0aW9uUG9pbnQgb3B0aW9uIGluc3RlYWQpJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJyb3dzZXJIb2xkZXJIb2xkZXIuY2xhc3NMaXN0LmFkZCgnZGFsbGlhbmNlLWluamVjdGlvbi1wb2ludCcpO1xuICAgIHRoaXMuYnJvd3NlckhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnLCBudWxsLCB7Y2xhc3NOYW1lOiAnZGFsbGlhbmNlIGRhbGxpYW5jZS1yb290JywgdGFiSW5kZXg6IC0xfSk7XG4gICAgaWYgKHRoaXMubWF4SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuYnJvd3NlckhvbGRlci5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCArICdweCc7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heEhlaWdodCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5icm93c2VySG9sZGVyLnN0eWxlLm1heEhlaWdodCA9IG51bGw7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMuYnJvd3NlckhvbGRlckhvbGRlcik7XG4gICAgdGhpcy5icm93c2VySG9sZGVySG9sZGVyLmFwcGVuZENoaWxkKHRoaXMuYnJvd3NlckhvbGRlcik7XG4gICAgdGhpcy5zdmdIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ21haW4taG9sZGVyJ30pO1xuXG4gICAgdGhpcy5pbml0VUkodGhpcy5icm93c2VySG9sZGVyLCB0aGlzLnN2Z0hvbGRlcik7XG5cbiAgICB0aGlzLnBpbm5lZFRpZXJIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ3RpZXItaG9sZGVyIHRpZXItaG9sZGVyLXBpbm5lZCd9KTtcbiAgICB0aGlzLnRpZXJIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgdGhpcy5tYWtlTG9hZGVyKDI0KSwge2NsYXNzTmFtZTogJ3RpZXItaG9sZGVyIHRpZXItaG9sZGVyLXJlc3QnfSk7XG5cbiAgICB0aGlzLmxvY1NpbmdsZUJhc2UgPSBtYWtlRWxlbWVudCgnc3BhbicsICcnLCB7Y2xhc3NOYW1lOiAnbG9jLXNpbmdsZS1iYXNlJ30pO1xuICAgIHZhciBsb2NTaW5nbGVCYXNlSG9sZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIHRoaXMubG9jU2luZ2xlQmFzZSx7Y2xhc3NOYW1lOiAnbG9jLXNpbmdsZS1iYXNlLWhvbGRlcid9KTtcbiAgICAvLyBBZGQgbGlzdGVuZXIgdG8gdXBkYXRlIHNpbmdsZSBiYXNlIGxvY2F0aW9uXG4gICAgdGhpcy5hZGRWaWV3TGlzdGVuZXIoZnVuY3Rpb24oY2hyLCBtaW5GbG9vciwgbWF4Rmxvb3IsIHpvb21TbGlkZXJWYWx1ZSwgem9vbVNsaWRlckRpY3QsIG1pbiwgbWF4KSB7XG4gICAgICAgIC8vIEp1c3Qgc2V0dGluZyB0ZXh0Q29udGVudCBjYXVzZXMgbGF5b3V0IGZsaWNrZXJpbmcgaW4gQmxpbmsuXG4gICAgICAgIC8vIFRoaXMgYXBwcm9hY2ggbWVhbnMgdGhhdCB0aGUgZWxlbWVudCBpcyBuZXZlciBlbXB0eS5cbiAgICAgICAgdmFyIGxvYyA9IE1hdGgucm91bmQoKG1heCArIG1pbikgLyAyKTtcbiAgICAgICAgc2VsZi5sb2NTaW5nbGVCYXNlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNociArICc6JyArIGZvcm1hdExvbmdJbnQobG9jKSkpO1xuICAgICAgICBzZWxmLmxvY1NpbmdsZUJhc2UucmVtb3ZlQ2hpbGQoc2VsZi5sb2NTaW5nbGVCYXNlLmZpcnN0Q2hpbGQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZGlzYWJsZVBpbm5pbmcpIHtcbiAgICAgICAgdGhpcy50aWVySG9sZGVySG9sZGVyID0gdGhpcy50aWVySG9sZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGllckhvbGRlckhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnLCBbbG9jU2luZ2xlQmFzZUhvbGRlciwgdGhpcy5waW5uZWRUaWVySG9sZGVyLCB0aGlzLnRpZXJIb2xkZXJdLCB7Y2xhc3NOYW1lOiAndGllci1ob2xkZXItaG9sZGVyJ30pO1xuICAgICAgICB0aGlzLnN2Z0hvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnRpZXJIb2xkZXJIb2xkZXIpO1xuICAgIH1cbiAgICB0aGlzLnN2Z0hvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnRpZXJIb2xkZXJIb2xkZXIpO1xuXG4gICAgdGhpcy5iaHRtbFJvb3QgPSBtYWtlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVQb3dlcmVkQnkpIHtcbiAgICAgICAgdGhpcy5iaHRtbFJvb3QuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3NwYW4nLCBbJ1Bvd2VyZWQgYnkgJywgbWFrZUVsZW1lbnQoJ2EnLCAnQmlvZGFsbGlhbmNlJywge2hyZWY6ICdodHRwOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvJ30pLCAnICcgKyBWRVJTSU9OXSwge2NsYXNzTmFtZTogJ3Bvd2VyZWQtYnknfSkpO1xuICAgIH1cbiAgICB0aGlzLmJyb3dzZXJIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5iaHRtbFJvb3QpO1xuXG4gICAgdGhpcy5yZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHRoaXNCLnJlc2l6ZVZpZXdlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLnJ1bGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICdndWlkZWxpbmUnfSlcbiAgICB0aGlzLnJ1bGVyMiA9IG1ha2VFbGVtZW50KCdkaXYnLCBudWxsLCB7Y2xhc3NOYW1lOiAnc2luZ2xlLWJhc2UtZ3VpZGVsaW5lJ30pO1xuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnJ1bGVyKTtcbiAgICB0aGlzLnRpZXJIb2xkZXJIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5ydWxlcjIpO1xuICAgIHRoaXMuY2hhaW5Db25maWdzID0gdGhpcy5jaGFpbnMgfHwge307XG4gICAgdGhpcy5jaGFpbnMgPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIHRoaXMuY2hhaW5Db25maWdzKSB7XG4gICAgICAgIHZhciBjYyA9IHRoaXMuY2hhaW5Db25maWdzW2tdO1xuICAgICAgICBpZiAoY2MgaW5zdGFuY2VvZiBDaGFpbnNldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IFNob3VsZCBubyBsb25nZXIgdXNlIFwibmV3IENoYWluc2V0XCIgaW4gQmlvZGFsbGlhbmNlIGNvbmZpZ3VyYXRpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhaW5zW2tdID0gbmV3IENoYWluc2V0KGNjKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZWRXb3JrZXJzO1xuICAgIGlmICh0aGlzLm1heFdvcmtlcnMgPiAwKSB7XG4gICAgICAgIHZhciBwdyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgdGhpcy5tYXhXb3JrZXJzOyArK2ZpKVxuICAgICAgICAgICAgcHcucHVzaChtYWtlRmV0Y2hXb3JrZXIodGhpcykpO1xuICAgICAgICBwcm9taXNlZFdvcmtlcnMgPSBQcm9taXNlLmFsbChwdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZWRXb3JrZXJzID0gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoV29ya2VycyA9IG51bGw7XG4gICAgdGhpcy5uZXh0V29ya2VyID0gMDtcbiAgICBwcm9taXNlZFdvcmtlcnMudGhlbihmdW5jdGlvbih2KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdCb290ZWQgJyArIHYubGVuZ3RoICsgJyB3b3JrZXJzJyk7XG4gICAgICAgIHRoaXNCLmZldGNoV29ya2VycyA9IHY7XG4gICAgfSwgZnVuY3Rpb24odikge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGJvb3Qgd29ya2VycycsIHYpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLm9mZnNjcmVlbkluaXRXaWR0aCB8fCAod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpc0IuYnJvd3NlckhvbGRlckhvbGRlcikuZGlzcGxheSAhPSAnbm9uZScgJiZcbiAgICAgICAgICAgIHRoaXNCLnRpZXJIb2xkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPiAwKSlcbiAgICAgICAge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHt0aGlzQi5yZWFsSW5pdDIoKX0sIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzQi5icm93c2VySG9sZGVySG9sZGVyKS5kaXNwbGF5ICE9ICdub25lJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzQi50aWVySG9sZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID4gMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IucmVhbEluaXQyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZWFsSW5pdDIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBsb2FkZXIgaWNvbiwgaWYgbmVlZGVkXG4gICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy50aWVySG9sZGVyKTtcbiAgICByZW1vdmVDaGlsZHJlbih0aGlzLnBpbm5lZFRpZXJIb2xkZXIpO1xuXG4gICAgdGhpcy5mZWF0dXJlUGFuZWxXaWR0aCA9IHRoaXMudGllckhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8IHRoaXNCLm9mZnNjcmVlbkluaXRXaWR0aCB8IDA7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplTGlzdGVuZXIsIGZhbHNlKTtcblxuICAgIHRoaXMuc2NhbGUgPSB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoIC8gKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KTtcbiAgICBpZiAoIXRoaXMuem9vbU1heCkge1xuICAgICAgICB0aGlzLnpvb21NYXggPSB0aGlzLnpvb21FeHB0ICogTWF0aC5sb2codGhpcy5tYXhWaWV3V2lkdGggLyB0aGlzLnpvb21CYXNlKTtcbiAgICAgICAgdGhpcy56b29tTWluID0gdGhpcy56b29tRXhwdCAqIE1hdGgubG9nKHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggLyB0aGlzLm1heFBpeGVsc1BlckJhc2UgLyB0aGlzLnpvb21CYXNlKTtcbiAgICB9XG4gICAgdGhpcy56b29tU2xpZGVyVmFsdWUgPSB0aGlzLnpvb21FeHB0ICogTWF0aC5sb2coKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMSkgLyB0aGlzLnpvb21CYXNlKTtcblxuICAgIC8vIEV2ZW50IGhhbmRsZXJzXG5cbiAgICB0aGlzLnRpZXJIb2xkZXJIb2xkZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChldi53aGVlbERlbHRhWCkge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZXYud2hlZWxEZWx0YVgvNTtcbiAgICAgICAgICAgIGlmICghdGhpc0IucmV2ZXJzZVNjcm9sbGluZykge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc0IubW92ZShkZWx0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXYud2hlZWxEZWx0YVkpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGV2LndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgaWYgKHRoaXNCLnJldmVyc2VTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNCLnRpZXJIb2xkZXIuc2Nyb2xsVG9wICs9IGRlbHRhO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGhpcy50aWVySG9sZGVySG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGV2LmF4aXMgPT0gMSkge1xuICAgICAgICAgICAgaWYgKGV2LmRldGFpbCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZXYuZGV0YWlsLzQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLnJldmVyc2VTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNCLm1vdmUoZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZXYuZGV0YWlsO1xuICAgICAgICAgICAgaWYgKCF0aGlzQi5yZXZlcnNlU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzQi50aWVySG9sZGVyLnNjcm9sbFRvcCArPSBkZWx0YTtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXYpIHtyZXR1cm4gdGhpc0IudG91Y2hTdGFydEhhbmRsZXIoZXYpfSwgZmFsc2UpO1xuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbihldikge3JldHVybiB0aGlzQi50b3VjaE1vdmVIYW5kbGVyKGV2KX0sIGZhbHNlKTtcbiAgICB0aGlzLnRpZXJIb2xkZXJIb2xkZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbihldikge3JldHVybiB0aGlzQi50b3VjaEVuZEhhbmRsZXIoZXYpfSwgZmFsc2UpO1xuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uKGV2KSB7cmV0dXJuIHRoaXNCLnRvdWNoQ2FuY2VsSGFuZGxlcihldil9LCBmYWxzZSk7XG5cbiAgICB2YXIga2V5SGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYmtoOiAnICsgZXYua2V5Q29kZSk7XG4gICAgICAgIGlmIChldi5rZXlDb2RlID09IDEzKSB7IC8vIGVudGVyXG4gICAgICAgICAgICB2YXIgbGF5b3V0c0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzQi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXNCLnRpZXJzW3RpXTtcbiAgICAgICAgICAgICAgICBpZiAodC53YW50ZWRMYXlvdXRIZWlnaHQgJiYgdC53YW50ZWRMYXlvdXRIZWlnaHQgIT0gdC5sYXlvdXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5sYXlvdXRIZWlnaHQgPSB0LndhbnRlZExheW91dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdC5jbGlwVGllcigpO1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IuYXJyYW5nZVRpZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSAzMiB8fCBldi5jaGFyQ29kZSA9PSAzMikgeyAvLyBzcGFjZVxuICAgICAgICAgICAgaWYgKCF0aGlzQi5pc1NuYXBab29taW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IuaXNTbmFwWm9vbWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1pvb20gPSAodGhpc0Iuc2F2ZWRab29tIHx8IDAuMCkgKyB0aGlzQi56b29tTWluO1xuICAgICAgICAgICAgICAgIHRoaXNCLnNhdmVkWm9vbSA9IHRoaXNCLnpvb21TbGlkZXJWYWx1ZSAtIHRoaXNCLnpvb21NaW47XG4gICAgICAgICAgICAgICAgdGhpc0Iuem9vbVNsaWRlclZhbHVlID0gbmV3Wm9vbTtcbiAgICAgICAgICAgICAgICB0aGlzQi56b29tKE1hdGguZXhwKCgxLjAgKiBuZXdab29tKSAvIHRoaXNCLnpvb21FeHB0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNCLmlzU25hcFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Wm9vbSA9ICh0aGlzQi5zYXZlZFpvb20gfHwgMjAuMCkgKyB0aGlzQi56b29tTWluO1xuICAgICAgICAgICAgICAgIHRoaXNCLnNhdmVkWm9vbSA9IHRoaXNCLnpvb21TbGlkZXJWYWx1ZSAtIHRoaXNCLnpvb21NaW47XG4gICAgICAgICAgICAgICAgdGhpc0Iuem9vbVNsaWRlclZhbHVlID0gbmV3Wm9vbTtcbiAgICAgICAgICAgICAgICB0aGlzQi56b29tKE1hdGguZXhwKCgxLjAgKiBuZXdab29tKSAvIHRoaXNCLnpvb21FeHB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDg1KSB7IC8vIHVcbiAgICAgICAgICAgIGlmICh0aGlzQi51aU1vZGUgPT09ICdvcHRzJykgeyAvLyBpZiB0aGUgb3B0aW9ucyBhcmUgdmlzaWJsZSwgdG9nZ2xlIHRoZSBjaGVja2JveCB0b29cbiAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpbmdsZUJhc2VIaWdodGxpZ2h0QnV0dG9uXCIpLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaW5nbGVCYXNlSGlnaHRsaWdodEJ1dHRvblwiKS5jaGVja2VkID0gIWNoZWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc0Iuc2luZ2xlQmFzZUhpZ2hsaWdodCA9ICF0aGlzQi5zaW5nbGVCYXNlSGlnaGxpZ2h0O1xuICAgICAgICAgICAgdGhpc0IucG9zaXRpb25SdWxlcigpO1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSAzOSkgeyAvLyByaWdodCBhcnJvd1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzQi5zY3JvbGxBcnJvd0tleShldiwgLTEpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gMzcpIHsgLy8gbGVmdCBhcnJvd1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzQi5zY3JvbGxBcnJvd0tleShldiwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSAzOCB8fCBldi5rZXlDb2RlID09IDg3KSB7IC8vIHVwIGFycm93IHwgd1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdHQgPSB0aGlzQi50aWVyc1tzdF07XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gdHQuZm9yY2VIZWlnaHQgfHwgdHQuc3VidGllcnNbMF0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChjaCA+PSA0MCkge1xuICAgICAgICAgICAgICAgICAgICB0dC5tZXJnZUNvbmZpZyh7aGVpZ2h0OiBjaC0xMH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0IDwgMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciB0dCA9IHRoaXNCLnRpZXJzW3N0XTtcblxuICAgICAgICAgICAgICAgIGlmICh0dC5xdWFudExlYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoID0gdHQuc3VidGllcnNbMF0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHEgPSB0dC5zdWJ0aWVyc1swXS5xdWFudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcW1pbiA9IDEuMCAqIHRxLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHFtYXggPSAxLjAgKiB0cS5tYXg7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHFzY2FsZSA9IChxbWF4IC0gcW1pbikgLyB0aDtcbiAgICAgICAgICAgICAgICAgICAgdHQubWVyZ2VDb25maWcoe3F1YW50TGVhcFRocmVzaG9sZDogcW1pbiArICgoTWF0aC5yb3VuZCgodHQucXVhbnRMZWFwVGhyZXNob2xkIC0gcW1pbikvcXNjYWxlKXwwKSsxKSpxc2NhbGV9KTtcblxuICAgICAgICAgICAgICAgICAgICB0dC5ub3RpZnkoJ1RocmVzaG9sZDogJyArIGZvcm1hdFF1YW50TGFiZWwodHQucXVhbnRMZWFwVGhyZXNob2xkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChldi5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY250ID0gdGhpc0Iuc2VsZWN0ZWRUaWVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNudCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgc3QgPSB0aGlzQi5zZWxlY3RlZFRpZXJzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjb250aWd1b3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgdGhpc0Iuc2VsZWN0ZWRUaWVycy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbXQucHVzaCh0aGlzQi50aWVyc1t0aGlzQi5zZWxlY3RlZFRpZXJzW3NpXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2kgPiAwICYmIHRoaXNCLnNlbGVjdGVkVGllcnNbc2ldIC0gdGhpc0Iuc2VsZWN0ZWRUaWVyc1tzaSAtIDFdICE9IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aWd1b3VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgc3QgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSB0aGlzQi5zZWxlY3RlZFRpZXJzLmxlbmd0aCAtIDE7IHNpID49IDA7IC0tc2kpXG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnRpZXJzLnNwbGljZSh0aGlzQi5zZWxlY3RlZFRpZXJzW3NpXSwgMSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzQi5zZWxlY3RlZFRpZXJzLnNwbGljZSgwLCBjbnQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlwID0gY29udGlndW91cyA/IHN0IC0gMSA6IHN0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBtdC5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllcnMuc3BsaWNlKGlwK3NpLCAwLCBtdFtzaV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5zZWxlY3RlZFRpZXJzLnB1c2goaXAgKyBzaSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpc0Iud2l0aFByZXNlcnZlZFNlbGVjdGlvbih0aGlzQi5fZW5zdXJlVGllcnNHcm91cGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzQi5tYXJrU2VsZWN0ZWRUaWVycygpO1xuICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeVRpZXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzQi5yZW9yZGVyVGllcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzQi5ub3RpZnlUaWVyKFwic2VsZWN0ZWRcIiwgc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3QgPSB0aGlzQi5nZXRTZWxlY3RlZFRpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNldFNlbGVjdGVkVGllcihzdCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnN0ID0gdGhpc0IudGllcnNbdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gbnN0LnJvdy5vZmZzZXRUb3AsIGJvdHRvbSA9IHRvcCArIG5zdC5yb3cub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wIDwgdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgfHwgYm90dG9tID4gdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgKyB0aGlzQi50aWVySG9sZGVyLm9mZnNldEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5ub3RpZnlUaWVyU2VsZWN0aW9uV3JhcCgtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gNDAgfHwgZXYua2V5Q29kZSA9PSA4MykgeyAvLyBkb3duIGFycm93IHwgc1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdHQgPSB0aGlzQi50aWVyc1tzdF07XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gdHQuZm9yY2VIZWlnaHQgfHwgdHQuc3VidGllcnNbMF0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHR0Lm1lcmdlQ29uZmlnKHtoZWlnaHQ6IGNoKzEwfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdHQgPSB0aGlzQi50aWVyc1tzdF07XG5cbiAgICAgICAgICAgICAgICBpZiAodHQucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aCA9IHR0LnN1YnRpZXJzWzBdLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRxID0gdHQuc3VidGllcnNbMF0ucXVhbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHFtaW4gPSAxLjAgKiB0cS5taW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBxbWF4ID0gMS4wICogdHEubWF4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXNjYWxlID0gKHFtYXggLSBxbWluKSAvIHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdCA9IE1hdGgucm91bmQoKHR0LnF1YW50TGVhcFRocmVzaG9sZCAtIHFtaW4pL3FzY2FsZSl8MDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHQubWVyZ2VDb25maWcoe3F1YW50TGVhcFRocmVzaG9sZDogcW1pbiArIChpdC0xKSpxc2NhbGV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0Lm5vdGlmeSgnVGhyZXNob2xkOiAnICsgZm9ybWF0UXVhbnRMYWJlbCh0dC5xdWFudExlYXBUaHJlc2hvbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXYuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNudCA9IHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjbnQgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0Iuc2VsZWN0ZWRUaWVyc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY29udGlnID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgdGhpc0Iuc2VsZWN0ZWRUaWVycy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbXQucHVzaCh0aGlzQi50aWVyc1t0aGlzQi5zZWxlY3RlZFRpZXJzW3NpXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2kgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzY29udGlnICs9ICh0aGlzQi5zZWxlY3RlZFRpZXJzW3NpXSAtIHRoaXNCLnNlbGVjdGVkVGllcnNbc2kgLSAxXSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGlndW91cyA9IGRpc2NvbnRpZyA9PSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgc3QgKyBjbnQgPj0gdGhpc0IudGllcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoIC0gMTsgc2kgPj0gMDsgLS1zaSlcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllcnMuc3BsaWNlKHRoaXNCLnNlbGVjdGVkVGllcnNbc2ldLCAxKTtcblxuICAgICAgICAgICAgICAgIHRoaXNCLnNlbGVjdGVkVGllcnMuc3BsaWNlKDAsIGNudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXAgPSBjb250aWd1b3VzID8gc3QgKyAxIDogc3QgKyBkaXNjb250aWc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IG10Lmxlbmd0aDsgKytzaSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi50aWVycy5zcGxpY2UoaXArc2ksIDAsIG10W3NpXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNlbGVjdGVkVGllcnMucHVzaChpcCArIHNpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzQi53aXRoUHJlc2VydmVkU2VsZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5fZW5zdXJlVGllcnNHcm91cGVkKHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXNCLm1hcmtTZWxlY3RlZFRpZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXNCLnJlb3JkZXJUaWVycygpO1xuICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeVRpZXIoXCJzZWxlY3RlZFwiLCBzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IHRoaXNCLnRpZXJzLmxlbmd0aCAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5zZXRTZWxlY3RlZFRpZXIoc3QgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5zdCA9IHRoaXNCLnRpZXJzW3RoaXNCLmdldFNlbGVjdGVkVGllcigpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9IG5zdC5yb3cub2Zmc2V0VG9wLCBib3R0b20gPSB0b3AgKyBuc3Qucm93Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCA8IHRoaXNCLnRpZXJIb2xkZXIuc2Nyb2xsVG9wIHx8IGJvdHRvbSA+IHRoaXNCLnRpZXJIb2xkZXIuc2Nyb2xsVG9wICsgdGhpc0IudGllckhvbGRlci5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnRpZXJIb2xkZXIuc2Nyb2xsVG9wID0gTWF0aC5taW4odG9wLCBib3R0b20gLSB0aGlzQi50aWVySG9sZGVyLm9mZnNldEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSAxODcgfHwgZXYua2V5Q29kZSA9PSA2MSkgeyAvLyArXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXNCLnpvb21TdGVwKC0xMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSAxODkgfHwgZXYua2V5Q29kZSA9PSAxNzMpIHsgLy8gLVxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzQi56b29tU3RlcCgxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSA3MyB8fCBldi5rZXlDb2RlID09IDEwNSkgeyAvLyBpXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgaWYgKHN0IDwgMCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzQi50aWVyc1tzdF07XG4gICAgICAgICAgICBpZiAoIXQuaW5mb1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB0LmluZm9FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHQudXBkYXRlSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdC5pbmZvVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHQuaW5mb0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0LnVwZGF0ZUhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHQuaW5mb1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDg0IHx8IGV2LmtleUNvZGUgPT0gMTE2KSB7IC8vIHRcbiAgICAgICAgICAgIHZhciBidW1wU3RhdHVzO1xuICAgICAgICAgICAgaWYoIGV2LnNoaWZ0S2V5ICl7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXNCLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXNCLnRpZXJzW3RpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidW1wU3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW1wU3RhdHVzID0gIXQuYnVtcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdC5tZXJnZUNvbmZpZyh7YnVtcGVkOiBidW1wU3RhdHVzfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0IDwgMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpc0IudGllcnNbc3RdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHQuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bXBTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVtcFN0YXR1cyA9ICF0LmJ1bXBlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0Lm1lcmdlQ29uZmlnKHtidW1wZWQ6IGJ1bXBTdGF0dXN9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSA3NyB8fCBldi5rZXlDb2RlID09IDEwOSkgeyAvLyBtXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmICgoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSAmJiB0aGlzQi5zZWxlY3RlZFRpZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzQi5tZXJnZVNlbGVjdGVkVGllcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDY4IHx8IGV2LmtleUNvZGUgPT0gMTAwKSB7IC8vIGRcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKHRoaXNCLnRpZXJzW3N0XS5kYXNTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gODAgfHwgZXYua2V5Q29kZSA9PSAxMTIpIHsgLy8gcFxuICAgICAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gYmUgY2FyZWZ1bCBiZWNhdXNlIG9yZGVyIG9mIHRpZXJzIGNvdWxkIGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIG9uY2Ugd2Ugc3RhcnQgdXBkYXRpbmcgcGlubmluZy5cbiAgICAgICAgICAgICAgICB2YXIgdHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzdCA9IDA7IHN0IDwgdGhpc0Iuc2VsZWN0ZWRUaWVycy5sZW5ndGg7ICsrc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHQucHVzaCh0aGlzQi50aWVyc1t0aGlzQi5zZWxlY3RlZFRpZXJzW3N0XV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdHQubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR0W3RpXS5tZXJnZUNvbmZpZyh7cGlubmVkOiAhdHRbdGldLnBpbm5lZH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdrZXk6ICcgKyBldi5rZXlDb2RlICsgJzsgY2hhcjogJyArIGV2LmNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmJyb3dzZXJIb2xkZXIuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbihldikge1xuICAgICAgICB0aGlzQi5icm93c2VySG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHRoaXMuYnJvd3NlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdGhpc0IuYnJvd3NlckhvbGRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5SGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIC8vIFBvcHVwIHN1cHBvcnQgKGRvZXMgdGhpcyByZWFsbHkgYmVsb25nIGhlcmU/IEZJWE1FKVxuICAgIHRoaXMuaFBvcHVwSG9sZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuaFBvcHVwSG9sZGVyLnN0eWxlWydmb250LWZhbWlseSddID0gJ2hlbHZldGljYSc7XG4gICAgdGhpcy5oUG9wdXBIb2xkZXIuc3R5bGVbJ2ZvbnQtc2l6ZSddID0gJzEycHQnO1xuICAgIHRoaXMuaFBvcHVwSG9sZGVyLmNsYXNzTGlzdC5hZGQoJ2RhbGxpYW5jZScpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5oUG9wdXBIb2xkZXIpO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK3QpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlc1t0XTtcbiAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICAgIGlmICh0aGlzLnJlc3RvcmVkQ29uZmlncykge1xuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5yZXN0b3JlZENvbmZpZ3NbdF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNvdXJjZS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5tYWtlVGllcihzb3VyY2UsIGNvbmZpZykudGhlbihmdW5jdGlvbih0aWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IucmVmcmVzaFRpZXIodGllcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9uRmlyc3RSZW5kZXIpIHtcbiAgICAgICAgUHJvbWlzZS5hbGwodGhpcy50aWVycy5tYXAodCA9PiB0LmZpcnN0UmVuZGVyUHJvbWlzZSkpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLm9uRmlyc3RSZW5kZXIoKSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICB0aGlzQi5fZW5zdXJlVGllcnNHcm91cGVkKCk7XG4gICAgdGhpc0IuYXJyYW5nZVRpZXJzKCk7XG4gICAgdGhpc0IucmVvcmRlclRpZXJzKCk7XG5cblxuICAgIHZhciBzcyA9IHRoaXMuZ2V0U2VxdWVuY2VTb3VyY2UoKTtcbiAgICBpZiAoc3MpIHtcbiAgICAgICAgc3MuZ2V0U2VxSW5mbyh0aGlzLmNociwgZnVuY3Rpb24oc2kpIHtcbiAgICAgICAgICAgIGlmIChzaSlcbiAgICAgICAgICAgICAgICB0aGlzQi5jdXJyZW50U2VxTWF4ID0gc2kubGVuZ3RoO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNCLmN1cnJlbnRTZXFNYXggPSAtMTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5xdWVyeVJlZ2lzdHJ5KCk7XG4gICAgZm9yICh2YXIgbSBpbiB0aGlzLmNoYWlucykge1xuICAgICAgICB0aGlzLnF1ZXJ5UmVnaXN0cnkobSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaHVicykge1xuICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpcy5odWJzLmxlbmd0aDsgKytoaSkge1xuICAgICAgICAgICAgdmFyIGhjID0gdGhpcy5odWJzW2hpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBoYyA9IHt1cmw6IGhjfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIChmdW5jdGlvbihoYykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RUcmFja0h1YihoYy51cmwsIGZ1bmN0aW9uKGh1YiwgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGRiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhjLmdlbm9tZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZGIgPSBodWIuZ2Vub21lc1toYy5nZW5vbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkYiA9IGh1Yi5nZW5vbWVzW3RoaXNCLmNvb3JkU3lzdGVtLnVjc2NOYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRkYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYy5tYXBwaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZGIubWFwcGluZyA9IGhjLm1hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhjLmxhYmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZGIuaHViLmFsdExhYmVsID0gaGMubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5odWJPYmplY3RzLnB1c2godGRiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhjKTtcbiAgICAgICAgICAgIH0pKGhjKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZ1bGxTY3JlZW4pIHtcbiAgICAgICAgdGhpcy5zZXRGdWxsU2NyZWVuSGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXR1c1Jlc3RvcmVkICYmIHRoaXMuc3RvcmVTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdG9yZVN0YXR1cygpO1xuICAgIH1cblxuICAgIHRoaXNCLnNldExvY2F0aW9uKHRoaXMuY2hyLCB0aGlzLnZpZXdTdGFydCwgdGhpcy52aWV3RW5kLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNCLnNldFNlbGVjdGVkVGllcigxKTtcbiAgICAgICAgLy8gUGluZyBhbnkgaW5pdCBsaXN0ZW5lcnMuXG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB0aGlzQi5pbml0TGlzdGVuZXJzLmxlbmd0aDsgKytpaSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzQi5pbml0TGlzdGVuZXJzW2lpXS5jYWxsKHRoaXNCKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vL1xuLy8gVG91Y2ggZXZlbnQgc3VwcG9ydFxuLy9cblxuQnJvd3Nlci5wcm90b3R5cGUudG91Y2hTdGFydEhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgIC8vIEV2ZW50cyBub3QgY29uc3VtZWQgc28gdGhleSBjYW4gYmUgaW50ZXJwcmV0dGVkIGFzIGNsaWNrcyBhcyB3ZWxsLlxuXG4gICAgdGhpcy50b3VjaE9yaWdpblggPSBldi50b3VjaGVzWzBdLnBhZ2VYO1xuICAgIHRoaXMudG91Y2hPcmlnaW5ZID0gZXYudG91Y2hlc1swXS5wYWdlWTtcbiAgICBpZiAoZXYudG91Y2hlcy5sZW5ndGggPT0gMikge1xuICAgICAgICB2YXIgc2VwID0gTWF0aC5hYnMoZXYudG91Y2hlc1swXS5wYWdlWCAtIGV2LnRvdWNoZXNbMV0ucGFnZVgpO1xuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnpvb21MYXN0U2VwID0gdGhpcy56b29tSW5pdGlhbFNlcCA9IHNlcDtcbiAgICAgICAgdGhpcy56b29tSW5pdGlhbFNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnRvdWNoTW92ZUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgIC8vIFRoZXNlIGV2ZW50cyAqYXJlKiBjb25zdW1lZCB0byBlbnN1cmUgd2UgbmV2ZXIgZ2V0IGFueSBkcmFnZ2luZyB0aGF0XG4gICAgLy8gd2UgZG9uJ3QgbWFuYWdlIG91cnNlbHZlcy5cblxuICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIHRvdWNoWCA9IGV2LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgIHZhciB0b3VjaFkgPSBldi50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICBpZiAodGhpcy50b3VjaE9yaWdpblggJiYgdG91Y2hYICE9IHRoaXMudG91Y2hPcmlnaW5YKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmUodG91Y2hYIC0gdGhpcy50b3VjaE9yaWdpblgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRvdWNoT3JpZ2luWSAmJiB0b3VjaFkgIT0gdGhpcy50b3VjaE9yaWdpblkpIHtcbiAgICAgICAgICAgIHRoaXMudGllckhvbGRlci5zY3JvbGxUb3AgLT0gKHRvdWNoWSAtIHRoaXMudG91Y2hPcmlnaW5ZKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoT3JpZ2luWCA9IHRvdWNoWDtcbiAgICAgICAgdGhpcy50b3VjaE9yaWdpblkgPSB0b3VjaFk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnpvb21pbmcgJiYgZXYudG91Y2hlcy5sZW5ndGggPT0gMikge1xuICAgICAgICB2YXIgc2VwID0gTWF0aC5hYnMoZXYudG91Y2hlc1swXS5wYWdlWCAtIGV2LnRvdWNoZXNbMV0ucGFnZVgpO1xuICAgICAgICBpZiAoc2VwICE9IHRoaXMuem9vbUxhc3RTZXApIHtcbiAgICAgICAgICAgIHZhciBjcCA9IChldi50b3VjaGVzWzBdLnBhZ2VYICsgZXYudG91Y2hlc1sxXS5wYWdlWCkvMjtcbiAgICAgICAgICAgIHZhciBzY3AgPSB0aGlzLnZpZXdTdGFydCArIChjcC90aGlzLnNjYWxlKXwwXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy56b29tSW5pdGlhbFNjYWxlICogKHNlcC90aGlzLnpvb21Jbml0aWFsU2VwKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXJ0ID0gc2NwIC0gKGNwL3RoaXMuc2NhbGUpfDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aWVyc1tpXS5nZXRSZW5kZXJlcigpLmRyYXdUaWVyKHRpZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpvb21MYXN0U2VwID0gc2VwO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUudG91Y2hFbmRIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUudG91Y2hDYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbn1cblxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYWtlVGllciA9IGZ1bmN0aW9uKHNvdXJjZSwgY29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbE1ha2VUaWVyKHNvdXJjZSwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBpbml0aWFsaXppbmcnLCBzb3VyY2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrIHx8IGUpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVhbE1ha2VUaWVyID0gZnVuY3Rpb24oc291cmNlLCBjb25maWcpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHZhciBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICBpZiAodGhpcy50aWVyQmFja2dyb3VuZENvbG9ycykge1xuICAgICAgICBiYWNrZ3JvdW5kID0gdGhpcy50aWVyQmFja2dyb3VuZENvbG9yc1t0aGlzLnRpZXJzLmxlbmd0aCAlIHRoaXMudGllckJhY2tncm91bmRDb2xvcnMubGVuZ3RoXTtcbiAgICB9XG5cbiAgICB2YXIgdGllciA9IG5ldyBEYXNUaWVyKHRoaXMsIHNvdXJjZSwgY29uZmlnLCBiYWNrZ3JvdW5kKTtcbiAgICB0aWVyLm9vcmlnaW4gPSB0aGlzLnZpZXdTdGFydFxuXG4gICAgdmFyIGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB2YXIgZHJhZ09yaWdpbiwgZHJhZ01vdmVPcmlnaW47XG4gICAgdmFyIGhvdmVyVGltZW91dDtcblxuICAgIHZhciBmZWF0dXJlTG9va3VwID0gZnVuY3Rpb24ocngsIHJ5KSB7XG4gICAgICAgIHZhciBzdCA9IHRpZXIuc3VidGllcnM7XG4gICAgICAgIGlmICghc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGkgPSAwO1xuICAgICAgICByeSAtPSB0aWVyLnBhZGRpbmc7O1xuICAgICAgICB3aGlsZSAoc3RpIDwgc3QubGVuZ3RoICYmIHJ5ID4gc3Rbc3RpXS5oZWlnaHQgJiYgc3RpIDwgKHN0Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICByeSA9IHJ5IC0gc3Rbc3RpXS5oZWlnaHQgLSB0aWVyLnBhZGRpbmc7XG4gICAgICAgICAgICArK3N0aTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RpID49IHN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdseXBocyA9IHN0W3N0aV0uZ2x5cGhzO1xuICAgICAgICB2YXIgdmlld0NlbnRlciA9ICh0aGlzQi52aWV3U3RhcnQgKyB0aGlzQi52aWV3RW5kKS8yO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gKHRpZXIuZ2x5cGhDYWNoZU9yaWdpbiAtIHRoaXNCLnZpZXdTdGFydCkqdGhpc0Iuc2NhbGU7XG4gICAgICAgIHJ4IC09IG9mZnNldDtcblxuICAgICAgICByZXR1cm4gZ2x5cGhMb29rdXAoZ2x5cGhzLCByeCwgcnkpO1xuICAgIH1cblxuICAgIHZhciBkcmFnTW92ZUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyIHJ4ID0gZXYuY2xpZW50WDtcbiAgICAgICAgaWYgKHJ4ICE9IGRyYWdNb3ZlT3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzQi5tb3ZlKChyeCAtIGRyYWdNb3ZlT3JpZ2luKSwgdHJ1ZSk7XG4gICAgICAgICAgICBkcmFnTW92ZU9yaWdpbiA9IHJ4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXNCLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBkcmFnVXBIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRyYWdNb3ZlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZHJhZ1VwSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgIHRoaXNCLm1vdmUoKGV2LmNsaWVudFggLSBkcmFnTW92ZU9yaWdpbikpOyAvLyBTbmFwIGJhY2sgKEZJWE1FOiBjb25zaWRlciBhbmltYXRpb24pXG4gICAgfVxuXG5cbiAgICB0aWVyLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHRoaXNCLmJyb3dzZXJIb2xkZXIuZm9jdXMoKTtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGJyID0gdGllci5yb3cuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciByeCA9IGV2LmNsaWVudFgsIHJ5ID0gZXYuY2xpZW50WTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZHJhZ01vdmVIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBkcmFnVXBIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgZHJhZ09yaWdpbiA9IGRyYWdNb3ZlT3JpZ2luID0gcng7XG4gICAgICAgIHRoaXNCLmlzRHJhZ2dpbmcgPSBmYWxzZTsgLy8gTm90IGRyYWdnaW5nIHVudGlsIGEgbW92ZW1lbnQgZXZlbnQgYXJyaXZlcy5cbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aWVyLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciBiciA9IHRpZXIucm93LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcnggPSBldi5jbGllbnRYIC0gYnIubGVmdCwgcnkgPSBldi5jbGllbnRZIC0gYnIudG9wO1xuXG4gICAgICAgIHZhciBoaXQgPSBmZWF0dXJlTG9va3VwKHJ4LCByeSk7XG4gICAgICAgIGlmIChoaXQgJiYgaGl0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRpZXIucm93LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpZXIucm93LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3ZlclRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIC8vIGlmICh0aWVyLmRhc1NvdXJjZS50aWVyX3R5cGUgIT09ICdzZXF1ZW5jZScgJiYgcnggIT0gZHJhZ01vdmVPcmlnaW4pIHtcbiAgICAgICAgICAgIC8vICAgIHRoaXNCLm1vdmUoKHJ4IC0gZHJhZ01vdmVPcmlnaW4pKTtcbiAgICAgICAgICAgIC8vICAgIGRyYWdNb3ZlT3JpZ2luID0gcng7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoaXQgPSBmZWF0dXJlTG9va3VwKHJ4LCByeSk7XG4gICAgICAgICAgICAgICAgaWYgKGhpdCAmJiBoaXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5ub3RpZnlGZWF0dXJlSG92ZXIoZXYsIGhpdFtoaXQubGVuZ3RoIC0gMV0sIGhpdCwgdGllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBkb3VibGVDbGlja1RpbWVvdXQgPSBudWxsO1xuICAgIHRpZXIudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciBiciA9IHRpZXIucm93LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcnggPSBldi5jbGllbnRYIC0gYnIubGVmdCwgcnkgPSBldi5jbGllbnRZIC0gYnIudG9wO1xuXG4gICAgICAgIHZhciBoaXQgPSBmZWF0dXJlTG9va3VwKHJ4LCByeSk7XG4gICAgICAgIGlmIChoaXQgJiYgaGl0Lmxlbmd0aCA+IDAgJiYgIXRoaXNCLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlmIChkb3VibGVDbGlja1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZG91YmxlQ2xpY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBkb3VibGVDbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXNCLmZlYXR1cmVEb3VibGVDbGljayhoaXQsIHJ4LCByeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvdWJsZUNsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZUNsaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeUZlYXR1cmUoZXYsIGhpdFtoaXQubGVuZ3RoLTFdLCBoaXQsIHRpZXIpO1xuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpc0IuaXNEcmFnZ2luZyAmJiByeCAhPSBkcmFnT3JpZ2luICYmIHRpZXIuc2VxdWVuY2VTb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpc0Iudmlld1N0YXJ0ICsgKHJ4L3RoaXNCLnNjYWxlKTtcbiAgICAgICAgICAgIHZhciBiID0gdGhpc0Iudmlld1N0YXJ0ICsgKGRyYWdPcmlnaW4vdGhpc0Iuc2NhbGUpO1xuXG4gICAgICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBhfDA7IG1heCA9IGJ8MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluID0gYnwwOyBtYXggPSBhfDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeVJlZ2lvblNlbGVjdCh0aGlzQi5jaHIsIG1pbiwgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzQi5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGllci52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIHRpZXIucmVtb3ZlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzQi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQi50aWVyc1t0aV0gPT09IHRpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzQi5yZW1vdmVUaWVyKHtpbmRleDogdGl9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgICB0aWVyLm5hbWVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHZhciBoaXRUaWVyID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpc0IudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLnRpZXJzW3RpXSA9PT0gdGllcikge1xuICAgICAgICAgICAgICAgICAgICBoaXRUaWVyID0gdGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaXRUaWVyID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXNCLnNlbGVjdGVkVGllcnMuaW5kZXhPZihoaXRUaWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNlbGVjdGVkVGllcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNlbGVjdGVkVGllcnMucHVzaChoaXRUaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iuc2VsZWN0ZWRUaWVycy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNCLm1hcmtTZWxlY3RlZFRpZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllclNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5icm93c2VySG9sZGVyLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllclNlbGVjdGlvbldyYXAoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzQi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0IudGllcnNbdGldID09PSB0aWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLmJyb3dzZXJIb2xkZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoICE9IDEgfHwgdGhpc0Iuc2VsZWN0ZWRUaWVyc1swXSAhPSB0aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0Iuc2V0U2VsZWN0ZWRUaWVyKHRpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aWVyLmluZm9WaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGllci5pbmZvRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB0aWVyLnVwZGF0ZUhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHRpZXIuaW5mb1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aWVyLmluZm9FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGllci51cGRhdGVIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aWVyLmluZm9WaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgdGllci5idW1wQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBidW1wU3RhdHVzO1xuICAgICAgICB2YXIgdCA9IHRpZXI7XG4gICAgICAgIGlmICh0LmRhc1NvdXJjZS5jb2xsYXBzZVN1cGVyR3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAoYnVtcFN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnVtcFN0YXR1cyA9ICF0LmJ1bXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQubWVyZ2VDb25maWcoe2J1bXBlZDogYnVtcFN0YXR1c30pO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG5cbiAgICB2YXIgZHJhZ0xhYmVsO1xuICAgIHZhciBkcmFnVGllckhvbGRlcjtcbiAgICB2YXIgZHJhZ1RpZXJIb2xkZXJTY3JvbGxMaW1pdDtcbiAgICB2YXIgdGllck9yZGluYWw7XG4gICAgdmFyIHlBdExhc3RSZW9yZGVyO1xuICAgIHZhciB0aWVyc1dlcmVSZW9yZGVyZWQgPSBmYWxzZTtcblxuICAgIHZhciBsYWJlbERyYWdIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gdGllci5sYWJlbDtcblxuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKCFkcmFnTGFiZWwpIHtcbiAgICAgICAgICAgIGlmICh0aWVyLnBpbm5lZCkge1xuICAgICAgICAgICAgICAgIGRyYWdUaWVySG9sZGVyID0gdGhpc0IucGlubmVkVGllckhvbGRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJhZ1RpZXJIb2xkZXIgPSB0aGlzQi50aWVySG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhZ1RpZXJIb2xkZXJTY3JvbGxMaW1pdCA9IGRyYWdUaWVySG9sZGVyLnNjcm9sbEhlaWdodCAtIGRyYWdUaWVySG9sZGVyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgZHJhZ0xhYmVsID0gbGFiZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgZHJhZ0xhYmVsLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgIGRyYWdUaWVySG9sZGVyLmFwcGVuZENoaWxkKGRyYWdMYWJlbCk7XG4gICAgICAgICAgICBsYWJlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzQi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0IudGllcnNbdGldID09PSB0aWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJPcmRpbmFsID0gdGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeUF0TGFzdFJlb3JkZXIgPSBldi5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhvbGRlckJDUiA9IGRyYWdUaWVySG9sZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBkcmFnTGFiZWwuc3R5bGUubGVmdCA9IChsYWJlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gaG9sZGVyQkNSLmxlZnQpICsgJ3B4JztcbiAgICAgICAgZHJhZ0xhYmVsLnN0eWxlLnRvcCA9IChldi5jbGllbnRZIC0gaG9sZGVyQkNSLnRvcCArIGRyYWdUaWVySG9sZGVyLnNjcm9sbFRvcCAtIDEwKSArICdweCc7XG5cbiAgICAgICAgdmFyIHB0eSA9IGV2LmNsaWVudFkgLSBob2xkZXJCQ1IudG9wICsgZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wO1xuICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpc0IudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICB2YXIgdHQgPSB0aGlzQi50aWVyc1t0aV07XG4gICAgICAgICAgICBpZiAodHQucGlubmVkIF4gdGllci5waW5uZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciB0dHIgPSB0dC5yb3cuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBwdHkgLT0gKHR0ci5ib3R0b20gLSB0dHIudG9wKTtcbiAgICAgICAgICAgIGlmIChwdHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpIDwgdGllck9yZGluYWwgJiYgZXYuY2xpZW50WSA8IHlBdExhc3RSZW9yZGVyIHx8IHRpID4gdGllck9yZGluYWwgJiYgZXYuY2xpZW50WSA+IHlBdExhc3RSZW9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLndpdGhQcmVzZXJ2ZWRTZWxlY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi50aWVycy5zcGxpY2UodGllck9yZGluYWwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllcnMuc3BsaWNlKHRpLCAwLCB0aWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLl9lbnN1cmVUaWVyc0dyb3VwZWQodGkgPiB0aWVyT3JkaW5hbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpeCA9IDA7IHRpeCA8IHRoaXNCLnRpZXJzLmxlbmd0aDsgKyt0aXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0IudGllcnNbdGl4XSA9PSB0aWVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZXJPcmRpbmFsID0gdGl4O1xuXG4gICAgICAgICAgICAgICAgICAgIHlBdExhc3RSZW9yZGVyID0gZXYuY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IucmVvcmRlclRpZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdUaWVySG9sZGVyLmFwcGVuZENoaWxkKGRyYWdMYWJlbCk7IC8vIEJlY2F1c2UgcmVvcmRlclRpZXJzIHJlbW92ZXMgYWxsIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgICAgICB0aWVyc1dlcmVSZW9yZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnTGFiZWwub2Zmc2V0VG9wIDwgZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBkcmFnVGllckhvbGRlci5zY3JvbGxUb3AgLT0gKGRyYWdUaWVySG9sZGVyLnNjcm9sbFRvcCAtIGRyYWdMYWJlbC5vZmZzZXRUb3ApO1xuICAgICAgICB9IGVsc2UgaWYgKChkcmFnTGFiZWwub2Zmc2V0VG9wICsgZHJhZ0xhYmVsLm9mZnNldEhlaWdodCkgPiAoZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wICsgZHJhZ1RpZXJIb2xkZXIub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgICAgICAgZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wID0gTWF0aC5taW4oZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnTGFiZWwub2Zmc2V0VG9wICsgZHJhZ0xhYmVsLm9mZnNldEhlaWdodCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRyYWdUaWVySG9sZGVyLnNjcm9sbFRvcCArIGRyYWdUaWVySG9sZGVyLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnVGllckhvbGRlclNjcm9sbExpbWl0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFiZWxSZWxlYXNlSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHRpZXIubGFiZWw7XG5cbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChkcmFnTGFiZWwpIHtcbiAgICAgICAgICAgIGRyYWdMYWJlbC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG4gICAgICAgICAgICBkcmFnVGllckhvbGRlci5yZW1vdmVDaGlsZChkcmFnTGFiZWwpO1xuICAgICAgICAgICAgZHJhZ0xhYmVsID0gbnVsbDtcbiAgICAgICAgICAgIGxhYmVsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbGFiZWxEcmFnSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbGFiZWxSZWxlYXNlSGFuZGxlciwgZmFsc2UpO1xuXG4gICAgICAgIGlmICh0aWVyc1dlcmVSZW9yZGVyZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzQi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0IudGllcnNbdGldID09IHRpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iuc2V0U2VsZWN0ZWRUaWVyKHRpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllcihcInJlb3JkZXJlZFwiLCB0aWVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aWVyLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aWVyc1dlcmVSZW9yZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbGFiZWxEcmFnSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbGFiZWxSZWxlYXNlSGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMudGllcnMucHVzaCh0aWVyKTsgIC8vIE5CIHRoaXMgY3VycmVudGx5IHRlbGxzIGFueSBleHRhbnQga25vd25TcGFjZSBhYm91dCB0aGUgbmV3IHRpZXIuXG5cbiAvLyBmZXRjaGVzIHN0eWxlc2hlZXRcbiAgICByZXR1cm4gdGllci5pbml0KCkudGhlbihmdW5jdGlvbiAodXBkYXRlZFRpZXIpIHtcbiAgICAgICAgdXBkYXRlZFRpZXIuY3VycmVudGx5SGVpZ2h0ID0gNTA7XG4gICAgICAgIHRoaXNCLnVwZGF0ZUhlaWdodCgpO1xuICAgICAgICB1cGRhdGVkVGllci51cGRhdGVMYWJlbCgpO1xuXG4gICAgICAgIHRoaXNCLndpdGhQcmVzZXJ2ZWRTZWxlY3Rpb24odGhpc0IuX2Vuc3VyZVRpZXJzR3JvdXBlZCk7XG4gICAgICAgIHVwZGF0ZWRUaWVyLl91cGRhdGVGcm9tQ29uZmlnKCk7XG4gICAgICAgIHRoaXNCLnJlb3JkZXJUaWVycygpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVkVGllcjtcbiAgICB9KTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVvcmRlclRpZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy50aWVySG9sZGVyKTtcbiAgICByZW1vdmVDaGlsZHJlbih0aGlzLnBpbm5lZFRpZXJIb2xkZXIpO1xuICAgIGlmICh0aGlzLmRpc2FibGVQaW5uaW5nKSB7XG4gICAgICAgIHRoaXMudGllckhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnJ1bGVyKTtcbiAgICAgICAgdGhpcy50aWVySG9sZGVyLmFwcGVuZENoaWxkKHRoaXMucnVsZXIyKTtcbiAgICB9XG4gICAgdmFyIGhhc1Bpbm5lZCA9IGZhbHNlO1xuICAgIHZhciBwaW5uZWRUaWVycyA9IFtdLCB1bnBpbm5lZFRpZXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy50aWVyc1tpXTtcbiAgICAgICAgdmFyIGhhc0hpZGRlblJlbmRlcmVyID0gWydzdWInLCdkdW1teSddLmluZGV4T2YodGhpcy50aWVyc1tpXS5kYXNTb3VyY2UucmVuZGVyZXIpICE9PSAtMTtcbiAgICAgICAgaWYgKHQucGlubmVkICYmICF0aGlzLmRpc2FibGVQaW5uaW5nKSB7XG4gICAgICAgICAgICBwaW5uZWRUaWVycy5wdXNoKHQpO1xuICAgICAgICAgICAgaWYgKCFoYXNIaWRkZW5SZW5kZXJlciB8fCAhdGhpcy50aWVyc1tpXS5kYXNTb3VyY2UuaGlkZGVuKVxuICAgICAgICAgICAgICAgIHRoaXMucGlubmVkVGllckhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnRpZXJzW2ldLnJvdyk7XG4gICAgICAgICAgICBoYXNQaW5uZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5waW5uZWRUaWVycy5wdXNoKHQpO1xuICAgICAgICAgICAgaWYgKCFoYXNIaWRkZW5SZW5kZXJlciB8fCAhdGhpcy50aWVyc1tpXS5kYXNTb3VyY2UuaGlkZGVuKVxuICAgICAgICAgICAgICAgIHRoaXMudGllckhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnRpZXJzW2ldLnJvdyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLndpdGhQcmVzZXJ2ZWRTZWxlY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGllcnMuc3BsaWNlKDAsIHRoaXMudGllcnMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaW5uZWRUaWVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXMudGllcnMucHVzaChwaW5uZWRUaWVyc1tpXSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5waW5uZWRUaWVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXMudGllcnMucHVzaCh1bnBpbm5lZFRpZXJzW2ldKTtcbiAgICB9KTtcblxuICAgIGlmIChoYXNQaW5uZWQpXG4gICAgICAgIHRoaXMucGlubmVkVGllckhvbGRlci5jbGFzc0xpc3QuYWRkKCd0aWVyLWhvbGRlci1waW5uZWQtZnVsbCcpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5waW5uZWRUaWVySG9sZGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3RpZXItaG9sZGVyLXBpbm5lZC1mdWxsJyk7XG5cbiAgICB0aGlzLmFycmFuZ2VUaWVycygpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS53aXRoUHJlc2VydmVkU2VsZWN0aW9uID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBzdCA9IFtdO1xuICAgIGZvciAodmFyIHhpID0gMDsgeGkgPCB0aGlzLnNlbGVjdGVkVGllcnMubGVuZ3RoOyArK3hpKSB7XG4gICAgICAgIHN0LnB1c2godGhpcy50aWVyc1t0aGlzLnNlbGVjdGVkVGllcnNbeGldXSk7XG4gICAgfVxuXG4gICAgZi5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zZWxlY3RlZFRpZXJzID0gW107XG4gICAgZm9yICh2YXIgc3RpID0gMDsgc3RpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrc3RpKSB7XG4gICAgICAgIGlmIChzdC5pbmRleE9mKHRoaXMudGllcnNbc3RpXSkgPj0gMClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUaWVycy5wdXNoKHN0aSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZWZyZXNoVGllciA9IGZ1bmN0aW9uKHRpZXIsIHRpZXJDYWxsYmFjaykge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0VGllclJlbmRlcmVyKHRpZXIpO1xuICAgIGlmICh0aWVyLmRhc1NvdXJjZS5yZW5kZXJlciA9PT0gJ211bHRpJykge1xuICAgICAgICByZW5kZXJlci5kcmF3VGllcih0aWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVuZGVyQ2FsbGJhY2sgPSB0aWVyQ2FsbGJhY2sgfHwgcmVuZGVyZXIucmVuZGVyVGllcjtcbiAgICAgICAgaWYgKHRoaXMua25vd25TcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5rbm93blNwYWNlLmludmFsaWRhdGUodGllciwgcmVuZGVyQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5nZXRUaWVyUmVuZGVyZXIgPSBmdW5jdGlvbih0aWVyKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGllci5kYXNTb3VyY2UucmVuZGVyZXIgfHwgdGhpcy5kZWZhdWx0UmVuZGVyZXI7XG4gICAgaWYgKHR5cGVvZihyZW5kZXJlcikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyc1tyZW5kZXJlcl07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YocmVuZGVyZXIucmVuZGVyVGllcikgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgIHR5cGVvZihyZW5kZXJlci5kcmF3VGllcikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGllciBkb2Vzbid0IGhhdmUgYSByZW5kZXJlclwiKTtcbiAgICB9XG59XG5cbi8qIEludGVybmFsIHVzZSBvbmx5LCBhc3N1bWVzIHNlbGVjdGlvbiBpcyBiZWluZyBtYW5hZ2VkIGVsc2V3aGVyZS4uLiAqL1xuXG5Ccm93c2VyLnByb3RvdHlwZS5fZW5zdXJlVGllcnNHcm91cGVkID0gZnVuY3Rpb24oZG93bikge1xuICAgIHZhciBncm91cGVkVGllcnMgPSB7fTtcbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRpZXJzW3RpXTtcbiAgICAgICAgaWYgKHQuZGFzU291cmNlLnRpZXJHcm91cCkge1xuICAgICAgICAgICAgcHVzaG8oZ3JvdXBlZFRpZXJzLCB0LmRhc1NvdXJjZS50aWVyR3JvdXAsIHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld1RpZXJzID0gW107XG4gICAgaWYgKGRvd24pXG4gICAgICAgIHRoaXMudGllcnMucmV2ZXJzZSgpO1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMudGllcnNbdGldO1xuICAgICAgICBpZiAodC5kYXNTb3VyY2UudGllckdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgbnQgPSBncm91cGVkVGllcnNbdC5kYXNTb3VyY2UudGllckdyb3VwXTtcbiAgICAgICAgICAgIGlmIChudCkge1xuICAgICAgICAgICAgICAgIGlmIChkb3duKVxuICAgICAgICAgICAgICAgICAgICBudC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbnRpID0gMDsgbnRpIDwgbnQubGVuZ3RoOyArK250aSlcbiAgICAgICAgICAgICAgICAgICAgbmV3VGllcnMucHVzaChudFtudGldKTtcbiAgICAgICAgICAgICAgICBncm91cGVkVGllcnNbdC5kYXNTb3VyY2UudGllckdyb3VwXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUaWVycy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkb3duKVxuICAgICAgICBuZXdUaWVycy5yZXZlcnNlKCk7XG4gICAgdGhpcy50aWVycy5zcGxpY2UoMCwgdGhpcy50aWVycy5sZW5ndGgpO1xuICAgIGZvciAodmFyIG50aSA9IDA7IG50aSA8IG5ld1RpZXJzLmxlbmd0aDsgKytudGkpXG4gICAgICAgIHRoaXMudGllcnMucHVzaChuZXdUaWVyc1tudGldKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuYXJyYW5nZVRpZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFycmFuZ2VkVGllcnMgPSBbXTtcbiAgICB2YXIgZ3JvdXBlZFRpZXJzID0ge307XG5cbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRpZXJzW3RpXTtcbiAgICAgICAgaWYgKHQucGlubmVkKSB7XG4gICAgICAgICAgICBhcnJhbmdlZFRpZXJzLnB1c2godCk7XG4gICAgICAgICAgICBpZiAodC5kYXNTb3VyY2UudGllckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcHVzaG8oZ3JvdXBlZFRpZXJzLCB0LmRhc1NvdXJjZS50aWVyR3JvdXAsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy50aWVyc1t0aV07XG4gICAgICAgIGlmICghdC5waW5uZWQpIHtcbiAgICAgICAgICAgIGFycmFuZ2VkVGllcnMucHVzaCh0KTtcbiAgICAgICAgICAgIGlmICh0LmRhc1NvdXJjZS50aWVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBwdXNobyhncm91cGVkVGllcnMsIHQuZGFzU291cmNlLnRpZXJHcm91cCwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBnIGluIGdyb3VwZWRUaWVycykge1xuICAgICAgICB2YXIgdGllcnMgPSBncm91cGVkVGllcnNbZ107XG4gICAgICAgIHZhciB0aWVyR3JvdXAgPSB0aGlzLnRpZXJHcm91cHNbZ107XG4gICAgICAgIGlmICghdGllckdyb3VwKSB7XG4gICAgICAgICAgICB0aWVyR3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogbWFrZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgnc3BhbicsIGcsIHtjbGFzc05hbWU6ICd0aWVyLWdyb3VwLWxhYmVsJ30pLFxuICAgICAgICAgICAgICAgICAgICB7Y2xhc3NOYW1lOiBcInRpZXItZ3JvdXBcIn0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50aWVyR3JvdXBzW2ddID0gdGllckdyb3VwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpZXJHcm91cC5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0aWVyR3JvdXAuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRpZXJHcm91cC5lbGVtZW50KTtcblxuICAgICAgICB2YXIgaG9sZGVyID0gdGllcnNbMF0ucGlubmVkID8gdGhpcy5waW5uZWRUaWVySG9sZGVyIDogdGhpcy50aWVySG9sZGVyO1xuICAgICAgICB2YXIgbWluID0gMTAwMDAwMDAsIG1heCA9IDA7XG4gICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aWVyc1t0aV0ucm93O1xuICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3cub2Zmc2V0VG9wKTtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm93Lm9mZnNldFRvcCArIHJvdy5vZmZzZXRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRpZXJHcm91cC5lbGVtZW50LnN0eWxlLnRvcCA9IG1pbiArICdweCc7XG4gICAgICAgIHRpZXJHcm91cC5lbGVtZW50LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgdGllckdyb3VwLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKG1heC1taW4pICsgJ3B4JztcbiAgICAgICAgaG9sZGVyLmFwcGVuZENoaWxkKHRpZXJHcm91cC5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aWVyQmFja2dyb3VuZENvbG9ycykge1xuICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgYXJyYW5nZWRUaWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gYXJyYW5nZWRUaWVyc1t0aV07XG4gICAgICAgICAgICB0LnNldEJhY2tncm91bmQodGhpcy50aWVyQmFja2dyb3VuZENvbG9yc1t0aSAlIHRoaXMudGllckJhY2tncm91bmRDb2xvcnMubGVuZ3RoXSk7XG4gICAgICAgICAgICBpZiAodC5kYXNTb3VyY2UudGllckdyb3VwKVxuICAgICAgICAgICAgICAgIHQubGFiZWwuc3R5bGUubGVmdCA9ICcxOHB4JztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0LmxhYmVsLnN0eWxlLmxlZnQgPSAnMnB4JztcbiAgICAgICAgICAgIHQuYmFja2dyb3VuZCA9IHRoaXMudGllckJhY2tncm91bmRDb2xvcnNbdGkgJSB0aGlzLnRpZXJCYWNrZ3JvdW5kQ29sb3JzLmxlbmd0aF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJldHJpZXZlVGllckRhdGEodGhpcy50aWVycyk7XG4gICAgdGhpcy5kcmF3T3ZlcmxheXMoKTtcbiAgICB0aGlzLnBvc2l0aW9uUnVsZXIoKTtcbn07XG5cbnZhciBkZWZhdWx0VGllclJlbmRlcmVyID0gZnVuY3Rpb24oc3RhdHVzLCB0aWVyKSB7XG4gICAgY29uc29sZS5sb2coXCJERVBSRUNBVEVEIVwiKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmV0cmlldmVUaWVyRGF0YSA9IGZ1bmN0aW9uKHRpZXJzKSB7XG4gICAgdGhpcy5ub3RpZnlMb2NhdGlvbigpO1xuICAgIHZhciB3aWR0aCA9ICh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCkgKyAxO1xuICAgIHZhciBtaW5FeHRyYVcgPSAodGhpcy5taW5FeHRyYVdpZHRoIC8gdGhpcy5zY2FsZSl8MDtcbiAgICB2YXIgbWF4RXh0cmFXID0gKHRoaXMubWF4RXh0cmFXaWR0aCAvIHRoaXMuc2NhbGUpfDA7XG5cbiAgICB2YXIgbmV3T3JpZ2luID0gKHRoaXMudmlld1N0YXJ0ICsgdGhpcy52aWV3RW5kKSAvIDI7XG4gICAgdmFyIG9oID0gbmV3T3JpZ2luIC0gdGhpcy5vcmlnaW47XG4gICAgdGhpcy5vcmlnaW4gPSBuZXdPcmlnaW47XG4gICAgdGhpcy5zY2FsZUF0TGFzdFJlZHJhdyA9IHRoaXMuc2NhbGU7XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aWVycy5sZW5ndGg7ICsrdCkge1xuICAgICAgICB2YXIgb2QgPSBvaDtcbiAgICAgICAgaWYgKHRpZXJzW3RdLm9yaWdpbkhheHgpIHtcbiAgICAgICAgICAgIG9kICs9IHRpZXJzW3RdLm9yaWdpbkhheHg7XG4gICAgICAgIH1cbiAgICAgICAgdGllcnNbdF0ub3JpZ2luSGF4eCA9IG9kO1xuICAgIH1cblxuICAgIHZhciBzY2FsZWRRdWFudFJlcyA9IHRoaXMudGFyZ2V0UXVhbnRSZXMgLyB0aGlzLnNjYWxlO1xuXG4gICAgdmFyIGlubmVyRHJhd25TdGFydCA9IE1hdGgubWF4KDEsICh0aGlzLnZpZXdTdGFydHwwKSAtIG1pbkV4dHJhVyk7XG4gICAgdmFyIGlubmVyRHJhd25FbmQgPSBNYXRoLm1pbigodGhpcy52aWV3RW5kfDApICsgbWluRXh0cmFXLCAoKHRoaXMuY3VycmVudFNlcU1heHwwKSA+IDAgPyAodGhpcy5jdXJyZW50U2VxTWF4fDApIDogMTAwMDAwMDAwMCkpXG4gICAgdmFyIG91dGVyRHJhd25TdGFydCA9IE1hdGgubWF4KDEsICh0aGlzLnZpZXdTdGFydHwwKSAtIG1heEV4dHJhVyk7XG4gICAgdmFyIG91dGVyRHJhd25FbmQgPSBNYXRoLm1pbigodGhpcy52aWV3RW5kfDApICsgbWF4RXh0cmFXLCAoKHRoaXMuY3VycmVudFNlcU1heHwwKSA+IDAgPyAodGhpcy5jdXJyZW50U2VxTWF4fDApIDogMTAwMDAwMDAwMCkpO1xuXG4gICAgaWYgKCF0aGlzLmtub3duU3BhY2UgfHwgdGhpcy5rbm93blNwYWNlLmNociAhPT0gdGhpcy5jaHIpIHtcbiAgICAgICAgdmFyIHNzID0gdGhpcy5nZXRTZXF1ZW5jZVNvdXJjZSgpO1xuICAgICAgICBpZiAodGhpcy5rbm93blNwYWNlKVxuICAgICAgICAgICAgdGhpcy5rbm93blNwYWNlLmNhbmNlbCgpO1xuICAgICAgICAvLyBrbm93biBzcGFjZSBpcyBjcmVhdGVkIGJhc2VkIG9uIHRoZSBlbnRpcmUgdGllciBsaXN0LCBmb3IgZnV0dXJlIGNhY2hpbmcgcHVycG9zZXMsIGV2ZW4gaWYgb25seSBhIHN1YnNldCBvZiB0aGUgdGllcnMgYXJlIG5lZWRlZCB0byBiZSByZW5kZXJlZCBub3cuXG4gICAgICAgIHRoaXMua25vd25TcGFjZSA9IG5ldyBLbm93blNwYWNlKHRoaXMudGllcnMsIHRoaXMuY2hyLCBvdXRlckRyYXduU3RhcnQsIG91dGVyRHJhd25FbmQsIHNjYWxlZFF1YW50UmVzLCBzcyk7XG4gICAgfVxuXG4gICAgdmFyIHNlZyA9IHRoaXMua25vd25TcGFjZS5iZXN0Q2FjaGVPdmVybGFwcGluZyh0aGlzLmNociwgaW5uZXJEcmF3blN0YXJ0LCBpbm5lckRyYXduRW5kKTtcbiAgICBpZiAoc2VnICYmIHNlZy5taW4gPD0gaW5uZXJEcmF3blN0YXJ0ICYmIHNlZy5tYXggPj0gaW5uZXJEcmF3bkVuZCkge1xuICAgICAgICB0aGlzLmRyYXduU3RhcnQgPSBNYXRoLm1heChzZWcubWluLCBvdXRlckRyYXduU3RhcnQpO1xuICAgICAgICB0aGlzLmRyYXduRW5kID0gTWF0aC5taW4oc2VnLm1heCwgb3V0ZXJEcmF3bkVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kcmF3blN0YXJ0ID0gb3V0ZXJEcmF3blN0YXJ0O1xuICAgICAgICB0aGlzLmRyYXduRW5kID0gb3V0ZXJEcmF3bkVuZDtcbiAgICB9XG5cbiAgICAvLyBzZW5kIGluIHRoZSBzdWJzZXQgb2YgdGllcnMgdG8gcmV0cmlldmUuXG4gICAgdGhpcy5rbm93blNwYWNlLnJldHJpZXZlRmVhdHVyZXModGllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3blN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd25FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkUXVhbnRSZXMpO1xufVxuXG5mdW5jdGlvbiBzZXRTb3VyY2VzKG1zaCwgYXZhaWxhYmxlU291cmNlcywgbWF5YmVNYXBwaW5nKSB7XG4gICAgaWYgKG1heWJlTWFwcGluZykge1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGF2YWlsYWJsZVNvdXJjZXMubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVNvdXJjZXNbc10ubWFwcGluZyA9IG1heWJlTWFwcGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtc2guc2V0KGF2YWlsYWJsZVNvdXJjZXMpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5xdWVyeVJlZ2lzdHJ5ID0gZnVuY3Rpb24obWF5YmVNYXBwaW5nLCB0cnlDYWNoZSkge1xuICAgIGlmICghdGhpcy5yZWdpc3RyeSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgY29vcmRzLCBtc2g7XG4gICAgaWYgKG1heWJlTWFwcGluZykge1xuICAgICAgICBjb29yZHMgPSB0aGlzLmNoYWluc1ttYXliZU1hcHBpbmddLmNvb3JkcztcbiAgICAgICAgaWYgKCF0aGlzQi5tYXBwYWJsZVNvdXJjZXNbbWF5YmVNYXBwaW5nXSkge1xuICAgICAgICAgICAgdGhpc0IubWFwcGFibGVTb3VyY2VzW21heWJlTWFwcGluZ10gPSBuZXcgT2JzZXJ2ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBtc2ggPSB0aGlzQi5tYXBwYWJsZVNvdXJjZXNbbWF5YmVNYXBwaW5nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb29yZHMgPSB0aGlzLmNvb3JkU3lzdGVtO1xuICAgICAgICBtc2ggPSB0aGlzLmF2YWlsYWJsZVNvdXJjZXM7XG4gICAgfVxuICAgIHZhciBjYWNoZUhhc2ggPSBoZXhfc2hhMShtaW5pSlNPTmlmeShjb29yZHMpKTtcbiAgICBpZiAodHJ5Q2FjaGUpIHtcbiAgICAgICAgdmFyIGNhY2hlVGltZSA9IGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLnJlZ2lzdHJ5LicgKyBjYWNoZUhhc2ggKyAnLmxhc3RfcXVlcmllZCddO1xuICAgICAgICBpZiAoY2FjaGVUaW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNldFNvdXJjZXMobXNoLCBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLnJlZ2lzdHJ5LicgKyBjYWNoZUhhc2ggKyAnLnNvdXJjZXMnXSksIG1heWJlTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlQWdlID0gKERhdGUubm93KCl8MCkgLSAoY2FjaGVUaW1lfDApO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZUFnZSA8ICgxMiAqIDYwICogNjAgKiAxMDAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAocmV4KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JhZCByZWdpc3RyeSBjYWNoZTogJyArIHJleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcnVybCA9IHRoaXMucmVnaXN0cnk7XG4gICAgaWYgKHJ1cmwuaW5kZXhPZignLy8nKSA9PSAwKSB7XG4gICAgICAgIHZhciBwcm90byA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgaWYgKHByb3RvICE9ICdodHRwczonICYmIHByb3RvICE9ICdodHRwOicpXG4gICAgICAgICAgICBydXJsID0gJ2h0dHA6JyArIHJ1cmw7XG4gICAgfVxuICAgIG5ldyBEQVNSZWdpc3RyeShydXJsKS5zb3VyY2VzKGZ1bmN0aW9uKHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVNvdXJjZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzb3VyY2VzLmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tzXTtcbiAgICAgICAgICAgIGlmICghc291cmNlLmNvb3JkcyB8fCBzb3VyY2UuY29vcmRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2Nvb3JkcyA9IHNvdXJjZS5jb29yZHNbMF07XG4gICAgICAgICAgICBpZiAoc2Nvb3Jkcy50YXhvbiAhPSBjb29yZHMudGF4b24gfHwgc2Nvb3Jkcy5hdXRoICE9IGNvb3Jkcy5hdXRoIHx8IHNjb29yZHMudmVyc2lvbiAhPSBjb29yZHMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXZhaWxhYmxlU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS5yZWdpc3RyeS4nICsgY2FjaGVIYXNoICsgJy5zb3VyY2VzJ10gPSBKU09OLnN0cmluZ2lmeShhdmFpbGFibGVTb3VyY2VzKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UucmVnaXN0cnkuJyArIGNhY2hlSGFzaCArICcubGFzdF9xdWVyaWVkJ10gPSAnJyArIERhdGUubm93KCk7XG5cbiAgICAgICAgc2V0U291cmNlcyhtc2gsIGF2YWlsYWJsZVNvdXJjZXMsIG1heWJlTWFwcGluZyk7XG4gICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgLy8gbXNoLnNldChudWxsKTtcbiAgICB9LCBjb29yZHMpO1xufVxuXG4vL1xuLy8gTmF2aWdhdGlvblxuLy9cblxuQnJvd3Nlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHBvcywgc29mdClcbntcbiAgICB2YXIgd2lkID0gdGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQ7XG4gICAgdmFyIG5TdGFydCA9IHRoaXMudmlld1N0YXJ0IC0gKCgxLjAgKiBwb3MpIC8gdGhpcy5zY2FsZSk7XG4gICAgdmFyIG5FbmQgPSBuU3RhcnQgKyB3aWQ7XG5cbiAgICBpZiAoIXNvZnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcU1heCA+IDAgJiYgbkVuZCA+IHRoaXMuY3VycmVudFNlcU1heCkge1xuICAgICAgICAgICAgbkVuZCA9IHRoaXMuY3VycmVudFNlcU1heDtcbiAgICAgICAgICAgIG5TdGFydCA9IHRoaXMudmlld0VuZCAtIHdpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoblN0YXJ0IDwgMSkge1xuICAgICAgICAgICAgblN0YXJ0ID0gMTtcbiAgICAgICAgICAgIG5FbmQgPSBuU3RhcnQgKyB3aWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldExvY2F0aW9uKG51bGwsIG5TdGFydCwgbkVuZCwgbnVsbCwgc29mdCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnpvb21TdGVwID0gZnVuY3Rpb24oZGVsdGEpIHtcbiAgICB2YXIgb3ogPSAxLjAgKiB0aGlzLnpvb21TbGlkZXJWYWx1ZTtcbiAgICB2YXIgbnogPSBveiArIGRlbHRhO1xuICAgIGlmIChueiA8IHRoaXMuem9vbU1pbikge1xuICAgICAgICBuej0gdGhpcy56b29tTWluO1xuICAgIH1cbiAgICBpZiAobnogPiB0aGlzLnpvb21NYXgpIHtcbiAgICAgICAgbnogPSB0aGlzLnpvb21NYXg7XG4gICAgfVxuXG4gICAgaWYgKG56ICE9IG96KSB7XG4gICAgICAgIHRoaXMuem9vbVNsaWRlclZhbHVlID0gbno7IC8vIEZJWE1FIG1heWJlIG91Z2h0IHRvIHNldCBpbnNpZGUgem9vbSFcbiAgICAgICAgdGhpcy56b29tKE1hdGguZXhwKCgxLjAgKiBueikgLyB0aGlzLnpvb21FeHB0KSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24oZmFjdG9yKSB7XG4gICAgdGhpcy56b29tRmFjdG9yID0gZmFjdG9yO1xuICAgIHZhciB2aWV3Q2VudGVyID0gTWF0aC5yb3VuZCgodGhpcy52aWV3U3RhcnQgKyB0aGlzLnZpZXdFbmQpIC8gMi4wKXwwO1xuICAgIHRoaXMudmlld1N0YXJ0ID0gdmlld0NlbnRlciAtIHRoaXMuem9vbUJhc2UgKiB0aGlzLnpvb21GYWN0b3IgLyAyO1xuICAgIHRoaXMudmlld0VuZCA9IHZpZXdDZW50ZXIgKyB0aGlzLnpvb21CYXNlICogdGhpcy56b29tRmFjdG9yIC8gMjtcbiAgICBpZiAodGhpcy5jdXJyZW50U2VxTWF4ID4gMCAmJiAodGhpcy52aWV3RW5kID4gdGhpcy5jdXJyZW50U2VxTWF4ICsgNSkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgdGhpcy52aWV3RW5kID0gdGhpcy5jdXJyZW50U2VxTWF4O1xuICAgICAgICB0aGlzLnZpZXdTdGFydCA9IHRoaXMudmlld0VuZCAtIGxlbiArIDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpZXdTdGFydCA8IDEpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgdGhpcy52aWV3U3RhcnQgPSAxO1xuICAgICAgICB0aGlzLnZpZXdFbmQgPSB0aGlzLnZpZXdTdGFydCArIGxlbiAtIDE7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUgPSB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoIC8gKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KVxuICAgIHZhciB3aWR0aCA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcblxuICAgIHZhciBzY2FsZVJhdCA9ICh0aGlzLnNjYWxlIC8gdGhpcy5zY2FsZUF0TGFzdFJlZHJhdyk7XG5cbiAgICB0aGlzLm5vdGlmeUxvY2F0aW9uKCk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNwYWNlQ2hlY2sgPSBmdW5jdGlvbihkb250UmVmcmVzaCkge1xuICAgIGlmICghdGhpcy5rbm93blNwYWNlIHx8IHRoaXMua25vd25TcGFjZS5jaHIgIT09IHRoaXMuY2hyKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gKCh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCl8MCkgKyAxO1xuICAgIHZhciBtaW5FeHRyYVcgPSAodGhpcy5taW5FeHRyYVdpZHRoIC8gdGhpcy5zY2FsZSl8MDtcbiAgICB2YXIgbWF4RXh0cmFXID0gKHRoaXMubWF4RXh0cmFXaWR0aCAvIHRoaXMuc2NhbGUpfDA7XG5cbiAgICBpZiAoKHRoaXMuZHJhd25TdGFydHwwKSA+IE1hdGgubWF4KDEsICgodGhpcy52aWV3U3RhcnR8MCkgLSBtaW5FeHRyYVcpfDApICB8fCAodGhpcy5kcmF3bkVuZHwwKSA8IE1hdGgubWluKCh0aGlzLnZpZXdFbmR8MCkgKyBtaW5FeHRyYVcsICgodGhpcy5jdXJyZW50U2VxTWF4fDApID4gMCA/ICh0aGlzLmN1cnJlbnRTZXFNYXh8MCkgOiAxMDAwMDAwMDAwKSkpICB7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVzaXplVmlld2VyID0gZnVuY3Rpb24oc2tpcFJlZnJlc2gpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLnRpZXJIb2xkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfCAwO1xuICAgIGlmICh3aWR0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgb2xkRlBXID0gTWF0aC5tYXgodGhpcy5mZWF0dXJlUGFuZWxXaWR0aCwgMzAwKTsgLy8gQ2FuIGdldCBzaWxseSB2YWx1ZXMgc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGJyb3dzZXIgaXMgaGlkZGVuLlxuICAgIHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggPSB3aWR0aHwwO1xuXG4gICAgaWYgKG9sZEZQVyAhPSB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoKSB7XG4gICAgICAgIHRoaXMuem9vbU1heCA9IHRoaXMuem9vbUV4cHQgKiBNYXRoLmxvZyh0aGlzLm1heFZpZXdXaWR0aCAvIHRoaXMuem9vbUJhc2UpO1xuICAgICAgICB0aGlzLnpvb21NaW4gPSB0aGlzLnpvb21FeHB0ICogTWF0aC5sb2codGhpcy5mZWF0dXJlUGFuZWxXaWR0aCAvIHRoaXMubWF4UGl4ZWxzUGVyQmFzZSAvIHRoaXMuem9vbUJhc2UpOyAgIC8vIEZJWE1FIGhhcmQtY29kZWQgbWluaW11bS5cbiAgICAgICAgdGhpcy56b29tU2xpZGVyVmFsdWUgPSB0aGlzLnpvb21FeHB0ICogTWF0aC5sb2coKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMSkgLyB0aGlzLnpvb21CYXNlKTtcblxuICAgICAgICB2YXIgdmlld1dpZHRoID0gdGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQ7XG4gICAgICAgIHZhciBudmUgPSB0aGlzLnZpZXdTdGFydCArICh2aWV3V2lkdGggKiB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoKSAvIG9sZEZQVztcblxuICAgICAgICB0aGlzLnZpZXdFbmQgPSBudmU7XG5cbiAgICAgICAgdmFyIHdpZCA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcU1heCA+IDAgJiYgdGhpcy52aWV3RW5kID4gdGhpcy5jdXJyZW50U2VxTWF4KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdFbmQgPSB0aGlzLmN1cnJlbnRTZXFNYXg7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGFydCA9IHRoaXMudmlld0VuZCAtIHdpZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlld1N0YXJ0IDwgMSkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhcnQgPSAxO1xuICAgICAgICAgICAgdGhpcy52aWV3RW5kID0gdGhpcy52aWV3U3RhcnQgKyB3aWQgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvblJ1bGVyKCk7XG5cbiAgICAgICAgaWYgKCFza2lwUmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy5zcGFjZUNoZWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlMb2NhdGlvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZ1bGxTY3JlZW4pIHtcbiAgICAgICAgdGhpcy5zZXRGdWxsU2NyZWVuSGVpZ2h0KCk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5zZXRGdWxsU2NyZWVuSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3QgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCAtIHRoaXMuYnJvd3NlckhvbGRlci5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5icm93c2VySG9sZGVyLnN0eWxlLm1heEhlaWdodCA9IE1hdGgubWF4KDMwMCwgd2luZG93LmlubmVySGVpZ2h0IC0gcmVzdCAtIDIwKSArICdweCdcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuYWRkVGllciA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIGNvbmYgPSBzaGFsbG93Q29weShjb25mKTtcbiAgICBjb25mLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlVGllcihjb25mKS50aGVuKGZ1bmN0aW9uICh0aWVyKSB7XG4gICAgICAgIHRoaXNCLnJlZnJlc2hUaWVyKHRpZXIpO1xuICAgICAgICB0aGlzQi5tYXJrU2VsZWN0ZWRUaWVycygpO1xuICAgICAgICB0aGlzQi5wb3NpdGlvblJ1bGVyKCk7XG4gICAgICAgIHRoaXNCLm5vdGlmeVRpZXIoXCJhZGRlZFwiLCB0aWVyKTtcbiAgICAgICAgcmV0dXJuIHRpZXI7XG4gICAgfSlcbn07XG5cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlVGllciA9IGZ1bmN0aW9uKGNvbmYsIGZvcmNlKSB7XG4gICAgdmFyIHRhcmdldCA9IC0xO1xuXG4gICAgaWYgKHR5cGVvZiBjb25mLmluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBjb25mLmluZGV4ID49MCAmJiBjb25mLmluZGV4IDwgdGhpcy50aWVycy5sZW5ndGgpIHtcbiAgICAgICAgdGFyZ2V0ID0gY29uZi5pbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgIHZhciB0cyA9IHRoaXMudGllcnNbdGldLmRhc1NvdXJjZTtcblxuICAgICAgICAgICAgaWYgKHNvdXJjZXNBcmVFcXVhbChjb25mLCB0cykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aTsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0IDwgMCkge1xuICAgICAgICB0aHJvdyBcIkNvdWxkbid0IGZpbmQgcmVxdWVzdGVkIHRpZXJcIjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0VGllciA9IHRoaXMudGllcnNbdGFyZ2V0XTtcbiAgICB0aGlzLnRpZXJzLnNwbGljZSh0YXJnZXQsIDEpO1xuXG4gICAgdmFyIG5zdCA9IFtdO1xuICAgIGZvciAodmFyIHN0aSA9IDA7IHN0aSA8IHRoaXMuc2VsZWN0ZWRUaWVycy5sZW5ndGg7ICsrc3RpKSB7XG4gICAgICAgIHZhciBzdCA9IHRoaXMuc2VsZWN0ZWRUaWVyc1tzdGldO1xuICAgICAgICBpZiAoc3QgPCB0YXJnZXQpIHtcbiAgICAgICAgICAgIG5zdC5wdXNoKHN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdCA+IHRhcmdldCkge1xuICAgICAgICAgICAgbnN0LnB1c2goc3QgLSAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkVGllcnMgPSBuc3Q7XG4gICAgdGhpcy5tYXJrU2VsZWN0ZWRUaWVycygpO1xuXG4gICAgdGFyZ2V0VGllci5kZXN0cm95KCk7XG4gICAgaWYgKHRoaXMua25vd25TcGFjZSkge1xuICAgICAgICB0aGlzLmtub3duU3BhY2UuZmVhdHVyZUNhY2hlW3RhcmdldFRpZXJdID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnJlb3JkZXJUaWVycygpO1xuICAgIHRoaXMubm90aWZ5VGllcihcInJlbW92ZWRcIiwgdGFyZ2V0VGllcik7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlbW92ZUFsbFRpZXJzID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5zZWxlY3RlZFRpZXJzID0gW107XG4gICAgdGhpcy5tYXJrU2VsZWN0ZWRUaWVycygpO1xuICAgIHRoaXMudGllcnMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0VGllcikge1xuICAgICAgICB0YXJnZXRUaWVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXNCLmtub3duU3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXNCLmtub3duU3BhY2UuZmVhdHVyZUNhY2hlW3RhcmdldFRpZXJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudGllcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnJlb3JkZXJUaWVycygpO1xuICAgIHRoaXMubm90aWZ5VGllcihcInJlbW92ZWRBbGxcIiwgbnVsbCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmdldFNlcXVlbmNlU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3NlcXVlbmNlU291cmNlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXMuX3NlcXVlbmNlU291cmNlID0gdGhpcy5fZ2V0U2VxdWVuY2VTb3VyY2UoKTtcbiAgICByZXR1cm4gdGhpcy5fc2VxdWVuY2VTb3VyY2U7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLl9nZXRTZXF1ZW5jZVNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICBpZiAodGhpcy50aWVyc1t0aV0uc2VxdWVuY2VTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpZXJzW3RpXS5zZXF1ZW5jZVNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLmRlZmF1bHRTb3VyY2VzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuZGVmYXVsdFNvdXJjZXNbc2ldO1xuICAgICAgICBpZiAocy5wcm92aWRlc19lbnRyeXBvaW50cyB8fCBzLnRpZXJfdHlwZSA9PSAnc2VxdWVuY2UnIHx8IHMudHdvQml0VVJJIHx8IHMudHdvQml0QmxvYikge1xuICAgICAgICAgICAgaWYgKHMudHdvQml0VVJJIHx8IHMudHdvQml0QmxvYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHdvQml0U2VxdWVuY2VTb3VyY2Uocyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMuZW5zZW1ibFVSSSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW5zZW1ibFNlcXVlbmNlU291cmNlKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERBU1NlcXVlbmNlU291cmNlKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uKG5ld0NociwgbmV3TWluLCBuZXdNYXgsIGNhbGxiYWNrLCBzb2Z0KSB7XG4gICAgaWYgKHR5cGVvZihuZXdNaW4pICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignbWluaW11bSBtdXN0IGJlIGEgbnVtYmVyIChnb3QgJyArIEpTT04uc3RyaW5naWZ5KG5ld01pbikgKyAnKScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mKG5ld01heCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdtYXhpbXVtIG11c3QgYmUgYSBudW1iZXIgKGdvdCAnICsgSlNPTi5zdHJpbmdpZnkobmV3TWF4KSArICcpJyk7XG4gICAgfVxuXG4gICAgaWYgKG5ld01pbiA+IG5ld01heCkge1xuICAgICAgICB2YXIgb2xkTmV3TWluID0gbmV3TWluO1xuICAgICAgICBuZXdNaW4gPSBuZXdNYXg7XG4gICAgICAgIG5ld01heCA9IG9sZE5ld01pbjtcbiAgICB9IGVsc2UgaWYgKG5ld01pbiA9PT0gbmV3TWF4KSB7XG4gICAgICAgIG5ld01heCArPSAxO1xuICAgIH1cblxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIGlmICgoIW5ld0NociB8fCBuZXdDaHIgPT0gdGhpcy5jaHIpICYmIHRoaXMuY3VycmVudFNlcU1heCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldExvY2F0aW9uKG51bGwsIG5ld01pbiwgbmV3TWF4LCBudWxsLCBjYWxsYmFjaywgc29mdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNzID0gdGhpcy5nZXRTZXF1ZW5jZVNvdXJjZSgpO1xuICAgICAgICBpZiAoIXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ05lZWQgYSBzZXF1ZW5jZSBzb3VyY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaW5kQ2hyID0gbmV3Q2hyIHx8IHRoaXMuY2hyO1xuICAgICAgICBzcy5nZXRTZXFJbmZvKGZpbmRDaHIsIGZ1bmN0aW9uKHNpKSB7XG4gICAgICAgICAgICBpZiAoIXNpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsdENocjtcbiAgICAgICAgICAgICAgICBpZiAoZmluZENoci5pbmRleE9mKCdjaHInKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdENociA9IGZpbmRDaHIuc3Vic3RyKDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdENociA9ICdjaHInICsgZmluZENocjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3MuZ2V0U2VxSW5mbyhhbHRDaHIsIGZ1bmN0aW9uKHNpMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpMiAmJiBuZXdDaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhcIkNvdWxkbid0IGZpbmQgc2VxdWVuY2UgJ1wiICsgbmV3Q2hyICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5fc2V0TG9jYXRpb24obnVsbCwgbmV3TWluLCBuZXdNYXgsIG51bGwsIGNhbGxiYWNrLCBzb2Z0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5fc2V0TG9jYXRpb24oYWx0Q2hyLCBuZXdNaW4sIG5ld01heCwgc2kyLCBjYWxsYmFjaywgc29mdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLl9zZXRMb2NhdGlvbihuZXdDaHIsIG5ld01pbiwgbmV3TWF4LCBzaSwgY2FsbGJhY2ssIHNvZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLl9zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uKG5ld0NociwgbmV3TWluLCBuZXdNYXgsIG5ld0NockluZm8sIGNhbGxiYWNrLCBzb2Z0KSB7XG4gICAgdmFyIGNockNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAobmV3Q2hyKSB7XG4gICAgICAgIGlmIChuZXdDaHIuaW5kZXhPZignY2hyJykgPT0gMClcbiAgICAgICAgICAgIG5ld0NociA9IG5ld0Noci5zdWJzdHJpbmcoMyk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hyICE9IG5ld0NocilcbiAgICAgICAgICAgIGNockNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwibmV3IGNocjogXCIgKyBuZXdDaHIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9sZCBjaHI6IFwiICsgdGhpcy5jaHIpO1xuICAgICAgICB0aGlzLmNociA9IG5ld0NocjtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxTWF4ID0gbmV3Q2hySW5mby5sZW5ndGg7XG4gICAgfVxuXG4gICAgbmV3TWluID0gcGFyc2VGbG9hdChuZXdNaW4pOyBuZXdNYXg9cGFyc2VGbG9hdChuZXdNYXgpO1xuXG4gICAgdmFyIG5ld1dpZHRoID0gTWF0aC5tYXgoMTAsIG5ld01heC1uZXdNaW4rMSk7XG5cbiAgICBpZiAoIXNvZnQpIHtcbiAgICAgICAgdmFyIGNzbSA9IHRoaXMuY3VycmVudFNlcU1heDtcbiAgICAgICAgaWYgKGNzbSA8PSAwKVxuICAgICAgICAgICAgY3NtID0gMTAwMDAwMDAwMDAwMDtcbiAgICAgICAgaWYgKG5ld01pbiA8IDEpIHtcbiAgICAgICAgICAgIG5ld01pbiA9IDE7IG5ld01heCA9IG5ld01pbiArIG5ld1dpZHRoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3TWF4ID4gY3NtKSB7XG4gICAgICAgICAgICBuZXdNYXggPSBjc207XG4gICAgICAgICAgICBuZXdNaW4gPSBNYXRoLm1heCgxLCBuZXdNYXggLSBuZXdXaWR0aCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy52aWV3U3RhcnQgPSBuZXdNaW47XG4gICAgdGhpcy52aWV3RW5kID0gbmV3TWF4O1xuICAgIHZhciBuZXdTY2FsZSA9IE1hdGgubWF4KHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggfHwgdGhpcy5vZmZzY3JlZW5Jbml0V2lkdGgsIDUwKSAvICh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCk7XG4gICAgdmFyIG9sZFNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB2YXIgc2NhbGVDaGFuZ2VkID0gKE1hdGguYWJzKG5ld1NjYWxlIC0gb2xkU2NhbGUpKSA+IDAuMDAwMDAxO1xuICAgIHRoaXMuc2NhbGUgPSBuZXdTY2FsZTtcblxuICAgIHZhciBuZXdaUywgb2xkWlM7XG4gICAgb2xkWlMgPSB0aGlzLnpvb21TbGlkZXJWYWx1ZTtcbiAgICB0aGlzLnpvb21TbGlkZXJWYWx1ZSA9IG5ld1pTID0gdGhpcy56b29tRXhwdCAqIE1hdGgubG9nKCh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCArIDEpIC8gdGhpcy56b29tQmFzZSk7XG5cbiAgICBpZiAoc2NhbGVDaGFuZ2VkIHx8IGNockNoYW5nZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnRpZXJzW2ldLnZpZXdwb3J0SG9sZGVyLnN0eWxlLmxlZnQgPSAnNTAwMHB4JztcbiAgICAgICAgICAgIHRoaXMudGllcnNbaV0ub3ZlcmxheS5zdHlsZS5sZWZ0ID0gJzUwMDBweCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICBpZiAodGhpcy5zYXZlZFpvb20pIHtcbiAgICAgICAgICAgIG5ld1pTIC09IHRoaXMuem9vbU1pbjtcbiAgICAgICAgICAgIG9sZFpTIC09IHRoaXMuem9vbU1pbjtcbiAgICAgICAgICAgIHZhciBkaWZUb0FjdGl2ZSA9IG5ld1pTIC0gb2xkWlM7XG4gICAgICAgICAgICB2YXIgZGlmVG9TYXZlZCA9IG5ld1pTIC0gdGhpcy5zYXZlZFpvb207XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmVG9BY3RpdmUpID4gTWF0aC5hYnMoZGlmVG9TYXZlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU25hcFpvb21pbmcgPSAhdGhpcy5pc1NuYXBab29taW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZWRab29tID0gb2xkWlM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzU25hcFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2F2ZWRab29tID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2aWV3Q2VudGVyID0gKHRoaXMudmlld1N0YXJ0ICsgdGhpcy52aWV3RW5kKS8yO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9ICh0aGlzLnZpZXdTdGFydCAtIHRoaXMudGllcnNbaV0ubm9yaWdpbikqdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMudGllcnNbaV0udmlld3BvcnRIb2xkZXIuc3R5bGUubGVmdCA9ICcnICsgKCgtb2Zmc2V0fDApIC0gMTAwMCkgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy50aWVyc1tpXS5kcmF3T3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlMb2NhdGlvbigpO1xuXG4gICAgdGhpcy5zcGFjZUNoZWNrKCk7XG4gICAgaWYgKHRoaXMuaW5zdHJ1bWVudEFjdGl2aXR5KVxuICAgICAgICB0aGlzLmFjdGl2aXR5U3RhcnRUaW1lID0gRGF0ZS5ub3coKXwwO1xuXG4gICAgLy8gdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNldENlbnRlckxvY2F0aW9uID0gZnVuY3Rpb24obmV3Q2hyLCBuZXdDZW50ZXJMb2MpIHtcbiAgICB2YXIgaGFsZldpZHRoID0gKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KS8yLFxuICAgIG5ld01pbiA9IG5ld0NlbnRlckxvYyAtIGhhbGZXaWR0aCxcbiAgICBuZXdNYXggPSBuZXdDZW50ZXJMb2MgKyBoYWxmV2lkdGg7XG4gICAgdGhpcy5zZXRMb2NhdGlvbihuZXdDaHIsIG5ld01pbiwgbmV3TWF4KTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucGluZ0FjdGl2aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmluc3RydW1lbnRBY3Rpdml0eSB8fCAhdGhpcy5hY3Rpdml0eVN0YXJ0VGltZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGFjdGl2aXR5ID0gMDtcbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgaWYgKHRoaXMudGllcnNbdGldLmxvYWRlckJ1dHRvbi5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpXG4gICAgICAgICAgICArK2FjdGl2aXR5O1xuICAgIH1cblxuICAgIGlmIChhY3Rpdml0eSA9PSAwKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpfDA7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHRvb2sgJyArIChub3ctdGhpcy5hY3Rpdml0eVN0YXJ0VGltZSkgKyAnbXMnKTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVN0YXJ0VGltZSA9IG51bGw7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hZGRJbml0TGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgdGhpcy5pbml0TGlzdGVuZXJzLnB1c2goaGFuZGxlcik7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmFkZEZlYXR1cmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLmZlYXR1cmVMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZUxpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlciwgb3B0cykge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy5mZWF0dXJlTGlzdGVuZXJzLCBoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubm90aWZ5RmVhdHVyZSA9IGZ1bmN0aW9uKGV2LCBmZWF0dXJlLCBoaXQsIHRpZXIpIHtcbiAgZm9yICh2YXIgZmxpID0gMDsgZmxpIDwgdGhpcy5mZWF0dXJlTGlzdGVuZXJzLmxlbmd0aDsgKytmbGkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUxpc3RlbmVyc1tmbGldKGV2LCBmZWF0dXJlLCBoaXQsIHRpZXIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhleC5zdGFjayk7XG4gICAgICB9XG4gIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuYWRkRmVhdHVyZUhvdmVyTGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy5mZWF0dXJlSG92ZXJMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZUhvdmVyTGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyLCBvcHRzKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLmZlYXR1cmVIb3Zlckxpc3RlbmVycywgaGFuZGxlcik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZUhvdmVyTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubm90aWZ5RmVhdHVyZUhvdmVyID0gZnVuY3Rpb24oZXYsIGZlYXR1cmUsIGhpdCwgdGllcikge1xuICAgIGZvciAodmFyIGZsaSA9IDA7IGZsaSA8IHRoaXMuZmVhdHVyZUhvdmVyTGlzdGVuZXJzLmxlbmd0aDsgKytmbGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUhvdmVyTGlzdGVuZXJzW2ZsaV0oZXYsIGZlYXR1cmUsIGhpdCwgdGllcik7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleC5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmFkZFZpZXdMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnZpZXdMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlVmlld0xpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlciwgb3B0cykge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy52aWV3TGlzdGVuZXJzLCBoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy52aWV3TGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubm90aWZ5TG9jYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnZzID0gTWF0aC5tYXgoMSwgdGhpcy52aWV3U3RhcnR8MCk7XG4gICAgdmFyIG52ZSA9IHRoaXMudmlld0VuZHwwO1xuICAgIGlmICh0aGlzLmN1cnJlbnRTZXFNYXggPiAwICYmIG52ZSA+IHRoaXMuY3VycmVudFNlcU1heClcbiAgICAgICAgbnZlID0gdGhpcy5jdXJyZW50U2VxTWF4O1xuXG4gICAgZm9yICh2YXIgbGxpID0gMDsgbGxpIDwgdGhpcy52aWV3TGlzdGVuZXJzLmxlbmd0aDsgKytsbGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmlld0xpc3RlbmVyc1tsbGldKFxuICAgICAgICAgICAgICAgIHRoaXMuY2hyLFxuICAgICAgICAgICAgICAgIG52cyxcbiAgICAgICAgICAgICAgICBudmUsXG4gICAgICAgICAgICAgICAgdGhpcy56b29tU2xpZGVyVmFsdWUsXG4gICAgICAgICAgICAgICAge2N1cnJlbnQ6IHRoaXMuem9vbVNsaWRlclZhbHVlLFxuICAgICAgICAgICAgICAgICBhbHRlcm5hdGU6ICh0aGlzLnNhdmVkWm9vbSt0aGlzLnpvb21NaW4pIHx8IHRoaXMuem9vbU1pbixcbiAgICAgICAgICAgICAgICAgaXNTbmFwWm9vbWluZzogdGhpcy5pc1NuYXBab29taW5nLFxuICAgICAgICAgICAgICAgICBtaW46IHRoaXMuem9vbU1pbixcbiAgICAgICAgICAgICAgICAgbWF4OiB0aGlzLnpvb21NYXh9LFxuICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGFydCxcbiAgICAgICAgICAgICAgICAgdGhpcy52aWV3RW5kKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4LnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuYWRkVGllckxpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHRoaXMudGllckxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZW1vdmVUaWVyTGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLnRpZXJMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLnRpZXJMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5ub3RpZnlUaWVyID0gZnVuY3Rpb24oc3RhdHVzLCB0aWVyKSB7XG4gICAgZm9yICh2YXIgdGxpID0gMDsgdGxpIDwgdGhpcy50aWVyTGlzdGVuZXJzLmxlbmd0aDsgKyt0bGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudGllckxpc3RlbmVyc1t0bGldKHN0YXR1cywgdGllcik7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleC5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmFkZFJlZ2lvblNlbGVjdExpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHRoaXMucmVnaW9uU2VsZWN0TGlzdGVuZXJzLnB1c2goaGFuZGxlcik7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlbW92ZVJlZ2lvblNlbGVjdExpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy5yZWdpb25TZWxlY3RMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLnJlZ2lvblNlbGVjdExpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLm5vdGlmeVJlZ2lvblNlbGVjdCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICBmb3IgKHZhciBybGkgPSAwOyBybGkgPCB0aGlzLnJlZ2lvblNlbGVjdExpc3RlbmVycy5sZW5ndGg7ICsrcmxpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvblNlbGVjdExpc3RlbmVyc1tybGldKGNociwgbWluLCBtYXgpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXguc3RhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbkJyb3dzZXIucHJvdG90eXBlLmhpZ2hsaWdodFJlZ2lvbiA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgaWYgKGNociA9PSB0aGlzLmNocikge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0UmVnaW9uKGNociwgbWluLCBtYXgpO1xuICAgIH1cblxuICAgIHZhciBzcyA9IHRoaXMuZ2V0U2VxdWVuY2VTb3VyY2UoKTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIHRocm93ICdOZWVkIGEgc2VxdWVuY2Ugc291cmNlJztcbiAgICB9XG5cbiAgICBzcy5nZXRTZXFJbmZvKGNociwgZnVuY3Rpb24oc2kpIHtcbiAgICAgICAgaWYgKCFzaSkge1xuICAgICAgICAgICAgdmFyIGFsdENocjtcbiAgICAgICAgICAgIGlmIChjaHIuaW5kZXhPZignY2hyJykgPT0gMCkge1xuICAgICAgICAgICAgICAgIGFsdENociA9IGNoci5zdWJzdHIoMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsdENociA9ICdjaHInICsgY2hyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3MuZ2V0U2VxSW5mbyhhbHRDaHIsIGZ1bmN0aW9uKHNpMikge1xuICAgICAgICAgICAgICAgIGlmICghc2kyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLl9oaWdobGlnaHRSZWdpb24oYWx0Q2hyLCBtaW4sIG1heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc0IuX2hpZ2hsaWdodFJlZ2lvbihjaHIsIG1pbiwgbWF4KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5faGlnaGxpZ2h0UmVnaW9uID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCkge1xuICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCB0aGlzLmhpZ2hsaWdodHMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5oaWdobGlnaHRzW2hpXTtcbiAgICAgICAgaWYgKGguY2hyID09IGNociAmJiBoLm1pbiA9PSBtaW4gJiYgaC5tYXggPT0gbWF4KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGlnaGxpZ2h0cy5wdXNoKG5ldyBSZWdpb24oY2hyLCBtaW4sIG1heCkpO1xuICAgIHZhciB2aXNTdGFydCA9IHRoaXMudmlld1N0YXJ0IC0gKDEwMDAvdGhpcy5zY2FsZSk7XG4gICAgdmFyIHZpc0VuZCA9IHRoaXMudmlld0VuZCArICgxMDAwL3RoaXMuc2NhbGUpO1xuICAgIGlmICgoY2hyID09IHRoaXMuY2hyIHx8IGNociA9PSAoJ2NocicrdGhpcy5jaHIpKSAmJiBtaW4gPCB2aXNFbmQgJiYgbWF4ID4gdmlzU3RhcnQpIHtcbiAgICAgICAgdGhpcy5kcmF3T3ZlcmxheXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeUxvY2F0aW9uKCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlnaGxpZ2h0cyA9IFtdO1xuICAgIHRoaXMuZHJhd092ZXJsYXlzKCk7XG4gICAgdGhpcy5ub3RpZnlMb2NhdGlvbigpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5kcmF3T3ZlcmxheXMgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgdGhpcy50aWVyc1t0aV0uZHJhd092ZXJsYXkoKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmZlYXR1cmVzSW5SZWdpb24gPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4KSB7XG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgaWYgKGNociAhPT0gdGhpcy5jaHIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgZmwgPSB0aGlzLnRpZXJzW3RpXS5jdXJyZW50RmVhdHVyZXMgfHwgW107XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmbC5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxbZmldO1xuICAgICAgICAgICAgaWYgKGYubWluIDw9IG1heCAmJiBmLm1heCA+PSBtaW4pIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cblxuXG5Ccm93c2VyLnByb3RvdHlwZS5nZXRTZWxlY3RlZFRpZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZFRpZXJzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkVGllcnNbMF07XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gLTE7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNldFNlbGVjdGVkVGllciA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUaWVycyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUaWVycyA9IFt0XTtcbiAgICB9XG4gICAgdGhpcy5tYXJrU2VsZWN0ZWRUaWVycygpO1xuICAgIHRoaXMubm90aWZ5VGllclNlbGVjdGlvbigpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYXJrU2VsZWN0ZWRUaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy50aWVyc1t0aV0ubmFtZUJ1dHRvbjtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFRpZXJzLmluZGV4T2YodGkpID49IDApIHtcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zZWxlY3RlZFRpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGJyb3dzZXJNaWQgPSB0aGlzLmJyb3dzZXJIb2xkZXIub2Zmc2V0VG9wICsgdGhpcy5icm93c2VySG9sZGVyLm9mZnNldEhlaWdodC8yO1xuICAgICAgICBpZiAoYnJvd3Nlck1pZCA+IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wICYmIChicm93c2VyTWlkICsgMTAwKSA8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wICsgd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5icm93c2VySG9sZGVyLmZvY3VzKCk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hZGRUaWVyU2VsZWN0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgdGhpcy50aWVyU2VsZWN0aW9uTGlzdGVuZXJzLnB1c2goaGFuZGxlcik7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlbW92ZVRpZXJTZWxlY3Rpb25MaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMudGllclNlbGVjdGlvbkxpc3RlbmVycywgaGFuZGxlcik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMudGllclNlbGVjdGlvbkxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLm5vdGlmeVRpZXJTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBmbGkgPSAwOyBmbGkgPCB0aGlzLnRpZXJTZWxlY3Rpb25MaXN0ZW5lcnMubGVuZ3RoOyArK2ZsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy50aWVyU2VsZWN0aW9uTGlzdGVuZXJzW2ZsaV0odGhpcy5zZWxlY3RlZFRpZXJzKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4LnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hZGRUaWVyU2VsZWN0aW9uV3JhcExpc3RlbmVyID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMudGllclNlbGVjdGlvbldyYXBMaXN0ZW5lcnMucHVzaChmKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlVGllclNlbGVjdGlvbldyYXBMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMudGllclNlbGVjdGlvbldyYXBMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLnRpZXJTZWxlY3Rpb25XcmFwTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubm90aWZ5VGllclNlbGVjdGlvbldyYXAgPSBmdW5jdGlvbihpKSB7XG4gICAgZm9yICh2YXIgZmxpID0gMDsgZmxpIDwgdGhpcy50aWVyU2VsZWN0aW9uV3JhcExpc3RlbmVycy5sZW5ndGg7ICsrZmxpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRpZXJTZWxlY3Rpb25XcmFwTGlzdGVuZXJzW2ZsaV0oaSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleC5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuQnJvd3Nlci5wcm90b3R5cGUucG9zaXRpb25SdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaXNwbGF5ID0gJ25vbmUnO1xuICAgIHZhciBsZWZ0ID0gJyc7XG4gICAgdmFyIHJpZ2h0ID0gJyc7XG5cbiAgICBpZiAodGhpcy5ydWxlckxvY2F0aW9uID09ICdjZW50ZXInKSB7XG4gICAgICAgIGRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBsZWZ0ID0gJycgKyAoKHRoaXMuZmVhdHVyZVBhbmVsV2lkdGgvMil8MCkgKyAncHgnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ydWxlckxvY2F0aW9uID09ICdsZWZ0Jykge1xuICAgICAgICBkaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgbGVmdCA9ICcwcHgnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ydWxlckxvY2F0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHJpZ2h0ID0gJzBweCdcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXIuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgdGhpcy5ydWxlci5zdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJ1bGVyLnN0eWxlLnJpZ2h0ID0gcmlnaHQ7XG5cbiAgICBpZih0aGlzLnNpbmdsZUJhc2VIaWdobGlnaHQpIHtcbiAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLmJvcmRlcldpZHRoID0gJzFweCc7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICAgICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSAnMHB4J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUud2lkdGggPSB0aGlzLnNjYWxlICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSAnMXB4J1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvc2l0aW9uIGFjY29tcGFueWluZyBzaW5nbGUgYmFzZSBsb2NhdGlvbiB0ZXh0XG4gICAgICAgIHRoaXMubG9jU2luZ2xlQmFzZS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB2YXIgY2VudHJlT2Zmc2V0ID0gdGhpcy5mZWF0dXJlUGFuZWxXaWR0aC8yIC0gdGhpcy5sb2NTaW5nbGVCYXNlLm9mZnNldFdpZHRoLzIgKyB0aGlzLnJ1bGVyMi5vZmZzZXRXaWR0aC8yO1xuICAgICAgICB0aGlzLmxvY1NpbmdsZUJhc2Uuc3R5bGUubGVmdCA9ICcnICsgKGNlbnRyZU9mZnNldHwwKSArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2NTaW5nbGVCYXNlLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUud2lkdGggPSAnMXB4JztcbiAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUuYm9yZGVyV2lkdGggPSAnMHB4JztcbiAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUuZGlzcGxheSA9IHRoaXMucnVsZXJMb2NhdGlvbiA9PSAnY2VudGVyJyA/ICdub25lJyA6ICdibG9jayc7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcjIuc3R5bGUubGVmdCA9ICcnICsgKCh0aGlzLmZlYXR1cmVQYW5lbFdpZHRoLzIpfDApICsgJ3B4JztcblxuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgdGllciA9IHRoaXMudGllcnNbdGldO1xuICAgICAgICB2YXIgcSA9IHRpZXIucXVhbnRPdmVybGF5O1xuXG4gICAgICAgIHZhciBxdWFudDtcbiAgICAgICAgaWYgKHRpZXIuc3VidGllcnMgJiYgdGllci5zdWJ0aWVycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcXVhbnQgPSB0aWVyLnN1YnRpZXJzWzBdLnF1YW50O1xuXG4gICAgICAgIGlmIChxKSB7XG4gICAgICAgICAgICBxLnN0eWxlLmRpc3BsYXkgPSBxdWFudCA/IGRpc3BsYXkgOiAnbm9uZSc7XG4gICAgICAgICAgICBxLnN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgcS5zdHlsZS5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5mZWF0dXJlRG91YmxlQ2xpY2sgPSBmdW5jdGlvbihoaXQsIHJ4LCByeSkge1xuICAgIGlmICghaGl0IHx8IGhpdC5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGYgPSBoaXRbaGl0Lmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFmLm1pbiB8fCAhZi5tYXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmc3RhcnQgPSAoKChmLm1pbnwwKSAtICh0aGlzLnZpZXdTdGFydHwwKSkgKiB0aGlzLnNjYWxlKTtcbiAgICB2YXIgZndpZHRoID0gKCgoZi5tYXggLSBmLm1pbikgKyAxKSAqIHRoaXMuc2NhbGUpO1xuXG4gICAgdmFyIG5ld01pZCA9ICgoKGYubWlufDApICsgKGYubWF4fDApKSkvMjtcbiAgICBpZiAoZndpZHRoID4gMTApIHtcbiAgICAgICAgdmFyIGZyYWMgPSAoMS4wICogKHJ4IC0gZnN0YXJ0KSkgLyBmd2lkdGg7XG4gICAgICAgIGlmIChmcmFjIDwgMC4zKSB7XG4gICAgICAgICAgICBuZXdNaWQgPSAoZi5taW58MCk7XG4gICAgICAgIH0gZWxzZSAgaWYgKGZyYWMgPiAwLjcpIHtcbiAgICAgICAgICAgIG5ld01pZCA9IChmLm1heHwwKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSB0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydDtcbiAgICB0aGlzLnNldExvY2F0aW9uKG51bGwsIG5ld01pZCAtICh3aWR0aC8yKSwgbmV3TWlkICsgKHdpZHRoLzIpKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuem9vbUZvclNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcbiAgICB2YXIgc3NTY2FsZTtcbiAgICBpZiAoc2NhbGUgPiB0aGlzLmhpZ2hab29tVGhyZXNob2xkKSB7XG4gICAgICAgIHNzU2NhbGUgPSAnaGlnaCc7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA+IHRoaXMubWVkaXVtWm9vbVRocmVzaG9sZCkge1xuICAgICAgICBzc1NjYWxlID0gJ21lZGl1bSc7XG4gICAgfSBlbHNlICB7XG4gICAgICAgIHNzU2NhbGUgPSAnbG93JztcbiAgICB9XG4gICAgcmV0dXJuIHNzU2NhbGU7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnpvb21Gb3JDdXJyZW50U2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy56b29tRm9yU2NhbGUodGhpcy5zY2FsZSk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aWVyVG90YWwgPSAwO1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSlcbiAgICAgICAgdGllclRvdGFsICs9ICh0aGlzLnRpZXJzW3RpXS5jdXJyZW50SGVpZ2h0IHx8IDMwKTtcbiAgICB0aGlzLnJ1bGVyLnN0eWxlLmhlaWdodCA9ICcnICsgdGllclRvdGFsICsgJ3B4JztcbiAgICB0aGlzLnJ1bGVyMi5zdHlsZS5oZWlnaHQgPSAnJyArIHRpZXJUb3RhbCArICdweCc7XG4gICAgdGhpcy5icm93c2VySG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuYnJvd3NlckhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJy13ZWJraXQtZmxleCc7XG4gICAgdGhpcy5icm93c2VySG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgLy8gdGhpcy5zdmdIb2xkZXIuc3R5bGUubWF4SGVpZ2h0ID0gJycgKyBNYXRoLm1heCh0aWVyVG90YWwsIDUwMCkgKyAncHgnO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5zY3JvbGxBcnJvd0tleSA9IGZ1bmN0aW9uKGV2LCBkaXIpIHtcbiAgICBpZiAodGhpcy5yZXZlcnNlS2V5U2Nyb2xsaW5nKVxuICAgICAgICBkaXIgPSAtZGlyO1xuXG4gICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICB2YXIgZmVkZ2UgPSBmYWxzZTtcbiAgICAgICAgaWYoZXYuc2hpZnRLZXkpe1xuICAgICAgICAgICAgZmVkZ2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sZWFwKGRpciwgZmVkZ2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY2FsZSA+IDEpIHtcbiAgICAgICAgLy8gcGVyLWJhc2Ugc2Nyb2xsaW5nIG1vZGUsIHRyaWVzIHRvIHBlcmZlY3RseSBjZW50ZXIuXG4gICAgICAgIHZhciBtaWQgPSAodGhpcy52aWV3U3RhcnQgKyB0aGlzLnZpZXdFbmQpLzJcbiAgICAgICAgdmFyIGVyciA9IG1pZCAtIE1hdGgucm91bmQobWlkKTtcbiAgICAgICAgdmFyIG4gPSAxO1xuICAgICAgICBpZiAoZXYuc2hpZnRLZXkpXG4gICAgICAgICAgICBuICo9IDEwO1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgbiA9IC1uO1xuICAgICAgICAgICAgbiAtPSBlcnI7XG4gICAgICAgICAgICBpZiAoZXJyID4gMClcbiAgICAgICAgICAgICAgICBuICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuIC09IGVycjtcbiAgICAgICAgICAgIGlmIChlcnIgPCAwKVxuICAgICAgICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldExvY2F0aW9uKG51bGwsIHRoaXMudmlld1N0YXJ0ICsgbiwgdGhpcy52aWV3RW5kICsgbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb3ZlKGV2LnNoaWZ0S2V5ID8gMTAwKmRpciA6IDI1KmRpcik7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5sZWFwID0gZnVuY3Rpb24oZGlyLCBmZWRnZSkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIHBvcz0oKHRoaXNCLnZpZXdTdGFydCArIHRoaXNCLnZpZXdFbmQgKyAxKS8yKXwwO1xuICAgIGlmIChkaXIgPiAwICYmIHRoaXNCLnZpZXdTdGFydCA8PSAxKSB7XG4gICAgICAgIHBvcyAtPSAxMDAwMDAwMDA7XG4gICAgfSBlbHNlIGlmIChkaXIgPCAwICYmIHRoaXNCLnZpZXdFbmQgPj0gdGhpc0IuY3VycmVudFNlcU1heCkge1xuICAgICAgICBwb3MgKz0gMTAwMDAwMDAwO1xuICAgIH1cblxuICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICB2YXIgdGllciA9IHRoaXNCLnRpZXJzW3N0XTtcblxuICAgIGlmICh0aWVyICYmICgodGllci5mZWF0dXJlU291cmNlICYmIHRoaXMuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdxdWFudExlYXAnKSAmJiB0eXBlb2YodGllci5xdWFudExlYXBUaHJlc2hvbGQpID09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICB8fCAodGllci5mZWF0dXJlU291cmNlICYmIHRoaXMuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdsZWFwJykpKSkge1xuICAgICAgICB0aWVyLmZpbmROZXh0RmVhdHVyZShcbiAgICAgICAgICAgICAgdGhpc0IuY2hyLFxuICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgIC1kaXIsXG4gICAgICAgICAgICAgIGZlZGdlLFxuICAgICAgICAgICAgICBmdW5jdGlvbihueHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChueHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbm1pbiA9IG54dC5taW47XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5tYXggPSBueHQubWF4O1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5taW4+cG9zKzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXg9bm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5taW49bm1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChubWF4PHBvcy0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm1pbj1ubWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXg9bm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWQgPSB0aGlzQi52aWV3RW5kIC0gdGhpc0Iudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICBpZihwYXJzZUZsb2F0KHdpZC8yKSA9PSBwYXJzZUludCh3aWQvMikpe3dpZC0tO31cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSAobm1pbiArIG5tYXggLSB3aWQpLzIgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbmQgPSBuZXdTdGFydCArIHdpZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBvczI9cG9zO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnNldExvY2F0aW9uKG54dC5zZWdtZW50LCBuZXdTdGFydCwgbmV3RW5kKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ25vIG5leHQgZmVhdHVyZScpOyAvLyBGSVhNRSBiZXR0ZXIgcmVwb3J0aW5nIHdvdWxkIGJlIG5pY2UhXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW92ZSgxMDAqZGlyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdseXBoTG9va3VwKGdseXBocywgcngsIHJ5LCBtYXRjaGVzKSB7XG4gICAgbWF0Y2hlcyA9IG1hdGNoZXMgfHwgW107XG5cbiAgICBmb3IgKHZhciBnaSA9IGdseXBocy5sZW5ndGggLSAxOyBnaSA+PSAwOyAtLWdpKSB7XG4gICAgICAgIHZhciBnID0gZ2x5cGhzW2dpXTtcbiAgICAgICAgaWYgKCFnLm5vdFNlbGVjdGFibGUgJiYgZy5taW4oKSA8PSByeCAmJiBnLm1heCgpID49IHJ4KSB7XG4gICAgICAgICAgICBpZiAoZy5taW5ZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ5IDwgZy5taW5ZKCkgfHwgcnkgPiBnLm1heFkoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnLmZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZy5mZWF0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZy5ncm91cCkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChnLmdyb3VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGcuZ2x5cGhzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdseXBoTG9va3VwKGcuZ2x5cGhzLCByeCwgcnksIG1hdGNoZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnLmdseXBoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdseXBoTG9va3VwKFtnLmdseXBoXSwgcngsIHJ5LCBtYXRjaGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLm5hbWVGb3JDb29yZFN5c3RlbSA9IGZ1bmN0aW9uKGNzKSB7XG4gICAgdmFyIHByaW1hcnkgPSBudWxsLCB1Y3NjID0gbnVsbDtcbiAgICBpZiAodGhpcy5hc3NlbWJseU5hbWVQcmltYXJ5KSB7XG4gICAgICAgIHByaW1hcnkgPSAnJyArIGNzLmF1dGg7XG4gICAgICAgIGlmICh0eXBlb2YoY3MudmVyc2lvbikgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcHJpbWFyeSArPSBjcy52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5hc3NlbWJseU5hbWVVY3NjKSB7XG4gICAgICAgIHVjc2MgPSBjcy51Y3NjTmFtZTtcbiAgICB9XG4gICAgaWYgKHByaW1hcnkgIT0gbnVsbCAmJiB1Y3NjICE9IG51bGwpXG4gICAgICAgIHJldHVybiBwcmltYXJ5ICsgJy8nICsgdWNzYztcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBwcmltYXJ5IHx8IHVjc2MgfHwgJ3Vua25vd24nO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYWtlTG9hZGVyID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHNpemUgPSBzaXplIHx8IDE2O1xuICAgIHZhciByZXRpbmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG4gICAgaWYgKHNpemUgPCAyMCkge1xuICAgICAgICByZXR1cm4gbWFrZUVsZW1lbnQoJ2ltZycsIG51bGwsIHtzcmM6IHRoaXMucmVzb2x2ZVVSTCgnJCRpbWcvc3Bpbm5lcl8nICsgKHJldGluYSA/IDE2IDogMzIpICsgJy5naWYnKSwgd2lkdGg6ICcxNicsIGhlaWdodDogJzE2J30pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlRWxlbWVudCgnaW1nJywgbnVsbCwge3NyYzogdGhpcy5yZXNvbHZlVVJMKCckJGltZy9zcGlubmVyXycgKyAocmV0aW5hID8gMjQgOiA0OCkgKyAnLmdpZicpLCB3aWR0aDogJzI0JywgaGVpZ2h0OiAnMjQnfSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5jYW5GZXRjaFBsYWluSFRUUCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIXRoaXMuX3BsYWluSFRUUFByb21pc2UpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHRoaXMuZ2V0V29ya2VyKCk7XG4gICAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYWluSFRUUFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdENvbW1hbmQoXG4gICAgICAgICAgICAgICAgICAgIHtjb21tYW5kOiAndGV4dHhocicsXG4gICAgICAgICAgICAgICAgICAgICB1cmk6IHNlbGYuaHR0cENhbmFyeVVSTH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCwgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9wbGFpbkhUVFBQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGV4dFhIUihcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5odHRwQ2FuYXJ5VVJMLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXN1bHQsIGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7dGltZW91dDogMjAwMH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BsYWluSFRUUFByb21pc2U7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmdldFdvcmtlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy51c2VGZXRjaFdvcmtlcnMgfHwgIXRoaXMuZmV0Y2hXb3JrZXJzIHx8IHRoaXMuZmV0Y2hXb3JrZXJzLmxlbmd0aD09MClcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodGhpcy5uZXh0V29ya2VyID49IHRoaXMuZmV0Y2hXb3JrZXJzLmxlbmd0aClcbiAgICAgICAgdGhpcy5uZXh0V29ya2VyID0gMDtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFdvcmtlcnNbdGhpcy5uZXh0V29ya2VyKytdO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZWdpc3RlclJlc29sdmVyID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcbiAgICB2YXIgaWQgPSAncmVzJyArICgrK3RoaXMucmVzb2x2ZXJTZWVkKTtcbiAgICB0aGlzLnJlc29sdmVyc1tpZF0gPSByZXNvbHZlcjtcbiAgICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIEZldGNoV29ya2VyKGJyb3dzZXIsIHdvcmtlcikge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy50YWdTZWVkID0gMDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuYnJvd3NlciA9IGJyb3dzZXI7XG4gICAgdGhpcy53b3JrZXIgPSB3b3JrZXI7XG5cbiAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgZGF0YSA9IGV2LmRhdGE7XG5cbiAgICAgICAgaWYgKCFkYXRhLmNtZCkge1xuICAgICAgICAgICAgdmFyIGNiID0gdGhpc0IuY2FsbGJhY2tzW2RhdGEudGFnXTtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKGRhdGEucmVzdWx0LCBkYXRhLmVycm9yKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc0IuY2FsbGJhY2tzW2RhdGEudGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmNtZCA9PSAncmVzb2x2ZScpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHRoaXNCLmJyb3dzZXIucmVzb2x2ZXJzW2RhdGEucmVzb2x2ZXJdO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIoZGF0YS51cmwpLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IGRhdGEudGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogZGF0YS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnI6IGVyci50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gcmVzb2x2ZXIgJyArIGRhdGEucmVzb2x2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0JhZCB3b3JrZXIgY2FsbGJhY2sgJyArIGRhdGEuY21kKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VGZXRjaFdvcmtlcihicm93c2VyKSB7XG4gICAgdmFyIHd1cmwgPSBicm93c2VyLnJlc29sdmVVUkwoYnJvd3Nlci53b3JrZXJQYXRoKTtcbiAgICBpZiAod3VybC5pbmRleE9mKCcvLycpID09IDApIHtcbiAgICAgICAgdmFyIHByb3RvID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAocHJvdG8gPT0gJ2h0dHBzOicpXG4gICAgICAgICAgICB3dXJsID0gJ2h0dHBzOicgKyB3dXJsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3dXJsID0gJ2h0dHA6JyArIHd1cmw7XG4gICAgfVxuXG4gICAgdmFyIHdzY3JpcHQgPSAnaW1wb3J0U2NyaXB0cyhcIicgKyB3dXJsICsgJz92ZXJzaW9uPScgKyBWRVJTSU9OICsgJ1wiKTsnO1xuICAgIHZhciB3YmxvYiA9IG5ldyBCbG9iKFt3c2NyaXB0XSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pO1xuXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwod2Jsb2IpKTtcblxuICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5kYXRhLnRhZyA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEZldGNoV29ya2VyKGJyb3dzZXIsIHdvcmtlcikpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtlci5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHJlamVjdChldi5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5GZXRjaFdvcmtlci5wcm90b3R5cGUucG9zdENvbW1hbmQgPSBmdW5jdGlvbihjbWQsIGNhbGxiYWNrLCB0cmFuc2Zlcikge1xuICAgIHZhciB0YWcgPSAneCcgKyAoKyt0aGlzLnRhZ1NlZWQpO1xuICAgIGNtZC50YWcgPSB0YWc7XG4gICAgdGhpcy5jYWxsYmFja3NbdGFnXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKGNtZCwgdHJhbnNmZXIpO1xufVxuXG5GZXRjaFdvcmtlci5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgQnJvd3NlcjogQnJvd3NlclxuICAgIH07XG5cbiAgICAvLyBSZXF1aXJlZCBiZWNhdXNlIHRoZXkgYWRkIHN0dWZmIHRvIEJyb3dzZXIucHJvdG90eXBlXG4gICAgcmVxdWlyZSgnLi9icm93c2VyLXVpJyk7XG4gICAgcmVxdWlyZSgnLi90cmFjay1hZGRlcicpO1xuICAgIHJlcXVpcmUoJy4vZmVhdHVyZS1wb3B1cCcpO1xuICAgIHJlcXVpcmUoJy4vdGllci1hY3Rpb25zJyk7XG4gICAgcmVxdWlyZSgnLi9kb211aScpO1xuICAgIHJlcXVpcmUoJy4vc2VhcmNoJyk7XG5cbiAgICB2YXIgc2EgPSByZXF1aXJlKCcuL3NvdXJjZWFkYXB0ZXJzJyk7XG4gICAgdmFyIFR3b0JpdFNlcXVlbmNlU291cmNlID0gc2EuVHdvQml0U2VxdWVuY2VTb3VyY2U7XG4gICAgdmFyIEVuc2VtYmxTZXF1ZW5jZVNvdXJjZSA9IHNhLkVuc2VtYmxTZXF1ZW5jZVNvdXJjZTtcbiAgICB2YXIgREFTU2VxdWVuY2VTb3VyY2UgPSBzYS5EQVNTZXF1ZW5jZVNvdXJjZTtcblxuICAgIHZhciBLbm93blNwYWNlID0gcmVxdWlyZSgnLi9rc3BhY2UnKS5Lbm93blNwYWNlO1xuXG4gICAgdmFyIERBU1JlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9kYXMnKS5EQVNSZWdpc3RyeTtcbn1cblxuZnVuY3Rpb24gU291cmNlQ2FjaGUoKSB7XG4gICAgdGhpcy5zb3VyY2VzQnlVUkkgPSB7fVxufVxuXG5Tb3VyY2VDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oY29uZikge1xuICAgIHZhciBzY2IgPSB0aGlzLnNvdXJjZXNCeVVSSVtzb3VyY2VEYXRhVVJJKGNvbmYpXTtcbiAgICBpZiAoc2NiKSB7XG4gICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzY2IuY29uZmlncy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VzQXJlRXF1YWxNb2R1bG9TdHlsZShzY2IuY29uZmlnc1tzaV0sIGNvbmYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYi5zb3VyY2VzW3NpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuU291cmNlQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKGNvbmYsIHNvdXJjZSkge1xuICAgIHZhciB1cmkgPSBzb3VyY2VEYXRhVVJJKGNvbmYpO1xuICAgIHZhciBzY2IgPSB0aGlzLnNvdXJjZXNCeVVSSVt1cmldO1xuICAgIGlmICghc2NiKSB7XG4gICAgICAgIHNjYiA9IHtjb25maWdzOiBbXSwgc291cmNlczogW119O1xuICAgICAgICB0aGlzLnNvdXJjZXNCeVVSSVt1cmldID0gc2NiO1xuICAgIH1cbiAgICBzY2IuY29uZmlncy5wdXNoKGNvbmYpO1xuICAgIHNjYi5zb3VyY2VzLnB1c2goc291cmNlKTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBjaGFpbnNldC5qczogbGlmdG92ZXIgc3VwcG9ydFxuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU1NvdXJjZSA9IGRhcy5EQVNTb3VyY2U7XG4gICAgdmFyIERBU1NlZ21lbnQgPSBkYXMuREFTU2VnbWVudDtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgcHVzaG8gPSB1dGlscy5wdXNobztcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcblxuICAgIHZhciBwYXJzZUNpZ2FyID0gcmVxdWlyZSgnLi9jaWdhcicpLnBhcnNlQ2lnYXI7XG5cbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgVVJMRmV0Y2hhYmxlID0gYmluLlVSTEZldGNoYWJsZTtcblxuICAgIHZhciBiYmkgPSByZXF1aXJlKCcuL2JpZ3dpZycpO1xuICAgIHZhciBtYWtlQndnID0gYmJpLm1ha2VCd2c7XG5cbiAgICB2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gQ2hhaW5zZXQoY29uZiwgc3JjVGFnLCBkZXN0VGFnLCBjb29yZHMpIHtcbiAgICBpZiAodHlwZW9mKGNvbmYpID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudXJpID0gY29uZjtcbiAgICAgICAgdGhpcy5zcmNUYWcgPSBzcmNUYWc7XG4gICAgICAgIHRoaXMuZGVzdFRhZyA9IGRlc3RUYWc7XG4gICAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXJpID0gY29uZi51cmk7XG4gICAgICAgIHRoaXMuc3JjVGFnID0gY29uZi5zcmNUYWc7XG4gICAgICAgIHRoaXMuZGVzdFRhZyA9IGNvbmYuZGVzdFRhZztcbiAgICAgICAgdGhpcy5jb29yZHMgPSBzaGFsbG93Q29weShjb25mLmNvb3Jkcyk7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbmYudHlwZTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNvbmYuY3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgdGhpcy5jaGFpbnNCeVNyYyA9IHt9O1xuICAgIHRoaXMuY2hhaW5zQnlEZXN0ID0ge307XG4gICAgdGhpcy5wb3N0RmV0Y2hRdWV1ZXMgPSB7fTtcbiAgICB0aGlzLmZldGNoZWRUaWxlcyA9IHt9O1xuICAgIHRoaXMuZ3JhbnVsYXJpdHkgPSAxMDAwMDAwOyAgLy8gc2l6ZSBpbiBiYXNlcyBvZiB0aWxlIHRvIGZldGNoXG5cbiAgICBpZiAodGhpcy50eXBlID09ICdiaWdiZWQnKSB7XG4gICAgICAgIHRoaXMuY2hhaW5GZXRjaGVyID0gbmV3IEJCSUNoYWluRmV0Y2hlcih0aGlzLnVyaSwgdGhpcy5jcmVkZW50aWFscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT0gJ2FsaWFzJykge1xuICAgICAgICB0aGlzLmNoYWluRmV0Y2hlciA9IG5ldyBBbGlhc0NoYWluRmV0Y2hlcihjb25mKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoYWluRmV0Y2hlciA9IG5ldyBEQVNDaGFpbkZldGNoZXIodGhpcy51cmksIHRoaXMuc3JjVGFnLCB0aGlzLmRlc3RUYWcpO1xuICAgIH1cbn07XG5cbkNoYWluc2V0LnByb3RvdHlwZS5leHBvcnRDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmk6IHRoaXMudXJpLFxuICAgICAgICBzcmNUYWc6IHRoaXMuc3JjVGFnLFxuICAgICAgICBkZXN0VGFnOiB0aGlzLmRlc3RUYWcsXG4gICAgICAgIGNvb3JkczogdGhpcy5jb29yZHMsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHNcbiAgICB9O1xufVxuXG5DaGFpbnNldC5wcm90b3R5cGUubWFwUG9pbnQgPSBmdW5jdGlvbihjaHIsIHBvcykge1xuICAgIHZhciBjaGFpbnMgPSB0aGlzLmNoYWluc0J5U3JjW2Nocl0gfHwgW107XG4gICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFpbnNbY2ldO1xuICAgICAgICBpZiAocG9zID49IGMuc3JjTWluICYmIHBvcyA8PSBjLnNyY01heCkge1xuICAgICAgICAgICAgdmFyIGNwb3M7XG4gICAgICAgICAgICBpZiAoYy5zcmNPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgY3BvcyA9IGMuc3JjTWF4IC0gcG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcG9zID0gcG9zIC0gYy5zcmNNaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmxvY2tzID0gYy5ibG9ja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gYmxvY2tzW2JpXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNyYyA9IGJbMF07XG4gICAgICAgICAgICAgICAgdmFyIGJEZXN0ID0gYlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNpemUgPSBiWzJdO1xuICAgICAgICAgICAgICAgIGlmIChjcG9zID49IGJTcmMgJiYgY3BvcyA8PSAoYlNyYyArIGJTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBvcyA9IGNwb3MgLSBiU3JjO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5kZXN0T3JpID09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHBvcyA9IGMuZGVzdE1heCAtIGJEZXN0IC0gYXBvcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwb3MgPSBhcG9zICsgYkRlc3QgKyBjLmRlc3RNaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzZXE6IGMuZGVzdENociwgcG9zOiBkcG9zLCBmbGlwcGVkOiAoYy5zcmNPcmkgIT0gYy5kZXN0T3JpKX1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbkNoYWluc2V0LnByb3RvdHlwZS5tYXBTZWdtZW50ID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCkge1xuICAgIHZhciBjaGFpbnMgPSB0aGlzLmNoYWluc0J5U3JjW2Nocl0gfHwgW107XG4gICAgdmFyIG1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFpbnNbY2ldO1xuICAgICAgICBpZiAobWF4ID49IGMuc3JjTWluICYmIG1pbiA8PSBjLnNyY01heCkge1xuICAgICAgICAgICAgdmFyIGNtaW4sIGNtYXg7XG4gICAgICAgICAgICBpZiAoYy5zcmNPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgY21pbiA9IGMuc3JjTWF4IC0gbWF4O1xuICAgICAgICAgICAgICAgIGNtYXggPSBjLnNyY01heCAtIG1pbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY21pbiA9IG1pbiAtIGMuc3JjTWluO1xuICAgICAgICAgICAgICAgIGNtYXggPSBtYXggLSBjLnNyY01pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBibG9ja3MgPSBjLmJsb2NrcztcbiAgICAgICAgICAgIGZvciAodmFyIGJpID0gMDsgYmkgPCBibG9ja3MubGVuZ3RoOyArK2JpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBibG9ja3NbYmldO1xuICAgICAgICAgICAgICAgIHZhciBiU3JjID0gYlswXTtcbiAgICAgICAgICAgICAgICB2YXIgYkRlc3QgPSBiWzFdO1xuICAgICAgICAgICAgICAgIHZhciBiU2l6ZSA9IGJbMl07XG4gICAgICAgICAgICAgICAgaWYgKGNtYXggPj0gYlNyYyAmJiBjbWluIDw9IChiU3JjICsgYlNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogYy5kZXN0Q2hyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxpcHBlZDogKGMuc3JjT3JpID09ICctJykgXiAoYy5kZXN0T3JpID09ICctJyl9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmRlc3RPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY21pbiA+PSBiU3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5tYXggPSBjLmRlc3RNYXggLSBiRGVzdCAtIGNtaW4gKyBiU3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm1heCA9IGMuZGVzdE1heCAtIGJEZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFydGlhbE1heCA9IGJTcmMgLSBjbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtYXggPD0gKGJTcmMgKyBiU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm1pbiA9IGMuZGVzdE1heCAtIGJEZXN0IC0gY21heCArIGJTcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ubWluID0gYy5kZXN0TWF4IC0gYkRlc3QgLSBiU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnBhcnRpYWxNaW4gPSBjbWF4IC0gYlNyYyAtIGJTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtaW4gPj0gYlNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ubWluID0gYy5kZXN0TWluICsgYkRlc3QgKyBjbWluIC0gYlNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5taW4gPSBjLmRlc3RNaW4gKyBiRGVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnBhcnRpYWxNaW4gPSBiU3JjIC0gY21pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbWF4IDw9IChiU3JjICsgYlNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5tYXggPSBjLmRlc3RNaW4gKyBiRGVzdCArIGNtYXggLSBiU3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm1heCA9IGMuZGVzdE1pbiArIGJEZXN0ICsgYlNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5wYXJ0aWFsTWF4ID0gY21heCAtIGJTcmMgLSBiU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5ncy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwcGluZ3M7XG59XG5cbkNoYWluc2V0LnByb3RvdHlwZS51bm1hcFBvaW50ID0gZnVuY3Rpb24oY2hyLCBwb3MpIHtcbiAgICB2YXIgY2hhaW5zID0gdGhpcy5jaGFpbnNCeURlc3RbY2hyXSB8fCBbXTtcbiAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY2hhaW5zLmxlbmd0aDsgKytjaSkge1xuICAgICAgICB2YXIgYyA9IGNoYWluc1tjaV07XG4gICAgICAgIGlmIChwb3MgPj0gYy5kZXN0TWluICYmIHBvcyA8PSBjLmRlc3RNYXgpIHtcbiAgICAgICAgICAgIHZhciBjcG9zO1xuICAgICAgICAgICAgaWYgKGMuc3JjT3JpID09ICctJykge1xuICAgICAgICAgICAgICAgIGNwb3MgPSBjLmRlc3RNYXggLSBwb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNwb3MgPSBwb3MgLSBjLmRlc3RNaW47XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYmxvY2tzID0gYy5ibG9ja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gYmxvY2tzW2JpXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNyYyA9IGJbMF07XG4gICAgICAgICAgICAgICAgdmFyIGJEZXN0ID0gYlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNpemUgPSBiWzJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNwb3MgPj0gYkRlc3QgJiYgY3BvcyA8PSAoYkRlc3QgKyBiU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwb3MgPSBjcG9zIC0gYkRlc3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRwb3MgPSBhcG9zICsgYlNyYyArIGMuc3JjTWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHBvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuZGVzdE9yaSA9PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwb3MgPSBjLnNyY01heCAtIGJTcmMgLSBhcG9zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHBvcyA9IGFwb3MgKyBiU3JjICsgYy5zcmNNaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzZXE6IGMuc3JjQ2hyLCBwb3M6IGRwb3MsIGZsaXBwZWQ6IChjLnNyY09yaSAhPSBjLmRlc3RPcmkpfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5DaGFpbnNldC5wcm90b3R5cGUuc291cmNlQmxvY2tzRm9yUmFuZ2UgPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBjYWxsYmFjaykge1xuICAgIHZhciBTVEFURV9QRU5ESU5HID0gMTtcbiAgICB2YXIgU1RBVEVfRkVUQ0hFRCA9IDI7XG5cbiAgICB2YXIgdGhpc0NTID0gdGhpcztcbiAgICB2YXIgbWluVGlsZSA9IChtaW4vdGhpcy5ncmFudWxhcml0eSl8MDtcbiAgICB2YXIgbWF4VGlsZSA9IChtYXgvdGhpcy5ncmFudWxhcml0eSl8MDtcblxuICAgIHZhciBuZWVkc05ld09yUGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBuZWVkc05ld0ZldGNoID0gZmFsc2U7XG4gICAgZm9yICh2YXIgdCA9IG1pblRpbGU7IHQgPD0gbWF4VGlsZTsgKyt0KSB7XG4gICAgICAgIHZhciB0biA9IGNociArICdfJyArIHQ7XG4gICAgICAgIGlmICh0aGlzLmZldGNoZWRUaWxlc1t0bl0gIT0gU1RBVEVfRkVUQ0hFRCkge1xuICAgICAgICAgICAgbmVlZHNOZXdPclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmV0Y2hlZFRpbGVzW3RuXSAhPSBTVEFURV9QRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaGVkVGlsZXNbdG5dID0gU1RBVEVfUEVORElORztcbiAgICAgICAgICAgICAgICBuZWVkc05ld0ZldGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc05ld09yUGVuZGluZykge1xuICAgICAgICBpZiAoIXRoaXMucG9zdEZldGNoUXVldWVzW2Nocl0pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhaW5GZXRjaGVyLmZldGNoQ2hhaW5zKFxuICAgICAgICAgICAgICAgIGNociwgXG4gICAgICAgICAgICAgICAgbWluVGlsZSAqIHRoaXMuZ3JhbnVsYXJpdHksIFxuICAgICAgICAgICAgICAgIChtYXhUaWxlKzEpICogdGhpcy5ncmFudWxhcml0eSAtIDEpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGNoYWlucykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpc0NTLmNoYWluc0J5RGVzdClcbiAgICAgICAgICAgICAgICAgICAgdGhpc0NTLmNoYWluc0J5RGVzdFtjaHJdID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gY2hhaW5zW2NpXTtcblxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2JzID0gdGhpc0NTLmNoYWluc0J5U3JjW2NoYWluLnNyY0Nocl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNicykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNDUy5jaGFpbnNCeVNyY1tjaGFpbi5zcmNDaHJdID0gW2NoYWluXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvY2kgPSAwOyBvY2kgPCBjYnMubGVuZ3RoOyArK29jaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2MgPSBjYnNbb2NpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9jLnNyY01pbiA9PSBjaGFpbi5zcmNNaW4gJiYgb2Muc3JjTWF4ID09IGNoYWluLnNyY01heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXNlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5wdXNoKGNoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYmQgPSB0aGlzQ1MuY2hhaW5zQnlEZXN0W2NoYWluLmRlc3RDaHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQ1MuY2hhaW5zQnlEZXN0W2NoYWluLmRlc3RDaHJdID0gW2NoYWluXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvY2kgPSAwOyBvY2kgPCBjYmQubGVuZ3RoOyArK29jaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2MgPSBjYmRbb2NpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9jLmRlc3RNaW4gPT0gY2hhaW4uZGVzdE1pbiAmJiBvYy5kZXN0TWF4ID09IGNoYWluLmRlc3RNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYmQucHVzaChjaGFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IG1pblRpbGU7IHQgPD0gbWF4VGlsZTsgKyt0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGNociArICdfJyArIHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNDUy5mZXRjaGVkVGlsZXNbdG5dID0gU1RBVEVfRkVUQ0hFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNDUy5wb3N0RmV0Y2hRdWV1ZXNbY2hyXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGZxID0gdGhpc0NTLnBvc3RGZXRjaFF1ZXVlc1tjaHJdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBmcS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGZxW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc0NTLnBvc3RGZXRjaFF1ZXVlc1tjaHJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICB9KTsgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2hvKHRoaXMucG9zdEZldGNoUXVldWVzLCBjaHIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gV2lsbCBlaXRoZXIgc3VjY2VlZCBpZiB0aGUgdGlsZXMgdGhhdCBhcmUgbmVlZGVkIGhhdmUgYWxyZWFkeSBiZWVuIGZldGNoZWQsXG4gICAgICAgICAgICAvLyBvciBxdWV1ZSB1cCBhIG5ldyBmZXRjaC5cblxuICAgICAgICAgICAgdGhpc0NTLnNvdXJjZUJsb2Nrc0ZvclJhbmdlKGNociwgbWluLCBtYXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyY0Jsb2NrcyA9IFtdO1xuICAgICAgICB2YXIgY2hhaW5zID0gdGhpcy5jaGFpbnNCeURlc3RbY2hyXSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hhaW5zW2NpXTtcbiAgICAgICAgICAgIGlmIChtaW4gPD0gYy5kZXN0TWF4ICYmIG1heCA+PSBjLmRlc3RNaW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY21pbiwgY21heDtcbiAgICAgICAgICAgICAgICBpZiAoYy5zcmNPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtaW4gPSBjLmRlc3RNYXggLSBtYXg7XG4gICAgICAgICAgICAgICAgICAgIGNtYXggPSBjLmRlc3RNYXggLSBtaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY21pbiA9IG1pbiAtIGMuZGVzdE1pbjtcbiAgICAgICAgICAgICAgICAgICAgY21heCA9IG1heCAtIGMuZGVzdE1pbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tzID0gYy5ibG9ja3M7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmkgPSAwOyBiaSA8IGJsb2Nrcy5sZW5ndGg7ICsrYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBibG9ja3NbYmldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYlNyYyA9IGJbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiRGVzdCA9IGJbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiU2l6ZSA9IGJbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtYXggPj0gYkRlc3QgJiYgY21pbiA8PSAoYkRlc3QgKyBiU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbWluID0gTWF0aC5tYXgoY21pbiwgYkRlc3QpIC0gYkRlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW1heCA9IE1hdGgubWluKGNtYXgsIGJEZXN0ICsgYlNpemUpIC0gYkRlc3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmRlc3RPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjQmxvY2tzLnB1c2gobmV3IERBU1NlZ21lbnQoYy5zcmNDaHIsIGMuc3JjTWF4IC0gYlNyYyAtIGFtYXgsIGMuc3JjTWF4IC0gYlNyYyAtIGFtaW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjQmxvY2tzLnB1c2gobmV3IERBU1NlZ21lbnQoYy5zcmNDaHIsIGMuc3JjTWluICsgYW1pbiArIGJTcmMsIGMuc3JjTWluICsgYW1heCArIGJTcmMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhzcmNCbG9ja3MpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gREFTQ2hhaW5GZXRjaGVyKHVyaSwgc3JjVGFnLCBkZXN0VGFnKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBuZXcgREFTU291cmNlKHVyaSk7XG4gICAgdGhpcy5zcmNUYWcgPSBzcmNUYWc7XG4gICAgdGhpcy5kZXN0VGFnID1kZXN0VGFnO1xufVxuXG5EQVNDaGFpbkZldGNoZXIucHJvdG90eXBlLmZldGNoQ2hhaW5zID0gZnVuY3Rpb24oY2hyLCBfbWluLCBfbWF4KSB7XG4gICAgdmFyIHRoaXNDUyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRoaXNDUy5zb3VyY2UuYWxpZ25tZW50cyhjaHIsIHt9LCBmdW5jdGlvbihhbGlnbnMpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYWkgPSAwOyBhaSA8IGFsaWducy5sZW5ndGg7ICsrYWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxuID0gYWxpZ25zW2FpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYWxuLmJsb2Nrcy5sZW5ndGg7ICsrYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gYWxuLmJsb2Nrc1tiaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmNTZWcsIGRlc3RTZWc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBibG9jay5zZWdtZW50cy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBibG9jay5zZWdtZW50c1tzaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gYWxuLm9iamVjdHNbc2VnLm9iamVjdF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmRiU291cmNlID09PSB0aGlzQ1Muc3JjVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjU2VnID0gc2VnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmouZGJTb3VyY2UgPT09IHRoaXNDUy5kZXN0VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFNlZyA9IHNlZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjU2VnICYmIGRlc3RTZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNDaHI6ICAgICBhbG4ub2JqZWN0c1tzcmNTZWcub2JqZWN0XS5hY2Nlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjTWluOiAgICAgc3JjU2VnLm1pbnwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY01heDogICAgIHNyY1NlZy5tYXh8MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPcmk6ICAgICBzcmNTZWcuc3RyYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RDaHI6ICAgIGFsbi5vYmplY3RzW2Rlc3RTZWcub2JqZWN0XS5hY2Nlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdE1pbjogICAgZGVzdFNlZy5taW58MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0TWF4OiAgICBkZXN0U2VnLm1heHwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RPcmk6ICAgIGRlc3RTZWcuc3RyYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrczogICAgIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNvcHMgPSBwYXJzZUNpZ2FyKHNyY1NlZy5jaWdhciksIGRlc3RvcHMgPSBwYXJzZUNpZ2FyKGRlc3RTZWcuY2lnYXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjT2Zmc2V0ID0gMCwgZGVzdE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjaSA9IDAsIGRlc3RpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmNpIDwgc3Jjb3BzLmxlbmd0aCAmJiBkZXN0aSA8IGRlc3RvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyY29wc1tzcmNpXS5vcCA9PSAnTScgJiYgZGVzdG9wc1tkZXN0aV0ub3AgPT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0xlbiA9IE1hdGgubWluKHNyY29wc1tzcmNpXS5jbnQsIGRlc3RvcHNbZGVzdGldLmNudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLmJsb2Nrcy5wdXNoKFtzcmNPZmZzZXQsIGRlc3RPZmZzZXQsIGJsb2NrTGVuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmNvcHNbc3JjaV0uY250ID09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3NyY2k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNvcHNbc3JjaV0uY250IC09IGJsb2NrTGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0b3BzW2Rlc3RpXS5jbnQgPT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGVzdGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0b3BzW2Rlc3RpXSAtPSBibG9ja0xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPZmZzZXQgKz0gYmxvY2tMZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RPZmZzZXQgKz0gYmxvY2tMZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcmNvcHNbc3JjaV0ub3AgPT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RPZmZzZXQgKz0gc3Jjb3BzW3NyY2krK10uY250O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVzdG9wc1tkZXN0aV0ub3AgPT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY09mZnNldCArPSBkZXN0b3BzW2Rlc3RpKytdLmNudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlucy5wdXNoKGNoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoY2hhaW5zKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIEJCSUNoYWluRmV0Y2hlcih1cmksIGNyZWRlbnRpYWxzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcblxuICAgIHRoaXMuYndnID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG1ha2VCd2cobmV3IFVSTEZldGNoYWJsZShzZWxmLnVyaSwge2NyZWRlbnRpYWxzOiBzZWxmLmNyZWRlbnRpYWxzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXI6IHNlbGYucmVzb2x2ZXJ9KSwgXG4gICAgICAgICAgZnVuY3Rpb24oYndnLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChid2cpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGJ3Zyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5id2cudGhlbihmdW5jdGlvbihid2csIGVycikge1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGkoeCkge1xuICAgIHJldHVybiBwYXJzZUludCh4KTtcbn1cblxuZnVuY3Rpb24gY2xlYW5DaHIoYykge1xuICAgIGlmIChjLmluZGV4T2YoJ2NocicpID09IDApXG4gICAgICAgIHJldHVybiBjLnN1YnN0cigzKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBiYmlGZWF0dXJlVG9DaGFpbihmZWF0dXJlKSB7XG4gICAgdmFyIGNoYWluID0ge1xuICAgICAgICBzcmNDaHI6ICAgICBjbGVhbkNocihmZWF0dXJlLnNyY0Nocm9tKSxcbiAgICAgICAgc3JjTWluOiAgICAgcGFyc2VJbnQoZmVhdHVyZS5zcmNTdGFydCksXG4gICAgICAgIHNyY01heDogICAgIHBhcnNlSW50KGZlYXR1cmUuc3JjRW5kKSxcbiAgICAgICAgc3JjT3JpOiAgICAgZmVhdHVyZS5zcmNPcmksXG4gICAgICAgIGRlc3RDaHI6ICAgIGNsZWFuQ2hyKGZlYXR1cmUuc2VnbWVudCksXG4gICAgICAgIGRlc3RNaW46ICAgIGZlYXR1cmUubWluIC0gMSwgICAgIC8vIENvbnZlcnQgYmFjayBmcm9tIGJpZ2JlZCBwYXJzZXJcbiAgICAgICAgZGVzdE1heDogICAgZmVhdHVyZS5tYXgsXG4gICAgICAgIGRlc3RPcmk6ICAgIGZlYXR1cmUub3JpLFxuICAgICAgICBibG9ja3M6ICAgICBbXVxuICAgIH07XG4gICAgdmFyIHNyY1N0YXJ0cyA9IGZlYXR1cmUuc3JjU3RhcnRzLnNwbGl0KCcsJykubWFwKHBpKTtcbiAgICB2YXIgZGVzdFN0YXJ0cyA9IGZlYXR1cmUuZGVzdFN0YXJ0cy5zcGxpdCgnLCcpLm1hcChwaSk7XG4gICAgdmFyIGJsb2NrTGVuZ3RocyA9IGZlYXR1cmUuYmxvY2tMZW5zLnNwbGl0KCcsJykubWFwKHBpKTtcbiAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgc3JjU3RhcnRzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICBjaGFpbi5ibG9ja3MucHVzaChbc3JjU3RhcnRzW2JpXSwgZGVzdFN0YXJ0c1tiaV0sIGJsb2NrTGVuZ3Roc1tiaV1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhaW47XG59XG5cbkJCSUNoYWluRmV0Y2hlci5wcm90b3R5cGUuZmV0Y2hDaGFpbnMgPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHRoaXMuYndnLnRoZW4oZnVuY3Rpb24oYndnLCBlcnIpIHtcbiAgICAgICAgaWYgKCFid2cpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vIEJXR1wiKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBid2cuZ2V0VW56b29tZWRWaWV3KCkucmVhZFdpZ0RhdGEoY2hyLCBtaW4sIG1heCwgZnVuY3Rpb24oZmVhdHMpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZlYXRzLm1hcChiYmlGZWF0dXJlVG9DaGFpbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gQWxpYXNDaGFpbkZldGNoZXIoY29uZikge1xuICAgIHRoaXMuY29uZiA9IGNvbmY7XG4gICAgdGhpcy5mb3J3YXJkQWxpYXNlcyA9IHt9O1xuICAgIHZhciBzYSA9IGNvbmYuc2VxdWVuY2VBbGlhc2VzIHx8IFtdO1xuICAgIGZvciAodmFyIGFpID0gMDsgYWkgPCBzYS5sZW5ndGg7ICsrYWkpIHtcbiAgICAgICAgdmFyIGFsID0gc2FbYWldO1xuICAgICAgICBpZiAoYWwubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBmYSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsLmxlbmd0aCAtIDE7ICsraSlcbiAgICAgICAgICAgIGZhLnB1c2goYWxbaV0pO1xuICAgICAgICB0aGlzLmZvcndhcmRBbGlhc2VzW2FsW2FsLmxlbmd0aCAtIDFdXSA9IGZhO1xuICAgIH1cbn1cblxuQWxpYXNDaGFpbkZldGNoZXIucHJvdG90eXBlLmZldGNoQ2hhaW5zID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCkge1xuICAgIHZhciByZXNwID0gW107XG4gICAgdmFyIGZhID0gdGhpcy5mb3J3YXJkQWxpYXNlc1tjaHJdIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzcC5wdXNoKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNyY0NocjogICAgICAgICBmYVtpXSxcbiAgICAgICAgICAgICAgICBzcmNNaW46ICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICBzcmNNYXg6ICAgICAgICAgMTAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBzcmNPcmk6ICAgICAgICAgJysnLFxuICAgICAgICAgICAgICAgIGRlc3RDaHI6ICAgICAgICBjaHIsXG4gICAgICAgICAgICAgICAgZGVzdE1pbjogICAgICAgIDEsXG4gICAgICAgICAgICAgICAgZGVzdE1heDogICAgICAgIDEwMDAwMDAwMDAsXG4gICAgICAgICAgICAgICAgZGVzdE9yaTogICAgICAgICcrJyxcbiAgICAgICAgICAgICAgICBibG9ja3M6IFtbMSwgMSwgMTAwMDAwMDAwMF1dXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3ApO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIENoYWluc2V0OiBDaGFpbnNldFxuICAgIH07XG59XG4iLCJcbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIGNoYWluc2V0LmpzOiBsaWZ0b3ZlciBzdXBwb3J0XG4vL1xuXG52YXIgQ0lHQVJfUkVHRVhQID0gbmV3IFJlZ0V4cCgnKFswLTldKikoW01JRFNdKScsICdnJyk7XG5cbmZ1bmN0aW9uIHBhcnNlQ2lnYXIoY2lnYXIpXG57XG4gICAgdmFyIGNpZ29wcyA9IFtdO1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gQ0lHQVJfUkVHRVhQLmV4ZWMoY2lnYXIpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjb3VudCA9IG1hdGNoWzFdO1xuICAgICAgICBpZiAoY291bnQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjaWdvcHMucHVzaCh7Y250OiBjb3VudHwwLCBvcDogbWF0Y2hbMl19KTtcbiAgICB9XG4gICAgcmV0dXJuIGNpZ29wcztcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBwYXJzZUNpZ2FyOiBwYXJzZUNpZ2FyXG4gICAgfTtcbn0iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gY29sb3IuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBEQ29sb3VyKHJlZCwgZ3JlZW4sIGJsdWUsIG5hbWUpIHtcbiAgICB0aGlzLnJlZCA9IHJlZHwwO1xuICAgIHRoaXMuZ3JlZW4gPSBncmVlbnwwO1xuICAgIHRoaXMuYmx1ZSA9IGJsdWV8MDtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbn1cblxuRENvbG91ci5wcm90b3R5cGUudG9TdmdTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBcInJnYihcIiArIHRoaXMucmVkICsgXCIsXCIgKyB0aGlzLmdyZWVuICsgXCIsXCIgKyB0aGlzLmJsdWUgKyBcIilcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5uYW1lO1xufVxuXG5mdW5jdGlvbiBoZXgyKHgpIHtcbiAgICB2YXIgeSA9ICcwMCcgKyB4LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4geS5zdWJzdHJpbmcoeS5sZW5ndGggLSAyKTtcbn1cblxuRENvbG91ci5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJyMnICsgaGV4Mih0aGlzLnJlZCkgKyBoZXgyKHRoaXMuZ3JlZW4pICsgaGV4Mih0aGlzLmJsdWUpO1xufVxuXG52YXIgcGFsZXR0ZSA9IHtcbiAgICByZWQ6IG5ldyBEQ29sb3VyKDI1NSwgMCwgMCwgJ3JlZCcpLFxuICAgIGdyZWVuOiBuZXcgRENvbG91cigwLCAyNTUsIDAsICdncmVlbicpLFxuICAgIGJsdWU6IG5ldyBEQ29sb3VyKDAsIDAsIDI1NSwgJ2JsdWUnKSxcbiAgICB5ZWxsb3c6IG5ldyBEQ29sb3VyKDI1NSwgMjU1LCAwLCAneWVsbG93JyksXG4gICAgd2hpdGU6IG5ldyBEQ29sb3VyKDI1NSwgMjU1LCAyNTUsICd3aGl0ZScpLFxuICAgIGJsYWNrOiBuZXcgRENvbG91cigwLCAwLCAwLCAnYmxhY2snKSxcbiAgICBncmF5OiBuZXcgRENvbG91cigxODAsIDE4MCwgMTgwLCAnZ3JheScpLFxuICAgIGdyZXk6IG5ldyBEQ29sb3VyKDE4MCwgMTgwLCAxODAsICdncmV5JyksXG4gICAgbGlnaHRza3libHVlOiBuZXcgRENvbG91cigxMzUsIDIwNiwgMjUwLCAnbGlnaHRza3libHVlJyksXG4gICAgbGlnaHRzYWxtb246IG5ldyBEQ29sb3VyKDI1NSwgMTYwLCAxMjIsICdsaWdodHNhbG1vbicpLFxuICAgIGhvdHBpbms6IG5ldyBEQ29sb3VyKDI1NSwgMTA1LCAxODAsICdob3RwaW5rJylcbn07XG5cbnZhciBDT0xPUl9SRSA9IG5ldyBSZWdFeHAoJ14jKFswLTlBLUZhLWZdezJ9KShbMC05QS1GYS1mXXsyfSkoWzAtOUEtRmEtZl17Mn0pJCcpO1xudmFyIENTU19DT0xPUl9SRSA9IC9yZ2JcXCgoWzAtOV0rKSwoWzAtOV0rKSwoWzAtOV0rKVxcKS9cblxuZnVuY3Rpb24gZGFzQ29sb3VyRm9yTmFtZShuYW1lKSB7XG4gICAgdmFyIGMgPSBwYWxldHRlW25hbWVdO1xuICAgIGlmICghYykge1xuICAgICAgICB2YXIgbWF0Y2ggPSBDT0xPUl9SRS5leGVjKG5hbWUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGMgPSBuZXcgRENvbG91cigoJzB4JyArIG1hdGNoWzFdKXwwLCAoJzB4JyArIG1hdGNoWzJdKXwwLCAoJzB4JyArIG1hdGNoWzNdKXwwLCBuYW1lKTtcbiAgICAgICAgICAgIHBhbGV0dGVbbmFtZV0gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgIFx0ICAgIG1hdGNoID0gQ1NTX0NPTE9SX1JFLmV4ZWMobmFtZSk7XG4gICAgXHQgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIFx0XHRjID0gbmV3IERDb2xvdXIobWF0Y2hbMV18MCwgbWF0Y2hbMl18MCwgbWF0Y2hbM118MCwgbmFtZSk7XG4gICAgICAgIFx0XHRwYWxldHRlW25hbWVdID0gYztcblx0ICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgY29uc29sZS5sb2coXCJjb3VsZG4ndCBoYW5kbGUgY29sb3I6IFwiICsgbmFtZSk7XG5cdFx0ICAgICAgYyA9IHBhbGV0dGUuYmxhY2s7XG5cdFx0ICAgICAgcGFsZXR0ZVtuYW1lXSA9IGM7XG5cdCAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIG1ha2VDb2xvdXJTdGVwcyhzdGVwcywgc3RvcHMsIGNvbG91cnMpIHtcbiAgICB2YXIgZGNvbG91cnMgPSBbXTtcbiAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY29sb3Vycy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgZGNvbG91cnMucHVzaChkYXNDb2xvdXJGb3JOYW1lKGNvbG91cnNbY2ldKSk7XG4gICAgfVxuXG4gICAgdmFyIGdyYWQgPSBbXTtcbiAgU1RFUF9MT09QOlxuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzdGVwczsgKytzaSkge1xuICAgICAgICB2YXIgcnMgPSAoMS4wICogc2kpIC8gKHN0ZXBzLTEpO1xuICAgICAgICB2YXIgc2NvcmUgPSBzdG9wc1swXSArIChzdG9wc1tzdG9wcy5sZW5ndGggLTFdIC0gc3RvcHNbMF0pICogcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmUgPj0gc3RvcHNbaV0gJiYgc2NvcmUgPD0gc3RvcHNbaSsxXSkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFjID0gKHNjb3JlIC0gc3RvcHNbaV0pIC8gKHN0b3BzW2krMV0gLSBzdG9wc1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhID0gZGNvbG91cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGNiID0gZGNvbG91cnNbaSsxXTtcblxuICAgICAgICAgICAgICAgIHZhciBmaWxsID0gbmV3IERDb2xvdXIoXG4gICAgICAgICAgICAgICAgICAgICgoY2EucmVkICogKDEuMCAtIGZyYWMpKSArIChjYi5yZWQgKiBmcmFjKSl8MCxcbiAgICAgICAgICAgICAgICAgICAgKChjYS5ncmVlbiAqICgxLjAgLSBmcmFjKSkgKyAoY2IuZ3JlZW4gKiBmcmFjKSl8MCxcbiAgICAgICAgICAgICAgICAgICAgKChjYS5ibHVlICogKDEuMCAtIGZyYWMpKSArIChjYi5ibHVlICogZnJhYykpfDBcbiAgICAgICAgICAgICAgICApLnRvU3ZnU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgZ3JhZC5wdXNoKGZpbGwpO1xuXG4gICAgICAgICAgICAgICAgY29udGludWUgU1RFUF9MT09QO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93ICdCYWQgc3RlcCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VHcmFkaWVudChzdGVwcywgY29sb3IxLCBjb2xvcjIsIGNvbG9yMykge1xuICAgIGlmIChjb2xvcjMpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDb2xvdXJTdGVwcyhzdGVwcywgWzAsIDAuNSwgMV0sIFtjb2xvcjEsIGNvbG9yMiwgY29sb3IzXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDb2xvdXJTdGVwcyhzdGVwcywgWzAsIDFdLCBbY29sb3IxLCBjb2xvcjJdKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbWFrZUNvbG91clN0ZXBzOiBtYWtlQ29sb3VyU3RlcHMsXG4gICAgICAgIG1ha2VHcmFkaWVudDogbWFrZUdyYWRpZW50LFxuICAgICAgICBkYXNDb2xvdXJGb3JOYW1lOiBkYXNDb2xvdXJGb3JOYW1lXG4gICAgfTtcbn1cbiIsIi8qIGpzaGludCBlc3ZlcnNpb246IDYgKi9cblxuaW1wb3J0ICogYXMgUGFwYSBmcm9tIFwicGFwYXBhcnNlXCI7XG5cbmV4cG9ydCB7IENzdkZpbGUsIGxvYWRDc3YgfTtcblxuZnVuY3Rpb24gQ3N2RmlsZSgpIHt9XG5cbmZ1bmN0aW9uIGxvYWRDc3YodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGxldCBjc3YgPSBuZXcgQ3N2RmlsZSgpO1xuXG4gICAgY3N2LnVyaSA9IHVyaTtcbiAgICBjc3Yub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgIGNhbGxiYWNrKGNzdik7XG4gICAgcmV0dXJuIGNzdjtcbn1cblxuQ3N2RmlsZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihkb25lQ2FsbGJhY2spIHtcbiAgICB2YXIgY29uZmlnID0geyBkb3dubG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVyciwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVzdWx0cywgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVDYWxsYmFjayhyZXN1bHRzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9O1xuXG4gICAgUGFwYS5wYXJzZSh0aGlzLnVyaSwgY29uZmlnKTtcbn07XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gZGFzLmpzOiBxdWVyaWVzIGFuZCBsb3ctbGV2ZWwgZGF0YSBtb2RlbC5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcbiAgICB2YXIgcHVzaG8gPSB1dGlscy5wdXNobztcblxuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4vY29sb3InKTtcbiAgICB2YXIgbWFrZUNvbG91clN0ZXBzID0gY29sb3IubWFrZUNvbG91clN0ZXBzO1xufVxuXG52YXIgZGFzTGliRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyTXNnKSB7XG4gICAgYWxlcnQoZXJyTXNnKTtcbn1cbnZhciBkYXNMaWJSZXF1ZXN0UXVldWUgPSBuZXcgQXJyYXkoKTtcblxuZnVuY3Rpb24gREFTU2VnbWVudChuYW1lLCBzdGFydCwgZW5kLCBkZXNjcmlwdGlvbikge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbn1cbkRBU1NlZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZSArICc6JyArIHRoaXMuc3RhcnQgKyAnLi4nICsgdGhpcy5lbmQ7XG59O1xuREFTU2VnbWVudC5wcm90b3R5cGUuaXNCb3VuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgJiYgdGhpcy5lbmQ7XG59XG5EQVNTZWdtZW50LnByb3RvdHlwZS50b0RBU1F1ZXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHEgPSAnc2VnbWVudD0nICsgdGhpcy5uYW1lO1xuICAgIGlmICh0aGlzLnN0YXJ0ICYmIHRoaXMuZW5kKSB7XG4gICAgICAgIHEgKz0gKCc6JyArIHRoaXMuc3RhcnQgKyAnLCcgKyB0aGlzLmVuZCk7XG4gICAgfVxuICAgIHJldHVybiBxO1xufVxuXG5cbmZ1bmN0aW9uIERBU1NvdXJjZShhMSwgYTIpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGExID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudXJpID0gYTE7XG4gICAgICAgIG9wdGlvbnMgPSBhMiB8fCB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gYTEgfHwge307XG4gICAgfVxuICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzW2tdID0gb3B0aW9uc1trXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29vcmRzKSB7XG4gICAgICAgIHRoaXMuY29vcmRzID0gW107XG4gICAgfVxuICAgIGlmICghdGhpcy5wcm9wcykge1xuICAgICAgICB0aGlzLnByb3BzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5kYXNCYXNlVVJJID0gdGhpcy51cmk7XG4gICAgaWYgKHRoaXMuZGFzQmFzZVVSSSAmJiB0aGlzLmRhc0Jhc2VVUkkuc3Vic3RyKHRoaXMudXJpLmxlbmd0aCAtIDEpICE9ICcvJykge1xuICAgICAgICB0aGlzLmRhc0Jhc2VVUkkgPSB0aGlzLmRhc0Jhc2VVUkkgKyAnLyc7XG4gICAgfVxufVxuXG5EQVNTb3VyY2UucHJvdG90eXBlLmdldFVSSSA9IGZ1bmN0aW9uKHVyaSkge1xuICAgIGlmICh0aGlzLnJlc29sdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyKHVyaSkudGhlbihmdW5jdGlvbiAodXJsT3JPYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsT3JPYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE9yT2JqO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsT3JPYmoudXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVyaSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBEQVNDb29yZHMoKSB7XG59XG5cbmZ1bmN0aW9uIGNvb3Jkc01hdGNoKGMxLCBjMikge1xuICAgIHJldHVybiBjMS50YXhvbiA9PSBjMi50YXhvbiAmJiBjMS5hdXRoID09IGMyLmF1dGggJiYgYzEudmVyc2lvbiA9PSBjMi52ZXJzaW9uO1xufVxuXG4vL1xuLy8gREFTIDEuNiBlbnRyeV9wb2ludHMgY29tbWFuZFxuLy9cblxuREFTU291cmNlLnByb3RvdHlwZS5lbnRyeVBvaW50cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhc1VSSSA9IHRoaXMuZGFzQmFzZVVSSSArICdlbnRyeV9wb2ludHMnO1xuICAgIHRoaXMuZG9Dcm9zc0RvbWFpblJlcXVlc3QoZGFzVVJJLCBmdW5jdGlvbihyZXNwb25zZVhNTCkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVhNTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW50cnlQb2ludHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgc2VncyA9IHJlc3BvbnNlWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdTRUdNRU5UJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnSWQgPSBzZWcuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ1NpemUgPSBzZWcuZ2V0QXR0cmlidXRlKCdzaXplJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdNaW4sIHNlZ01heDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01pbiA9IDE7IHNlZ01heCA9IHNlZ1NpemV8MDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01pbiA9IHNlZy5nZXRBdHRyaWJ1dGUoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnTWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnTWluIHw9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdNYXggPSBzZWcuZ2V0QXR0cmlidXRlKCdzdG9wJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnTWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnTWF4IHw9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ0Rlc2MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ0Rlc2MgPSBzZWcuZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW50cnlQb2ludHMucHVzaChuZXcgREFTU2VnbWVudChzZWdJZCwgc2VnTWluLCBzZWdNYXgsIHNlZ0Rlc2MpKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgIFxuICAgICAgICAgICAgICAgY2FsbGJhY2soZW50cnlQb2ludHMpO1xuICAgIH0pOyAgICAgICAgIFxufVxuXG4vL1xuLy8gREFTIDEuNiBzZXF1ZW5jZSBjb21tYW5kXG4vLyBEbyB3ZSBuZWVkIGFuIG9wdGlvbiB0byBmYWxsIGJhY2sgdG8gdGhlIGRuYSBjb21tYW5kP1xuLy9cblxuZnVuY3Rpb24gREFTU2VxdWVuY2UobmFtZSwgc3RhcnQsIGVuZCwgYWxwaGEsIHNlcSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIHRoaXMuYWxwaGFiZXQgPSBhbHBoYTtcbiAgICB0aGlzLnNlcSA9IHNlcTtcbn1cblxuREFTU291cmNlLnByb3RvdHlwZS5zZXF1ZW5jZSA9IGZ1bmN0aW9uKHNlZ21lbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhc1VSSSA9IHRoaXMuZGFzQmFzZVVSSSArICdzZXF1ZW5jZT8nICsgc2VnbWVudC50b0RBU1F1ZXJ5KCk7XG4gICAgdGhpcy5kb0Nyb3NzRG9tYWluUmVxdWVzdChkYXNVUkksIGZ1bmN0aW9uKHJlc3BvbnNlWE1MKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2VYTUwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKFtdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBzZWdzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1NFUVVFTkNFJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnSWQgPSBzZWcuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnTWluID0gc2VnLmdldEF0dHJpYnV0ZSgnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ01heCA9IHNlZy5nZXRBdHRyaWJ1dGUoJ3N0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ0FscGhhID0gJ0ROQSc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdTZXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdTZXEgPSBzZWcuZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdTZXEgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSByYXdTZXEuaW5kZXhPZignXFxuJywgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2UgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdTZXEgKz0gcmF3U2VxLnN1YnN0cmluZyhpZHgsIHNwYWNlKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBzcGFjZSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnU2VxICs9IHJhd1NlcS5zdWJzdHJpbmcoaWR4KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vxcy5wdXNoKG5ldyBEQVNTZXF1ZW5jZShzZWdJZCwgc2VnTWluLCBzZWdNYXgsIHNlZ0FscGhhLCBzZWdTZXEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2Vxcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLy9cbi8vIERBUyAxLjYgZmVhdHVyZXMgY29tbWFuZFxuLy9cblxuZnVuY3Rpb24gREFTRmVhdHVyZSgpIHtcbn1cblxuZnVuY3Rpb24gREFTR3JvdXAoaWQpIHtcbiAgICBpZiAoaWQpXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbn1cblxuZnVuY3Rpb24gREFTTGluayhkZXNjLCB1cmkpIHtcbiAgICB0aGlzLmRlc2MgPSBkZXNjO1xuICAgIHRoaXMudXJpID0gdXJpO1xufVxuXG5EQVNTb3VyY2UucHJvdG90eXBlLmZlYXR1cmVzID0gZnVuY3Rpb24oc2VnbWVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgdmFyIGRhc1VSSTtcbiAgICBpZiAodGhpcy5mZWF0dXJlc191cmkpIHtcbiAgICAgICAgZGFzVVJJID0gdGhpcy5mZWF0dXJlc191cmk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBbXTtcblxuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgZmlsdGVycy5wdXNoKHNlZ21lbnQudG9EQVNRdWVyeSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgZyA9IG9wdGlvbnMuZ3JvdXA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGcgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goJ2dyb3VwX2lkPScgKyBnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZ2kgPSAwOyBnaSA8IGcubGVuZ3RoOyArK2dpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCgnZ3JvdXBfaWQ9JyArIGdbZ2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hZGphY2VudCkge1xuICAgICAgICAgICAgdmFyIGFkaiA9IG9wdGlvbnMuYWRqYWNlbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFkaiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGFkaiA9IFthZGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgYWkgPSAwOyBhaSA8IGFkai5sZW5ndGg7ICsrYWkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goJ2FkamFjZW50PScgKyBhZGpbYWldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKCd0eXBlPScgKyBvcHRpb25zLnR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgb3B0aW9ucy50eXBlLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goJ3R5cGU9JyArIG9wdGlvbnMudHlwZVt0aV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4Ymlucykge1xuICAgICAgICAgICAgZmlsdGVycy5wdXNoKCdtYXhiaW5zPScgKyBvcHRpb25zLm1heGJpbnMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkYXNVUkkgPSB0aGlzLmRhc0Jhc2VVUkkgKyAnZmVhdHVyZXM/JyArIGZpbHRlcnMuam9pbignOycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soW10sICdObyBmaWx0ZXJzIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgfSBcbiAgIFxuXG4gICAgdGhpcy5kb0Nyb3NzRG9tYWluUmVxdWVzdChkYXNVUkksIGZ1bmN0aW9uKHJlc3BvbnNlWE1MLCByZXEpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZVhNTCkge1xuICAgICAgICAgICAgdmFyIG1zZztcbiAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDApIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnc2VydmVyIG1heSBub3Qgc3VwcG9ydCBDT1JTJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbXNnID0gJ3N0YXR1cz0nICsgcmVxLnN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKFtdLCAnRmFpbGVkIHJlcXVlc3Q6ICcgKyBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4vKiAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgIHZhciBjYXBzID0gcmVxLmdldFJlc3BvbnNlSGVhZGVyKCdYLURBUy1DYXBhYmlsdGllcycpO1xuICAgICAgICAgICAgaWYgKGNhcHMpIHtcbiAgICAgICAgICAgICAgICBhbGVydChjYXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAqL1xuXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB2YXIgc2VnbWVudE1hcCA9IHt9O1xuXG4gICAgICAgIHZhciBzZWdzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1NFR01FTlQnKTtcbiAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNlZ3MubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudFhNTCA9IHNlZ3Nbc2ldO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnRYTUwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgc2VnbWVudE1hcFtzZWdtZW50SURdID0ge1xuICAgICAgICAgICAgICAgIG1pbjogc2VnbWVudFhNTC5nZXRBdHRyaWJ1dGUoJ3N0YXJ0JyksXG4gICAgICAgICAgICAgICAgbWF4OiBzZWdtZW50WE1MLmdldEF0dHJpYnV0ZSgnc3RvcCcpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZmVhdHVyZVhNTHMgPSBzZWdtZW50WE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdGRUFUVVJFJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVYTUxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlWE1Mc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZGFzRmVhdHVyZSA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5zZWdtZW50ID0gc2VnbWVudElEO1xuICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUuaWQgPSBmZWF0dXJlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLmxhYmVsID0gZmVhdHVyZS5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG5cblxuLypcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGZlYXR1cmUuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNoaWxkTm9kZXMubGVuZ3RoOyArK2MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNuID0gY2hpbGROb2Rlc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNuLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gY24udGFnTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIHZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChjbi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHZhbCA9IGNuLmZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlW2tleV0gPSAneCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICovXG5cblxuICAgICAgICAgICAgICAgIHZhciBzcG9zID0gZWxlbWVudFZhbHVlKGZlYXR1cmUsIFwiU1RBUlRcIik7XG4gICAgICAgICAgICAgICAgdmFyIGVwb3MgPSBlbGVtZW50VmFsdWUoZmVhdHVyZSwgXCJFTkRcIik7XG4gICAgICAgICAgICAgICAgaWYgKChzcG9zfDApID4gKGVwb3N8MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5taW4gPSBlcG9zfDA7XG4gICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUubWF4ID0gc3Bvc3wwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUubWluID0gc3Bvc3wwO1xuICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLm1heCA9IGVwb3N8MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVjID0gZmVhdHVyZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnVFlQRScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZSA9IHRlY1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS50eXBlID0gdGUuZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLnR5cGVJZCA9IHRlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUudHlwZUN2ID0gdGUuZ2V0QXR0cmlidXRlKCdjdklkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGFzRmVhdHVyZS50eXBlID0gZWxlbWVudFZhbHVlKGZlYXR1cmUsIFwiVFlQRVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhc0ZlYXR1cmUudHlwZSAmJiBkYXNGZWF0dXJlLnR5cGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLnR5cGUgPSBkYXNGZWF0dXJlLnR5cGVJZDsgLy8gRklYTUU/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUubWV0aG9kID0gZWxlbWVudFZhbHVlKGZlYXR1cmUsIFwiTUVUSE9EXCIpO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaSA9IGVsZW1lbnRWYWx1ZShmZWF0dXJlLCBcIk9SSUVOVEFUSU9OXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUub3JpZW50YXRpb24gPSBvcmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUuc2NvcmUgPSBlbGVtZW50VmFsdWUoZmVhdHVyZSwgXCJTQ09SRVwiKTtcbiAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLmxpbmtzID0gZGFzTGlua3NPZihmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLm5vdGVzID0gZGFzTm90ZXNPZihmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzID0gZmVhdHVyZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkdST1VQXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGdpICA9IDA7IGdpIDwgZ3JvdXBzLmxlbmd0aDsgKytnaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBYTUwgPSBncm91cHNbZ2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGFzR3JvdXAgPSBuZXcgREFTR3JvdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgZGFzR3JvdXAudHlwZSA9IGdyb3VwWE1MLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgICAgICAgICBkYXNHcm91cC5pZCA9IGdyb3VwWE1MLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZGFzR3JvdXAubGlua3MgPSBkYXNMaW5rc09mKGdyb3VwWE1MKTtcbiAgICAgICAgICAgICAgICAgICAgZGFzR3JvdXAubm90ZXMgPSBkYXNOb3Rlc09mKGdyb3VwWE1MKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXNGZWF0dXJlLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5ncm91cHMgPSBuZXcgQXJyYXkoZGFzR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5ncm91cHMucHVzaChkYXNHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWdpYyBub3Rlcy4gIENoZWNrIHdpdGggVEFEIGJlZm9yZSBjaGFuZ2luZyB0aGlzLlxuICAgICAgICAgICAgICAgIGlmIChkYXNGZWF0dXJlLm5vdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5pID0gMDsgbmkgPCBkYXNGZWF0dXJlLm5vdGVzLmxlbmd0aDsgKytuaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBkYXNGZWF0dXJlLm5vdGVzW25pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmluZGV4T2YoJ0dlbmVuYW1lPScpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2cgPSBuZXcgREFTR3JvdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZy50eXBlPSdnZW5lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZy5pZCA9IG4uc3Vic3RyaW5nKDkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGFzRmVhdHVyZS5ncm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5ncm91cHMgPSBuZXcgQXJyYXkoZ2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUuZ3JvdXBzLnB1c2goZ2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZWMgPSBmZWF0dXJlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdQQVJUJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgcGVjLmxlbmd0aDsgKytwaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGVjW3BpXS5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlYyA9IGZlYXR1cmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1BBUkVOVCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgcGVjLmxlbmd0aDsgKytwaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwZWNbcGldLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLnBhcmVudHMgPSBwYXJlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZGFzRmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgY2FsbGJhY2soZmVhdHVyZXMsIHVuZGVmaW5lZCwgc2VnbWVudE1hcCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKFtdLCBlcnIpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBEQVNBbGlnbm1lbnQodHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5vYmplY3RzID0ge307XG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcbn1cblxuREFTU291cmNlLnByb3RvdHlwZS5hbGlnbm1lbnRzID0gZnVuY3Rpb24oc2VnbWVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGFzVVJJID0gdGhpcy5kYXNCYXNlVVJJICsgJ2FsaWdubWVudD9xdWVyeT0nICsgc2VnbWVudDtcbiAgICB0aGlzLmRvQ3Jvc3NEb21haW5SZXF1ZXN0KGRhc1VSSSwgZnVuY3Rpb24ocmVzcG9uc2VYTUwpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZVhNTCkge1xuICAgICAgICAgICAgY2FsbGJhY2soW10sICdGYWlsZWQgcmVxdWVzdCAnICsgZGFzVVJJKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGlnbm1lbnRzID0gW107XG4gICAgICAgIHZhciBhbGlYTUxzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2FsaWdubWVudCcpO1xuICAgICAgICBmb3IgKHZhciBhaSA9IDA7IGFpIDwgYWxpWE1Mcy5sZW5ndGg7ICsrYWkpIHtcbiAgICAgICAgICAgIHZhciBhbGlYTUwgPSBhbGlYTUxzW2FpXTtcbiAgICAgICAgICAgIHZhciBhbGkgPSBuZXcgREFTQWxpZ25tZW50KGFsaVhNTC5nZXRBdHRyaWJ1dGUoJ2FsaWduVHlwZScpKTtcbiAgICAgICAgICAgIHZhciBvYmpYTUxzID0gYWxpWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhbGlnbk9iamVjdCcpO1xuICAgICAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IG9ialhNTHMubGVuZ3RoOyArK29pKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ialhNTCA9IG9ialhNTHNbb2ldO1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAgICAgICAgICBvYmpYTUwuZ2V0QXR0cmlidXRlKCdpbnRPYmplY3RJZCcpLFxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3Npb246ICAgb2JqWE1MLmdldEF0dHJpYnV0ZSgnZGJBY2Nlc3Npb25JZCcpLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAgICAgb2JqWE1MLmdldEF0dHJpYnV0ZSgnb2JqZWN0VmVyc2lvbicpLFxuICAgICAgICAgICAgICAgICAgICBkYlNvdXJjZTogICAgb2JqWE1MLmdldEF0dHJpYnV0ZSgnZGJTb3VyY2UnKSxcbiAgICAgICAgICAgICAgICAgICAgZGJWZXJzaW9uOiAgIG9ialhNTC5nZXRBdHRyaWJ1dGUoJ2RiVmVyc2lvbicpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhbGkub2JqZWN0c1tvYmouaWRdID0gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYmxvY2tYTUxzID0gYWxpWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdibG9jaycpO1xuICAgICAgICAgICAgZm9yICh2YXIgYmkgPSAwOyBiaSA8IGJsb2NrWE1Mcy5sZW5ndGg7ICsrYmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tYTUwgPSBibG9ja1hNTHNbYmldO1xuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6ICAgICAgYmxvY2tYTUwuZ2V0QXR0cmlidXRlKCdibG9ja09yZGVyJyksXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzOiAgIFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc2VnWE1McyA9IGJsb2NrWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzZWdtZW50Jyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNlZ1hNTHMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdYTUwgPSBzZWdYTUxzW3NpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogICAgICBzZWdYTUwuZ2V0QXR0cmlidXRlKCdpbnRPYmplY3RJZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAgICAgICAgIHNlZ1hNTC5nZXRBdHRyaWJ1dGUoJ3N0YXJ0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6ICAgICAgICAgc2VnWE1MLmdldEF0dHJpYnV0ZSgnZW5kJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJhbmQ6ICAgICAgc2VnWE1MLmdldEF0dHJpYnV0ZSgnc3RyYW5kJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaWdhcjogICAgICAgZWxlbWVudFZhbHVlKHNlZ1hNTCwgJ2NpZ2FyJylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suc2VnbWVudHMucHVzaChzZWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbGkuYmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgICAgICAgfSAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBhbGlnbm1lbnRzLnB1c2goYWxpKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhhbGlnbm1lbnRzKTtcbiAgICB9KTtcbn1cblxuXG5mdW5jdGlvbiBEQVNTdHlsZXNoZWV0KCkge1xuICAgIHRoaXMuc3R5bGVzID0gW107XG59XG5cbkRBU1N0eWxlc2hlZXQucHJvdG90eXBlLnB1c2hTdHlsZSA9IGZ1bmN0aW9uKGZpbHRlcnMsIHpvb20sIHN0eWxlKSB7XG4gICAgaWYgKCFmaWx0ZXJzKSB7XG4gICAgICAgIGZpbHRlcnMgPSB7dHlwZTogJ2RlZmF1bHQnfTtcbiAgICB9XG4gICAgdmFyIHN0eWxlSG9sZGVyID0gc2hhbGxvd0NvcHkoZmlsdGVycyk7XG4gICAgaWYgKHpvb20pIHtcbiAgICAgICAgc3R5bGVIb2xkZXIuem9vbSA9IHpvb207XG4gICAgfVxuICAgIHN0eWxlSG9sZGVyLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5zdHlsZXMucHVzaChzdHlsZUhvbGRlcik7XG59XG5cbmZ1bmN0aW9uIERBU1N0eWxlKCkge1xufVxuXG5mdW5jdGlvbiBwYXJzZUdyYWRpZW50KGdyYWQpIHtcbiAgICB2YXIgc3RlcHMgPSBncmFkLmdldEF0dHJpYnV0ZSgnc3RlcHMnKTtcbiAgICBpZiAoc3RlcHMpIHtcbiAgICAgICAgc3RlcHMgPSBzdGVwc3wwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXBzID0gNTA7XG4gICAgfVxuXG4gICAgdmFyIHN0b3BzID0gW107XG4gICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgIHZhciBzZSA9IGdyYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1NUT1AnKTtcbiAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc2UubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzdG9wID0gc2Vbc2ldO1xuICAgICAgICBzdG9wcy5wdXNoKDEuMCAqIHN0b3AuZ2V0QXR0cmlidXRlKCdzY29yZScpKTtcbiAgICAgICAgY29sb3JzLnB1c2goc3RvcC5maXJzdENoaWxkLm5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VDb2xvdXJTdGVwcyhzdGVwcywgc3RvcHMsIGNvbG9ycyk7XG59XG5cbkRBU1NvdXJjZS5wcm90b3R5cGUuc3R5bGVzaGVldCA9IGZ1bmN0aW9uKHN1Y2Nlc3NDQiwgZmFpbHVyZUNCKSB7XG4gICAgdmFyIGRhc1VSSSwgY3JlZHMgPSB0aGlzLmNyZWRlbnRpYWxzO1xuICAgIGlmICh0aGlzLnN0eWxlc2hlZXRfdXJpKSB7XG4gICAgICAgIGRhc1VSSSA9IHRoaXMuc3R5bGVzaGVldF91cmk7XG4gICAgICAgIGNyZWRzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGFzVVJJID0gdGhpcy5kYXNCYXNlVVJJICsgJ3N0eWxlc2hlZXQnO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0VVJJKGRhc1VSSSkudGhlbihmdW5jdGlvbihkYXNVUkkpIHtcbiAgICAgICAgZG9Dcm9zc0RvbWFpblJlcXVlc3QoZGFzVVJJLCBmdW5jdGlvbihyZXNwb25zZVhNTCkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVhNTCkge1xuICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlQ0IpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUNCKCk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3R5bGVzaGVldCA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG4gICAgICAgICAgICB2YXIgdHlwZVhNTHMgPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnVFlQRScpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlWE1Mcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlU3R5bGUgPSB0eXBlWE1Mc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB7fTtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudHlwZSA9IHR5cGVTdHlsZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7IC8vIEFtIEkgcmlnaHQgaW4gdGhpbmtpbmcgdGhhdCB0aGlzIG1ha2VzIERBU1NUWUxFIFhNTCBpbnZhbGlkPyAgVWdoLlxuICAgICAgICAgICAgICAgIGZpbHRlci5sYWJlbCA9IHR5cGVTdHlsZS5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgICAgICAgICAgICAgZmlsdGVyLm1ldGhvZCA9IHR5cGVTdHlsZS5nZXRBdHRyaWJ1dGUoJ21ldGhvZCcpO1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaFhNTHMgPSB0eXBlU3R5bGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0dMWVBIJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZ2kgPSAwOyBnaSA8IGdseXBoWE1Mcy5sZW5ndGg7ICsrZ2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoWE1MID0gZ2x5cGhYTUxzW2dpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb20gPSBnbHlwaFhNTC5nZXRBdHRyaWJ1dGUoJ3pvb20nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gY2hpbGRFbGVtZW50T2YoZ2x5cGhYTUwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZ2x5cGggPSBnbHlwaC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGdseXBoLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5sb2NhbE5hbWUgPT0gJ0JHR1JBRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbY2hpbGQubG9jYWxOYW1lXSA9IHBhcnNlR3JhZGllbnQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW2NoaWxkLmxvY2FsTmFtZV0gPSBjaGlsZC5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKGZpbHRlciwgem9vbSwgc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Y2Nlc3NDQihzdHlsZXNoZWV0KTtcbiAgICAgICAgfSwgY3JlZHMpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICBmYWlsdXJlQ0IoKTtcbiAgICB9KTtcbn1cblxuLy9cbi8vIHNvdXJjZXMgY29tbWFuZFxuLy8gXG5cbmZ1bmN0aW9uIERBU1JlZ2lzdHJ5KHVyaSwgb3B0cylcbntcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzOyAgIFxufVxuXG5EQVNSZWdpc3RyeS5wcm90b3R5cGUuc291cmNlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBmYWlsdXJlLCBvcHRzKVxue1xuICAgIGlmICghb3B0cykge1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlcnMgPSBbXTtcbiAgICBpZiAob3B0cy50YXhvbikge1xuICAgICAgICBmaWx0ZXJzLnB1c2goJ29yZ2FuaXNtPScgKyBvcHRzLnRheG9uKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgICBmaWx0ZXJzLnB1c2goJ2F1dGhvcml0eT0nICsgb3B0cy5hdXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyc2lvbikge1xuICAgICAgICBmaWx0ZXJzLnB1c2goJ3ZlcnNpb249JyArIG9wdHMudmVyc2lvbik7XG4gICAgfVxuICAgIHZhciBxdXJpID0gdGhpcy51cmk7XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBxdXJpID0gcXVyaSArICc/JyArIGZpbHRlcnMuam9pbignJicpOyAgIC8vICcmJyBhcyBhIHNlcGFyYXRvciB0byBoYWNrIGFyb3VuZCBkYXNyZWdpc3RyeS5vcmcgYnVnLlxuICAgIH1cblxuICAgIGRvQ3Jvc3NEb21haW5SZXF1ZXN0KHF1cmksIGZ1bmN0aW9uKHJlc3BvbnNlWE1MKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2VYTUwgJiYgZmFpbHVyZSkge1xuICAgICAgICAgICAgZmFpbHVyZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTsgICAgICAgXG4gICAgICAgIHZhciBzb3VyY2VYTUxzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1NPVVJDRScpO1xuICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc291cmNlWE1Mcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VYTUwgPSBzb3VyY2VYTUxzW3NpXTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uWE1McyA9IHNvdXJjZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnVkVSU0lPTicpO1xuICAgICAgICAgICAgaWYgKHZlcnNpb25YTUxzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2ZXJzaW9uWE1MID0gdmVyc2lvblhNTHNbMF07XG5cbiAgICAgICAgICAgIHZhciBjb29yZFhNTHMgPSB2ZXJzaW9uWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDT09SRElOQVRFUycpO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNvb3JkWE1Mcy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRYTUwgPSBjb29yZFhNTHNbY2ldO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZCA9IG5ldyBEQVNDb29yZHMoKTtcbiAgICAgICAgICAgICAgICBjb29yZC5hdXRoID0gY29vcmRYTUwuZ2V0QXR0cmlidXRlKCdhdXRob3JpdHknKTtcbiAgICAgICAgICAgICAgICBjb29yZC50YXhvbiA9IGNvb3JkWE1MLmdldEF0dHJpYnV0ZSgndGF4aWQnKTtcbiAgICAgICAgICAgICAgICBjb29yZC52ZXJzaW9uID0gY29vcmRYTUwuZ2V0QXR0cmlidXRlKCd2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goY29vcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY2FwcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNhcFhNTHMgPSB2ZXJzaW9uWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDQVBBQklMSVRZJyk7XG4gICAgICAgICAgICB2YXIgdXJpO1xuICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNhcFhNTHMubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcFhNTCA9IGNhcFhNTHNbY2ldO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhcHMucHVzaChjYXBYTUwuZ2V0QXR0cmlidXRlKCd0eXBlJykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhcFhNTC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PSAnZGFzMTpmZWF0dXJlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZlcCA9IGNhcFhNTC5nZXRBdHRyaWJ1dGUoJ3F1ZXJ5X3VyaScpO1xuICAgICAgICAgICAgICAgICAgICB1cmkgPSBmZXAuc3Vic3RyaW5nKDAsIGZlcC5sZW5ndGggLSAoJ2ZlYXR1cmVzJy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BYTUxzID0gdmVyc2lvblhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnUFJPUCcpO1xuICAgICAgICAgICAgZm9yICh2YXIgcGkgPSAwOyBwaSA8IHByb3BYTUxzLmxlbmd0aDsgKytwaSkge1xuICAgICAgICAgICAgICAgIHB1c2hvKHByb3BzLCBwcm9wWE1Mc1twaV0uZ2V0QXR0cmlidXRlKCduYW1lJyksIHByb3BYTUxzW3BpXS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodXJpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBEQVNTb3VyY2UodXJpLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZV91cmk6IHNvdXJjZVhNTC5nZXRBdHRyaWJ1dGUoJ3VyaScpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAgc291cmNlWE1MLmdldEF0dHJpYnV0ZSgndGl0bGUnKSxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogIHNvdXJjZVhNTC5nZXRBdHRyaWJ1dGUoJ2Rlc2NyaXB0aW9uJyksXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczogY2Fwc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjYWxsYmFjayhzb3VyY2VzKTtcbiAgICB9KTtcbn1cblxuXG4vL1xuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbi8vXG5cbmZ1bmN0aW9uIGVsZW1lbnRWYWx1ZShlbGVtZW50LCB0YWcpXG57XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwICYmIGNoaWxkcmVuWzBdLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdmFyIGMgPSBjaGlsZHJlblswXTtcbiAgICAgICAgaWYgKGMuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGMuZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgbmkgPSAwOyBuaSA8IGMuY2hpbGROb2Rlcy5sZW5ndGg7ICsrbmkpIHtcbiAgICAgICAgICAgICAgICBzICs9IGMuY2hpbGROb2Rlc1tuaV0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hpbGRFbGVtZW50T2YoZWxlbWVudClcbntcbiAgICBpZiAoZWxlbWVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfSB3aGlsZSAoY2hpbGQgIT0gbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5cbmZ1bmN0aW9uIGRhc0xpbmtzT2YoZWxlbWVudClcbntcbiAgICB2YXIgbGlua3MgPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgbWF5YmVMaW5rQ2hpbGRlbiA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0xJTksnKTtcbiAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgbWF5YmVMaW5rQ2hpbGRlbi5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgdmFyIGxpbmtYTUwgPSBtYXliZUxpbmtDaGlsZGVuW2NpXTtcbiAgICAgICAgaWYgKGxpbmtYTUwucGFyZW50Tm9kZSA9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKG5ldyBEQVNMaW5rKGxpbmtYTUwuZmlyc3RDaGlsZCA/IGxpbmtYTUwuZmlyc3RDaGlsZC5ub2RlVmFsdWUgOiAnVW5rbm93bicsIGxpbmtYTUwuZ2V0QXR0cmlidXRlKCdocmVmJykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbGlua3M7XG59XG5cbmZ1bmN0aW9uIGRhc05vdGVzT2YoZWxlbWVudClcbntcbiAgICB2YXIgbm90ZXMgPSBbXTtcbiAgICB2YXIgbWF5YmVOb3RlcyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ05PVEUnKTtcbiAgICBmb3IgKHZhciBuaSA9IDA7IG5pIDwgbWF5YmVOb3Rlcy5sZW5ndGg7ICsrbmkpIHtcbiAgICAgICAgaWYgKG1heWJlTm90ZXNbbmldLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIG5vdGVzLnB1c2gobWF5YmVOb3Rlc1tuaV0uZmlyc3RDaGlsZC5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3Rlcztcbn1cblxuZnVuY3Rpb24gZG9Dcm9zc0RvbWFpblJlcXVlc3QodXJsLCBoYW5kbGVyLCBjcmVkZW50aWFscywgY3VzdEF1dGgpIHtcbiAgICAvLyBUT0RPOiBleHBsaWNpdCBlcnJvciBoYW5kbGVycz9cblxuICAgIGlmICh3aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgICAgICAgICAgZG9tLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICBkb20ubG9hZFhNTChyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIGhhbmRsZXIoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub3BlbihcImdldFwiLCB1cmwpO1xuICAgICAgICByZXEuc2VuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aW1pbmcgb3V0ICcgICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIobnVsbCwgcmVxKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIDUwMDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJlcS5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGltZW91dCBvbiAnICsgdXJsKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID49IDIwMCB8fCByZXEuc3RhdHVzID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIocmVxLnJlc3BvbnNlWE1MLCByZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vcGVuKFwiZ2V0XCIsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBJRTEwLzExIGZpeDogVGhlIHRpbWVvdXQgcHJvcGVydHkgbWF5IGJlIHNldCBvbmx5IGluIHRoZSB0aW1lIGludGVydmFsIGJldHdlZW4gYSBjYWxsIHRvIHRoZSBvcGVuIG1ldGhvZFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGFuZCB0aGUgZmlyc3QgY2FsbCB0byB0aGUgc2VuZCBtZXRob2QuXG4gICAgICAgICAgICByZXEudGltZW91dCA9IDUwMDA7XG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXN0QXV0aCkge1xuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdYLURBUy1BdXRob3Jpc2F0aW9uJywgY3VzdEF1dGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQveG1sJyk7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL3htbCwqLyonKTtcbiAgICAgICAgICAgIHJlcS5zZW5kKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXIobnVsbCwgcmVxLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuREFTU291cmNlLnByb3RvdHlwZS5kb0Nyb3NzRG9tYWluUmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgaGFuZGxlciwgZXJySGFuZGxlcikge1xuICAgIHZhciBjdXN0QXV0aDtcbiAgICBpZiAodGhpcy54VXNlcikge1xuICAgICAgICBjdXN0QXV0aCA9ICdCYXNpYyAnICsgYnRvYSh0aGlzLnhVc2VyICsgJzonICsgdGhpcy54UGFzcyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvQ3Jvc3NEb21haW5SZXF1ZXN0KHVybCwgaGFuZGxlciwgdGhpcy5jcmVkZW50aWFscywgY3VzdEF1dGgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJySGFuZGxlcikge1xuICAgICAgICAgICAgZXJySGFuZGxlcihlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0Rhc0Jvb2xlYW5UcnVlKHMpIHtcbiAgICBzID0gKCcnICsgcykudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gcz09PSd5ZXMnIHx8IHM9PT0ndHJ1ZSc7XG59XG5cbmZ1bmN0aW9uIGlzRGFzQm9vbGVhbk5vdEZhbHNlKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHMgPSAoJycgKyBzKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBzIT09J25vJyB8fCBzIT09J2ZhbHNlJztcbn1cblxuZnVuY3Rpb24gY29weVN0eWxlc2hlZXQoc3MpIHtcbiAgICB2YXIgbnNzID0gc2hhbGxvd0NvcHkoc3MpO1xuICAgIG5zcy5zdHlsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc3Muc3R5bGVzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgc2ggPSBuc3Muc3R5bGVzW3NpXSA9IHNoYWxsb3dDb3B5KHNzLnN0eWxlc1tzaV0pO1xuICAgICAgICBzaC5fbWV0aG9kUkUgPSBzaC5fbGFiZWxSRSA9IHNoLl90eXBlUkUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNoLnN0eWxlID0gc2hhbGxvd0NvcHkoc2guc3R5bGUpO1xuICAgICAgICBzaC5zdHlsZS5pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2guc3R5bGUuX2dyYWRpZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbnNzO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIERBU0dyb3VwOiBEQVNHcm91cCxcbiAgICAgICAgREFTRmVhdHVyZTogREFTRmVhdHVyZSxcbiAgICAgICAgREFTU3R5bGVzaGVldDogREFTU3R5bGVzaGVldCxcbiAgICAgICAgREFTU3R5bGU6IERBU1N0eWxlLFxuICAgICAgICBEQVNTb3VyY2U6IERBU1NvdXJjZSxcbiAgICAgICAgREFTU2VnbWVudDogREFTU2VnbWVudCxcbiAgICAgICAgREFTUmVnaXN0cnk6IERBU1JlZ2lzdHJ5LFxuICAgICAgICBEQVNTZXF1ZW5jZTogREFTU2VxdWVuY2UsXG4gICAgICAgIERBU0xpbms6IERBU0xpbmssXG5cbiAgICAgICAgaXNEYXNCb29sZWFuVHJ1ZTogaXNEYXNCb29sZWFuVHJ1ZSxcbiAgICAgICAgaXNEYXNCb29sZWFuTm90RmFsc2U6IGlzRGFzQm9vbGVhbk5vdEZhbHNlLFxuICAgICAgICBjb3B5U3R5bGVzaGVldDogY29weVN0eWxlc2hlZXQsXG4gICAgICAgIGNvb3Jkc01hdGNoOiBjb29yZHNNYXRjaFxuICAgIH07XG59XG4iLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgU3ViVGllciB9IGZyb20gXCIuL2ZlYXR1cmUtZHJhdy5qc1wiO1xuXG5pbXBvcnQgeyBkcmF3U2VxVGllciB9IGZyb20gXCIuL3NlcXVlbmNlLWRyYXcuanNcIjtcblxuXG5pbXBvcnQgeyBSYW5nZSwgdW5pb24gfSBmcm9tIFwiLi9zcGFucy5qc1wiO1xuXG5pbXBvcnQgeyBzaGFsbG93Q29weSwgcHVzaG8gfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG5cbmltcG9ydCAqIGFzIEdseXBocyBmcm9tIFwiLi9nbHlwaHMuanNcIjtcblxuaW1wb3J0IHsgaXNEYXNCb29sZWFuVHJ1ZSxcbiAgICAgICAgIGlzRGFzQm9vbGVhbk5vdEZhbHNlLFxuICAgICAgICAgREFTRmVhdHVyZSB9IGZyb20gXCIuL2Rhcy5qc1wiO1xuXG5pbXBvcnQgeyBtYWtlR3JhZGllbnQgfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5pbXBvcnQgeyBwYXJzZUNpZ2FyIH0gZnJvbSBcIi4vY2lnYXIuanNcIjtcblxuaW1wb3J0IHsgZm9ybWF0UXVhbnRMYWJlbCB9IGZyb20gXCIuL251bWZvcm1hdHNcIjtcblxuaW1wb3J0ICogYXMgUiBmcm9tIFwicmFtZGFcIjtcblxuLy8gVGhlIG9ubHkgZnVuY3Rpb25zIHRoYXQgbXVzdCBiZSBleHBvcnRlZCBieSBhIHJlbmRlcmVyIGFyZSByZW5kZXJUaWVyXG4vLyBhbmQgZHJhd1RpZXIsIHRoZSByZXN0IGFyZSBleHBvcnRlZCBmb3IgdXNlIGluIG90aGVyIHJlbmRlcmVycy5cbmV4cG9ydCB7IHJlbmRlclRpZXIsXG4gICAgICAgICBkcmF3VGllcixcbiAgICAgICAgIHByZXBhcmVTdWJ0aWVycyxcbiAgICAgICAgIHByZXBhcmVWaWV3cG9ydCxcbiAgICAgICAgIHBhaW50LFxuICAgICAgICAgZHJhd1VubWFwcGVkLFxuICAgICAgICAgY2xlYXJWaWV3cG9ydCxcbiAgICAgICAgIGNyZWF0ZVF1YW50T3ZlcmxheSxcbiAgICAgICAgIHBhaW50UXVhbnRcbiAgICAgICB9O1xuXG5mdW5jdGlvbiByZW5kZXJUaWVyKHN0YXR1cywgdGllcikge1xuICAgIGRyYXdUaWVyKHRpZXIpO1xuICAgIHRpZXIudXBkYXRlU3RhdHVzKHN0YXR1cyk7XG59XG5cbmZ1bmN0aW9uIGRyYXdUaWVyKHRpZXIpIHtcbiAgICBsZXQgY2FudmFzID0gdGllci52aWV3cG9ydC5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgbGV0IHJldGluYSA9IHRpZXIuYnJvd3Nlci5yZXRpbmEgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxO1xuXG4gICAgaWYgKHRpZXIuc2VxdWVuY2VTb3VyY2UpIHtcbiAgICAgICAgbGV0IHNlcXVlbmNlID0gdGllci5jdXJyZW50U2VxdWVuY2U7XG4gICAgICAgIGRyYXdTZXFUaWVyKHRpZXIsIHNlcXVlbmNlKTtcbiAgICB9IGVsc2UgaWYgKHRpZXIuY3VycmVudEZlYXR1cmVzKSB7XG4gICAgICAgIHByZXBhcmVTdWJ0aWVycyh0aWVyLCBjYW52YXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gc2VxdWVuY2Ugb3IgZmVhdHVyZXMgaW4gdGllciFcIik7XG4gICAgfVxuXG4gICAgaWYgKHRpZXIuc3VidGllcnMpIHtcbiAgICAgICAgbGV0IHZPZmZzZXQgPSBSLmRlZmF1bHRUbygwLCB0aWVyLmRhc1NvdXJjZS52T2Zmc2V0KTtcblxuICAgICAgICBwcmVwYXJlVmlld3BvcnQodGllciwgY2FudmFzLCByZXRpbmEsIHRydWUsIHZPZmZzZXQpO1xuICAgICAgICBwYWludCh0aWVyLCBjYW52YXMsIHZPZmZzZXQpO1xuICAgIH1cblxuICAgIHRpZXIuZHJhd092ZXJsYXkoKTtcbiAgICB0aWVyLnBhaW50UXVhbnQoKTtcblxuICAgIGlmICh0eXBlb2YodGllci5kYXNTb3VyY2UuZHJhd0NhbGxiYWNrKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRpZXIuZGFzU291cmNlLmRyYXdDYWxsYmFjayhjYW52YXMsIHRpZXIpO1xuICAgIH1cblxuICAgIHRpZXIub3JpZ2luSGF4eCA9IDA7XG4gICAgdGllci5icm93c2VyLmFycmFuZ2VUaWVycygpO1xufVxuXG5mdW5jdGlvbiBnbHlwaHNGb3JHcm91cChjYW52YXMsIGZlYXR1cmVzLCB5LCBncm91cEVsZW1lbnQsIHRpZXIpIHtcbiAgICBsZXQgZ3N0eWxlID0gdGllci5zdHlsZUZvckZlYXR1cmUoZ3JvdXBFbGVtZW50KTtcbiAgICBsZXQgbGFiZWw7XG4gICAgbGV0IGxhYmVsV2FudGVkID0gZmFsc2U7XG5cbiAgICBsZXQgZ2x5cGhzID0gW107XG4gICAgbGV0IHN0cmFuZCA9IG51bGw7XG5cbiAgICBmZWF0dXJlcy5mb3JFYWNoKGYgPT4ge1xuICAgICAgICBpZiAoZi5vcmllbnRhdGlvbiAmJiBzdHJhbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmFuZCA9IGYub3JpZW50YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxhYmVsICYmIGYubGFiZWwpIHtcbiAgICAgICAgICAgIGxhYmVsID0gZi5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdHlsZSA9IHRpZXIuc3R5bGVGb3JGZWF0dXJlKGYpO1xuICAgICAgICBpZiAoc3R5bGUgJiYgIWYucGFydHMpIHtcbiAgICAgICAgICAgIGlmIChpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLkxBQkVMKSlcbiAgICAgICAgICAgICAgICBsYWJlbFdhbnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGxldCBnbHlwaCA9IGdseXBoRm9yRmVhdHVyZShjYW52YXMsIGYsIHksIHN0eWxlLCB0aWVyLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChnbHlwaClcbiAgICAgICAgICAgICAgICBnbHlwaHMucHVzaChnbHlwaCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChnbHlwaHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIGxldCBjb25uZWN0b3IgPSAnZmxhdCc7XG4gICAgaWYgKGdzdHlsZSAmJiBnc3R5bGUuZ2x5cGggPT09ICdMSU5FJykge1xuICAgICAgICAvLyBTdGljayB3aXRoIGZsYXQuLi5cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGllci5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3VwcyAmJiAhdGllci5idW1wZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJhbmQgPT09ICcrJyB8fCBzdHJhbmQgPT09ICctJykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9ICdjb2xsYXBzZWQnICsgc3RyYW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0cmFuZCA9PT0gJysnIHx8IHN0cmFuZCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yID0gJ2hhdCcgKyBzdHJhbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbGFiZWxUZXh0ID0gbnVsbDtcbiAgICBpZiAoKGxhYmVsICYmIGxhYmVsV2FudGVkKSB8fFxuICAgICAgICAoZ3N0eWxlICYmIChpc0Rhc0Jvb2xlYW5UcnVlKGdzdHlsZS5MQUJFTCkgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNEYXNCb29sZWFuVHJ1ZShnc3R5bGUuTEFCRUxTKSkpKSB7ICAvLyBIQUNLLCBMQUJFTFMgc2hvdWxkIHdvcmsuXG4gICAgICAgIGxhYmVsVGV4dCA9IGdyb3VwRWxlbWVudC5sYWJlbCB8fCBsYWJlbDtcbiAgICB9XG5cbiAgICBsZXQgZ3JvdXBHbHlwaCA9IG5ldyBHbHlwaHMuR3JvdXBHbHlwaChnbHlwaHMsIGNvbm5lY3Rvcik7XG4gICAgaWYgKGxhYmVsVGV4dCkge1xuICAgICAgICBpZiAoc3RyYW5kID09PSAnKycpIHtcbiAgICAgICAgICAgIGxhYmVsVGV4dCA9ICc+JyArIGxhYmVsVGV4dDtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJhbmQgPT09ICctJykge1xuICAgICAgICAgICAgbGFiZWxUZXh0ID0gJzwnICsgbGFiZWxUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwR2x5cGggPSBuZXcgR2x5cGhzLkxhYmVsbGVkR2x5cGgoY2FudmFzLCBncm91cEdseXBoLCBsYWJlbFRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgZ3JvdXBHbHlwaC5idW1wID0gdHJ1ZTtcbiAgICByZXR1cm4gZ3JvdXBHbHlwaDtcbn1cblxuZnVuY3Rpb24gZ2x5cGhGb3JGZWF0dXJlKGNhbnZhcywgZmVhdHVyZSwgeSwgc3R5bGUsIHRpZXIsIGZvcmNlSGVpZ2h0LCBub0xhYmVsKSB7XG4gICAgbGV0IHNjYWxlID0gdGllci5icm93c2VyLnNjYWxlO1xuICAgIGxldCBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuICAgIGxldCBnbHlwaFR5cGUgPSBzdHlsZS5nbHlwaCB8fCAnQk9YJztcblxuICAgIGxldCBtaW4gPSBmZWF0dXJlLm1pbjtcbiAgICBsZXQgbWF4ID0gZmVhdHVyZS5tYXg7XG4gICAgbGV0IHN0cmFuZCA9IGZlYXR1cmUub3JpZW50YXRpb247XG4gICAgbGV0IHNjb3JlID0gZmVhdHVyZS5zY29yZTtcbiAgICBsZXQgbGFiZWwgPSBmZWF0dXJlLmxhYmVsIHx8IGZlYXR1cmUuaWQ7XG5cbiAgICAvLyBIaWRlIGdseXBocyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gYSBwaXhlbCBpbiB3aWR0aC5cbiAgICBpZiAodGllci5kYXNTb3VyY2UuaGlkZVN1YnBpeGVsR2x5cGhzICYmIChtYXggLSBtaW4pICogc2NhbGUgPCAxKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBtaW5Qb3MgPSAobWluIC0gb3JpZ2luKSAqIHNjYWxlO1xuICAgIGxldCByYXdNYXhQb3MgPSAoKG1heCAtIG9yaWdpbiArIDEpICogc2NhbGUpO1xuICAgIGxldCBtYXhQb3MgPSBNYXRoLm1heChyYXdNYXhQb3MsIG1pblBvcyArIDEpO1xuXG4gICAgZm9yY2VIZWlnaHQgPSBmb3JjZUhlaWdodCAqIDEuMDtcbiAgICBsZXQgaGVpZ2h0ID0gKHRpZXIuZm9yY2VIZWlnaHQgfHwgc3R5bGUuSEVJR0hUIHx8IGZvcmNlSGVpZ2h0IHx8IDEyKSAqIDEuMDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgKiAxLjA7XG4gICAgbGV0IGJ1bXAgPSBzdHlsZS5CVU1QICYmIGlzRGFzQm9vbGVhblRydWUoc3R5bGUuQlVNUCk7XG5cbiAgICBsZXQgZ2x5cGg7XG4gICAgbGV0IHF1YW50O1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBnbHlwaFxuICAgIGlmIChnbHlwaFR5cGUgPT09ICdDUk9TUycgfHxcbiAgICAgICAgZ2x5cGhUeXBlID09PSAnRVgnIHx8XG4gICAgICAgIGdseXBoVHlwZSA9PT0gJ1RSSUFOR0xFJyB8fFxuICAgICAgICBnbHlwaFR5cGUgPT09ICdET1QnIHx8XG4gICAgICAgIGdseXBoVHlwZSA9PT0gJ1NRVUFSRScgfHxcbiAgICAgICAgZ2x5cGhUeXBlID09PSAnU1RBUicgfHxcbiAgICAgICAgZ2x5cGhUeXBlID09PSAnUExJTVNPTEwnKSB7XG4gICAgICAgIFtnbHlwaCwgcXVhbnRdID0gZmVhdHVyZVRvQ3Jvc3NMaWtlR2x5cGgoY2FudmFzLCB0aWVyLCBmZWF0dXJlLCB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdseXBoVHlwZSwgc3R5bGUsIGZvcmNlSGVpZ2h0LCBub0xhYmVsKTtcblxuICAgIH0gZWxzZSBpZiAoZ2x5cGhUeXBlID09PSAnSElTVE9HUkFNJyB8fCBnbHlwaFR5cGUgPT09ICdHUkFESUVOVCcgJiYgc2NvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFtnbHlwaCwgcXVhbnRdID0gZmVhdHVyZVRvR3JhZGllbnRMaWtlR2x5cGgoY2FudmFzLCB0aWVyLCBmZWF0dXJlLCB5LCBnbHlwaFR5cGUsIHN0eWxlLCBmb3JjZUhlaWdodCk7XG5cbiAgICB9IGVsc2UgaWYgKGdseXBoVHlwZSA9PT0gJ0hJRERFTicpIHtcbiAgICAgICAgZ2x5cGggPSBuZXcgR2x5cGhzLlBhZGRlZEdseXBoKG51bGwsIG1pblBvcywgbWF4UG9zKTtcbiAgICAgICAgbm9MYWJlbCA9IHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKGdseXBoVHlwZSA9PT0gJ0FSUk9XJykge1xuICAgICAgICBsZXQgY29sb3IgPSBzdHlsZS5GR0NPTE9SIHx8ICdwdXJwbGUnO1xuICAgICAgICBsZXQgcGFyYWxsZWwgPSBpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLlBBUkFMTEVMKTtcbiAgICAgICAgbGV0IHN3ID0gaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5TT1VUSFdFU1QpO1xuICAgICAgICBsZXQgbmUgPSBpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLk5PUlRIRUFTVCk7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5BcnJvd0dseXBoKG1pblBvcywgbWF4UG9zLCBoZWlnaHQsIGNvbG9yLCBwYXJhbGxlbCwgc3csIG5lKTtcblxuICAgIH0gZWxzZSBpZiAoZ2x5cGhUeXBlID09PSAnQU5DSE9SRURfQVJST1cnKSB7XG4gICAgICAgIGxldCBzdHJva2UgPSBzdHlsZS5GR0NPTE9SIHx8ICdub25lJztcbiAgICAgICAgbGV0IGZpbGwgPSBzdHlsZS5CR0NPTE9SIHx8ICdncmVlbic7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5BQXJyb3dHbHlwaChtaW5Qb3MsIG1heFBvcywgaGVpZ2h0LCBmaWxsLCBzdHJva2UsIHN0cmFuZCk7XG4gICAgICAgIGdseXBoLmJ1bXAgPSB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChnbHlwaFR5cGUgPT09ICdTUEFOJykge1xuICAgICAgICBsZXQgc3Ryb2tlID0gc3R5bGUuRkdDT0xPUiB8fCAnYmxhY2snO1xuICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuU3BhbkdseXBoKG1pblBvcywgbWF4UG9zLCBoZWlnaHQsIHN0cm9rZSk7XG5cbiAgICB9IGVsc2UgaWYgKGdseXBoVHlwZSA9PT0gJ0xJTkUnKSB7XG4gICAgICAgIGxldCBzdHJva2UgPSBzdHlsZS5GR0NPTE9SIHx8ICdibGFjayc7XG4gICAgICAgIGxldCBsaW5lU3R5bGUgPSBzdHlsZS5TVFlMRSB8fCAnc29saWQnO1xuICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuTGluZUdseXBoKG1pblBvcywgbWF4UG9zLCBoZWlnaHQsIGxpbmVTdHlsZSwgc3RyYW5kLCBzdHJva2UpO1xuXG4gICAgfSBlbHNlIGlmIChnbHlwaFR5cGUgPT09ICdQUklNRVJTJykge1xuICAgICAgICBsZXQgc3Ryb2tlID0gc3R5bGUuRkdDT0xPUiB8fCAnYmxhY2snO1xuICAgICAgICBsZXQgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgJ3JlZCc7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5QcmltZXJzR2x5cGgobWluUG9zLCBtYXhQb3MsIGhlaWdodCwgZmlsbCwgc3Ryb2tlKTtcblxuICAgIH0gZWxzZSBpZiAoZ2x5cGhUeXBlID09PSAnVEVYVCcpIHtcbiAgICAgICAgbGV0IHN0cmluZyA9IHN0eWxlLlNUUklORyB8fCAndGV4dCc7XG4gICAgICAgIGxldCBmaWxsID0gc3R5bGUuRkdDT0xPUiB8fCAnYmxhY2snO1xuICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuVGV4dEdseXBoKGNhbnZhcywgbWluUG9zLCBtYXhQb3MsIGhlaWdodCwgZmlsbCwgc3RyaW5nKTtcblxuICAgIH0gZWxzZSBpZiAoZ2x5cGhUeXBlID09PSAnVE9PTUFOWScpIHtcbiAgICAgICAgbGV0IHN0cm9rZSA9IHN0eWxlLkZHQ09MT1IgfHwgJ2dyYXknO1xuICAgICAgICBsZXQgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgJ29yYW5nZSc7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5Ub29NYW55R2x5cGgobWluUG9zLCBtYXhQb3MsIGhlaWdodCwgZmlsbCwgc3Ryb2tlKTtcblxuICAgIH0gZWxzZSBpZiAoZ2x5cGhUeXBlID09PSAnUE9JTlQnKSB7XG4gICAgICAgIFtnbHlwaCwgcXVhbnRdID0gZmVhdHVyZVRvUG9pbnRHbHlwaCh0aWVyLCBmZWF0dXJlLCBzdHlsZSk7XG5cbiAgICB9IGVsc2UgaWYgKGdseXBoVHlwZSA9PT0gJ19fU0VRVUVOQ0UnKSB7XG4gICAgICAgIGdseXBoID0gc2VxdWVuY2VHbHlwaChjYW52YXMsIHRpZXIsIGZlYXR1cmUsIHN0eWxlLCBmb3JjZUhlaWdodCk7XG5cbiAgICB9IGVsc2UgaWYgKGdseXBoVHlwZSA9PT0gJ19fSU5TRVJUSU9OJykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uTGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0eWxlLl9fSU5TRVJUSU9OUyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaW5zZXJ0aW9uTGFiZWxzID0gaXNEYXNCb29sZWFuTm90RmFsc2Uoc3R5bGUuX19JTlNFUlRJT05TKVxuICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuVHJpYW5nbGVHbHlwaChtaW5Qb3MsIDUsICdTJywgNSwgdGllci5icm93c2VyLmJhc2VDb2xvcnNbJ0knXSk7XG4gICAgICAgIGlmIChpbnNlcnRpb25MYWJlbHMpXG4gICAgICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuTGFiZWxsZWRHbHlwaChjYW52YXMsIGdseXBoLCBmZWF0dXJlLmluc2VydGlvbiB8fCBmZWF0dXJlLmFsdEFsbGVsZXNbMF0sIGZhbHNlLCAnY2VudGVyJywgJ2Fib3ZlJywgJzdweCBzYW5zLXNlcmlmJyk7XG5cbiAgICAgICAgaWYgKChtYXhQb3MgLSBtaW5Qb3MpID4gMSkge1xuICAgICAgICAgICAgbGV0IHN0cm9rZSA9IHN0eWxlLkZHQ09MT1IgfHwgJ3JlZCc7XG4gICAgICAgICAgICBsZXQgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgc3R5bGUuQ09MT1IxIHx8ICdncmVlbic7XG4gICAgICAgICAgICBsZXQgYmcgPSBuZXcgR2x5cGhzLkJveEdseXBoKG1pblBvcywgNSwgKG1heFBvcyAtIG1pblBvcyksIGhlaWdodCwgZmlsbCwgc3Ryb2tlKTtcbiAgICAgICAgICAgIGdseXBoID0gbmV3IEdseXBocy5Hcm91cEdseXBoKFtiZywgZ2x5cGhdKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChnbHlwaFR5cGUgPT09ICdfX05PTkUnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfSBlbHNlIGlmIChnbHlwaFR5cGUgPT09ICdCT1gnKSB7XG4gICAgICAgIGxldCBzdHJva2UgPSBzdHlsZS5GR0NPTE9SIHx8IG51bGw7XG4gICAgICAgIGxldCBmaWxsID0gc3R5bGUuQkdDT0xPUiB8fCBzdHlsZS5DT0xPUjEgfHwgJ2dyZWVuJztcbiAgICAgICAgaWYgKHN0eWxlLkJHSVRFTSAmJiBmZWF0dXJlLml0ZW1SZ2IpXG4gICAgICAgICAgICBmaWxsID0gZmVhdHVyZS5pdGVtUmdiO1xuICAgICAgICBsZXQgc2NhbGUgPSAobWF4UG9zIC0gbWluUG9zKSAvIChtYXggLSBtaW4pO1xuICAgICAgICBpZiAoZmVhdHVyZS50eXBlID09ICd0cmFuc2xhdGlvbicgJiZcbiAgICAgICAgICAgIChmZWF0dXJlLm1ldGhvZCA9PSAncHJvdGVpbl9jb2RpbmcnIHx8IGZlYXR1cmUucmVhZGZyYW1lRXhwbGljaXQpICYmXG4gICAgICAgICAgICAoIWZlYXR1cmUudGFncyB8fCBmZWF0dXJlLnRhZ3MuaW5kZXhPZignY2RzX3N0YXJ0X05GJykgPCAwIHx8IGZlYXR1cmUucmVhZGZyYW1lRXhwbGljaXQpICYmXG4gICAgICAgICAgICAoIXRpZXIuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMgfHwgdGllci5idW1wZWQpICYmXG4gICAgICAgICAgICBzY2FsZSA+PSAwLjUpIHtcbiAgICAgICAgICAgIGxldCByZWZTZXEgPSBnZXRSZWZTZXEodGllciwgbWluLCBtYXgpO1xuICAgICAgICAgICAgZ2x5cGggPSBuZXcgR2x5cGhzLkFtaW5vQWNpZEdseXBoKG1pblBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmU2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUub3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5yZWFkZnJhbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGggPSBuZXcgR2x5cGhzLkJveEdseXBoKG1pblBvcywgMCwgKG1heFBvcyAtIG1pblBvcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LCBmaWxsLCBzdHJva2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLkxBQkVMKSB8fCBmZWF0dXJlLmZvcmNlTGFiZWwpICYmXG4gICAgICAgIGxhYmVsICYmICFub0xhYmVsKSB7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5MYWJlbGxlZEdseXBoKGNhbnZhcywgZ2x5cGgsIGxhYmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1bXApIHtcbiAgICAgICAgZ2x5cGguYnVtcCA9IHRydWU7XG4gICAgfVxuXG4gICAgZ2x5cGguZmVhdHVyZSA9IGZlYXR1cmU7XG5cbiAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZVtcIkhJREVBWElTTEFCRUxcIl0pKVxuICAgICAgICBxdWFudCA9IG51bGw7XG5cbiAgICBpZiAocXVhbnQpIHtcbiAgICAgICAgZ2x5cGgucXVhbnQgPSBxdWFudDtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUuWklOREVYKSB7XG4gICAgICAgIGdseXBoLnppbmRleCA9IHN0eWxlLlpJTkRFWCB8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufVxuXG5cbmZ1bmN0aW9uIGdyb3VwRmVhdHVyZXModGllciwgY2FudmFzLCB5KSB7XG4gICAgbGV0IGdseXBocyA9IFtdO1xuICAgIGxldCBnYnNGZWF0dXJlcyA9IHt9O1xuICAgIGxldCBnYnNTdHlsZXMgPSB7fTtcbiAgICBsZXQgc3RhY2tlZEZlYXR1cmVzID0gW107XG5cbiAgICBSLm1hcChmZWF0dXJlcyA9PiB7XG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB0aWVyLnN0eWxlRm9yRmVhdHVyZShmZWF0dXJlKTtcblxuICAgICAgICAgICAgaWYgKGZlYXR1cmUucGFydHMgfHwgIXN0eWxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLmdseXBoID09PSAnTElORVBMT1QnKSB7XG4gICAgICAgICAgICAgICAgcHVzaG8oZ2JzRmVhdHVyZXMsIHN0eWxlLmlkLCBmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBnYnNTdHlsZXNbc3R5bGUuaWRdID0gc3R5bGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmdseXBoID09PSAnU1RBQ0tFRCcpIHtcbiAgICAgICAgICAgICAgICBzdGFja2VkRmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGdseXBoID0gZ2x5cGhGb3JGZWF0dXJlKGNhbnZhcywgZmVhdHVyZSwgeSwgc3R5bGUsIHRpZXIpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaClcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhzLnB1c2goZ2x5cGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCB0aWVyLnVuZ3JvdXBlZEZlYXR1cmVzKTtcblxuICAgIGlmIChzdGFja2VkRmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBnbHlwaHMgPSBnbHlwaHMuY29uY2F0KG1ha2VTdGFja2VkQmFycyhzdGFja2VkRmVhdHVyZXMsIHRpZXIpKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBnYnMgaW4gZ2JzRmVhdHVyZXMpIHtcbiAgICAgICAgbGV0IGdmID0gZ2JzRmVhdHVyZXNbZ2JzXTtcbiAgICAgICAgbGV0IHN0eWxlID0gZ2JzU3R5bGVzW2dic107XG4gICAgICAgIGlmIChzdHlsZS5nbHlwaCA9PT0gJ0xJTkVQTE9UJykge1xuICAgICAgICAgICAgbGV0IGxpbmVHcmFwaEdseXBocyA9IG1ha2VMaW5lUGxvdChnZiwgc3R5bGUsIHRpZXIsIHkpO1xuICAgICAgICAgICAgbGluZUdyYXBoR2x5cGhzLmZvckVhY2goZyA9PiBnbHlwaHMucHVzaChnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG5mdW5jdGlvbiBnbHlwaGlmeUdyb3Vwcyh0aWVyLCBjYW52YXMsIGdseXBocywgeSkge1xuICAgIGxldCBncm91cElkcyA9IE9iamVjdC5rZXlzKHRpZXIuZ3JvdXBlZEZlYXR1cmVzKTtcbiAgICBsZXQgZ3JvdXBHbHlwaHMgPSB7fTtcblxuICAgIGdyb3VwSWRzLnNvcnQoKGcxLCBnMikgPT5cbiAgICAgICAgICAgICAgICAgIHRpZXIuZ3JvdXBlZEZlYXR1cmVzW2cyXVswXS5zY29yZSAtIHRpZXIuZ3JvdXBlZEZlYXR1cmVzW2cxXVswXS5zY29yZSk7XG5cblxuICAgIGdyb3VwSWRzLmZvckVhY2goZ0lkID0+IHtcbiAgICAgICAgbGV0IGdseXBocyA9IGdseXBoc0Zvckdyb3VwKGNhbnZhcywgdGllci5ncm91cGVkRmVhdHVyZXNbZ0lkXSwgeSwgdGllci5ncm91cHNbZ0lkXSwgdGllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aWVyLmRhc1NvdXJjZS5jb2xsYXBzZVN1cGVyR3JvdXBzICYmICF0aWVyLmJ1bXBlZCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbGxhcHNlZF9nZW5lJyA6ICd0ZW50Jyk7XG5cbiAgICAgICAgaWYgKGdseXBocykge1xuICAgICAgICAgICAgZ2x5cGhzLmdyb3VwID0gdGllci5ncm91cHNbZ0lkXTtcbiAgICAgICAgICAgIGdyb3VwR2x5cGhzW2dJZF0gPSBnbHlwaHM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBncm91cEdseXBocztcbn1cblxuZnVuY3Rpb24gYnVtcFN1YnRpZXJzKHRpZXIsIGdseXBocywgZ3JpZCwgZ3JpZE9mZnNldCwgZ3JpZFNwYWNpbmcpIHtcbiAgICBsZXQgc3VidGllck1heCA9XG4gICAgICAgICAgICB0aWVyLnN1YnRpZXJNYXggfHxcbiAgICAgICAgICAgIHRpZXIuZGFzU291cmNlLnN1YnRpZXJNYXggfHxcbiAgICAgICAgICAgIHRpZXIuYnJvd3Nlci5kZWZhdWx0U3VidGllck1heDtcblxuICAgIGxldCBzdWJ0aWVyc0V4Y2VlZGVkID0gZmFsc2U7XG5cbiAgICBsZXQgdW5idW1wZWRTVCA9IG5ldyBTdWJUaWVyKCk7XG4gICAgbGV0IGJ1bXBlZFNUcyA9IFtdO1xuXG4gICAgLy8gV2Ugd2FudCB0byBhZGQgZWFjaCBnbHlwaCB0byBlaXRoZXIgdGhlIHN1YnRpZXJcbiAgICAvLyBjb250YWluaW5nIHVuYnVtcGVkIHN1YnRpZXJzLCBvciB0byB0aGUgZmlyc3QgYnVtcGVkIHN1YnRpZXIuXG4gICAgZ2x5cGhzLmZvckVhY2goZ2x5cGggPT4ge1xuICAgICAgICAvLyBpZiB0aGUgZ2x5cGggaXMgdG8gYmUgYnVtcGVkLi4uXG4gICAgICAgIGlmIChnbHlwaC5idW1wICYmXG4gICAgICAgICAgICAodGllci5idW1wZWQgfHxcbiAgICAgICAgICAgIHRpZXIuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpKSB7XG5cbiAgICAgICAgICAgIGxldCBnbHlwaFRpZXIgPSBidW1wZWRTVHMuZmluZChzdCA9PiBzdC5oYXNTcGFjZUZvcihnbHlwaCkpO1xuXG4gICAgICAgICAgICBpZiAoZ2x5cGhUaWVyKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhUaWVyLmFkZChnbHlwaCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJ1bXBlZFNUcy5sZW5ndGggPj0gc3VidGllck1heCkge1xuICAgICAgICAgICAgICAgIHN1YnRpZXJzRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VidGllciA9IG5ldyBTdWJUaWVyKCk7XG4gICAgICAgICAgICAgICAgc3VidGllci5hZGQoZ2x5cGgpO1xuICAgICAgICAgICAgICAgIGJ1bXBlZFNUcy5wdXNoKHN1YnRpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5idW1wZWRTVC5hZGQoZ2x5cGgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodW5idW1wZWRTVC5nbHlwaHMubGVuZ3RoID4gMCkge1xuICAgICAgICBidW1wZWRTVHMgPSBbdW5idW1wZWRTVF0uY29uY2F0KGJ1bXBlZFNUcyk7XG4gICAgfVxuXG4gICAgLy8gU2ltcGxlIGhhY2sgdG8gbWFrZSB0aGUgaG9yaXpvbnRhbCBncmlkIGluIGJ1bXBlZCBzdWJ0aWVycyAoZS5nLiBsaW5lcGxvdHMpXG4gICAgLy8gb3B0aW9uYWwgYW5kIGNvbmZpZ3VyYWJsZS5cbiAgICBpZiAoZ3JpZCkge1xuICAgICAgICBidW1wZWRTVHMuZm9yRWFjaChzdWJ0aWVyID0+IHtcbiAgICAgICAgICAgIGlmIChzdWJ0aWVyLnF1YW50KSB7XG4gICAgICAgICAgICAgICAgc3VidGllci5nbHlwaHMudW5zaGlmdChuZXcgR2x5cGhzLkdyaWRHbHlwaChzdWJ0aWVyLmhlaWdodCwgZ3JpZE9mZnNldCwgZ3JpZFNwYWNpbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYnVtcGVkU1RzLmZvckVhY2goc3VidGllciA9PiB7XG4gICAgICAgIHN1YnRpZXIuZ2x5cGhzLnNvcnQoKGcxLCBnMikgPT4gKGcxLnppbmRleCB8fCAwKSAtIChnMi56aW5kZXggfHwgMCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtidW1wZWRTVHMsIHN1YnRpZXJzRXhjZWVkZWRdO1xufVxuXG4vLyBUaGUgd2hvbGUgdGllciBpcyB0cmFuc2xhdGVkIGRvd253YXJkIG9uIGl0cyBjYW52YXMgYnkgeSBwaXhlbHNcbmZ1bmN0aW9uIHByZXBhcmVTdWJ0aWVycyh0aWVyLCBjYW52YXMsIHk9MCwgZ3JpZD10cnVlKSB7XG5cbiAgICBsZXQgTUlOX1BBRERJTkcgPSAzO1xuICAgIHRpZXIucGFkZGluZyA9IHR5cGVvZih0aWVyLmRhc1NvdXJjZS5wYWRkaW5nKSA9PT0gJ251bWJlcicgP1xuICAgICAgICB0aWVyLmRhc1NvdXJjZS5wYWRkaW5nIDogTUlOX1BBRERJTkc7XG5cbiAgICB0aWVyLnNjYWxlVmVydGljYWwgPSB0eXBlb2YodGllci5kYXNTb3VyY2Uuc2NhbGVWZXJ0aWNhbCkgPT09ICdib29sZWFuJyA/XG4gICAgICAgIHRpZXIuZGFzU291cmNlLnNjYWxlVmVydGljYWwgOiBmYWxzZTtcblxuICAgIGxldCBnbHlwaHMgPSBncm91cEZlYXR1cmVzKHRpZXIsIGNhbnZhcywgeSk7XG5cbiAgICAvLyBNZXJnZSBzdXBlcmdyb3Vwc1xuICAgIGlmICh0aWVyLmRhc1NvdXJjZS5jb2xsYXBzZVN1cGVyR3JvdXBzICYmICF0aWVyLmJ1bXBlZCkge1xuICAgICAgICBmb3IgKGxldCBzZ0lkIGluIHRpZXIuc3VwZXJHcm91cHMpIHtcbiAgICAgICAgICAgIGxldCBzZ0dyb3VwID0gdGllci5zdXBlckdyb3Vwc1tzZ0lkXTtcbiAgICAgICAgICAgIHRpZXIuZ3JvdXBzW3NnSWRdID0gc2hhbGxvd0NvcHkodGllci5ncm91cHNbc2dJZF0pO1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gdGllci5ncm91cHNbc2dJZF07XG4gICAgICAgICAgICBncm91cC5pc1N1cGVyR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGZlYXR1cmVzQnlUeXBlID0ge307XG5cbiAgICAgICAgICAgIGxldCBzZ01pbiA9IDEwMDAwMDAwMDAwLCBzZ01heCA9IC0xMDAwMDAwMDAwMDtcbiAgICAgICAgICAgIGxldCBzZ1NlZyA9IG51bGw7XG5cbiAgICAgICAgICAgIHNnR3JvdXAuZm9yRWFjaCgoZywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBncm91cGVkRmVhdHVyZSA9IHRpZXIuZ3JvdXBlZEZlYXR1cmVzW3NnR3JvdXBbaV1dO1xuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBlZEZlYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGdyb3VwZWRGZWF0dXJlLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hvKGZlYXR1cmVzQnlUeXBlLCBmZWF0dXJlLnR5cGUsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBzZ01pbiA9IE1hdGgubWluKGZlYXR1cmUubWluLCBzZ01pbik7XG4gICAgICAgICAgICAgICAgICAgIHNnTWF4ID0gTWF0aC5tYXgoZmVhdHVyZS5tYXgsIHNnTWF4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc2VnbWVudCAmJiAhc2dTZWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZ1NlZyA9IGZlYXR1cmUuc2VnbWVudDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChncm91cCAmJiAhZ3JvdXAubGlua3MgfHwgZ3JvdXAubGlua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmxpbmtzID0gdGllci5ncm91cHNbc2dHcm91cFswXV0ubGlua3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRpZXIuZ3JvdXBlZEZlYXR1cmVzW3NnR3JvdXBbaV1dO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGllci5ncm91cHNbc2dJZF0ubWF4ID0gc2dNYXg7XG4gICAgICAgICAgICB0aWVyLmdyb3Vwc1tzZ0lkXS5taW4gPSBzZ01pbjtcbiAgICAgICAgICAgIHRpZXIuZ3JvdXBzW3NnSWRdLnNlZ21lbnQgPSBzZ1NlZztcblxuICAgICAgICAgICAgUi5tYXAoZmVhdHVyZXMgPT4ge1xuXG4gICAgICAgICAgICAgICAgbGV0IHRlbXBsYXRlID0gZmVhdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgbGV0IGxvYyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmwgPSBuZXcgUmFuZ2UoZmVhdHVyZS5taW4sIGZlYXR1cmUubWF4KTtcbiAgICAgICAgICAgICAgICAgICAgbG9jID0gbG9jID8gdW5pb24obG9jLCBmbCkgOiBmbDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxldCBtZXJnZWRSYW5nZXMgPSBsb2MucmFuZ2VzKCk7XG5cbiAgICAgICAgICAgICAgICBtZXJnZWRSYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3NDb3ZlcmFnZSA9ICgocmFuZ2UubWF4KCkgfCAwKSAtIChyYW5nZS5taW4oKSB8IDApICsgMSkgKiBzZ0dyb3VwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdENvdmVyYWdlID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZtaW4gPSBmZWF0dXJlLm1pbiB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZtYXggPSBmZWF0dXJlLm1heCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZtaW4gPD0gcmFuZ2UubWF4KCkgJiYgZm1heCA+PSByYW5nZS5taW4oKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0Q292ZXJhZ2UgKz0gKE1hdGgubWluKGZtYXgsIHJhbmdlLm1heCgpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZtaW4sIHJhbmdlLm1pbigpKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RmVhdHVyZSA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmVhdHVyZVtrZXldID0gdGVtcGxhdGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZlYXR1cmUubWluID0gcmFuZ2UubWluKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZlYXR1cmUubWF4ID0gcmFuZ2UubWF4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdGZWF0dXJlLmxhYmVsICYmIHNnR3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmVhdHVyZS5sYWJlbCArPSAnICgnICsgc2dHcm91cC5sZW5ndGggKyAnIHZhcnMpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZlYXR1cmUudmlzdWFsV2VpZ2h0ID0gKCgxLjAgKiBhY3RDb3ZlcmFnZSkgLyBwb3NDb3ZlcmFnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHVzaG8odGllci5ncm91cGVkRmVhdHVyZXMsIHNnSWQsIG5ld0ZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZmVhdHVyZXNCeVR5cGUpO1xuXG4gICAgICAgICAgICBkZWxldGUgdGllci5zdXBlckdyb3Vwc1tzZ0lkXTsgLy8gRG8gd2Ugd2FudCB0aGlzP1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2x5cGhpZnkgZ3JvdXBzLlxuICAgIGxldCBncm91cEdseXBocyA9IGdseXBoaWZ5R3JvdXBzKHRpZXIsIGNhbnZhcywgZ2x5cGhzLCB5KTtcblxuICAgIFIubWFwKHN1cGVyR3JvdXAgPT4ge1xuICAgICAgICBsZXQgc2dHbHlwaHMgPSBbXTtcbiAgICAgICAgbGV0IHNnTWluID0gMTAwMDAwMDAwMDA7XG4gICAgICAgIGxldCBzZ01heCA9IC0xMDAwMDAwMDAwMDtcblxuICAgICAgICBzdXBlckdyb3VwLmZvckVhY2goZ2x5cGhzID0+IHtcbiAgICAgICAgICAgIGxldCBnR2x5cGhzID0gZ3JvdXBHbHlwaHNbZ2x5cGhzXTtcbiAgICAgICAgICAgIGlmIChnR2x5cGhzKSB7XG4gICAgICAgICAgICAgICAgc2dHbHlwaHMucHVzaChnR2x5cGhzKTtcbiAgICAgICAgICAgICAgICBzZ01pbiA9IE1hdGgubWluKHNnTWluLCBnR2x5cGhzLm1pbigpKTtcbiAgICAgICAgICAgICAgICBzZ01heCA9IE1hdGgubWF4KHNnTWF4LCBnR2x5cGhzLm1heCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2dHbHlwaHMuZm9yRWFjaChnbHlwaCA9PiB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChuZXcgR2x5cGhzLlBhZGRlZEdseXBoKGdseXBoLCBzZ01pbiwgc2dNYXgpKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGllci5zdXBlckdyb3Vwcyk7XG5cbiAgICBSLm1hcChnbHlwaCA9PiBnbHlwaHMucHVzaChnbHlwaCksIGdyb3VwR2x5cGhzKTtcblxuICAgIGxldCBbc3VidGllcnMsIHN1YnRpZXJzRXhjZWVkZWRdID0gYnVtcFN1YnRpZXJzKHRpZXIsIGdseXBocywgZ3JpZCwgeSk7XG5cbiAgICB0aWVyLmdseXBoQ2FjaGVPcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgaWYgKHN1YnRpZXJzRXhjZWVkZWQpXG4gICAgICAgIHRpZXIudXBkYXRlU3RhdHVzKCdCdW1waW5nIGxpbWl0IGV4Y2VlZGVkLCB1c2UgdGhlIHRyYWNrIGVkaXRvciB0byBzZWUgbW9yZSBmZWF0dXJlcycpO1xuICAgIGVsc2VcbiAgICAgICAgdGllci51cGRhdGVTdGF0dXMoKTtcblxuICAgIHRpZXIuc3VidGllcnMgPSBzdWJ0aWVycztcbn1cblxuLy8gRmlsbHMgb3V0IGFyZWFzIHRoYXQgaGF2ZW4ndCBiZWVuIGZldGNoZWQgYXMgZ3JheSBibG9ja3NcbmZ1bmN0aW9uIGRyYXdVbm1hcHBlZCh0aWVyLCBjYW52YXMsIHBhZGRpbmcpIHtcbiAgICBsZXQgZHJhd1N0YXJ0ID0gIHRpZXIuYnJvd3Nlci52aWV3U3RhcnQgLSAxMDAwLjAvdGllci5icm93c2VyLnNjYWxlO1xuICAgIGxldCBkcmF3RW5kID0gdGllci5icm93c2VyLnZpZXdFbmQgKyAxMDAwLjAvdGllci5icm93c2VyLnNjYWxlO1xuICAgIGxldCB1bm1hcHBlZEJsb2NrcyA9IFtdO1xuICAgIGlmICh0aWVyLmtub3duQ292ZXJhZ2UpIHtcbiAgICAgICAgbGV0IGtub3duUmFuZ2VzID0gdGllci5rbm93bkNvdmVyYWdlLnJhbmdlcygpO1xuICAgICAgICBrbm93blJhbmdlcy5mb3JFYWNoKChyYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5taW4oKSA+IGRyYXdTdGFydClcbiAgICAgICAgICAgICAgICAgICAgdW5tYXBwZWRCbG9ja3MucHVzaCh7bWluOiBkcmF3U3RhcnQsIG1heDogcmFuZ2UubWluKCkgLSAxfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVubWFwcGVkQmxvY2tzLnB1c2goe21pbjoga25vd25SYW5nZXNbaW5kZXgtMV0ubWF4KCkgKyAxLCBtYXg6IHJhbmdlLm1pbigpIC0gMX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT0ga25vd25SYW5nZXMubGVuZ3RoIC0gMSAmJiByYW5nZS5tYXgoKSA8IGRyYXdFbmQpIHtcbiAgICAgICAgICAgICAgICB1bm1hcHBlZEJsb2Nrcy5wdXNoKHttaW46IHJhbmdlLm1heCgpICsgMSwgbWF4OiBkcmF3RW5kfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodW5tYXBwZWRCbG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjYW52YXMuZmlsbFN0eWxlID0gJ2dyYXknO1xuICAgICAgICB1bm1hcHBlZEJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgIGxldCBtaW4gPSAoYmxvY2subWluIC0gdGllci5icm93c2VyLnZpZXdTdGFydCkgKiB0aWVyLmJyb3dzZXIuc2NhbGUgKyAxMDAwO1xuICAgICAgICAgICAgbGV0IG1heCA9IChibG9jay5tYXggLSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0KSAqIHRpZXIuYnJvd3Nlci5zY2FsZSArIDEwMDA7XG4gICAgICAgICAgICBjYW52YXMuZmlsbFJlY3QobWluLCAwLCBtYXggLSBtaW4sIHBhZGRpbmcpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFyVmlld3BvcnQoY2FudmFzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY2FudmFzLmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbn1cblxuLy8gTWFrZSB0aGUgdmlld3BvcnQgJiBjYW52YXMgdGhlIGNvcnJlY3Qgc2l6ZSBmb3IgdGhlIHRpZXJcbmZ1bmN0aW9uIHByZXBhcmVWaWV3cG9ydCh0aWVyLCBjYW52YXMsIHJldGluYSwgY2xlYXI9dHJ1ZSwgdk9mZnNldD0wKSB7XG4gICAgY2FudmFzLnNhdmUoKTtcbiAgICBsZXQgZGVzaXJlZFdpZHRoID0gdGllci5icm93c2VyLmZlYXR1cmVQYW5lbFdpZHRoICsgMjAwMDtcbiAgICBpZiAocmV0aW5hKSB7XG4gICAgICAgIGRlc2lyZWRXaWR0aCAqPSAyO1xuICAgIH1cblxuICAgIGxldCBmcHcgPSB0aWVyLnZpZXdwb3J0LndpZHRofDA7XG4gICAgaWYgKGZwdyA8IGRlc2lyZWRXaWR0aCAtIDUwKSB7XG4gICAgICAgIHRpZXIudmlld3BvcnQud2lkdGggPSBmcHcgPSBkZXNpcmVkV2lkdGg7XG4gICAgfVxuXG4gICAgbGV0IGxoID0gdGllci5wYWRkaW5nICsgdk9mZnNldDtcblxuICAgIHRpZXIuc3VidGllcnMuZm9yRWFjaChzID0+IGxoICs9IHMuaGVpZ2h0ICsgdGllci5wYWRkaW5nKTtcblxuICAgIGxoICs9IDY7XG4gICAgbGggPSBNYXRoLm1heChsaCwgdGllci5icm93c2VyLm1pblRpZXJIZWlnaHQpO1xuXG4gICAgbGV0IGNhbnZhc0hlaWdodCA9IGxoO1xuICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgY2FudmFzSGVpZ2h0ICo9IDI7XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhc0hlaWdodCAhPSB0aWVyLnZpZXdwb3J0LmhlaWdodCkge1xuICAgICAgICB0aWVyLnZpZXdwb3J0LmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICB9XG5cbiAgICB0aWVyLnZpZXdwb3J0SG9sZGVyLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgdGllci52aWV3cG9ydC5zdHlsZS53aWR0aCA9IHJldGluYSA/ICgnJyArIChmcHcvMikgKyAncHgnKSA6ICgnJyArIGZwdyArICdweCcpO1xuICAgIHRpZXIudmlld3BvcnQuc3R5bGUuaGVpZ2h0ID0gJycgKyBsaCArICdweCc7XG4gICAgdGllci5sYXlvdXRIZWlnaHQgPSAgTWF0aC5tYXgobGgsIHRpZXIuYnJvd3Nlci5taW5UaWVySGVpZ2h0KTtcblxuICAgIHRpZXIudXBkYXRlSGVpZ2h0KCk7XG4gICAgdGllci5ub3JpZ2luID0gdGllci5icm93c2VyLnZpZXdTdGFydDtcblxuICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgY2FudmFzLnNjYWxlKDIsIDIpO1xuICAgIH1cblxuICAgIGlmIChjbGVhcikge1xuICAgICAgICBjbGVhclZpZXdwb3J0KGNhbnZhcywgZnB3LCBjYW52YXNIZWlnaHQpO1xuICAgIH1cblxuICAgIGRyYXdVbm1hcHBlZCh0aWVyLCBjYW52YXMsIGxoKTtcblxuICAgIGNhbnZhcy5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIHBhaW50KHRpZXIsIGNhbnZhcywgdk9mZnNldD0wKSB7XG4gICAgY2FudmFzLnNhdmUoKTtcbiAgICBsZXQgb3ZlcmxheUxhYmVsQ2FudmFzID0gbmV3IEdseXBocy5PdmVybGF5TGFiZWxDYW52YXMoKTtcbiAgICBsZXQgb2Zmc2V0ID0gKCh0aWVyLmdseXBoQ2FjaGVPcmlnaW4gLSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0KSp0aWVyLmJyb3dzZXIuc2NhbGUpKzEwMDA7XG4gICAgY2FudmFzLnRyYW5zbGF0ZShvZmZzZXQsIHZPZmZzZXQgKyB0aWVyLnBhZGRpbmcpO1xuICAgIG92ZXJsYXlMYWJlbENhbnZhcy50cmFuc2xhdGUoMCwgdGllci5wYWRkaW5nKTtcblxuICAgIHRpZXIucGFpbnRUb0NvbnRleHQoY2FudmFzLCBvdmVybGF5TGFiZWxDYW52YXMsIG9mZnNldCk7XG5cbiAgICBpZiAob3ZlcmxheUxhYmVsQ2FudmFzLmdseXBocy5sZW5ndGggPiAwKVxuICAgICAgICB0aWVyLm92ZXJsYXlMYWJlbENhbnZhcyA9IG92ZXJsYXlMYWJlbENhbnZhcztcbiAgICBlbHNlXG4gICAgICAgIHRpZXIub3ZlcmxheUxhYmVsQ2FudmFzID0gbnVsbDtcbiAgICBjYW52YXMucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRTY29yZU1pbk1heCh0aWVyLCBzdHlsZSkge1xuICAgIGxldCBzbWluID0gdGllci5xdWFudE1pbihzdHlsZSk7XG4gICAgbGV0IHNtYXggPSB0aWVyLnF1YW50TWF4KHN0eWxlKTtcblxuICAgIGlmICghc21heCkge1xuICAgICAgICBpZiAoc21pbiA8IDApIHtcbiAgICAgICAgICAgIHNtYXggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc21heCA9IDEwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc21pbikge1xuICAgICAgICBzbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIFtzbWluLCBzbWF4XTtcbn1cblxuZnVuY3Rpb24gcmVsU2NvcmVPcmlnaW4oc2NvcmUsIHNtaW4sIHNtYXgpIHtcbiAgICBsZXQgcmVsU2NvcmUgPSAoKDEuMCAqIHNjb3JlKSAtIHNtaW4pIC8gKHNtYXgtc21pbik7XG4gICAgbGV0IHJlbE9yaWdpbiA9ICgtMS4wICogc21pbikgLyAoc21heCAtIHNtaW4pO1xuXG4gICAgcmV0dXJuIFtyZWxTY29yZSwgcmVsT3JpZ2luXTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVmU2VxKHRpZXIsIG1pbiwgbWF4KSB7XG4gICAgbGV0IHJlZlNlcSA9IG51bGw7XG4gICAgaWYgKHRpZXIuY3VycmVudFNlcXVlbmNlKSB7XG4gICAgICAgIGxldCBjc1N0YXJ0ID0gdGllci5jdXJyZW50U2VxdWVuY2Uuc3RhcnR8MDtcbiAgICAgICAgbGV0IGNzRW5kID0gdGllci5jdXJyZW50U2VxdWVuY2UuZW5kfDA7XG4gICAgICAgIGlmIChjc1N0YXJ0IDw9IG1heCAmJiBjc0VuZCA+PSBtaW4pIHtcbiAgICAgICAgICAgIGxldCBzZk1pbiA9IE1hdGgubWF4KG1pbiwgY3NTdGFydCk7XG4gICAgICAgICAgICBsZXQgc2ZNYXggPSBNYXRoLm1pbihtYXgsIGNzRW5kKTtcblxuICAgICAgICAgICAgcmVmU2VxID0gdGllci5jdXJyZW50U2VxdWVuY2Uuc2VxLnN1YnN0cihzZk1pbiAtIGNzU3RhcnQsIHNmTWF4IC0gc2ZNaW4gKyAxKTtcbiAgICAgICAgICAgIHdoaWxlIChtaW4gPCBzZk1pbikge1xuICAgICAgICAgICAgICAgIHJlZlNlcSA9ICdOJyArIHJlZlNlcTtcbiAgICAgICAgICAgICAgICBzZk1pbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG1heCA+IHNmTWF4KSB7XG4gICAgICAgICAgICAgICAgcmVmU2VxID0gcmVmU2VxICsgJ04nO1xuICAgICAgICAgICAgICAgIHNmTWF4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZlNlcTtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZVRvQ3Jvc3NMaWtlR2x5cGgoY2FudmFzLCB0aWVyLCBmZWF0dXJlLCB5LCBnbHlwaFR5cGUsIHN0eWxlLCBmb3JjZUhlaWdodCwgbm9MYWJlbCkge1xuICAgIGxldCBzY2FsZSA9IHRpZXIuYnJvd3Nlci5zY2FsZTtcbiAgICBsZXQgb3JpZ2luID0gdGllci5icm93c2VyLnZpZXdTdGFydDtcblxuICAgIGxldCBzY29yZSA9IGZlYXR1cmUuc2NvcmU7XG4gICAgbGV0IGxhYmVsID0gZmVhdHVyZS5sYWJlbCB8fCBmZWF0dXJlLmlkO1xuXG4gICAgbGV0IG1pblBvcyA9IChmZWF0dXJlLm1pbiAtIG9yaWdpbikgKiBzY2FsZTtcbiAgICBsZXQgbWF4UG9zID0gTWF0aC5tYXgoKGZlYXR1cmUubWF4IC0gb3JpZ2luICsgMSkgKiBzY2FsZSwgbWluUG9zICsgMSk7XG5cbiAgICBsZXQgaGVpZ2h0ID0gKHRpZXIuZm9yY2VIZWlnaHQgfHwgc3R5bGUuSEVJR0hUIHx8IGZvcmNlSGVpZ2h0IHx8IDEyKSAqIDEuMDtcbiAgICBsZXQgcmVxdWlyZWRIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBsZXQgZ2x5cGggPSBudWxsO1xuICAgIGxldCBxdWFudCA9IG51bGw7XG5cbiAgICBsZXQgc3Ryb2tlID0gc3R5bGUuRkdDT0xPUiB8fCAnYmxhY2snO1xuICAgIGxldCBmaWxsID0gc3R5bGUuQkdDT0xPUiB8fCAnbm9uZSc7XG4gICAgbGV0IG91dGxpbmUgPSBzdHlsZS5TVFJPS0VDT0xPUjtcblxuICAgIGlmIChzdHlsZS5CR0lURU0gJiYgZmVhdHVyZS5pdGVtUmdiKSB7XG4gICAgICAgIHN0cm9rZSA9IGZlYXR1cmUuaXRlbVJnYjtcblxuICAgIH0gZWxzZSBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5DT0xPUl9CWV9TQ09SRTIpKSB7XG4gICAgICAgIGxldCBncmFkID0gc3R5bGUuQkdHUkFEIHx8IHN0eWxlLl9ncmFkaWVudDtcbiAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICBncmFkID0gbWFrZUdyYWRpZW50KDUwLCBzdHlsZS5DT0xPUjEsIHN0eWxlLkNPTE9SMiwgc3R5bGUuQ09MT1IzKTtcbiAgICAgICAgICAgIHN0eWxlLl9ncmFkaWVudCA9IGdyYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2NvcmUyID0gZmVhdHVyZS5zY29yZTI7XG4gICAgICAgIGlmIChzY29yZTIgIT09IHVuZGVmaW5lZCB8fCAhc3Ryb2tlKSB7XG4gICAgICAgICAgICBzY29yZTIgPSBzY29yZTIgfHwgMDtcblxuICAgICAgICAgICAgbGV0IHNtaW4yID0gc3R5bGUuTUlOMiA/ICgxLjAgKiBzdHlsZS5NSU4yKSA6IDAuMDtcbiAgICAgICAgICAgIGxldCBzbWF4MiA9IHN0eWxlLk1BWDIgPyAoMS4wICogc3R5bGUuTUFYMikgOiAxLjA7XG4gICAgICAgICAgICBsZXQgcmVsU2NvcmUyID0gKCgxLjAgKiBzY29yZTIpIC0gc21pbjIpIC8gKHNtYXgyLXNtaW4yKTtcblxuICAgICAgICAgICAgbGV0IHN0ZXAgPSAocmVsU2NvcmUyKmdyYWQubGVuZ3RoKSB8IDA7XG4gICAgICAgICAgICBSLmNsYW1wKDAsIHN0ZXAsIGdyYWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBzdHJva2UgPSBncmFkW3N0ZXBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNpemUgPSBzdHlsZS5TSVpFIHx8IGhlaWdodDtcbiAgICBpZiAoc3R5bGUuUlNJWkUpIHtcbiAgICAgICAgc2l6ZSA9ICgxLjAgKiBzdHlsZS5SU0laRSkgKiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLlNUUk9LRVRIUkVTSE9MRCkge1xuICAgICAgICBpZiAoc2l6ZSA8ICgxLjAgKiBzdHlsZS5TVFJPS0VUSFJFU0hPTEQpKVxuICAgICAgICAgICAgb3V0bGluZSA9IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IG1pZCA9IChtaW5Qb3MgKyBtYXhQb3MpLzI7XG5cbiAgICBpZiAoZ2x5cGhUeXBlID09PSAnRVgnKSB7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5FeEdseXBoKG1pZCwgc2l6ZSwgc3Ryb2tlKTtcblxuICAgIH0gZWxzZSBpZiAoZ2x5cGhUeXBlID09PSAnVFJJQU5HTEUnKSB7XG4gICAgICAgIGxldCBkaXIgPSBzdHlsZS5ESVJFQ1RJT04gfHwgJ04nO1xuICAgICAgICBsZXQgd2lkdGggPSBzdHlsZS5MSU5FV0lEVEggfHwgc2l6ZTtcbiAgICAgICAgZ2x5cGggPSBuZXcgR2x5cGhzLlRyaWFuZ2xlR2x5cGgobWlkLCBzaXplLCBkaXIsIHdpZHRoLCBzdHJva2UsIG91dGxpbmUpO1xuXG4gICAgfSBlbHNlIGlmIChnbHlwaFR5cGUgPT09ICdET1QnKSB7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5Eb3RHbHlwaChtaWQsIHNpemUsIHN0cm9rZSwgb3V0bGluZSk7XG5cbiAgICB9IGVsc2UgaWYgKGdseXBoVHlwZSA9PT0gJ1BMSU1TT0xMJykge1xuICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuUGxpbXNvbGxHbHlwaChtaWQsIHNpemUsIDAuMiAqIHNpemUsIHN0cm9rZSwgb3V0bGluZSk7XG5cbiAgICB9IGVsc2UgaWYgKGdseXBoVHlwZSA9PT0gJ1NRVUFSRScpIHtcbiAgICAgICAgZ2x5cGggPSBuZXcgR2x5cGhzLkJveEdseXBoKG1pZCAtIHNpemUvMiwgMCwgc2l6ZSwgc2l6ZSwgc3Ryb2tlLCBvdXRsaW5lKTtcblxuICAgIH0gZWxzZSBpZiAoZ2x5cGhUeXBlID09PSAnU1RBUicpIHtcbiAgICAgICAgbGV0IHBvaW50cyA9IHN0eWxlLlBPSU5UUyB8fCA1O1xuICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuU3RhckdseXBoKG1pZCwgc2l6ZS8yLCBwb2ludHMsIHN0cm9rZSwgb3V0bGluZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuQ3Jvc3NHbHlwaChtaWQsIHNpemUsIHN0cm9rZSk7XG5cbiAgICB9XG5cbiAgICBpZiAoZmlsbCAmJiBmaWxsICE9PSAnbm9uZScgJiYgKG1heFBvcyAtIG1pblBvcykgPiA1KSB7XG4gICAgICAgIGxldCBib3hHbHlwaCA9IG5ldyBHbHlwaHMuQm94R2x5cGgobWluUG9zLCAwLCAobWF4UG9zIC0gbWluUG9zKSwgc2l6ZSwgZmlsbCk7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5Hcm91cEdseXBoKFtib3hHbHlwaCwgZ2x5cGhdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5TQ0FUVEVSKSkge1xuICAgICAgICBsZXQgW3NtaW4sIHNtYXhdID0gZ2V0U2NvcmVNaW5NYXgodGllciwgc3R5bGUpO1xuXG4gICAgICAgIGxldCBbcmVsU2NvcmUsIHJlbE9yaWdpbl0gPSByZWxTY29yZU9yaWdpbihzY29yZSwgc21pbiwgc21heCk7XG5cbiAgICAgICAgaWYgKHJlbFNjb3JlIDwgMC4wIHx8IHJlbFNjb3JlID4gMS4wKSB7XG4gICAgICAgICAgICAvLyBHbHlwaCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAgICAgICAgLy8gU2hvdWxkIHdlIGFsbG93IGZvciBcInBhcnRpYWxseSBzaG93aW5nXCIgZ2x5cGhzP1xuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5TaGlmdCA9IHggPT4gKHggLSByZWxPcmlnaW4pICogcmVxdWlyZWRIZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxLCBvcmlnaW5TaGlmdChyZWxTY29yZSkpO1xuICAgICAgICAgICAgeSA9IHkgKyBvcmlnaW5TaGlmdCgxKTtcblxuICAgICAgICAgICAgaWYgKHJlbFNjb3JlID49IHJlbE9yaWdpbilcbiAgICAgICAgICAgICAgICB5ID0geSAtIGhlaWdodDtcblxuICAgICAgICAgICAgcXVhbnQgPSB7bWluOiBzbWluLCBtYXg6IHNtYXh9O1xuXG4gICAgICAgICAgICBsZXQgaGVpZ2h0RnVkZ2UgPSAwO1xuICAgICAgICAgICAgbGV0IGZlYXR1cmVMYWJlbCA9IFIuZGVmYXVsdFRvKHN0eWxlLkxBQkVMLCBmZWF0dXJlLmZvcmNlTGFiZWwpO1xuXG4gICAgICAgICAgICBpZiAoaXNEYXNCb29sZWFuTm90RmFsc2UoZmVhdHVyZUxhYmVsKSAmJiBsYWJlbCAmJiAhbm9MYWJlbCkge1xuICAgICAgICAgICAgICAgIGdseXBoID0gbmV3IEdseXBocy5MYWJlbGxlZEdseXBoKGNhbnZhcywgZ2x5cGgsIGxhYmVsLCB0cnVlLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMYWJlbCA9PSAnYWJvdmUnID8gJ2Fib3ZlJyA6ICdiZWxvdycpO1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTGFiZWwgPT09ICdhYm92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0RnVkZ2UgPSBnbHlwaC50ZXh0SGVpZ2h0ICsgMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9MYWJlbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbHlwaCA9IG5ldyBHbHlwaHMuVHJhbnNsYXRlZEdseXBoKGdseXBoLCAwLCB5IC0gKHNpemUgLyAyKSAtIGhlaWdodEZ1ZGdlLCByZXF1aXJlZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2dseXBoLCBxdWFudF07XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmVUb0dyYWRpZW50TGlrZUdseXBoKGNhbnZhcywgdGllciwgZmVhdHVyZSwgeSwgZ2x5cGhUeXBlLCBzdHlsZSwgZm9yY2VIZWlnaHQpIHtcbiAgICBsZXQgc2NhbGUgPSB0aWVyLmJyb3dzZXIuc2NhbGU7XG4gICAgbGV0IG9yaWdpbiA9IHRpZXIuYnJvd3Nlci52aWV3U3RhcnQ7XG5cbiAgICBsZXQgc2NvcmUgPSBmZWF0dXJlLnNjb3JlO1xuXG4gICAgbGV0IG1pblBvcyA9IChmZWF0dXJlLm1pbiAtIG9yaWdpbikgKiBzY2FsZTtcbiAgICBsZXQgbWF4UG9zID0gTWF0aC5tYXgoKGZlYXR1cmUubWF4IC0gb3JpZ2luICsgMSkgKiBzY2FsZSwgbWluUG9zICsgMSk7XG5cbiAgICBsZXQgaGVpZ2h0ID0gKHRpZXIuZm9yY2VIZWlnaHQgfHwgc3R5bGUuSEVJR0hUIHx8IGZvcmNlSGVpZ2h0IHx8IDEyKSAqIDEuMDtcbiAgICBsZXQgcmVxdWlyZWRIZWlnaHQgPSBoZWlnaHQgKiAxLjA7XG5cbiAgICBsZXQgZ2x5cGggPSBudWxsO1xuICAgIGxldCBxdWFudCA9IG51bGw7XG5cbiAgICBsZXQgY2VudGVyT25BeGlzID0gaXNEYXNCb29sZWFuVHJ1ZShzdHlsZVtcIkFYSVNDRU5URVJcIl0pO1xuXG5cbiAgICBsZXQgW3NtaW4sIHNtYXhdID0gZ2V0U2NvcmVNaW5NYXgodGllciwgc3R5bGUpO1xuXG4gICAgLy8gQVVUT01JTiAmIEFVVE9NQVggcmVzcGVjdGl2ZWx5IHNldCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kc1xuICAgIGlmIChpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLkFVVE9NSU4pKSB7XG4gICAgICAgIHNtaW4gPSB0aWVyLmN1cnJlbnRGZWF0dXJlc01pblNjb3JlKjAuOTU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic21pbjpcXHRcIiArIHNtaW4pO1xuICAgIH1cbiAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5BVVRPTUFYKSkge1xuICAgICAgICBzbWF4ID0gdGllci5jdXJyZW50RmVhdHVyZXNNYXhTY29yZSoxLjA1O1xuICAgICAgICBjb25zb2xlLmxvZyhcInNtYXg6XFx0XCIgKyBzbWF4KTtcbiAgICB9XG5cbiAgICBpZiAoKDEuMCAqIHNjb3JlKSA8ICgxLjAgKiBzbWluKSkge1xuICAgICAgICBzY29yZSA9IHNtaW47XG4gICAgfVxuICAgIGlmICgoMS4wICogc2NvcmUpID4gKDEuMCAqIHNtYXgpKSB7XG4gICAgICAgIHNjb3JlID0gc21heDtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBzbWluL3NtYXggaW4gY2FzZSB3ZSB3YW50IHRvIGNlbnRlciB0aGUgaGlzdG9ncmFtXG4gICAgLy8gb24gdGhlIGhvcml6b250YWwgYXhpc1xuICAgIGlmIChjZW50ZXJPbkF4aXMpIHtcbiAgICAgICAgbGV0IHRtaW4gPSB0aWVyLnF1YW50TWluKHN0eWxlKTtcbiAgICAgICAgbGV0IHRtYXggPSB0aWVyLnF1YW50TWF4KHN0eWxlKTtcblxuICAgICAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5BVVRPTUlOKSkge1xuICAgICAgICAgICAgdG1pbiA9IHRpZXIuY3VycmVudEZlYXR1cmVzTWluU2NvcmUqMC45NTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5BVVRPTUFYKSkge1xuICAgICAgICAgICAgdG1heCA9IHRpZXIuY3VycmVudEZlYXR1cmVzTWF4U2NvcmUqMS4wNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNtaW4gPSB0bWluIC0gKCh0bWF4IC0gdG1pbikgLyAyKTtcbiAgICAgICAgc21heCA9IHRtYXggLSAoKHRtYXggLSB0bWluKSAvIDIpO1xuICAgIH1cblxuICAgIGxldCBbcmVsU2NvcmUsIHJlbE9yaWdpbl0gPSByZWxTY29yZU9yaWdpbihzY29yZSwgc21pbiwgc21heCk7XG5cbiAgICBpZiAoZ2x5cGhUeXBlID09PSAnSElTVE9HUkFNJykge1xuICAgICAgICBsZXQgb3JpZ2luU2hpZnQgPSB4ID0+IHggLSBNYXRoLm1heCgwLCByZWxPcmlnaW4pO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmFicyhvcmlnaW5TaGlmdChyZWxTY29yZSkpICogcmVxdWlyZWRIZWlnaHQ7XG4gICAgICAgIHkgPSB5ICsgb3JpZ2luU2hpZnQoMS4wKSAqIHJlcXVpcmVkSGVpZ2h0O1xuXG4gICAgICAgIGlmIChyZWxTY29yZSA+PSByZWxPcmlnaW4pXG4gICAgICAgICAgICB5IC09IGhlaWdodDtcblxuICAgICAgICBpZiAoY2VudGVyT25BeGlzKVxuICAgICAgICAgICAgeSArPSBoZWlnaHQgLyAyO1xuXG4gICAgICAgIGlmIChpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlW1wiSElERUFYSVNMQUJFTFwiXSkpXG4gICAgICAgICAgICBxdWFudCA9IG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHF1YW50ID0ge21pbjogc21pbiwgbWF4OiBzbWF4fTtcbiAgICB9XG5cbiAgICBsZXQgc3Ryb2tlID0gc3R5bGUuRkdDT0xPUiB8fCBudWxsO1xuICAgIGxldCBmaWxsID0gc3R5bGUuQkdDT0xPUiB8fCBzdHlsZS5DT0xPUjEgfHwgJ2dyZWVuJztcbiAgICBpZiAoc3R5bGUuQkdJVEVNICYmIGZlYXR1cmUuaXRlbVJnYilcbiAgICAgICAgZmlsbCA9IGZlYXR1cmUuaXRlbVJnYjtcbiAgICBsZXQgYWxwaGEgPSBzdHlsZS5BTFBIQSA/ICgxLjAgKiBzdHlsZS5BTFBIQSkgOiBudWxsO1xuXG4gICAgaWYgKHN0eWxlLkJHR1JBRCkge1xuICAgICAgICBsZXQgZ3JhZCA9IHN0eWxlLkJHR1JBRDtcbiAgICAgICAgbGV0IHN0ZXAgPSAocmVsU2NvcmUqZ3JhZC5sZW5ndGgpfDA7XG4gICAgICAgIHN0ZXAgPSBSLmNsYW1wKDAsIHN0ZXAsIGdyYWQubGVuZ3RoIC0gMSk7XG4gICAgICAgIGZpbGwgPSBncmFkW3N0ZXBdO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5DT0xPUjIpIHtcbiAgICAgICAgbGV0IGdyYWQgPSBzdHlsZS5fZ3JhZGllbnQ7XG4gICAgICAgIGlmICghZ3JhZCkge1xuICAgICAgICAgICAgZ3JhZCA9IG1ha2VHcmFkaWVudCg1MCwgc3R5bGUuQ09MT1IxLCBzdHlsZS5DT0xPUjIsIHN0eWxlLkNPTE9SMyk7XG4gICAgICAgICAgICBzdHlsZS5fZ3JhZGllbnQgPSBncmFkO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0ZXAgPSAocmVsU2NvcmUqZ3JhZC5sZW5ndGgpIHwgMDtcbiAgICAgICAgc3RlcCA9IFIuY2xhbXAoMCwgc3RlcCwgZ3JhZC5sZW5ndGggLSAxKTtcbiAgICAgICAgZmlsbCA9IGdyYWRbc3RlcF07XG4gICAgfVxuXG4gICAgbGV0IHRlbXBHbHlwaCA9IG5ldyBHbHlwaHMuQm94R2x5cGgobWluUG9zLCB5LCAobWF4UG9zIC0gbWluUG9zKSwgaGVpZ2h0LCBmaWxsLCBzdHJva2UsIGFscGhhKTtcbiAgICBnbHlwaCA9IG5ldyBHbHlwaHMuVHJhbnNsYXRlZEdseXBoKHRlbXBHbHlwaCwgMCwgMCwgcmVxdWlyZWRIZWlnaHQpO1xuXG4gICAgcmV0dXJuIFtnbHlwaCwgcXVhbnRdO1xufVxuXG5mdW5jdGlvbiBmZWF0dXJlVG9Qb2ludEdseXBoKHRpZXIsIGZlYXR1cmUsIHN0eWxlKSB7XG4gICAgbGV0IHNjYWxlID0gdGllci5icm93c2VyLnNjYWxlO1xuICAgIGxldCBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgbGV0IHNjb3JlID0gZmVhdHVyZS5zY29yZTtcblxuICAgIGxldCBtaW5Qb3MgPSAoZmVhdHVyZS5taW4gLSBvcmlnaW4pICogc2NhbGU7XG4gICAgbGV0IG1heFBvcyA9IE1hdGgubWF4KChmZWF0dXJlLm1heCAtIG9yaWdpbiArIDEpICogc2NhbGUsIG1pblBvcyArIDEpO1xuXG4gICAgbGV0IGhlaWdodCA9IHRpZXIuZm9yY2VIZWlnaHQgfHwgc3R5bGUuSEVJR0hUIHx8IDMwO1xuXG4gICAgbGV0IGdseXBoID0gbnVsbDtcbiAgICBsZXQgcXVhbnQgPSBudWxsO1xuXG4gICAgbGV0IFtzbWluLCBzbWF4XSA9IGdldFNjb3JlTWluTWF4KHRpZXIsIHN0eWxlKTtcbiAgICBsZXQgeXNjYWxlID0gKCgxLjAgKiBoZWlnaHQpIC8gKHNtYXggLSBzbWluKSk7XG4gICAgbGV0IHJlbFNjb3JlID0gKCgxLjAgKiBzY29yZSkgLSBzbWluKSAvIChzbWF4LXNtaW4pO1xuICAgIGxldCBzYyA9ICgoc2NvcmUgLSAoMS4wKnNtaW4pKSAqIHlzY2FsZSl8MDtcbiAgICBxdWFudCA9IHttaW46IHNtaW4sIG1heDogc21heH07XG5cbiAgICBsZXQgZmlsbCA9IHN0eWxlLkZHQ09MT1IgfHwgc3R5bGUuQ09MT1IxIHx8ICdibGFjayc7XG4gICAgaWYgKHN0eWxlLkNPTE9SMikge1xuICAgICAgICBsZXQgZ3JhZCA9IHN0eWxlLl9ncmFkaWVudDtcbiAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICBncmFkID0gbWFrZUdyYWRpZW50KDUwLCBzdHlsZS5DT0xPUjEsIHN0eWxlLkNPTE9SMiwgc3R5bGUuQ09MT1IzKTtcbiAgICAgICAgICAgIHN0eWxlLl9ncmFkaWVudCA9IGdyYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RlcCA9IChyZWxTY29yZSpncmFkLmxlbmd0aCl8MDtcbiAgICAgICAgc3RlcCA9IFIuY2xhbXAoMCwgc3RlcCwgZ3JhZC5sZW5ndGggLSAxKTtcbiAgICAgICAgZmlsbCA9IGdyYWRbc3RlcF07XG4gICAgfVxuXG4gICAgZ2x5cGggPSBuZXcgR2x5cGhzLlBvaW50R2x5cGgoKG1pblBvcyArIG1heFBvcykvMiwgaGVpZ2h0LXNjLCBoZWlnaHQsIGZpbGwpO1xuXG4gICAgcmV0dXJuIFtnbHlwaCwgcXVhbnRdO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW5jZUdseXBoKGNhbnZhcywgdGllciwgZmVhdHVyZSwgc3R5bGUsIGZvcmNlSGVpZ2h0KSB7XG4gICAgbGV0IHNjYWxlID0gdGllci5icm93c2VyLnNjYWxlO1xuICAgIGxldCBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgbGV0IG1pbiA9IGZlYXR1cmUubWluO1xuICAgIGxldCBtYXggPSBmZWF0dXJlLm1heDtcbiAgICBsZXQgbWluUG9zID0gKGZlYXR1cmUubWluIC0gb3JpZ2luKSAqIHNjYWxlO1xuICAgIGxldCBtYXhQb3MgPSBNYXRoLm1heCgoZmVhdHVyZS5tYXggLSBvcmlnaW4gKyAxKSAqIHNjYWxlLCBtaW5Qb3MgKyAxKTtcblxuICAgIGxldCBoZWlnaHQgPSAodGllci5mb3JjZUhlaWdodCB8fCBzdHlsZS5IRUlHSFQgfHwgZm9yY2VIZWlnaHQgfHwgMTIpICogMS4wO1xuXG4gICAgbGV0IGdseXBoID0gbnVsbDtcblxuICAgIGxldCByYXdzZXEgPSBmZWF0dXJlLnNlcTtcbiAgICBsZXQgc2VxID0gcmF3c2VxO1xuICAgIGxldCByYXdxdWFscyA9IGZlYXR1cmUucXVhbHM7XG4gICAgbGV0IHF1YWxzID0gcmF3cXVhbHM7XG4gICAgbGV0IGluc2VydGlvbkxhYmVscyA9IGlzRGFzQm9vbGVhblRydWUoc3R5bGUuX19JTlNFUlRJT05TKTtcblxuICAgIGxldCBpbmRlbHMgPSBbXTtcbiAgICBpZiAoZmVhdHVyZS5jaWdhcikge1xuICAgICAgICBsZXQgb3BzID0gcGFyc2VDaWdhcihmZWF0dXJlLmNpZ2FyKTtcbiAgICAgICAgc2VxID0gJyc7XG4gICAgICAgIHF1YWxzID0gJyc7XG4gICAgICAgIGxldCBjdXJzb3IgPSAwO1xuXG4gICAgICAgIG9wcy5mb3JFYWNoKGNvID0+IHtcbiAgICAgICAgICAgIGlmIChjby5vcCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgc2VxICs9IHJhd3NlcS5zdWJzdHIoY3Vyc29yLCBjby5jbnQpO1xuICAgICAgICAgICAgICAgIHF1YWxzICs9IHJhd3F1YWxzLnN1YnN0cihjdXJzb3IsIGNvLmNudCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yICs9IGNvLmNudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY28ub3AgPT09ICdEJykge1xuICAgICAgICAgICAgICAgIHNlcSArPSBcIi1cIi5yZXBlYXQoY28uY250KTtcbiAgICAgICAgICAgICAgICBxdWFscyArPSBcIlpcIi5yZXBlYXQoY28uY250KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY28ub3AgPT09ICdJJykge1xuICAgICAgICAgICAgICAgIGxldCBpbnNlcSA9IHJhd3NlcS5zdWJzdHIoY3Vyc29yLCBjby5jbnQpO1xuICAgICAgICAgICAgICAgIGxldCBpZyA9IG5ldyBHbHlwaHMuVHJhbnNsYXRlZEdseXBoKFxuICAgICAgICAgICAgICAgICAgICBuZXcgR2x5cGhzLlRyaWFuZ2xlR2x5cGgobWluUG9zICsgKHNlcS5sZW5ndGgqc2NhbGUpLCA2LCAnUycsIDUsIHRpZXIuYnJvd3Nlci5iYXNlQ29sb3JzWydJJ10pLFxuICAgICAgICAgICAgICAgICAgICAwLCAtMiwgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydGlvbkxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgaWcgPSBuZXcgR2x5cGhzLkxhYmVsbGVkR2x5cGgoY2FudmFzLCBpZywgaW5zZXEsIGZhbHNlLCAnY2VudGVyJywgJ2Fib3ZlJywgJzdweCBzYW5zLXNlcmlmJyk7XG4gICAgICAgICAgICAgICAgaWcuZmVhdHVyZSA9IHtsYWJlbDogJ0luc2VydGlvbjogJyArIGluc2VxLCB0eXBlOiAnaW5zZXJ0aW9uJywgbWV0aG9kOiAnaW5zZXJ0aW9uJ307XG4gICAgICAgICAgICAgICAgaW5kZWxzLnB1c2goaWcpO1xuXG4gICAgICAgICAgICAgICAgY3Vyc29yICs9IGNvLmNudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY28ub3AgPT09ICdTJykge1xuICAgICAgICAgICAgICAgIGN1cnNvciArPSBjby5jbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1bmtub3duIGNpZ29wJyArIGNvLm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlZlNlcSA9IGdldFJlZlNlcSh0aWVyLCBtaW4sIG1heCk7XG4gICAgaWYgKHNlcSAmJiByZWZTZXEgJiZcbiAgICAgICAgKHN0eWxlLl9fU0VRQ09MT1IgPT09ICdtaXNtYXRjaCcgfHxcbiAgICAgICAgIHN0eWxlLl9fU0VRQ09MT1IgPT09ICdtaXNtYXRjaC1hbGwnKSkge1xuICAgICAgICBsZXQgbWlzbWF0Y2hTZXEgPSBbXTtcbiAgICAgICAgbGV0IG1hdGNoID0gZmVhdHVyZS5vcmllbnRhdGlvbiA9PT0gJy0nID8gJywnIDogJy4nO1xuICAgICAgICBzZXEuZm9yRWFjaCgoXywgaSkgPT4gbWlzbWF0Y2hTZXEucHVzaChzZXFbaV0gPT0gcmVmU2VxW2ldID8gbWF0Y2ggOiBzZXFbaV0pKTtcbiAgICAgICAgc2VxID0gbWlzbWF0Y2hTZXEuam9pbignJyk7XG4gICAgfVxuXG4gICAgbGV0IHN0cmFuZENvbG9yID0gZmVhdHVyZS5vcmllbnRhdGlvbiA9PT0gJy0nID9cbiAgICAgICAgICAgICAgc3R5bGUuX21pbnVzQ29sb3IgfHwgJ2xpZ2h0c2t5Ymx1ZSdcbiAgICAgICAgICAgIDogc3R5bGUuX3BsdXNDb2xvciB8fCAnbGlnaHRzYWxtb24nO1xuXG4gICAgaWYgKHN0eWxlLl9fZGlzYWJsZVF1YWxzKVxuICAgICAgICBxdWFscyA9IGZhbHNlO1xuXG4gICAgZ2x5cGggPSBuZXcgR2x5cGhzLlNlcXVlbmNlR2x5cGgoXG4gICAgICAgIHRpZXIuYnJvd3Nlci5iYXNlQ29sb3JzLFxuICAgICAgICBzdHJhbmRDb2xvcixcbiAgICAgICAgbWluUG9zLFxuICAgICAgICBtYXhQb3MsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgc2VxLFxuICAgICAgICByZWZTZXEsXG4gICAgICAgIHN0eWxlLl9fU0VRQ09MT1IsXG4gICAgICAgIHF1YWxzLFxuICAgICAgICAhaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5fX0NMRUFSQkcpLFxuICAgICAgICB0aWVyLnNjYWxlVmVydGljYWxcbiAgICApO1xuXG4gICAgaWYgKGluc2VydGlvbkxhYmVscylcbiAgICAgICAgZ2x5cGggPSBuZXcgR2x5cGhzLlRyYW5zbGF0ZWRHbHlwaChnbHlwaCwgMCwgNyk7XG5cbiAgICBpZiAoaW5kZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5kZWxzLnNwbGljZSgwLCAwLCBnbHlwaCk7XG4gICAgICAgIGdseXBoID0gbmV3IEdseXBocy5Hcm91cEdseXBoKGluZGVscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufVxuXG5mdW5jdGlvbiBtYWtlTGluZVBsb3QoZmVhdHVyZXMsIHN0eWxlLCB0aWVyLCB5c2hpZnQpIHtcbiAgICB5c2hpZnQgPSB5c2hpZnQgfHwgMDtcblxuICAgIGxldCBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0LCBzY2FsZSA9IHRpZXIuYnJvd3Nlci5zY2FsZTtcbiAgICBsZXQgaGVpZ2h0ID0gdGllci5mb3JjZUhlaWdodCB8fCBzdHlsZS5IRUlHSFQgfHwgMzA7XG4gICAgbGV0IG1pbiA9IHRpZXIucXVhbnRNaW4oc3R5bGUpO1xuICAgIGxldCBtYXggPSB0aWVyLnF1YW50TWF4KHN0eWxlKTtcblxuICAgIC8vIEFVVE9NSU4gJiBBVVRPTUFYIHJlc3BlY3RpdmVseSBzZXQgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZHNcbiAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5BVVRPTUlOKSkge1xuICAgICAgICAvLyBhZGQgc29tZSBiYXNpY2FsbHkgYXJiaXRyYXJ5IHBhZGRpbmdcbiAgICAgICAgbWluID0gdGllci5jdXJyZW50RmVhdHVyZXNNaW5TY29yZSowLjk1O1xuICAgIH1cbiAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5BVVRPTUFYKSkge1xuICAgICAgICBtYXggPSB0aWVyLmN1cnJlbnRGZWF0dXJlc01heFNjb3JlKjEuMDU7XG4gICAgfVxuXG4gICAgbGV0IHlzY2FsZSA9ICgoMS4wICogaGVpZ2h0KSAvIChtYXggLSBtaW4pKTtcbiAgICBsZXQgY29sb3IgPSBzdHlsZS5GR0NPTE9SIHx8IHN0eWxlLkNPTE9SMSB8fCAnYmxhY2snO1xuXG4gICAgbGV0IHByZXZTaWduID0gMTtcbiAgICBsZXQgY3VyU2lnbiA9IG51bGw7XG5cbiAgICBsZXQgY3VyR2x5cGhQb2ludHMgPSBbXTtcbiAgICBsZXQgZ2x5cGhTZXF1ZW5jZXMgPSBbXTtcblxuICAgIGxldCBwcmV2UG9pbnQgPSBudWxsO1xuXG4gICAgZmVhdHVyZXMuZm9yRWFjaChmID0+IHtcbiAgICAgICAgbGV0IHB4ID0gKCgoKGYubWlufDApICsgKGYubWF4fDApKSAvIDIpIC0gb3JpZ2luKSAqIHNjYWxlO1xuICAgICAgICBsZXQgc2MgPSAoKGYuc2NvcmUgLSAoMS4wKm1pbikpICogeXNjYWxlKXwwO1xuXG4gICAgICAgIC8vIEFkZGl0aXZlIHRyYWNrcyBhcmUgYWx3YXlzIGFib3ZlIHRoZSB4LWF4aXMsIGFuZCBhcmUgY29sb3JlZFxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgc2NvcmUgaXMgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXG4gICAgICAgIGlmIChpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLkFERElUSVZFKSkge1xuICAgICAgICAgICAgY3VyU2lnbiA9IGYuc2NvcmUgPCAwID8gLTEgOiAxO1xuXG4gICAgICAgICAgICBpZiAoY3VyU2lnbiAhPT0gcHJldlNpZ24pIHtcbiAgICAgICAgICAgICAgICBnbHlwaFNlcXVlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBjdXJHbHlwaFBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHByZXZTaWduID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLlBPU0NPTE9SXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHN0eWxlLk5FR0NPTE9SXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VyR2x5cGhQb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGFkZCB0aGUgcHJldmlvdXMgcG9pbnQgdG8gdGhpcyBzZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdGhlcmUgaXMgYSBnYXAgaW4gdGhlIHJlc3VsdGluZyBwbG90XG4gICAgICAgICAgICAgICAgY3VyR2x5cGhQb2ludHMucHVzaChwcmV2UG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlNpZ24gPSBjdXJTaWduO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyU2lnbiA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcHkgPSAoaGVpZ2h0IC0gKHNjICogY3VyU2lnbikpICsgeXNoaWZ0O1xuICAgICAgICBwcmV2UG9pbnQgPSB7eDogcHgsIHk6IHB5fTtcbiAgICAgICAgY3VyR2x5cGhQb2ludHMucHVzaChwcmV2UG9pbnQpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBOZWVkIHRvIGFkZCB0aGUgZmluYWwgc2VxdWVuY2Ugb2YgcG9pbnRzIGFzIHdlbGwuXG4gICAgaWYgKGlzRGFzQm9vbGVhblRydWUoc3R5bGUuQURESVRJVkUpKSB7XG4gICAgICAgIGNvbG9yID0gY3VyU2lnbiA9PT0gMSA/IHN0eWxlLlBPU0NPTE9SIDogc3R5bGUuTkVHQ09MT1I7XG4gICAgfVxuICAgIGdseXBoU2VxdWVuY2VzLnB1c2goe1xuICAgICAgICBwb2ludHM6IGN1ckdseXBoUG9pbnRzLFxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcblxuXG4gICAgbGV0IGxnZ3MgPSBnbHlwaFNlcXVlbmNlcy5tYXAoZ3MgPT4ge1xuICAgICAgICBsZXQgbGdnID0gbmV3IEdseXBocy5MaW5lR3JhcGhHbHlwaChncy5wb2ludHMsIGdzLmNvbG9yLCBoZWlnaHQpO1xuICAgICAgICBsZ2cucXVhbnQgPSB7bWluLCBtYXh9O1xuXG4gICAgICAgIGlmIChzdHlsZS5aSU5ERVgpXG4gICAgICAgICAgICBsZ2cuemluZGV4ID0gc3R5bGUuWklOREVYfDA7XG5cbiAgICAgICAgcmV0dXJuIGxnZztcbiAgICB9KTtcblxuICAgIHJldHVybiBsZ2dzO1xufVxuXG5mdW5jdGlvbiBtYWtlU3RhY2tlZEJhcnMoZmVhdHVyZXMsIHRpZXIpIHtcbiAgICBsZXQgZ2x5cGhzID0gW107XG5cbiAgICBsZXQgcG9zU3RhY2tzID0gW10sXG4gICAgICAgIG5lZ1N0YWNrcyA9IFtdO1xuXG4gICAgY29uc3Qgc2NhbGUgPSB0aWVyLmJyb3dzZXIuc2NhbGUsIG9yaWdpbiA9IHRpZXIuYnJvd3Nlci52aWV3U3RhcnQ7XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXNbZmldO1xuICAgICAgICBjb25zdCBzdHlsZSA9IHRpZXIuc3R5bGVGb3JGZWF0dXJlKGZlYXR1cmUpO1xuICAgICAgICBsZXQgc2NvcmUgPSBmZWF0dXJlLnNjb3JlICogMS4wO1xuXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aWVyLmZvcmNlSGVpZ2h0IHx8IHN0eWxlLkhFSUdIVCB8fCAxMjtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRIZWlnaHQgPSBoZWlnaHQgPSAxLjAgKiBoZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgbWluID0gZmVhdHVyZS5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IGZlYXR1cmUubWF4O1xuXG4gICAgICAgIGNvbnN0IG1pblBvcyA9IChtaW4gLSBvcmlnaW4pICogc2NhbGU7XG4gICAgICAgIGNvbnN0IHJhd01heFBvcyA9ICgobWF4IC0gb3JpZ2luICsgMSkgKiBzY2FsZSk7XG4gICAgICAgIGNvbnN0IG1heFBvcyA9IE1hdGgubWF4KHJhd01heFBvcywgbWluUG9zICsgMSk7XG5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgc29tZXdoYXQgbWF0Y2ggdGhlICdISVNUT0dSQU0nIHBhdGguXG5cbiAgICAgICAgdmFyIHNtaW4gPSB0aWVyLnF1YW50TWluKHN0eWxlKTtcbiAgICAgICAgdmFyIHNtYXggPSB0aWVyLnF1YW50TWF4KHN0eWxlKTtcblxuICAgICAgICBpZiAoIXNtYXgpIHtcbiAgICAgICAgICAgIGlmIChzbWluIDwgMCkge1xuICAgICAgICAgICAgICAgIHNtYXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbWF4ID0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWF4ID0gc21heCAqIDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc21pbikge1xuICAgICAgICAgICAgc21pbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWluID0gc21pbiAqIDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFja09yaWdpbjtcbiAgICAgICAgaWYgKHNjb3JlID49IDApIHtcbiAgICAgICAgICAgIHN0YWNrT3JpZ2luID0gcG9zU3RhY2tzW21pbl0gfHwgMDtcbiAgICAgICAgICAgIHBvc1N0YWNrc1ttaW5dID0gc3RhY2tPcmlnaW4gKyBzY29yZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrT3JpZ2luID0gbmVnU3RhY2tzW21pbl0gfHwgMDtcbiAgICAgICAgICAgIG5lZ1N0YWNrc1ttaW5dID0gc3RhY2tPcmlnaW4gKyBzY29yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFja09yaWdpbiA+IHNtYXggfHwgc3RhY2tPcmlnaW4gPCBzbWluKSB7XG4gICAgICAgICAgICAvLyBTdGFjayBoYXMgZXh0ZW5kZWQgb3V0c2lkZSBvZiByYW5nZS5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YWNrT3JpZ2luICsgc2NvcmUgPCBzbWluKSB7XG4gICAgICAgICAgICBzY29yZSA9IHNtaW4gLSBzdGFja09yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2tPcmlnaW4gKyBzY29yZSA+IHNtYXgpIHtcbiAgICAgICAgICAgIHNjb3JlID0gc21heCAtIHN0YWNrT3JpZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbFNjb3JlRW5kID0gKHNjb3JlICsgc3RhY2tPcmlnaW4gLSBzbWluKSAvIChzbWF4IC0gc21pbik7XG4gICAgICAgIHZhciByZWxTY29yZVN0YXJ0ID0gKHN0YWNrT3JpZ2luIC0gc21pbikgLyAoc21heCAtIHNtaW4pXG4gICAgICAgIHZhciByZWxTY29yZU1heCA9IE1hdGgubWF4KHJlbFNjb3JlU3RhcnQsIHJlbFNjb3JlRW5kKTtcbiAgICAgICAgdmFyIHJlbFNjb3JlTWluID0gTWF0aC5taW4ocmVsU2NvcmVTdGFydCwgcmVsU2NvcmVFbmQpO1xuXG4gICAgICAgIGhlaWdodCA9IChyZWxTY29yZU1heCAtIHJlbFNjb3JlTWluKSAqIHJlcXVpcmVkSGVpZ2h0O1xuICAgICAgICB2YXIgeSA9ICgxLjAgLSByZWxTY29yZU1heCkgKiByZXF1aXJlZEhlaWdodDtcblxuICAgICAgICBsZXQgc3Ryb2tlID0gc3R5bGUuRkdDT0xPUiB8fCBudWxsO1xuICAgICAgICBsZXQgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgc3R5bGUuQ09MT1IxIHx8ICdncmVlbic7XG4gICAgICAgIGlmIChzdHlsZS5CR0lURU0gJiYgZmVhdHVyZS5pdGVtUmdiKVxuICAgICAgICAgICAgZmlsbCA9IGZlYXR1cmUuaXRlbVJnYjtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBzdHlsZS5BTFBIQSA/ICgxLjAgKiBzdHlsZS5BTFBIQSkgOiBudWxsO1xuXG4gICAgICAgIGxldCBnZyA9IG5ldyBHbHlwaHMuQm94R2x5cGgobWluUG9zLCB5LCAobWF4UG9zIC0gbWluUG9zKSwgaGVpZ2h0LCBmaWxsLCBzdHJva2UsIGFscGhhKTtcbiAgICAgICAgZ2cgPSBuZXcgR2x5cGhzLlRyYW5zbGF0ZWRHbHlwaChnZywgMCwgMCwgcmVxdWlyZWRIZWlnaHQpO1xuICAgICAgICBnZy5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgZ2cucXVhbnQgPSB7XG4gICAgICAgICAgICBtaW46IHNtaW4sIG1heDogc21heFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3R5bGUuWklOREVYKSB7XG4gICAgICAgICAgICBnZy56aW5kZXggPSBzdHlsZS5aSU5ERVggfCAwO1xuICAgICAgICB9XG4gICAgICAgIGdseXBocy5wdXNoKGdnKTtcblxuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG4vLyBoZWlnaHQgaXMgc3VidGllciBoZWlnaHRcbmZ1bmN0aW9uIGNyZWF0ZVF1YW50T3ZlcmxheSh0aWVyLCBoZWlnaHQsIHJldGluYT1mYWxzZSkge1xuICAgIGxldCB3aWR0aCA9IDUwO1xuXG4gICAgdGllci5xdWFudE92ZXJsYXkuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRpZXIucXVhbnRPdmVybGF5LndpZHRoID0gcmV0aW5hID8gd2lkdGgqMiA6IHdpZHRoO1xuICAgIHRpZXIucXVhbnRPdmVybGF5LnN0eWxlLmhlaWdodCA9ICcnICsgKHJldGluYSA/IGhlaWdodC8yIDogaGVpZ2h0KSArICdweCc7XG4gICAgdGllci5xdWFudE92ZXJsYXkuc3R5bGUud2lkdGggPSAnJyArIHdpZHRoICsgJ3B4JztcbiAgICB0aWVyLnF1YW50T3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIGxldCBjYW52YXMgPSB0aWVyLnF1YW50T3ZlcmxheS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgaWYgKHJldGluYSkge1xuICAgICAgICBjYW52YXMuc2NhbGUoMiwgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gcGFpbnRRdWFudChjYW52YXMsIHRpZXIsIHF1YW50LCB0aWNzKSB7XG4gICAgY2FudmFzLnNhdmUoKTtcblxuICAgIGxldCBoID0gdGllci5xdWFudE92ZXJsYXkuaGVpZ2h0O1xuICAgIGxldCB3ID0gMTAwO1xuXG4gICAgbGV0IHRpY1NwYWNpbmcgPSAoaCArIHRpZXIucGFkZGluZyoyKSAvIHRpY3M7XG4gICAgbGV0IHRpY0ludGVydmFsID0gKHF1YW50Lm1heCAtIHF1YW50Lm1pbikgLyB0aWNzO1xuXG4gICAgY2FudmFzLmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY2FudmFzLmdsb2JhbEFscGhhID0gMC42O1xuICAgIGlmICh0aWVyLmJyb3dzZXIucnVsZXJMb2NhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIGNhbnZhcy5maWxsUmVjdCh3LTMwLCAwLCAzMCwgaCArIHRpZXIucGFkZGluZyoyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuZmlsbFJlY3QoMCwgMCwgMzAsIGggKyB0aWVyLnBhZGRpbmcqMik7XG4gICAgfVxuICAgIGNhbnZhcy5nbG9iYWxBbHBoYSA9IDEuMDtcblxuICAgIGNhbnZhcy5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgY2FudmFzLmxpbmVXaWR0aCA9IDE7XG4gICAgY2FudmFzLmJlZ2luUGF0aCgpO1xuICAgIGlmICh0aWVyLmJyb3dzZXIucnVsZXJMb2NhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIGNhbnZhcy5tb3ZlVG8odyAtIDgsIHRpZXIucGFkZGluZyk7XG4gICAgICAgIGNhbnZhcy5saW5lVG8odywgdGllci5wYWRkaW5nKTtcbiAgICAgICAgY2FudmFzLmxpbmVUbyh3LCBoICsgdGllci5wYWRkaW5nKTtcbiAgICAgICAgY2FudmFzLmxpbmVUbyh3IC0gOCwgaCArIHRpZXIucGFkZGluZyk7XG5cbiAgICAgICAgZm9yIChsZXQgdCA9IDE7IHQgPCB0aWNzLTE7IHQrKykge1xuICAgICAgICAgICAgbGV0IHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgY2FudmFzLm1vdmVUbyh3LCB0eSk7XG4gICAgICAgICAgICBjYW52YXMubGluZVRvKHcgLSA1LCB0eSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMubW92ZVRvKDgsIHRpZXIucGFkZGluZyk7XG4gICAgICAgIGNhbnZhcy5saW5lVG8oMCwgdGllci5wYWRkaW5nKTtcbiAgICAgICAgY2FudmFzLmxpbmVUbygwLCBoICsgdGllci5wYWRkaW5nKTtcbiAgICAgICAgY2FudmFzLmxpbmVUbyg4LCBoICsgdGllci5wYWRkaW5nKTtcblxuICAgICAgICBmb3IgKGxldCB0ID0gMTsgdCA8IHRpY3MtMTsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICBjYW52YXMubW92ZVRvKDAsIHR5KTtcbiAgICAgICAgICAgIGNhbnZhcy5saW5lVG8oNSwgdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbnZhcy5zdHJva2UoKTtcblxuICAgIGNhbnZhcy5maWxsU3R5bGUgPSAnYmxhY2snO1xuXG4gICAgaWYgKHRpZXIuYnJvd3Nlci5ydWxlckxvY2F0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgY2FudmFzLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGNhbnZhcy5maWxsVGV4dChmb3JtYXRRdWFudExhYmVsKHF1YW50Lm1heCksIHctOSwgOCk7XG4gICAgICAgIGNhbnZhcy5maWxsVGV4dChmb3JtYXRRdWFudExhYmVsKHF1YW50Lm1pbiksIHctOSwgaCArIHRpZXIucGFkZGluZyk7XG5cbiAgICAgICAgZm9yIChsZXQgdCA9IDE7IHQgPCB0aWNzLTE7IHQrKykge1xuICAgICAgICAgICAgbGV0IHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgY2FudmFzLmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwoKDEuMCpxdWFudC5tYXgpIC0gKHQqdGljSW50ZXJ2YWwpKSwgdyAtIDksIHR5ICsgMyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBjYW52YXMuZmlsbFRleHQoZm9ybWF0UXVhbnRMYWJlbChxdWFudC5tYXgpLCA5LCA4KTtcbiAgICAgICAgY2FudmFzLmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwocXVhbnQubWluKSwgOSwgaCArIHRpZXIucGFkZGluZyk7XG5cbiAgICAgICAgZm9yIChsZXQgdCA9IDE7IHQgPCB0aWNzLTE7IHQrKykge1xuICAgICAgICAgICAgbGV0IHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgY2FudmFzLmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwoKDEuMCpxdWFudC5tYXgpIC0gKHQqdGljSW50ZXJ2YWwpKSwgOSwgdHkgKyAzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbnZhcy5yZXN0b3JlKCk7XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gZG9tdWkuanM6IFNWRyBVSSBjb21wb25lbnRzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbiAgICB2YXIgcmVtb3ZlQ2hpbGRyZW4gPSB1dGlscy5yZW1vdmVDaGlsZHJlbjtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlQWxsUG9wdXBzID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy5oUG9wdXBIb2xkZXIpO1xuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMucG9wdXBIb2xkZXIpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYWtlVG9vbHRpcCA9IGZ1bmN0aW9uKGVsZSwgdGV4dClcbntcbiAgICB2YXIgaXNpbiA9IGZhbHNlO1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICB2YXIgb3V0bGlzdGVuZXI7XG4gICAgb3V0bGlzdGVuZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpc2luID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBvdXRsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dXAgPSBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgbXggPSBldi5jbGllbnRYICsgd2luZG93LnNjcm9sbFgsIG15ID0gZXYuY2xpZW50WSArIHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR0dDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRleHQpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHR0dCA9IHRleHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0dHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb3B1cCA9IG1ha2VFbGVtZW50KCdkaXYnLFxuICAgICAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICd0b29sdGlwLWFycm93J30pLFxuICAgICAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ2RpdicsIHR0dCwge2NsYXNzTmFtZTogJ3Rvb2x0aXAtaW5uZXInfSldLCBcbiAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogJ3Rvb2x0aXAgYm90dG9tIGluJ30sIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnJyArIChteSArIDIwKSArICdweCcsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICcnICsgTWF0aC5tYXgobXggLSAzMCwgMjApICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXNCLmhQb3B1cEhvbGRlci5hcHBlbmRDaGlsZChwb3B1cCk7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVIYW5kbGVyO1xuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmhQb3B1cEhvbGRlci5yZW1vdmVDaGlsZChwb3B1cCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heSBoYXZlIGJlZW4gcmVtb3ZlZCBieSBvdGhlciBjb2RlIHdoaWNoIGNsZWFycyB0aGUgcG9wdXAgbGF5ZXIuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlLm9mZnNldFBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBlbGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaXNpbiA9IHRydWVcbiAgICAgICAgZWxlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgb3V0bGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgc2V0dXAoZXYpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBlbGUuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnQnLCBmdW5jdGlvbihldikge1xuICAgICAgICBpc2luID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucG9waXQgPSBmdW5jdGlvbihldiwgbmFtZSwgZWxlLCBvcHRzKVxue1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgaWYgKCFvcHRzKSBcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIGlmICghZXYpIFxuICAgICAgICBldiA9IHt9O1xuXG4gICAgdmFyIHdpZHRoID0gb3B0cy53aWR0aCB8fCAyMDA7XG5cbiAgICB2YXIgbXgsIG15O1xuXG4gICAgaWYgKGV2LmNsaWVudFgpIHtcbiAgICAgICAgdmFyIG14ID0gIGV2LmNsaWVudFgsIG15ID0gZXYuY2xpZW50WTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBteCA9IDUwMDsgbXk9IDUwO1xuICAgIH1cbiAgICBteCArPSAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xuICAgIG15ICs9ICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgIHZhciB3aW5XaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgdmFyIHRvcCA9IG15O1xuICAgIHZhciBsZWZ0ID0gTWF0aC5taW4obXggLSAod2lkdGgvMikgLSA0LCAod2luV2lkdGggLSB3aWR0aCAtIDMwKSk7XG5cbiAgICB2YXIgcG9wdXAgPSBtYWtlRWxlbWVudCgnZGl2Jyk7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gJ3BvcG92ZXIgZmFkZSAnICsgKGV2LmNsaWVudFggPyAnYm90dG9tICcgOiAnJykgKyAnaW4nO1xuICAgIHBvcHVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHBvcHVwLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBwb3B1cC5zdHlsZS50b3AgPSAnJyArIHRvcCArICdweCc7XG4gICAgcG9wdXAuc3R5bGUubGVmdCA9ICcnICsgbGVmdCArICdweCc7XG4gICAgcG9wdXAuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgaWYgKHdpZHRoID4gMjc2KSB7XG4gICAgICAgIC8vIEhBQ0sgQm9vdHN0cmFwcGlmaWNhdGlvbi4uLlxuICAgICAgICBwb3B1cC5zdHlsZS5tYXhXaWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB9XG5cbiAgICBwb3B1cC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ2Fycm93J30pKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBjbG9zZUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdidXR0b24nLCAnJywge2NsYXNzTmFtZTogJ2Nsb3NlJ30pO1xuICAgICAgICBjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJnRpbWVzOydcblxuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgY2xvc2VCdXR0b24uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBjbG9zZUJ1dHRvbi5zdHlsZS5jb2xvciA9ICdibGFjayc7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzQi5yZW1vdmVBbGxQb3B1cHMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB2YXIgdGJhciA9IG1ha2VFbGVtZW50KCdoNCcsIFttYWtlRWxlbWVudCgnc3BhbicsIG5hbWUsIG51bGwsIHttYXhXaWR0aDogJzIwMHB4J30pLCBjbG9zZUJ1dHRvbl0sIHsvKmNsYXNzTmFtZTogJ3BvcG92ZXItdGl0bGUnICovfSwge3BhZGRpbmdMZWZ0OiAnMTBweCcsIHBhZGRpbmdSaWdodDogJzEwcHgnfSk7XG5cbiAgICAgICAgdmFyIGRyYWdPWCwgZHJhZ09ZO1xuICAgICAgICB2YXIgbW92ZUhhbmRsZXIsIHVwSGFuZGxlcjtcbiAgICAgICAgbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCArIChldi5jbGllbnRYIC0gZHJhZ09YKTtcbiAgICAgICAgICAgIGlmIChsZWZ0IDwgOCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSA4O1xuICAgICAgICAgICAgfSBpZiAobGVmdCA+ICh3aW5XaWR0aCAtIHdpZHRoIC0gMzIpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICh3aW5XaWR0aCAtIHdpZHRoIC0gMjYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wID0gdG9wICsgKGV2LmNsaWVudFkgLSBkcmFnT1kpO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgoMTAsIHRvcCk7XG4gICAgICAgICAgICBwb3B1cC5zdHlsZS50b3AgPSAnJyArIHRvcCArICdweCc7XG4gICAgICAgICAgICBwb3B1cC5zdHlsZS5sZWZ0ID0gJycgKyBNYXRoLm1pbihsZWZ0LCAod2luV2lkdGggLSB3aWR0aCAtIDEwKSkgKyAncHgnO1xuICAgICAgICAgICAgZHJhZ09YID0gZXYuY2xpZW50WDsgZHJhZ09ZID0gZXYuY2xpZW50WTtcbiAgICAgICAgfVxuICAgICAgICB1cEhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdXBIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGJhci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBkcmFnT1ggPSBldi5jbGllbnRYOyBkcmFnT1kgPSBldi5jbGllbnRZO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICBwb3B1cC5hcHBlbmRDaGlsZCh0YmFyKTtcbiAgICB9XG5cbiAgICBwb3B1cC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnZGl2JywgZWxlLCB7Y2xhc3NOYW1lOiAncG9wb3Zlci1jb250ZW50J30sIHtcbiAgICAgICAgcGFkZGluZzogJzBweCdcbiAgICB9KSk7XG4gICAgdGhpcy5oUG9wdXBIb2xkZXIuYXBwZW5kQ2hpbGQocG9wdXApO1xuXG4gICAgdmFyIHBvcHVwSGFuZGxlID0ge1xuICAgICAgICBub2RlOiBwb3B1cCxcbiAgICAgICAgZGlzcGxheWVkOiB0cnVlXG4gICAgfTtcbiAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChldi50YXJnZXQgPT0gcG9wdXApIHtcbiAgICAgICAgICAgIHBvcHVwSGFuZGxlLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHJldHVybiBwb3B1cEhhbmRsZTtcbn1cblxuZnVuY3Rpb24gbWFrZVRyZWVUYWJsZVNlY3Rpb24odGl0bGUsIGNvbnRlbnQsIHZpc2libGUpIHtcbiAgICB2YXIgdHRCdXR0b24gPSBtYWtlRWxlbWVudCgnaScpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIHR0QnV0dG9uLmNsYXNzTmFtZSA9ICdmYSBmYS1jYXJldC1kb3duJztcbiAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICd0YWJsZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dEJ1dHRvbi5jbGFzc05hbWUgPSAnZmEgZmEtY2FyZXQtcmlnaHQnO1xuICAgICAgICAgICAgY29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSgpO1xuXG4gICAgdHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmlzaWJsZSA9ICF2aXNpYmxlO1xuICAgICAgICB1cGRhdGUoKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgaGVhZGluZyA9IG1ha2VFbGVtZW50KCdoNicsIFt0dEJ1dHRvbiwgJyAnLCB0aXRsZV0sIHt9LCB7ZGlzcGxheTogJ2Jsb2NrJywgYmFja2dyb3VuZDogJ2dyYXknLCBjb2xvcjogJ3doaXRlJywgd2lkdGg6ICcxMDAlJywgcGFkZGluZzogJzVweCAycHgnLCBtYXJnaW46ICcwcHgnfSk7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50KCdkaXYnLCBbaGVhZGluZywgY29udGVudF0sIHt9KTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBtYWtlVHJlZVRhYmxlU2VjdGlvbjogbWFrZVRyZWVUYWJsZVNlY3Rpb25cbiAgICB9O1xufVxuIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIERlZmF1bHRSZW5kZXJlciBmcm9tIFwiLi9kZWZhdWx0LXJlbmRlcmVyXCI7XG5cbmV4cG9ydCB7IHJlbmRlclRpZXIsIGRyYXdUaWVyIH07XG5cbmZ1bmN0aW9uIHJlbmRlclRpZXIoc3RhdHVzLCB0aWVyKSB7XG4gICAgZHJhd1RpZXIodGllcik7XG4gICAgdGllci51cGRhdGVTdGF0dXMoc3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gZHJhd1RpZXIodGllcikge1xuICAgIGxldCBjYW52YXMgPSB0aWVyLnZpZXdwb3J0LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgcmV0aW5hID0gdGllci5icm93c2VyLnJldGluYSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG4gICAgaWYgKHJldGluYSkge1xuICAgICAgICBjYW52YXMuc2NhbGUoMiwgMik7XG4gICAgfVxuXG4gICAgbGV0IGZlYXR1cmVzID0gdGllci5jdXJyZW50RmVhdHVyZXM7XG4gICAgbGV0IHNlcXVlbmNlID0gdGllci5jdXJyZW50U2VxdWVuY2U7XG4gICAgaWYgKHRpZXIuc2VxdWVuY2VTb3VyY2UpIHtcbiAgICAgICAgRGVmYXVsdFJlbmRlcmVyLmRyYXdTZXFUaWVyKHRpZXIsIHNlcXVlbmNlKTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmVzKSB7XG4gICAgICAgIERlZmF1bHRSZW5kZXJlci5wcmVwYXJlU3VidGllcnModGllciwgY2FudmFzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNlcXVlbmNlIG9yIGZlYXR1cmVzIGluIHRpZXIhXCIpO1xuICAgIH1cblxuICAgIGlmICh0aWVyLnN1YnRpZXJzKSB7XG4gICAgICAgIERlZmF1bHRSZW5kZXJlci5wcmVwYXJlVmlld3BvcnQodGllciwgY2FudmFzLCByZXRpbmEsIHRydWUpO1xuICAgIH1cblxuICAgIHRpZXIuZHJhd092ZXJsYXkoKTtcbiAgICB0aWVyLnBhaW50UXVhbnQoKTtcblxuICAgIGlmICh0eXBlb2YodGllci5kYXNTb3VyY2UuZHJhd0NhbGxiYWNrKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRpZXIuZGFzU291cmNlLmRyYXdDYWxsYmFjayhjYW52YXMsIHRpZXIpO1xuICAgIH1cblxuICAgIHRpZXIub3JpZ2luSGF4eCA9IDA7XG4gICAgdGllci5icm93c2VyLmFycmFuZ2VUaWVycygpO1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGVuY29kZS5qczogaW50ZXJmYWNlIGZvciBFTkNPREUgRENDIHNlcnZpY2VzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbG9va3VwRW5jb2RlVVJJKHVyaSwganNvbikge1xuICAgIGlmICh1cmkuaW5kZXhPZignPycpIDwgMClcbiAgICAgICAgdXJpID0gdXJpICsgJz9zb2Z0PXRydWUnO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGFjY2VwdCwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdFcnJvciBjb2RlICcgKyByZXEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcCA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0KGpzb24gPyByZXNwIDogcmVzcC5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXEub3BlbignR0VUJywgdXJpLCB0cnVlKTtcbiAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgIHJlcS5zZW5kKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIEVuY29kZVVSTEhvbGRlcih1cmwpIHtcbiAgICB0aGlzLnJhd3VybCA9IHVybDtcbn1cblxuRW5jb2RlVVJMSG9sZGVyLnByb3RvdHlwZS5nZXRVUkxQcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudXJsUHJvbWlzZSAmJiB0aGlzLnVybFByb21pc2VWYWxpZGl0eSA+IERhdGUubm93KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsUHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVybFByb21pc2UgPSBsb29rdXBFbmNvZGVVUkkodGhpcy5yYXd1cmwsIHRydWUpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3AubG9jYXRpb247XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVybFByb21pc2VWYWxpZGl0eSA9IERhdGUubm93KCkgKyAoMTIgKiAzNjAwICogMTAwMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVybFByb21pc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBFbmNvZGVGZXRjaGFibGUodXJsLCBzdGFydCwgZW5kLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRzID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXJsID0gKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnID8gbmV3IEVuY29kZVVSTEhvbGRlcih1cmwpIDogdXJsKTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xufVxuXG5cblxuRW5jb2RlRmV0Y2hhYmxlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHMsIGwpIHtcbiAgICBpZiAocyA8IDApIHtcbiAgICAgICAgdGhyb3cgJ0JhZCBzbGljZSAnICsgcztcbiAgICB9XG5cbiAgICB2YXIgbnMgPSB0aGlzLnN0YXJ0LCBuZSA9IHRoaXMuZW5kO1xuICAgIGlmIChucyAmJiBzKSB7XG4gICAgICAgIG5zID0gbnMgKyBzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5zID0gcyB8fCBucztcbiAgICB9XG4gICAgaWYgKGwgJiYgbnMpIHtcbiAgICAgICAgbmUgPSBucyArIGwgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5lID0gbmUgfHwgbCAtIDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRW5jb2RlRmV0Y2hhYmxlKHRoaXMudXJsLCBucywgbmUsIHRoaXMub3B0cyk7XG59XG5cbkVuY29kZUZldGNoYWJsZS5wcm90b3R5cGUuZmV0Y2hBc1RleHQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxlbmd0aDtcbiAgICBzZWxmLnVybC5nZXRVUkxQcm9taXNlKCkudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNlbGYuZW5kKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5lbmQgLSBzZWxmLnN0YXJ0ID4gMTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ01vbnN0ZXIgZmV0Y2ghJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgc2VsZi5zdGFydCArICctJyArIHNlbGYuZW5kKTtcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYuZW5kIC0gc2VsZi5zdGFydCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDIwMCB8fCByZXEuc3RhdHVzID09IDIwNikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNlbGYub3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLnNlbmQoKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH0pO1xufVxuXG5FbmNvZGVGZXRjaGFibGUucHJvdG90eXBlLnNhbHRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5FbmNvZGVGZXRjaGFibGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIGF0dGVtcHQsIHRydW5jYXRlZExlbmd0aCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGF0dGVtcHQgPSBhdHRlbXB0IHx8IDE7XG4gICAgaWYgKGF0dGVtcHQgPiAzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICBzZWxmLnVybC5nZXRVUkxQcm9taXNlKCkudGhlbihmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcS5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG4gICAgICAgIGlmIChzZWxmLmVuZCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZW5kIC0gc2VsZi5zdGFydCA+IDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdNb25zdGVyIGZldGNoISc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIHNlbGYuc3RhcnQgKyAnLScgKyBzZWxmLmVuZCk7XG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmVuZCAtIHNlbGYuc3RhcnQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDIwMCB8fCByZXEuc3RhdHVzID09IDIwNikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmwgPSByZXEucmVzcG9uc2UuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoICE9IGJsICYmICghdHJ1bmNhdGVkTGVuZ3RoIHx8IGJsICE9IHRydW5jYXRlZExlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mZXRjaChjYWxsYmFjaywgYXR0ZW1wdCArIDEsIGJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxLm1velJlc3BvbnNlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXEubW96UmVzcG9uc2VBcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoICYmIGxlbmd0aCAhPSByLmxlbmd0aCAmJiAoIXRydW5jYXRlZExlbmd0aCB8fCByLmxlbmd0aCAhPSB0cnVuY2F0ZWRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmV0Y2goY2FsbGJhY2ssIGF0dGVtcHQgKyAxLCByLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhic3RyaW5nVG9CdWZmZXIocmVxLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmV0Y2goY2FsbGJhY2ssIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZWxmLm9wdHMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5zZW5kKCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJzdHJpbmdUb0J1ZmZlcihyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyZXN1bHQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJhW2ldID0gcmVzdWx0LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBiYS5idWZmZXI7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbG9va3VwRW5jb2RlVVJJOiBsb29rdXBFbmNvZGVVUkksXG4gICAgICAgIEVuY29kZUZldGNoYWJsZTogRW5jb2RlRmV0Y2hhYmxlXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyBlbnNlbWJsanNvbi5qcyAtLSBxdWVyeSB0aGUgRW5zZW1ibCBSRVNUIEFQSS5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgZGFsbGlhbmNlX3JlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnkgPSBzYS5yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5O1xuICAgIHZhciBGZWF0dXJlU291cmNlQmFzZSA9IHNhLkZlYXR1cmVTb3VyY2VCYXNlO1xuXG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU1N0eWxlc2hlZXQgPSBkYXMuREFTU3R5bGVzaGVldDtcbiAgICB2YXIgREFTU3R5bGUgPSBkYXMuREFTU3R5bGU7XG4gICAgdmFyIERBU0ZlYXR1cmUgPSBkYXMuREFTRmVhdHVyZTtcbiAgICB2YXIgREFTR3JvdXAgPSBkYXMuREFTR3JvdXA7XG59XG5cbmZ1bmN0aW9uIEVuc2VtYmxGZWF0dXJlU291cmNlKHNvdXJjZSkge1xuICAgIEZlYXR1cmVTb3VyY2VCYXNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5iYXNlID0gc291cmNlLnVyaSB8fCAnLy9yZXN0LmVuc2VtYmwub3JnJztcbiAgICBpZiAodGhpcy5iYXNlLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgICAgdmFyIHByb3RvID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAocHJvdG8gPT0gJ2h0dHA6JyB8fCBwcm90byA9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgLy8gUHJvdG9jb2wtcmVsYXRpdmUgVVJMcyBva2F5LlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gJ2h0dHA6JyArIHRoaXMuYmFzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNwZWNpZXMgPSBzb3VyY2Uuc3BlY2llcyB8fCAnaHVtYW4nO1xuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy50eXBlID0gW3NvdXJjZS50eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnR5cGUgPSBzb3VyY2UudHlwZSB8fCBbJ3JlZ3VsYXRvcnknXTtcbiAgICB9XG59XG5cbkVuc2VtYmxGZWF0dXJlU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlKTtcbkVuc2VtYmxGZWF0dXJlU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVuc2VtYmxGZWF0dXJlU291cmNlO1xuXG5FbnNlbWJsRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuXG4gICAgdmFyIHRzU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICB0c1N0eWxlLmdseXBoID0gJ19fTk9ORSc7XG4gICAgaWYgKHRoaXMudHlwZS5pbmRleE9mKCdleG9uJykgPj0gMClcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICd0cmFuc2NyaXB0J30sIG51bGwsIHRzU3R5bGUpO1xuICAgIGlmICh0aGlzLnR5cGUuaW5kZXhPZignZXhvbicpID49IDAgfHwgdGhpcy50eXBlLmluZGV4T2YoJ3RyYW5zY3JpcHQnKSA+PSAwKVxuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2dlbmUnfSwgbnVsbCwgdHNTdHlsZSk7XG5cbiAgICB2YXIgY2RzU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICBjZHNTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgIGNkc1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgIGNkc1N0eWxlLkJHQ09MT1IgPSAncmVkJ1xuICAgIGNkc1N0eWxlLkhFSUdIVCA9IDg7XG4gICAgY2RzU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgY2RzU3R5bGUuTEFCRUwgPSB0cnVlO1xuICAgIGNkc1N0eWxlLlpJTkRFWCA9IDEwO1xuICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnY2RzJ30sIG51bGwsIGNkc1N0eWxlKTtcblxuICAgIHtcbiAgICAgICAgdmFyIHZhclN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHZhclN0eWxlLmdseXBoID0gJ1NRVUFSRSc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICAvLyB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ2JsdWUnO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3ZhcmlhdGlvbicsIG1ldGhvZDogJy4rX1VUUl92YXJpYW50J30sIG51bGwsIHZhclN0eWxlKTtcbiAgICB9XG4gICAge1xuICAgICAgICB2YXIgdmFyU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdmFyU3R5bGUuZ2x5cGggPSAnVFJJQU5HTEUnO1xuICAgICAgICB2YXJTdHlsZS5ESVJFQ1RJT04gPSAnUyc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICAvLyB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ2JsdWUnO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3ZhcmlhdGlvbicsIG1ldGhvZDogJ21pc3NlbnNlX3ZhcmlhbnQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdUUklBTkdMRSc7XG4gICAgICAgIHZhclN0eWxlLkRJUkVDVElPTiA9ICdOJztcbiAgICAgICAgdmFyU3R5bGUuQlVNUCA9ICd5ZXMnO1xuICAgICAgICB2YXJTdHlsZS5MQUJFTCA9ICdubyc7XG4gICAgICAgIC8vIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLkZHQ09MT1IgPSAnYmx1ZSc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndmFyaWF0aW9uJywgbWV0aG9kOiAnc3BsaWNlXy4rX3ZhcmlhbnQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdTVEFSJztcbiAgICAgICAgdmFyU3R5bGUuUE9JTlRTID0gNjtcbiAgICAgICAgdmFyU3R5bGUuQlVNUCA9ICd5ZXMnO1xuICAgICAgICB2YXJTdHlsZS5MQUJFTCA9ICdubyc7XG4gICAgICAgIC8vIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLkZHQ09MT1IgPSAnYmx1ZSc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndmFyaWF0aW9uJywgbWV0aG9kOiAncmVndWxhdG9yeV9yZWdpb25fdmFyaWFudCd9LCBudWxsLCB2YXJTdHlsZSk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgdmFyIHZhclN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHZhclN0eWxlLmdseXBoID0gJ1BMSU1TT0xMJztcbiAgICAgICAgdmFyU3R5bGUuQlVNUCA9ICd5ZXMnO1xuICAgICAgICB2YXJTdHlsZS5MQUJFTCA9ICdubyc7XG4gICAgICAgIC8vIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLkZHQ09MT1IgPSAncmdiKDUwLDgwLDI1NSknO1xuICAgICAgICB2YXJTdHlsZS5TVFJPS0VDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndmFyaWF0aW9uJ30sIG51bGwsIHZhclN0eWxlKTtcbiAgICB9XG4gICAgICAgIHtcbiAgICAgICAgdmFyIHZhclN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHZhclN0eWxlLmdseXBoID0gJ1NRVUFSRSc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JlZCc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnaW5kZWwnLCBtZXRob2Q6ICcuK19VVFJfdmFyaWFudCd9LCBudWxsLCB2YXJTdHlsZSk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgdmFyIHZhclN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHZhclN0eWxlLmdseXBoID0gJ1RSSUFOR0xFJztcbiAgICAgICAgdmFyU3R5bGUuRElSRUNUSU9OID0gJ1MnO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdyZWQnO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2luZGVsJywgbWV0aG9kOiAnbWlzc2Vuc2VfdmFyaWFudCd9LCBudWxsLCB2YXJTdHlsZSk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgdmFyIHZhclN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHZhclN0eWxlLmdseXBoID0gJ1RSSUFOR0xFJztcbiAgICAgICAgdmFyU3R5bGUuRElSRUNUSU9OID0gJ04nO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdyZWQnO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2luZGVsJywgbWV0aG9kOiAnc3BsaWNlXy4rX3ZhcmlhbnQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdTVEFSJztcbiAgICAgICAgdmFyU3R5bGUuUE9JTlRTID0gNjtcbiAgICAgICAgdmFyU3R5bGUuQlVNUCA9ICd5ZXMnO1xuICAgICAgICB2YXJTdHlsZS5MQUJFTCA9ICdubyc7XG4gICAgICAgIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLkZHQ09MT1IgPSAncmVkJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdpbmRlbCcsIG1ldGhvZDogJ3JlZ3VsYXRvcnlfcmVnaW9uX3ZhcmlhbnQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdQTElNU09MTCc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JlZCc7XG4gICAgICAgIHZhclN0eWxlLlNUUk9LRUNPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdpbmRlbCd9LCBudWxsLCB2YXJTdHlsZSk7XG4gICAgfVxuXG4gICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgd2lnU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ29yYW5nZSdcbiAgICB3aWdTdHlsZS5IRUlHSFQgPSA4O1xuICAgIHdpZ1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgIHdpZ1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbn1cblxuXG5FbnNlbWJsRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NhbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtdO1xufVxuXG5FbnNlbWJsRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgdXJsID0gdGhpcy5iYXNlICsgJy9vdmVybGFwL3JlZ2lvbi8nICsgdGhpcy5zcGVjaWVzICsgJy8nICsgY2hyICsgJzonICsgbWluICsgJy0nICsgbWF4O1xuXG4gICAgdmFyIGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50eXBlLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICBmaWx0ZXJzLnB1c2goJ2ZlYXR1cmU9JyArIHRoaXMudHlwZVt0aV0pO1xuICAgIH1cbiAgICBmaWx0ZXJzLnB1c2goJ2NvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgdXJsID0gdXJsICsgJz8nICsgZmlsdGVycy5qb2luKCc7Jyk7XG5cbiAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0aWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG5cbiAgICBcdCAgICBpZiAocmVxLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gJ0Vycm9yIGNvZGUgJyArIHJlcS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpyID0gSlNPTi5wYXJzZShyZXEucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGpyLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHt9O1xuXG4gICAgXHRcdCAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIFx0ICAgIH0gZWxzZSB7XG4gICAgICAgIFx0XHR2YXIgamYgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZSk7XG4gICAgICAgIFx0XHR2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgXHRcdGZvciAodmFyIGZpID0gMDsgZmkgPCBqZi5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgXHRcdCAgICB2YXIgaiA9IGpmW2ZpXTtcblxuICAgICAgICBcdFx0ICAgIHZhciBub3RlcyA9IFtdO1xuICAgICAgICBcdFx0ICAgIHZhciBmID0gbmV3IERBU0ZlYXR1cmUoKTtcbiAgICAgICAgXHRcdCAgICBmLnNlZ21lbnQgPSBjaHI7XG4gICAgICAgIFx0XHQgICAgZi5taW4gPSBqWydzdGFydCddIHwgMDtcbiAgICAgICAgXHRcdCAgICBmLm1heCA9IGpbJ2VuZCddIHwgMDtcbiAgICAgICAgXHRcdCAgICBmLnR5cGUgPSBqLmZlYXR1cmVfdHlwZSB8fCAndW5rbm93bic7XG4gICAgICAgIFx0XHQgICAgZi5pZCA9IGouSUQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGouUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JwID0gbmV3IERBU0dyb3VwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncnAuaWQgPSBqLlBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuZ3JvdXBzID0gW2dycF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoai5zdHJhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqLnN0cmFuZCA8IDApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYub3JpZW50YXRpb24gPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChqLnN0cmFuZCA+IDApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYub3JpZW50YXRpb24gPSAnKyc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoai5jb25zZXF1ZW5jZV90eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZi5tZXRob2QgPSBqLmNvbnNlcXVlbmNlX3R5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGouYWx0X2FsbGVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVzLnB1c2goJ0FsbGVsZXM9JyArIGouYWx0X2FsbGVsZXMuam9pbignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqLmFsdF9hbGxlbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoai5hbHRfYWxsZWxlc1sxXS5sZW5ndGggIT0gai5hbHRfYWxsZWxlc1swXS5sZW5ndGggfHwgai5hbHRfYWxsZWxlc1sxXSA9PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi50eXBlID0gJ2luZGVsJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXHRcdCAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYubm90ZXMgPSBub3RlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcdFx0ICAgIGZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgIFx0XHR9XG4gICAgICAgIFx0XHRjYWxsYmFjayhudWxsLCBmZWF0dXJlcyk7XG4gICAgXHQgICAgfVxuICAgIFx0fVxuXHRcbiAgICB9O1xuICAgIFxuICAgIHRoaXNCLmJ1c3krKztcbiAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICByZXEuc2VuZCgpO1xufVxuXG5FbnNlbWJsRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuY2FwYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY2FwcyA9IHt9O1xuICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlLmluZGV4T2YoJ3RyYW5zY3JpcHQnKSA+PSAwKSB7XG4gICAgICAgIGNhcHMuc2VhcmNoID0gWydnZW5lJ107XG4gICAgfVxuICAgIHJldHVybiBjYXBzO1xufVxuXG5FbnNlbWJsRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlfS9sb29rdXAvc3ltYm9sLyR7dGhpcy5zcGVjaWVzfS8ke3F1ZXJ5fT9jb250ZW50LXR5cGU9YXBwbGljYXRpb24vanNvbmA7XG4gICAgY29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpXG4gICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAzMDAgfHwgcmVxLnN0YXR1cyA8IDIwMCkge1xuICAgICAgICAgICAgICAgIGxldCBlcnIgPSAnRXJyb3IgY29kZSAnICsgcmVxLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIganIgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0ganIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge307XG5cbiAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSA0MDApICAgIC8vIEUhIHJldHVybnMgYW4gZXJyb3IgaWYgdGhlIGxvb2t1cCBmYWlscy4gIFdobyBrbm93cz9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gSlNPTi5wYXJzZShyZXEucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3AgJiYgcmVzcC5zZXFfcmVnaW9uX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogcmVzcC5zZXFfcmVnaW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IHJlc3Auc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IHJlc3AuZW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICByZXEuc2VuZCgpO1xufVxuXG5kYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSgnZW5zZW1ibCcsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHJldHVybiB7ZmVhdHVyZXM6IG5ldyBFbnNlbWJsRmVhdHVyZVNvdXJjZShzb3VyY2UpfTtcbn0pO1xuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGV4cG9ydC1jb25maWcuanNcbi8vXG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIHNoYWxsb3dDb3B5ID0gdXRpbHMuc2hhbGxvd0NvcHk7XG5cbiAgICB2YXIgc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpO1xuICAgIHZhciBoZXhfc2hhMSA9IHNoYTEuaGV4X3NoYTE7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgY29weVN0eWxlc2hlZXQgPSBkYXMuY29weVN0eWxlc2hlZXQ7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmV4cG9ydEZ1bGxDb25maWcgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBjaHI6IHRoaXMuY2hyLFxuICAgICAgICB2aWV3U3RhcnQ6IHRoaXMudmlld1N0YXJ0fDAsXG4gICAgICAgIHZpZXdFbmQ6IHRoaXMudmlld0VuZHwwLFxuICAgICAgICBjb29raWVLZXk6ICdkYWxsaWFuY2VfJyArIGhleF9zaGExKERhdGUubm93KCkpLFxuXG4gICAgICAgIGNvb3JkU3lzdGVtOiB0aGlzLmNvb3JkU3lzdGVtLFxuXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuZXhwb3J0U291cmNlQ29uZmlnKCksXG5cbiAgICAgICAgY2hhaW5zOiB0aGlzLmV4cG9ydENoYWlucygpXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnByZWZpeClcbiAgICAgICAgY29uZmlnLnByZWZpeCA9IHRoaXMucHJlZml4O1xuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuZXhwb3J0Q2hhaW5zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNjID0ge307XG4gICAgdmFyIGNzID0gdGhpcy5jaGFpbnMgfHwge307XG4gICAgZm9yICh2YXIgayBpbiBjcykge1xuICAgICAgICBjY1trXSA9IGNzW2tdLmV4cG9ydENvbmZpZygpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmV4cG9ydFNvdXJjZUNvbmZpZyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBzb3VyY2VDb25maWcgPSBbXTtcbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgdmFyIHRpZXIgPSB0aGlzLnRpZXJzW3RpXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNoYWxsb3dDb3B5KHRpZXIuZGFzU291cmNlKTtcblxuICAgICAgICBpZiAoc291cmNlLm5vUGVyc2lzdClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHNvdXJjZS5jb29yZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNvdXJjZS5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzb3VyY2UuZGlzYWJsZWQpXG4gICAgICAgICAgICBzb3VyY2UuZGlzYWJsZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRpZXIuY29uZmlnLnN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5zdHlsZSA9IGNvcHlTdHlsZXNoZWV0KHRpZXIuY29uZmlnLnN0eWxlc2hlZXQpLnN0eWxlcztcbiAgICAgICAgICAgIHNvdXJjZS5zdHlsZXNoZWV0X3VyaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc3R5bGUpIHtcbiAgICAgICAgICAgIHNvdXJjZS5zdHlsZSA9IGNvcHlTdHlsZXNoZWV0KHtzdHlsZXM6IHNvdXJjZS5zdHlsZX0pLnN0eWxlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YodGllci5jb25maWcubmFtZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzb3VyY2UubmFtZSA9IHRpZXIuY29uZmlnLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGllci5jb25maWcuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5mb3JjZUhlaWdodCA9IHRpZXIuY29uZmlnLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGllci5jb25maWcuZm9yY2VNaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc291cmNlLmZvcmNlTWluID0gdGllci5jb25maWcuZm9yY2VNaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpZXIuY29uZmlnLmZvcmNlTWluRHluYW1pYylcbiAgICAgICAgICAgIHNvdXJjZS5mb3JjZU1pbkR5bmFtaWMgPSB0aWVyLmNvbmZpZy5mb3JjZU1pbkR5bmFtaWM7XG4gICAgICAgIGlmICh0aWVyLmNvbmZpZy5mb3JjZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb3VyY2UuZm9yY2VNYXggPSB0aWVyLmNvbmZpZy5mb3JjZU1heDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGllci5jb25maWcuYnVtcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5idW1wZWQgPSB0aWVyLmNvbmZpZy5idW1wZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpZXIuY29uZmlnLmZvcmNlTWF4RHluYW1pYylcbiAgICAgICAgICAgIHNvdXJjZS5mb3JjZU1heER5bmFtaWMgPSB0aWVyLmNvbmZpZy5mb3JjZU1heER5bmFtaWM7XG5cbiAgICAgICAgc291cmNlQ29uZmlnLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlQ29uZmlnO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5leHBvcnRQYWdlVGVtcGxhdGUgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHRlbXBsYXRlID0gJzxodG1sPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgIDxoZWFkPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgICAgPHNjcmlwdCBsYW5ndWFnZT1cImphdmFzY3JpcHRcIiBzcmM9XCInICsgdGhpcy5yZXNvbHZlVVJMKCckJGRhbGxpYW5jZS1jb21waWxlZC5qcycpICsgJ1wiPjwvc2NyaXB0PlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgICAgPHNjcmlwdCBsYW5ndWFnZT1cImphdmFzY3JpcHRcIj5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAnICAgICAgdmFyIGRhbGxpYW5jZV9icm93c2VyID0gbmV3IEJyb3dzZXIoJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwb3J0RnVsbENvbmZpZyhvcHRzKSwgbnVsbCwgMikgKyAnKTtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnICAgIDwvc2NyaXB0PlxcbicgKyAgXG4gICAgICAgICAgICAgICAgICAgJyAgPC9oZWFkPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgIDxib2R5PlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgICAgPGRpdiBpZD1cInN2Z0hvbGRlclwiPkRhbGxpYW5jZSBnb2VzIGhlcmU8L2Rpdj5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAnICA8L2JvZHk+XFxuJyArXG4gICAgICAgICAgICAgICAgICAgJzxodG1sPlxcbic7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG59IiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGV4cG9ydC1pbWFnZS5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgZyA9IHJlcXVpcmUoJy4vZ2x5cGhzJyk7XG4gICAgdmFyIE92ZXJsYXlMYWJlbENhbnZhcyA9IGcuT3ZlcmxheUxhYmVsQ2FudmFzO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdFF1YW50TGFiZWwgPSBuZi5mb3JtYXRRdWFudExhYmVsO1xuICAgIHZhciBmb3JtYXRMb25nSW50ID0gbmYuZm9ybWF0TG9uZ0ludDtcblxuICAgIHZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbiAgICB2YXIgZHJhd1NlcVRpZXJHQyA9IHJlcXVpcmUoJy4vc2VxdWVuY2UtZHJhdycpLmRyYXdTZXFUaWVyR0M7XG59XG5cbmZ1bmN0aW9uIGZpbGxUZXh0UmlnaHRKdXN0aWZpZWQoZywgdGV4dCwgeCwgeSkge1xuICAgIGcuZmlsbFRleHQodGV4dCwgeCAtIGcubWVhc3VyZVRleHQodGV4dCkud2lkdGgsIHkpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5leHBvcnRJbWFnZSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBmcHcgPSBvcHRzLndpZHRoIHx8IHRoaXMuZmVhdHVyZVBhbmVsV2lkdGg7XG4gICAgdmFyIHBhZGRpbmcgPSAzO1xuICAgIHZhciB5cG9zID0gMDtcbiAgICBpZiAob3B0cy5iYW5uZXIgfHwgb3B0cy5yZWdpb24pIHtcbiAgICAgICAgeXBvcyA9IDQwO1xuICAgIH1cblxuICAgIHZhciBiYWNrdXBGUFcgPSB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoO1xuICAgIHZhciBiYWNrdXBTY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgdGhpcy5mZWF0dXJlUGFuZWxXaWR0aCA9IGZwdztcbiAgICB0aGlzLnNjYWxlID0gdGhpcy5mZWF0dXJlUGFuZWxXaWR0aCAvICh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCk7XG4gICAgXG4gICAgdmFyIHRvdEhlaWdodCA9IHlwb3M7XG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgIGlmICh0aSA+IDApXG4gICAgICAgICAgICB0b3RIZWlnaHQgKz0gcGFkZGluZztcbiAgICAgICAgdmFyIHRpZXIgPSB0aGlzLnRpZXJzW3RpXTtcblxuICAgICAgICB0aWVyLmJhY2t1cFN1YnRpZXJzID0gdGllci5zdWJ0aWVycztcbiAgICAgICAgdGllci5iYWNrdXBPcmlnaW5IYXh4ID0gdGllci5vcmlnaW5IYXh4O1xuICAgICAgICB0aWVyLmJhY2t1cExheW91dEhlaWdodCA9IHRpZXIubGF5b3V0SGVpZ2h0O1xuXG4gICAgICAgIGlmICh0aWVyLnN1YnRpZXJzKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0VGllclJlbmRlcmVyKHRpZXIpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyICYmIHJlbmRlcmVyLnByZXBhcmVTdWJ0aWVycykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnByZXBhcmVTdWJ0aWVycyh0aWVyLCB0aWVyLnZpZXdwb3J0LmdldENvbnRleHQoJzJkJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGllci5zdWJ0aWVycykge1xuICAgICAgICAgICAgICAgIHZhciBsaCA9IHRpZXIucGFkZGluZztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRpZXIuc3VidGllcnMubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGggPSBsaCArIHRpZXIuc3VidGllcnNbc10uaGVpZ2h0ICsgdGllci5wYWRkaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaCArPSA2XG4gICAgICAgICAgICAgICAgdGllci5sYXlvdXRIZWlnaHQgPSBNYXRoLm1heChsaCwgdGhpcy5taW5UaWVySGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aWVyLmxheW91dEhlaWdodCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRvdEhlaWdodCArPSB0aWVyLmxheW91dEhlaWdodDtcbiAgICB9XG4gICAgdmFyIG11bHQgPSBvcHRzLnJlc29sdXRpb25NdWx0aXBsaWVyIHx8IDEuMDtcbiAgICB2YXIgbWFyZ2luID0gMjAwO1xuXG4gICAgdmFyIGN3ID0gKChmcHcgKyBtYXJnaW4pICogbXVsdCl8MDtcbiAgICB2YXIgY2ggPSAodG90SGVpZ2h0ICogbXVsdCl8MDtcbiAgICB2YXIgYyA9IG1ha2VFbGVtZW50KCdjYW52YXMnLCBudWxsLCB7d2lkdGg6IGN3LCBoZWlnaHQ6IGNofSk7XG4gICAgdmFyIGcgPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgZy5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGcuZmlsbFJlY3QoMCwgMCwgY3csIGNoKTtcblxuICAgIGcuc2NhbGUobXVsdCwgbXVsdCk7XG5cbiAgICBpZiAob3B0cy5yZWdpb24pIHtcbiAgICAgICAgZy5zYXZlKCk7XG4gICAgICAgIGcuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgZy5mb250ID0gJzEycHQgc2Fucy1zZXJpZic7XG4gICAgICAgIGcuZmlsbFRleHQoXG4gICAgICAgICAgICB0aGlzLmNociArICc6JyArIGZvcm1hdExvbmdJbnQodGhpcy52aWV3U3RhcnQpICsgJy4uJyArIGZvcm1hdExvbmdJbnQodGhpcy52aWV3RW5kKSxcbiAgICAgICAgICAgIG1hcmdpbiArIDEwMCxcbiAgICAgICAgICAgIDI4XG4gICAgICAgICk7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmJhbm5lcikge1xuICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgZy5maWxsU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICBnLmZvbnQgPSAnMTJwdCBzYW5zLXNlcmlmJztcbiAgICAgICAgZmlsbFRleHRSaWdodEp1c3RpZmllZChnLCAnR3JhcGhpY3MgZnJvbSBCaW9kYWxsaWFuY2UgJyArIFZFUlNJT04sIG1hcmdpbiArIGZwdyAtIDEwMCwgMjgpO1xuICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBnLmZvbnQgPSAnMTBweCBzYW5zLXNlcmlmJztcbiAgICBcbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgdmFyIHRpZXIgPSB0aGlzLnRpZXJzW3RpXTtcbiAgICAgICAgdmFyIG9mZnNldCA9ICgodGllci5nbHlwaENhY2hlT3JpZ2luIC0gdGhpcy52aWV3U3RhcnQpKnRoaXMuc2NhbGUpO1xuXG4gICAgICAgIHZhciBvYyA9IG5ldyBPdmVybGF5TGFiZWxDYW52YXMoKTtcbiAgICAgICAgZy5zYXZlKCk7ICAgICAgIC8vIDFcbiAgICAgICAgZy50cmFuc2xhdGUoMCwgeXBvcyk7XG5cbiAgICAgICAgZy5zYXZlKCk7ICAgICAgIC8vIDJcbiAgICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgICAgZy5tb3ZlVG8obWFyZ2luLCAwKTtcbiAgICAgICAgZy5saW5lVG8obWFyZ2luICsgZnB3LCAwKTtcbiAgICAgICAgZy5saW5lVG8obWFyZ2luICsgZnB3LCB0aWVyLmxheW91dEhlaWdodCk7XG4gICAgICAgIGcubGluZVRvKG1hcmdpbiwgdGllci5sYXlvdXRIZWlnaHQpO1xuICAgICAgICBnLmNsb3NlUGF0aCgpO1xuICAgICAgICBnLmNsaXAoKTtcbiAgICAgICAgZy50cmFuc2xhdGUobWFyZ2luLCAwKTtcblxuICAgICAgICBnLnNhdmUoKTsgICAgICAvLyAzXG4gICAgICAgIGcudHJhbnNsYXRlKG9mZnNldCwgMCk7XG4gICAgICAgIGlmICh0aWVyLnN1YnRpZXJzKSB7XG4gICAgICAgICAgICB0aWVyLnBhaW50VG9Db250ZXh0KGcsIG9jLCBvZmZzZXQgKyAxMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1NlcVRpZXJHQyh0aWVyLCB0aWVyLmN1cnJlbnRTZXF1ZW5jZSwgZyk7XG4gICAgICAgIH1cbiAgICAgICAgZy5yZXN0b3JlKCk7ICAgLy8gMlxuICAgICAgICBcbiAgICAgICAgZy5zYXZlKCkgICAgICAgLy8gM1xuICAgICAgICBnLnRyYW5zbGF0ZShvZmZzZXQsIDApO1xuICAgICAgICBvYy5kcmF3KGcsIC1vZmZzZXQsIGZwdyAtIG9mZnNldCk7XG4gICAgICAgIGcucmVzdG9yZSgpOyAgIC8vIDJcbiAgICAgICAgZy5yZXN0b3JlKCk7ICAgLy8gMVxuXG4gICAgICAgIHZhciBoYXNRdWFudCA9IGZhbHNlO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgdmFyIHN1YnRpZXJzID0gdGllci5zdWJ0aWVycyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgc3RpID0gMDsgc3RpIDwgc3VidGllcnMubGVuZ3RoOyArK3N0aSkge1xuICAgICAgICAgICAgdmFyIHN1YnRpZXIgPSBzdWJ0aWVyc1tzdGldO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzdWJ0aWVyLnF1YW50KSB7XG4gICAgICAgICAgICAgICAgaGFzUXVhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBxID0gc3VidGllci5xdWFudDtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHN1YnRpZXIuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdmFyIG51bVRpY3MgPSAyO1xuICAgICAgICAgICAgICAgIGlmIChoID4gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtVGljcyA9IDEgKyAoKGgvMjApIHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0aWNTcGFjaW5nID0gaCAvIChudW1UaWNzIC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIHRpY0ludGVydmFsID0gKHEubWF4IC0gcS5taW4pIC8gKG51bVRpY3MgLSAxKTtcblxuICAgICAgICAgICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZy5tb3ZlVG8obWFyZ2luICsgNSwgcG9zKTtcbiAgICAgICAgICAgICAgICBnLmxpbmVUbyhtYXJnaW4sIHBvcyk7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8obWFyZ2luLCBwb3MgKyBzdWJ0aWVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8obWFyZ2luICsgNSwgcG9zICsgc3VidGllci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgICAgICAgICBnLm1vdmVUbyhtYXJnaW4sIHBvcyArIHR5KTtcbiAgICAgICAgICAgICAgICAgICAgZy5saW5lVG8obWFyZ2luKzMsIHBvcyArIHR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZy5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICAgICAgZy5zdHJva2VXaWR0aCA9IDI7XG4gICAgICAgICAgICAgICAgZy5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGcuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICBmaWxsVGV4dFJpZ2h0SnVzdGlmaWVkKGcsIGZvcm1hdFF1YW50TGFiZWwocS5tYXgpLCBtYXJnaW4gLSAzLCBwb3MgKyA3KTtcbiAgICAgICAgICAgICAgICBmaWxsVGV4dFJpZ2h0SnVzdGlmaWVkKGcsIGZvcm1hdFF1YW50TGFiZWwocS5taW4pLCBtYXJnaW4gLSAzLCBwb3MgKyBzdWJ0aWVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDE7IHQgPCBudW1UaWNzLTE7ICsrdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxUZXh0UmlnaHRKdXN0aWZpZWQoZywgZm9ybWF0UXVhbnRMYWJlbCgoMS4wKnEubWF4KSAtICh0KnRpY0ludGVydmFsKSksIG1hcmdpbiAtIDMsIHBvcyArIHR5ICsgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3MgKz0gc3VidGllci5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aWVyLmNvbmZpZy5uYW1lID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGxhYmVsTmFtZSA9IHRpZXIuY29uZmlnLm5hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxhYmVsTmFtZSA9IHRpZXIuZGFzU291cmNlLm5hbWU7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gZy5tZWFzdXJlVGV4dChsYWJlbE5hbWUpLndpZHRoO1xuICAgICAgICBnLmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIGcuZmlsbFRleHQobGFiZWxOYW1lLCBtYXJnaW4gLSAoaGFzUXVhbnQgPyAyOCA6IDEyKSAtIGxhYmVsV2lkdGgsICh0aWVyLmxheW91dEhlaWdodCArIDMpIC8gMik7XG5cbiAgICAgICAgZy5yZXN0b3JlKCk7IC8vIDBcblxuICAgICAgICB5cG9zICs9IHRpZXIubGF5b3V0SGVpZ2h0ICsgcGFkZGluZztcblxuICAgICAgICB0aWVyLnN1YnRpZXJzID0gdGllci5iYWNrdXBTdWJ0aWVycztcbiAgICAgICAgdGllci5vcmlnaW5IYXh4ID0gdGllci5iYWNrdXBPcmlnaW5IYXh4O1xuICAgICAgICB0aWVyLmxheW91dEhlaWdodCA9IHRpZXIuYmFja3VwTGF5b3V0SGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhpZ2hsaWdodHMpIHtcbiAgICAgICAgZy5zYXZlKCk7XG5cbiAgICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgICAgZy5tb3ZlVG8obWFyZ2luLCAwKTtcbiAgICAgICAgZy5saW5lVG8obWFyZ2luICsgZnB3LCAwKTtcbiAgICAgICAgZy5saW5lVG8obWFyZ2luICsgZnB3LCB5cG9zKTtcbiAgICAgICAgZy5saW5lVG8obWFyZ2luLCB5cG9zKTtcbiAgICAgICAgZy5jbG9zZVBhdGgoKTtcbiAgICAgICAgZy5jbGlwKCk7XG5cbiAgICAgICAgZy50cmFuc2xhdGUobWFyZ2luICsgb2Zmc2V0LCAwKTtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMudmlld1N0YXJ0O1xuICAgICAgICB2YXIgdmlzU3RhcnQgPSB0aGlzLnZpZXdTdGFydDtcbiAgICAgICAgdmFyIHZpc0VuZCA9IHRoaXMudmlld0VuZDtcblxuICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpcy5oaWdobGlnaHRzLmxlbmd0aDsgKytoaSkge1xuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmhpZ2hsaWdodHNbaGldO1xuICAgICAgICAgICAgaWYgKCgoaC5jaHIgPT09IHRoaXMuY2hyKSB8fCAoaC5jaHIgPT09ICgnY2hyJyArIHRoaXMuY2hyKSkpICYmIGgubWluIDwgdmlzRW5kICYmIGgubWF4ID4gdmlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBnLmdsb2JhbEFscGhhID0gdGhpcy5kZWZhdWx0SGlnaGxpZ2h0QWxwaGE7XG4gICAgICAgICAgICAgICAgZy5maWxsU3R5bGUgPSB0aGlzLmRlZmF1bHRIaWdobGlnaHRGaWxsO1xuICAgICAgICAgICAgICAgIGcuZmlsbFJlY3QoKGgubWluIC0gb3JpZ2luKSAqIHRoaXMuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGgubWF4IC0gaC5taW4pICogdGhpcy5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHlwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZXJQb3MgPSAtMTsgXG4gICAgaWYgKG9wdHMucnVsZXIgPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcnVsZXJQb3MgPSBtYXJnaW4gKyAoKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMSkqdGhpcy5zY2FsZSkgLyAyO1xuICAgIH0gZWxzZSBpZiAob3B0cy5ydWxlciA9PSAnbGVmdCcpIHtcbiAgICAgICAgcnVsZXJQb3MgPSBtYXJnaW47XG4gICAgfSBlbHNlIGlmIChvcHRzLnJ1bGVyID09ICdyaWdodCcpIHtcbiAgICAgICAgcnVsZXJQb3MgPSBtYXJnaW4gKyAoKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMSkqdGhpcy5zY2FsZSk7XG4gICAgfVxuICAgIGlmIChydWxlclBvcyA+PSAwKSB7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgIGcubW92ZVRvKHJ1bGVyUG9zLCAwKTtcbiAgICAgICAgZy5saW5lVG8ocnVsZXJQb3MsIHlwb3MpO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggPSBiYWNrdXBGUFc7XG4gICAgdGhpcy5zY2FsZSA9IGJhY2t1cFNjYWxlO1xuXG4gICAgcmV0dXJuIGMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTRcbi8vXG4vLyBleHBvcnQtdWkuanNcbi8vXG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIG1ha2VFbGVtZW50ID0gdXRpbHMubWFrZUVsZW1lbnQ7XG4gICAgdmFyIHJlbW92ZUNoaWxkcmVuID0gdXRpbHMucmVtb3ZlQ2hpbGRyZW47XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLm9wZW5FeHBvcnRQYW5lbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiID0gdGhpcztcbiAgICBpZiAodGhpcy51aU1vZGUgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIHRoaXMuaGlkZVRvb2xQYW5lbCgpO1xuICAgICAgICB0aGlzLnNldFVpTW9kZSgnbm9uZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBvcnRGb3JtID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICdleHBvcnQtZm9ybSd9KTtcbiAgICAgICAgdmFyIGV4cG9ydFNlbGVjdCA9IG1ha2VFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnU1ZHJywge3ZhbHVlOiAnc3ZnJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnSW1hZ2UnLCB7dmFsdWU6ICdwbmcnfSkpO1xuICAgICAgICBleHBvcnRTZWxlY3QuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsICdEYWxsaWFuY2UgY29uZmlnJywge3ZhbHVlOiAnY29uZmlnJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnRGFsbGlhbmNlIHNvdXJjZXMnLCB7dmFsdWU6ICdzb3VyY2VzJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnRGFsbGlhbmNlIHBhZ2UnLCB7dmFsdWU6ICdwYWdlJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LnZhbHVlID0gJ3N2Zyc7XG5cbiAgICAgICAgZXhwb3J0U2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihleHBvcnRDb250ZW50KTtcbiAgICAgICAgICAgIHNldHVwRU9UKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgZXhwb3J0Rm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFsnRXhwb3J0IGFzOiAnLCBleHBvcnRTZWxlY3RdKSk7XG5cbiAgICAgICAgdmFyIGV4cG9ydEhpZ2hsaWdodHNUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogdGhpcy5leHBvcnRIaWdobGlnaHRzfSk7XG4gICAgICAgIGV4cG9ydEhpZ2hsaWdodHNUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIuZXhwb3J0SGlnaGxpZ2h0cyA9IGV4cG9ydEhpZ2hsaWdodHNUb2dnbGUuY2hlY2tlZDtcbiAgICAgICAgICAgIGIuc3RvcmVTdGF0dXMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB2YXIgZXhwb3J0UnVsZXJUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogdGhpcy5leHBvcnRSdWxlcn0pO1xuICAgICAgICBleHBvcnRSdWxlclRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgYi5leHBvcnRSdWxlciA9IGV4cG9ydFJ1bGVyVG9nZ2xlLmNoZWNrZWQ7XG4gICAgICAgICAgICBiLnN0b3JlU3RhdHVzKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgdmFyIGV4cG9ydFJlZ2lvblRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiB0aGlzLmV4cG9ydFJlZ2lvbn0pO1xuICAgICAgICBleHBvcnRSZWdpb25Ub2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIuZXhwb3J0UmVnaW9uID0gZXhwb3J0UmVnaW9uVG9nZ2xlLmNoZWNrZWQ7XG4gICAgICAgICAgICBiLnN0b3JlU3RhdHVzKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgdmFyIGV4cG9ydEJhbm5lclRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiB0aGlzLmV4cG9ydEJhbm5lcn0pO1xuICAgICAgICBleHBvcnRCYW5uZXJUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIuZXhwb3J0QmFubmVyID0gZXhwb3J0QmFubmVyVG9nZ2xlLmNoZWNrZWQ7XG4gICAgICAgICAgICBiLnN0b3JlU3RhdHVzKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgdmFyIGV4cG9ydFNjYWxlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcxLjAnfSk7XG4gICAgICAgIHZhciBleHBvcnRXaWR0aCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnODAwJ30pO1xuXG4gICAgICAgIHZhciBleHBvcnRCdXR0b24gPSBtYWtlRWxlbWVudCgnYnV0dG9uJywgJ0V4cG9ydCcsIHtjbGFzc05hbWU6ICdidG4gYnRuLXByaW1hcnknfSk7XG4gICAgICAgIGV4cG9ydEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihleHBvcnRDb250ZW50KTtcblxuICAgICAgICAgICAgdmFyIGJsb2JVUkw7XG4gICAgICAgICAgICB2YXIgbm90ZSwgdHlwZSwgbmFtZTtcbiAgICAgICAgICAgIGlmIChleHBvcnRTZWxlY3QudmFsdWUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYi5tYWtlU1ZHKHtoaWdobGlnaHRzOiBleHBvcnRIaWdobGlnaHRzVG9nZ2xlLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYW5uZXI6IGIuZXhwb3J0QmFubmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiBiLmV4cG9ydFJlZ2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVyOiBleHBvcnRSdWxlclRvZ2dsZS5jaGVja2VkID8gYi5ydWxlckxvY2F0aW9uIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlSW50KGV4cG9ydFdpZHRoLnZhbHVlKSB8fCA4MDB9KSk7XG4gICAgICAgICAgICAgICAgbm90ZSA9ICdTVkcnO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnaW1hZ2Uvc3ZnJztcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2RhbGxpYW5jZS12aWV3LnN2Zyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cG9ydFNlbGVjdC52YWx1ZSA9PT0gJ3BuZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdCA9IHBhcnNlRmxvYXQoZXhwb3J0U2NhbGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChtdWx0IDwgMC4xIHx8IG11bHQgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBhbGVydCgnYmFkIHNjYWxlICcgKyBtdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJsb2JVUkwgPSBiLmV4cG9ydEltYWdlKHtoaWdobGlnaHRzOiBleHBvcnRIaWdobGlnaHRzVG9nZ2xlLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbm5lcjogYi5leHBvcnRCYW5uZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogYi5leHBvcnRSZWdpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVyOiBleHBvcnRSdWxlclRvZ2dsZS5jaGVja2VkID8gYi5ydWxlckxvY2F0aW9uIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uTXVsdGlwbGllcjogbXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlSW50KGV4cG9ydFdpZHRoLnZhbHVlKSB8fCA4MDB9KTtcbiAgICAgICAgICAgICAgICBub3RlID0gJ0ltYWdlJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2ltYWdlL3BuZyc7XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdkYWxsaWFuY2Utdmlldy5wbmcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHBvcnRTZWxlY3QudmFsdWUgPT09ICdjb25maWcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IEpTT04uc3RyaW5naWZ5KGIuZXhwb3J0RnVsbENvbmZpZygpLCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtjb25maWddLCB7dHlwZTogJ3RleHQvcGxhaW4nfSk7XG4gICAgICAgICAgICAgICAgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgbm90ZSA9ICdDb25maWd1cmF0aW9uJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnZGFsbGlhbmNlLWNvbmZpZy5qc29uJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwb3J0U2VsZWN0LnZhbHVlID09PSAnc291cmNlcycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5zdHJpbmdpZnkoYi5leHBvcnRTb3VyY2VDb25maWcoKSwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbY29uZmlnXSwge3R5cGU6ICd0ZXh0L3BsYWluJ30pO1xuICAgICAgICAgICAgICAgIGJsb2JVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgIG5vdGUgPSAnU291cmNlIGFycmF5JztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnZGFsbGlhbmNlLXNvdXJjZXMuanNvbic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cG9ydFNlbGVjdC52YWx1ZSA9PT0gJ3BhZ2UnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBiLmV4cG9ydFBhZ2VUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gJ3RleHQvaHRtbCc7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbcGFnZV0sIHt0eXBlOiB0eXBlfSk7XG4gICAgICAgICAgICAgICAgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgbm90ZSA9ICdQYWdlIHRlbXBsYXRlJztcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2RhbGxpYW5jZS12aWV3Lmh0bWwnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmxvYlVSTCkge1xuICAgICAgICAgICAgICAgIHZhciBkb3dubG9hZExpbmsgPSBtYWtlRWxlbWVudCgnYScsICdbRG93bmxvYWRdJywge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBibG9iVVJMLFxuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpZXdMaW5rID0gbWFrZUVsZW1lbnQoJ2EnLCAnW1ByZXZpZXcgaW4gYnJvd3Nlcl0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGJsb2JVUkwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ19uZXcnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBleHBvcnRDb250ZW50LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgWycnICsgbm90ZSArICcgY3JlYXRlZDogJywgZG93bmxvYWRMaW5rLCBwcmV2aWV3TGlua10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGIuYWRkVmlld0xpc3RlbmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oZXhwb3J0Q29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBiLmFkZFRpZXJMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGV4cG9ydENvbnRlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZXhwb3J0Q29udGVudCA9IG1ha2VFbGVtZW50KCdwJywgJycpO1xuXG4gICAgICAgIHZhciBlb3RIaWdobGlnaHRzID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0luY2x1ZGUgaGlnaGxpZ2h0cycsIHt9LCB7d2lkdGg6ICc0MDBweCcsIHRleHRBbGlnbjogJ3JpZ2h0J30pLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBleHBvcnRIaWdobGlnaHRzVG9nZ2xlKV0pO1xuICAgICAgICB2YXIgZW90R3VpZGVsaW5lID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0luY2x1ZGUgdmVydGljYWwgZ3VpZGVsaW5lJywge30sIHt0ZXh0QWxpZ246ICdyaWdodCd9KSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgZXhwb3J0UnVsZXJUb2dnbGUpXSk7XG4gICAgICAgIHZhciBlb3RTY2FsZSA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ1NjYWxlIG11bHRpcGxpZXInLCB7fSwge3RleHRBbGlnbjogJ3JpZ2h0J30pLFxuICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIGV4cG9ydFNjYWxlKV0pO1xuICAgICAgICB2YXIgZW90V2lkdGggPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdXaWR0aCAobG9naWNhbCBweCknLCB7fSwge3RleHRBbGlnbjogJ3JpZ2h0J30pLFxuICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIGV4cG9ydFdpZHRoKV0pO1xuICAgICAgICB2YXIgZW90UmVnaW9uID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgIFttYWtlRWxlbWVudCgndGgnLCAnTGFiZWwgd2l0aCBnZW5vbWljIGNvb3JkaW5hdGVzJywge30sIHt0ZXh0QWxpZ246ICdyaWdodCd9KSxcbiAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBleHBvcnRSZWdpb25Ub2dnbGUpXSk7XG4gICAgICAgIHZhciBlb3RCYW5uZXIgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdJbmNsdWRlIGJhbm5lcicsIHt9LCB7dGV4dEFsaWduOiAncmlnaHQnfSksXG4gICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgZXhwb3J0QmFubmVyVG9nZ2xlKV0pO1xuXG4gICAgICAgIHZhciBleHBvcnRPcHRzVGFibGUgPSBtYWtlRWxlbWVudCgndGFibGUnLFxuICAgICAgICAgICAgW2VvdEhpZ2hsaWdodHMsXG4gICAgICAgICAgICAgZW90R3VpZGVsaW5lLFxuICAgICAgICAgICAgIGVvdFdpZHRoLFxuICAgICAgICAgICAgIGVvdFNjYWxlLFxuICAgICAgICAgICAgIGVvdFJlZ2lvbl0sIG51bGwsIHt3aWR0aDogJzUwMHB4J30pO1xuICAgICAgICB2YXIgc2V0dXBFT1QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlcyA9IGV4cG9ydFNlbGVjdC52YWx1ZTtcbiAgICAgICAgICAgIGVvdEhpZ2hsaWdodHMuc3R5bGUuZGlzcGxheSA9IChlcyA9PSAnc3ZnJyB8fCBlcyA9PSAncG5nJykgPyAndGFibGUtcm93JyA6ICdub25lJztcbiAgICAgICAgICAgIGVvdEd1aWRlbGluZS5zdHlsZS5kaXNwbGF5ID0gKGVzID09ICdzdmcnIHx8IGVzID09ICdwbmcnKSA/ICd0YWJsZS1yb3cnIDogJ25vbmUnO1xuICAgICAgICAgICAgZW90U2NhbGUuc3R5bGUuZGlzcGxheSA9IChlcyA9PSAncG5nJykgPyAndGFibGUtcm93JyA6ICdub25lJztcbiAgICAgICAgICAgIGVvdFdpZHRoLnN0eWxlLmRpc3BsYXkgPSAoZXMgPT0gJ3N2ZycgfHwgZXMgPT0gJ3BuZycpID8gJ3RhYmxlLXJvdycgOiAnbm9uZSc7XG4gICAgICAgICAgICBlb3RSZWdpb24uc3R5bGUuZGlzcGxheSA9IChlcyA9PSAnc3ZnJyB8fCBlcyA9PSAncG5nJykgPyAndGFibGUtcm93JyA6ICdub25lJztcbiAgICAgICAgICAgIGVvdEJhbm5lci5zdHlsZS5kaXNwbGF5ID0gKGVzID09ICdzdmcnIHx8IGVzID09ICdwbmcnKSA/ICd0YWJsZS1yb3cnIDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIHNldHVwRU9UKCk7XG5cbiAgICAgICAgZXhwb3J0Rm9ybS5hcHBlbmRDaGlsZChleHBvcnRPcHRzVGFibGUpO1xuICAgICAgICBleHBvcnRGb3JtLmFwcGVuZENoaWxkKGV4cG9ydEJ1dHRvbik7XG4gICAgICAgIGV4cG9ydEZvcm0uYXBwZW5kQ2hpbGQoZXhwb3J0Q29udGVudCk7XG5cbiAgICAgICAgaWYgKHRoaXMudWlNb2RlICE9PSAnbm9uZScpXG4gICAgICAgICAgICB0aGlzLmhpZGVUb29sUGFuZWwoKTtcbiAgICAgICAgdGhpcy5icm93c2VySG9sZGVyLmluc2VydEJlZm9yZShleHBvcnRGb3JtLCB0aGlzLnN2Z0hvbGRlcik7XG4gICAgICAgIHRoaXMuYWN0aXZlVG9vbFBhbmVsID0gZXhwb3J0Rm9ybTtcblxuICAgICAgICB0aGlzLnNldFVpTW9kZSgnZXhwb3J0Jyk7XG4gICAgfVxufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gZXhwb3J0cy5qczogc2hpbSB0byBleHBvcnQgc3ltYm9scyBpbnRvIGdsb2JhbCBuYW1lc3BhY2UgZm9yIGVhc2Ugb2YgZW1iZWRkaW5nXG4vL1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbnZhciBjaGFpbnNldCA9IHJlcXVpcmUoJy4vY2hhaW5zZXQnKTtcbnZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xudmFyIHNjID0gcmVxdWlyZSgnLi9zb3VyY2Vjb21wYXJlJyk7XG5cbndpbmRvdy5Ccm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xud2luZG93LnNvdXJjZXNBcmVFcXVhbCA9IHNjLnNvdXJjZXNBcmVFcXVhbDtcbndpbmRvdy5DaGFpbnNldCA9IGNoYWluc2V0LkNoYWluc2V0OyAgICAvLyBQcmUtMC4xMiBjb25maWd1cmF0aW9ucyBuZWVkIHRoaXMuXG5cbi8vIFVzZWZ1bCBmb3IgaW5mbyBwbHVnaW5zLiAgU2hvdWxkIGJlIHJlY29uc2lkZXJlZCBpbiB0aGUgZnV0dXJlLlxud2luZG93Lm1ha2VFbGVtZW50ID0gdXRpbHMubWFrZUVsZW1lbnQ7XG5cbi8vIEFsbG93IHNvdXJjZSBwbHVnaW5zIHRvIGJlIGxvYWRlZCBzZXBhcmF0ZWx5Llxud2luZG93LmRhbGxpYW5jZV9yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5ID0gc2EucmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeTtcbndpbmRvdy5kYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5ID0gc2EucmVnaXN0ZXJQYXJzZXJGYWN0b3J5O1xud2luZG93LmRhbGxpYW5jZV9tYWtlUGFyc2VyID0gc2EubWFrZVBhcnNlcjtcblxuLy8gREFTKiBvYmplY3RzIGZvciBzb21lIHBsdWdpbnMgLS0gcmVtb3ZlIHdoZW4gcGx1Z2luIEFQSSBjaGFuZ2VzLi4uXG5cbndpbmRvdy5EQVNTZXF1ZW5jZSA9IGRhcy5EQVNTZXF1ZW5jZTtcbndpbmRvdy5EQVNGZWF0dXJlID0gZGFzLkRBU0ZlYXR1cmU7XG53aW5kb3cuREFTR3JvdXAgPSBkYXMuREFTR3JvdXA7XG53aW5kb3cuREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xud2luZG93LkRBU1N0eWxlID0gZGFzLkRBU1N0eWxlO1xud2luZG93LkRBU1NvdXJjZSA9IGRhcy5EQVNTb3VyY2U7ICAgIC8vIFByZS0wLjggY29uZmlndXJhdGlvbnMgdXNlZCB0aGlzLiAgU3RpbGwgc29tZSBhcm91bmQuLi5cblxudmFyIHJ1bGVyID0gcmVxdWlyZShcIi4vcnVsZXJzXCIpO1xud2luZG93LlJ1bGVyID0gcnVsZXIuUnVsZXI7XG53aW5kb3cucnVsZXJEcmF3Q2FsbGJhY2sgPSBydWxlci5ydWxlckRyYXdDYWxsYmFjaztcblxud2luZG93LldyYXBwZWRSZW5kZXJlciA9IHJlcXVpcmUoXCIuL3dyYXBwZWQtcmVuZGVyZXIuZXM2XCIpO1xuIiwiLy9cbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBmZWF0dXJlLWRyYXcuanM6IG5ldyBmZWF0dXJlLXRpZXIgcmVuZGVyZXJcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB0aWVyID0gcmVxdWlyZSgnLi90aWVyJyk7XG4gICAgdmFyIERhc1RpZXIgPSB0aWVyLkRhc1RpZXI7XG5cbiAgICB2YXIgbmYgPSByZXF1aXJlKCcuL251bWZvcm1hdHMnKTtcbiAgICB2YXIgZm9ybWF0UXVhbnRMYWJlbCA9IG5mLmZvcm1hdFF1YW50TGFiZWw7XG59XG5cbmZ1bmN0aW9uIFN1YlRpZXIoKSB7XG4gICAgdGhpcy5nbHlwaHMgPSBbXTtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5xdWFudCA9IG51bGw7XG59XG5cblN1YlRpZXIucHJvdG90eXBlLmluZGV4Rm9yID0gZnVuY3Rpb24oZ2x5cGgpIHtcbiAgICB2YXIgZ21pbiA9IGdseXBoLm1pbigpO1xuICAgIHZhciBsYiA9IDAsIHViID0gdGhpcy5nbHlwaHMubGVuZ3RoO1xuICAgIHdoaWxlICh1YiA+IGxiKSB7XG4gICAgICAgIHZhciBtaWQgPSAoKGxiICsgdWIpLzIpfDA7XG4gICAgICAgIGlmIChtaWQgPj0gdGhpcy5nbHlwaHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2x5cGhzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1nID0gdGhpcy5nbHlwaHNbbWlkXTtcbiAgICAgICAgaWYgKGdtaW4gPCBtZy5taW4oKSkge1xuICAgICAgICAgICAgdWIgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYiA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHViO1xufVxuXG5TdWJUaWVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihnbHlwaCkge1xuICAgIHZhciBpbmQgPSB0aGlzLmluZGV4Rm9yKGdseXBoKTtcbiAgICB0aGlzLmdseXBocy5zcGxpY2UoaW5kLCAwLCBnbHlwaCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmhlaWdodCwgZ2x5cGguaGVpZ2h0KCkpO1xuICAgIGlmIChnbHlwaC5xdWFudCAmJiB0aGlzLnF1YW50ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5xdWFudCA9IGdseXBoLnF1YW50O1xuICAgIH1cbn1cblxuU3ViVGllci5wcm90b3R5cGUuaGFzU3BhY2VGb3IgPSBmdW5jdGlvbihnbHlwaCkge1xuICAgIHZhciBpbmQgPSB0aGlzLmluZGV4Rm9yKGdseXBoKTtcbiAgICBpZiAoaW5kID4gMCAmJiB0aGlzLmdseXBoc1tpbmQtMV0ubWF4KCkgPj0gZ2x5cGgubWluKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaW5kIDwgdGhpcy5nbHlwaHMubGVuZ3RoICYmIHRoaXMuZ2x5cGhzW2luZF0ubWluKCkgPD0gZ2x5cGgubWF4KCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5wYWludFRvQ29udGV4dCA9IGZ1bmN0aW9uKGdjLCBvYywgb2Zmc2V0KSB7XG4gICAgdmFyIHN1YnRpZXJzID0gdGhpcy5zdWJ0aWVycztcbiAgICB2YXIgZnB3ID0gdGhpcy52aWV3cG9ydC53aWR0aHwwO1xuXG4gICAgZ2Muc2F2ZSgpO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3VidGllcnMubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgdmFyIHF1YW50ID0gbnVsbDtcbiAgICAgICAgdmFyIGdseXBocyA9IHN1YnRpZXJzW3NdLmdseXBocztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgICAgIGlmIChnbHlwaC5taW4oKSA8IGZwdy1vZmZzZXQgJiYgZ2x5cGgubWF4KCkgPiAtb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICAgICAgICAgIGdseXBoLmRyYXcoZ2MsIG9jKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGgucXVhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnQgPSBnbHlwaC5xdWFudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHRpZiAocXVhbnQgJiYgcXVhbnQubWluIDwgMCAmJiBxdWFudC5tYXggPiAwICYmIHRoaXMuZGFzU291cmNlLnplcm9MaW5lKSB7XG5cdCAgICB2YXIgcnkgPSBzdWJ0aWVyc1swXS5oZWlnaHQgKiAocXVhbnQubWF4IC8gKHF1YW50Lm1heCAtIHF1YW50Lm1pbikpXG5cdCAgICBnYy5zYXZlKCk7XG5cdCAgICBnYy5zdHJva2VTdHlsZSA9IHRoaXMuZGFzU291cmNlLnplcm9MaW5lO1xuXHQgICAgZ2MubGluZVdpZHRoID0gMC41O1xuXHQgICAgZ2MuYmVnaW5QYXRoKCk7XG5cdCAgICBnYy5tb3ZlVG8oLTEwMDAsIHJ5KTtcblx0ICAgIGdjLmxpbmVUbyhmcHcgKyAxMDAwLCByeSk7XG5cdCAgICBnYy5zdHJva2UoKTtcblx0ICAgIGdjLnJlc3RvcmUoKTtcblx0fVxuXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVmVydGljYWwpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYnJvd3Nlci5zY2FsZTtcbiAgICAgICAgICAgIGdjLnRyYW5zbGF0ZSgwLCBzY2FsZSArIHRoaXMucGFkZGluZyk7XG4gICAgICAgICAgICBvYy50cmFuc2xhdGUoMCwgc2NhbGUgKyB0aGlzLnBhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2MudHJhbnNsYXRlKDAsIHN1YnRpZXJzW3NdLmhlaWdodCArIHRoaXMucGFkZGluZyk7XG4gICAgICAgICAgICBvYy50cmFuc2xhdGUoMCwgc3VidGllcnNbc10uaGVpZ2h0ICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnYy5yZXN0b3JlKCk7XG5cbiAgICBpZiAocXVhbnQgJiYgdGhpcy5xdWFudExlYXBUaHJlc2hvbGQgJiYgdGhpcy5mZWF0dXJlU291cmNlICYmIHRoaXMuYnJvd3Nlci5zb3VyY2VBZGFwdGVySXNDYXBhYmxlKHRoaXMuZmVhdHVyZVNvdXJjZSwgJ3F1YW50TGVhcCcpKSB7XG4gICAgICAgIHZhciByeSA9IHN1YnRpZXJzWzBdLmhlaWdodCAqICgxLjAgLSAoKHRoaXMucXVhbnRMZWFwVGhyZXNob2xkIC0gcXVhbnQubWluKSAvIChxdWFudC5tYXggLSBxdWFudC5taW4pKSk7XG5cbiAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICBnYy5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICBnYy5saW5lV2lkdGggPSAwLjM7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5tb3ZlVG8oLTEwMDAsIHJ5KTtcbiAgICAgICAgZ2MubGluZVRvKGZwdyArIDEwMDAsIHJ5KTtcbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIGdjLnJlc3RvcmUoKTtcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnBhaW50UXVhbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMucXVhbnRPdmVybGF5KVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0aW5hID0gdGhpcy5icm93c2VyLnJldGluYSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG5cbiAgICB2YXIgcXVhbnQ7XG4gICAgaWYgKHRoaXMuc3VidGllcnMgJiYgdGhpcy5zdWJ0aWVycy5sZW5ndGggPiAwKVxuICAgICAgICBxdWFudCA9IHRoaXMuc3VidGllcnNbMF0ucXVhbnQ7XG5cbiAgICBpZiAocXVhbnQpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLnN1YnRpZXJzWzBdLmhlaWdodDtcbiAgICAgICAgdmFyIHcgPSA1MDtcbiAgICAgICAgdGhpcy5xdWFudE92ZXJsYXkuaGVpZ2h0ID0gdGhpcy52aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgIHRoaXMucXVhbnRPdmVybGF5LndpZHRoID0gcmV0aW5hID8gdyoyIDogdztcbiAgICAgICAgdGhpcy5xdWFudE92ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gJycgKyAocmV0aW5hID8gdGhpcy5xdWFudE92ZXJsYXkuaGVpZ2h0LzIgOiB0aGlzLnF1YW50T3ZlcmxheS5oZWlnaHQpICsgJ3B4JztcbiAgICAgICAgdGhpcy5xdWFudE92ZXJsYXkuc3R5bGUud2lkdGggPSAnJyArIHcgKyAncHgnO1xuICAgICAgICB0aGlzLnF1YW50T3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMucXVhbnRPdmVybGF5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmIChyZXRpbmEpXG4gICAgICAgICAgICBjdHguc2NhbGUoMiwgMik7XG5cbiAgICAgICAgdmFyIG51bVRpY3MgPSAyO1xuICAgICAgICBpZiAoaCA+IDQwKSB7XG4gICAgICAgICAgICBudW1UaWNzID0gMSArICgoaC8yMCkgfCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGljU3BhY2luZyA9IChoICsgdGhpcy5wYWRkaW5nKjIpIC8gKG51bVRpY3MgLSAxKTtcbiAgICAgICAgdmFyIHRpY0ludGVydmFsID0gKHF1YW50Lm1heCAtIHF1YW50Lm1pbikgLyAobnVtVGljcyAtIDEpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNjtcbiAgICAgICAgaWYgKHRoaXMuYnJvd3Nlci5ydWxlckxvY2F0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh3LTMwLCAwLCAzMCwgaCArIHRoaXMucGFkZGluZyoyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAzMCwgaCArIHRoaXMucGFkZGluZyoyKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAodGhpcy5icm93c2VyLnJ1bGVyTG9jYXRpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh3IC0gOCwgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8odywgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8odywgaCArIHRoaXMucGFkZGluZyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHcgLSA4LCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh3LCB0eSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh3IC0gNSwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyg4LCB0aGlzLnBhZGRpbmcpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCB0aGlzLnBhZGRpbmcpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oOCwgaCArIHRoaXMucGFkZGluZyk7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IG51bVRpY3MtMTsgKyt0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgdHkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oNSwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgICBpZiAodGhpcy5icm93c2VyLnJ1bGVyTG9jYXRpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZm9ybWF0UXVhbnRMYWJlbChxdWFudC5tYXgpLCB3LTksIDgpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwocXVhbnQubWluKSwgdy05LCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwoKDEuMCpxdWFudC5tYXgpIC0gKHQqdGljSW50ZXJ2YWwpKSwgdyAtIDksIHR5ICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwocXVhbnQubWF4KSwgOSwgOCk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZm9ybWF0UXVhbnRMYWJlbChxdWFudC5taW4pLCA5LCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwoKDEuMCpxdWFudC5tYXgpIC0gKHQqdGljSW50ZXJ2YWwpKSwgOSwgdHkgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVhbnRPdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5zdHlsZUZvckZlYXR1cmUgPSBmdW5jdGlvbihmKSB7XG4gICAgdmFyIHNzU2NhbGUgPSB0aGlzLmJyb3dzZXIuem9vbUZvckN1cnJlbnRTY2FsZSgpO1xuXG4gICAgaWYgKCF0aGlzLnN0eWxlc2hlZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlID0gbnVsbDtcbiAgICB2YXIgc3MgPSB0aGlzLnN0eWxlc2hlZXQuc3R5bGVzO1xuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgdmFyIHNoID0gc3Nbc2ldO1xuICAgICAgICBpZiAoc2guem9vbSAmJiBzaC56b29tICE9IHNzU2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc2gub3JpZW50YXRpb24gIT0gZi5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsUkUgPSBzaC5fbGFiZWxSRTtcbiAgICAgICAgaWYgKCFsYWJlbFJFIHx8ICFsYWJlbFJFLnRlc3QpIHtcbiAgICAgICAgICAgIGxhYmVsUkUgPSBuZXcgUmVnRXhwKCdeJyArIHNoLmxhYmVsICsgJyQnKTtcbiAgICAgICAgICAgIHNoLl9sYWJlbFJFID0gbGFiZWxSRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2gubGFiZWwgJiYgIShsYWJlbFJFLnRlc3QoZi5sYWJlbCkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0aG9kUkUgPSBzaC5fbWV0aG9kUkU7XG4gICAgICAgIGlmICghbWV0aG9kUkUgfHwgIW1ldGhvZFJFLnRlc3QpIHtcbiAgICAgICAgICAgIG1ldGhvZFJFID0gbmV3IFJlZ0V4cCgnXicgKyBzaC5tZXRob2QgKyAnJCcpO1xuICAgICAgICAgICAgc2guX21ldGhvZFJFID0gbWV0aG9kUkU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoLm1ldGhvZCAmJiAhKG1ldGhvZFJFLnRlc3QoZi5tZXRob2QpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChzaC50eXBlID09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIGlmICghbWF5YmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmUgPSBzaC5zdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlUkUgPSBzaC5fdHlwZVJFO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZVJFIHx8ICF0eXBlUkUudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlUkUgPSBuZXcgUmVnRXhwKCdeJyArIHNoLnR5cGUgKyAnJCcpO1xuICAgICAgICAgICAgICAgICAgICBzaC5fdHlwZVJFID0gdHlwZVJFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXR5cGVSRS50ZXN0KGYudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaC5zdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIG1heWJlO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5xdWFudE1pbiA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgaWYgKHRoaXMuZm9yY2VNaW5EeW5hbWljKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGZWF0dXJlc01pblNjb3JlIHx8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YodGhpcy5mb3JjZU1pbikgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcmNlTWluO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHlsZS5NSU4gfHwgdGhpcy5jdXJyZW50RmVhdHVyZXNNaW5TY29yZSB8fCAwO1xuICAgIH1cbn1cblxuRGFzVGllci5wcm90b3R5cGUucXVhbnRNYXggPSBmdW5jdGlvbihzdHlsZSkge1xuICAgIGlmICh0aGlzLmZvcmNlTWF4RHluYW1pYykge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RmVhdHVyZXNNYXhTY29yZSB8fCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKHRoaXMuZm9yY2VNYXgpID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JjZU1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R5bGUuTUFYIHx8IHRoaXMuY3VycmVudEZlYXR1cmVzTWF4U2NvcmUgfHwgMDtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgU3ViVGllcjogU3ViVGllclxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDExXG4vL1xuLy8gZmVhdHVyZS1wb3B1cC5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIHBpY2sgPSB1dGlscy5waWNrO1xuICAgIHZhciBwdXNobmV3ID0gdXRpbHMucHVzaG5ldztcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbn1cblxuXG52YXIgVEFHVkFMX05PVEVfUkUgPSBuZXcgUmVnRXhwKCdeKFtBLVphLXpfLV0rKT0oLispJyk7XG5cbkJyb3dzZXIucHJvdG90eXBlLmFkZEZlYXR1cmVJbmZvUGx1Z2luID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5mZWF0dXJlSW5mb1BsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5mb1BsdWdpbnMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mZWF0dXJlSW5mb1BsdWdpbnMucHVzaChoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gRmVhdHVyZUluZm8oaGl0LCBmZWF0dXJlLCBncm91cCkge1xuICAgIHZhciBuYW1lID0gcGljayhncm91cC50eXBlLCBmZWF0dXJlLnR5cGUpO1xuICAgIHZhciBmaWQgPSBwaWNrKGdyb3VwLmxhYmVsLCBmZWF0dXJlLmxhYmVsLCBncm91cC5pZCwgZmVhdHVyZS5pZCk7XG4gICAgaWYgKGZpZCAmJiBmaWQuaW5kZXhPZignX19kYXp6bGUnKSAhPSAwKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lICsgJzogJyArIGZpZDtcbiAgICB9XG5cbiAgICB0aGlzLmhpdCA9IGhpdDtcbiAgICB0aGlzLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgIHRoaXMuZ3JvdXAgPSBncm91cDtcbiAgICB0aGlzLnRpdGxlID0gbmFtZTtcbiAgICB0aGlzLnNlY3Rpb25zID0gW107XG59XG5cbkZlYXR1cmVJbmZvLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRpdGxlID0gdDtcbn1cblxuRmVhdHVyZUluZm8ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGxhYmVsLCBpbmZvKSB7XG4gICAgaWYgKHR5cGVvZiBpbmZvID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmZvID0gbWFrZUVsZW1lbnQoJ3NwYW4nLCBpbmZvKTtcbiAgICB9XG4gICAgdGhpcy5zZWN0aW9ucy5wdXNoKHtsYWJlbDogbGFiZWwsIGluZm86IGluZm99KTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuZmVhdHVyZVBvcHVwID0gZnVuY3Rpb24oZXYsIF9faWdub3JlZF9mZWF0dXJlLCBoaXQsIHRpZXIpIHtcbiAgICB2YXIgaGkgPSBoaXQubGVuZ3RoO1xuICAgIHZhciBmZWF0dXJlID0gLS1oaSA+PSAwID8gaGl0W2hpXSA6IHt9O1xuICAgIHZhciBncm91cCA9IC0taGkgPj0gMCA/IGhpdFtoaV0gOiB7fTtcblxuICAgIHZhciBmZWF0dXJlSW5mbyA9IG5ldyBGZWF0dXJlSW5mbyhoaXQsIGZlYXR1cmUsIGdyb3VwKTtcbiAgICBmZWF0dXJlSW5mby50aWVyID0gdGllcjtcbiAgICB2YXIgZmlwcyA9IHRoaXMuZmVhdHVyZUluZm9QbHVnaW5zIHx8IFtdO1xuICAgIGZvciAodmFyIGZpcGkgPSAwOyBmaXBpIDwgZmlwcy5sZW5ndGg7ICsrZmlwaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmlwc1tmaXBpXShmZWF0dXJlLCBmZWF0dXJlSW5mbyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2sgfHwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlwcyA9IHRpZXIuZmVhdHVyZUluZm9QbHVnaW5zIHx8IFtdO1xuICAgIGZvciAoZmlwaSA9IDA7IGZpcGkgPCBmaXBzLmxlbmd0aDsgKytmaXBpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaXBzW2ZpcGldKGZlYXR1cmUsIGZlYXR1cmVJbmZvKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayB8fCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQWxsUG9wdXBzKCk7XG5cbiAgICB2YXIgdGFibGUgPSBtYWtlRWxlbWVudCgndGFibGUnLCBudWxsLCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSk7XG4gICAgdGFibGUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGFibGUuc3R5bGUubWFyZ2luID0gJzBweCc7XG5cbiAgICB2YXIgaWR4ID0gMDtcbiAgICBpZiAoZmVhdHVyZS5tZXRob2QgJiYgIXRpZXIuZGFzU291cmNlLnN1cHByZXNzTWV0aG9kKSB7XG4gICAgICAgIHZhciByb3cgPSBtYWtlRWxlbWVudCgndHInLCBbXG4gICAgICAgICAgICBtYWtlRWxlbWVudCgndGgnLCAnTWV0aG9kJyksXG4gICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBmZWF0dXJlLm1ldGhvZClcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICsraWR4O1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciBsb2M7XG4gICAgICAgIGlmIChncm91cC5zZWdtZW50KSB7XG4gICAgICAgICAgICBsb2MgPSBncm91cDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYyA9IGZlYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IG1ha2VFbGVtZW50KCd0cicsIFtcbiAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0aCcsICdMb2NhdGlvbicpLFxuICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgbG9jLnNlZ21lbnQgKyAnOicgKyBsb2MubWluICsgJy0nICsgbG9jLm1heCwge30sIHttaW5XaWR0aDogJzIwMHB4J30pXG4gICAgICAgIF0pO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICArK2lkeDtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmUuc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBmZWF0dXJlLnNjb3JlICE9PSBudWxsICYmIGZlYXR1cmUuc2NvcmUgIT0gJy0nXG4gICAgICAgICYmICFmZWF0dXJlLnN1cHByZXNzU2NvcmUgJiYgIXRpZXIuZGFzU291cmNlLnN1cHByZXNzU2NvcmVcbiAgICApIHtcbiAgICAgICAgdmFyIHJvdyA9IG1ha2VFbGVtZW50KCd0cicsIFtcbiAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0aCcsICdTY29yZScpLFxuICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgJycgKyBmZWF0dXJlLnNjb3JlKVxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgKytpZHg7XG4gICAgfVxuICAgIHtcbiAgICAgICAgdmFyIGxpbmtzID0gbWF5YmVDb25jYXQoZ3JvdXAubGlua3MsIGZlYXR1cmUubGlua3MpO1xuICAgICAgICBpZiAobGlua3MgJiYgbGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IG1ha2VFbGVtZW50KCd0cicsIFtcbiAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGgnLCAnTGlua3MnKSxcbiAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBsaW5rcy5tYXAoZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVsZW1lbnQoJ2RpdicsIG1ha2VFbGVtZW50KCdhJywgbC5kZXNjLCB7aHJlZjogbC51cmksIHRhcmdldDogJ19uZXcnfSkpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgKytpZHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgICB2YXIgbm90ZXMgPSBtYXliZUNvbmNhdChncm91cC5ub3RlcywgZmVhdHVyZS5ub3Rlcyk7XG4gICAgICAgIGZvciAodmFyIG5pID0gMDsgbmkgPCBub3Rlcy5sZW5ndGg7ICsrbmkpIHtcbiAgICAgICAgICAgIHZhciBrID0gJ05vdGUnO1xuICAgICAgICAgICAgdmFyIHYgPSBub3Rlc1tuaV07XG4gICAgICAgICAgICB2YXIgbSA9IHYubWF0Y2goVEFHVkFMX05PVEVfUkUpO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBrID0gbVsxXTtcbiAgICAgICAgICAgICAgICB2ID0gbVsyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJvdyA9IG1ha2VFbGVtZW50KCd0cicsIFtcbiAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGgnLCBrKSxcbiAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCB2KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgKytpZHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBmaXNpID0gMDsgZmlzaSA8IGZlYXR1cmVJbmZvLnNlY3Rpb25zLmxlbmd0aDsgKytmaXNpKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZmVhdHVyZUluZm8uc2VjdGlvbnNbZmlzaV07XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCd0cicsIFtcbiAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0aCcsIHNlY3Rpb24ubGFiZWwpLFxuICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgc2VjdGlvbi5pbmZvKV0pKTtcbiAgICB9ICAgICAgICBcblxuICAgIHRoaXMucG9waXQoZXYsIGZlYXR1cmVJbmZvLnRpdGxlIHx8ICdGZWF0dXJlJywgdGFibGUsIHt3aWR0aDogNDUwfSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlQ29uY2F0KGEsIGIpIHtcbiAgICB2YXIgbCA9IFtdO1xuICAgIGlmIChhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHVzaG5ldyhsLCBhW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHB1c2huZXcobCwgYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGw7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIHB1c2hvID0gdXRpbHMucHVzaG87XG4gICAgdmFyIHB1c2huZXdvID0gdXRpbHMucHVzaG5ld287XG59XG5cbmZ1bmN0aW9uIHNvcnRGZWF0dXJlcyh0aWVyKVxue1xuICAgIHZhciBkbWluID0gdGllci5icm93c2VyLmRyYXduU3RhcnQsIGRtYXggPSB0aWVyLmJyb3dzZXIuZHJhd25FbmQ7XG4gICAgdmFyIHVuZ3JvdXBlZEZlYXR1cmVzID0ge307XG4gICAgdmFyIGdyb3VwZWRGZWF0dXJlcyA9IHt9O1xuICAgIHZhciBkcmF3bkdyb3VwZWRGZWF0dXJlcyA9IHt9O1xuICAgIHZhciBncm91cE1pbnMgPSB7fSwgZ3JvdXBNYXhlcyA9IHt9O1xuICAgIHZhciBncm91cHMgPSB7fTtcbiAgICB2YXIgc3VwZXJHcm91cHMgPSB7fTtcbiAgICB2YXIgZ3JvdXBzVG9TdXBlcnMgPSB7fTtcbiAgICB2YXIgbm9uUG9zaXRpb25hbCA9IFtdO1xuICAgIHZhciBtaW5TY29yZSwgbWF4U2NvcmU7XG4gICAgdmFyIGZiaWQ7XG5cbiAgICB2YXIgaW5pdF9mYmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZiaWQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IHRpZXIuY3VycmVudEZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgdmFyIGYgPSB0aWVyLmN1cnJlbnRGZWF0dXJlc1tmaV07XG4gICAgICAgICAgICBpZiAoZi5pZCkge1xuICAgICAgICAgICAgICAgIGZiaWRbZi5pZF0gPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgc3VwZXJQYXJlbnRzT2YgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIC8vIEZJWE1FOiBzaG91bGQgcmVjdXIuXG4gICAgICAgIHZhciBzcGlkcyA9IFtdO1xuICAgICAgICBpZiAoZi5wYXJlbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgZi5wYXJlbnRzLmxlbmd0aDsgKytwaSkge1xuICAgICAgICAgICAgICAgIHZhciBwaWQgPSBmLnBhcmVudHNbcGldO1xuICAgICAgICAgICAgICAgIHZhciBwID0gZmJpZFtwaWRdO1xuICAgICAgICAgICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWxlcnQocC50eXBlICsgJzonICsgcC50eXBlQ3YpO1xuICAgICAgICAgICAgICAgIGlmIChwLnR5cGVDdiA9PSAnU086MDAwMDcwNCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaG5ldyhzcGlkcywgcGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwaWRzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCB0aWVyLmN1cnJlbnRGZWF0dXJlcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgdmFyIGYgPSB0aWVyLmN1cnJlbnRGZWF0dXJlc1tmaV07XG4gICAgICAgIGlmIChmLnBhcnRzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmF3biA9IGYubWluIDw9IGRtYXggJiYgZi5tYXggPj0gZG1pbjtcblxuICAgICAgICBpZiAoIWYubWluIHx8ICFmLm1heCkge1xuICAgICAgICAgICAgbm9uUG9zaXRpb25hbC5wdXNoKGYpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZi5zY29yZSAmJiBmLnNjb3JlICE9ICcuJyAmJiBmLnNjb3JlICE9ICctJykge1xuICAgICAgICAgICAgdmFyIHNjID0gMS4wICogZi5zY29yZTtcbiAgICAgICAgICAgIGlmICghbWluU2NvcmUgfHwgc2MgPCBtaW5TY29yZSkge1xuICAgICAgICAgICAgICAgIG1pblNjb3JlID0gc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1heFNjb3JlIHx8IHNjID4gbWF4U2NvcmUpIHtcbiAgICAgICAgICAgICAgICBtYXhTY29yZSA9IHNjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZHcm91cHMgPSBbXTtcbiAgICAgICAgdmFyIGZTdXBlckdyb3VwID0gbnVsbDtcbiAgICAgICAgaWYgKGYuZ3JvdXBzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBnaSA9IDA7IGdpIDwgZi5ncm91cHMubGVuZ3RoOyArK2dpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBmLmdyb3Vwc1tnaV07XG4gICAgICAgICAgICAgICAgdmFyIGdpZCA9IGcuaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGcudHlwZSA9PSAnZ2VuZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGlrZSBhIHN1cGVyLWdyb3VwZXIuLi5cbiAgICAgICAgICAgICAgICAgICAgZlN1cGVyR3JvdXAgPSBnaWQ7IFxuICAgICAgICAgICAgICAgICAgICBncm91cHNbZ2lkXSA9IGc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnLnR5cGUgPT0gJ3RyYW5zbGF0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIGlnbm9yZSB0aGlzIHRvIGdldCBzZW5zaWJsZSByZXN1bHRzIGZyb20gYmotZSA6LSguXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaG8oZ3JvdXBlZEZlYXR1cmVzLCBnaWQsIGYpO1xuICAgICAgICAgICAgICAgICAgICBncm91cHNbZ2lkXSA9IGc7XG4gICAgICAgICAgICAgICAgICAgIGZHcm91cHMucHVzaChnaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZ20gPSBncm91cE1pbnNbZ2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvZ20gfHwgZi5taW4gPCBvZ20pXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cE1pbnNbZ2lkXSA9IGYubWluO1xuXG4gICAgICAgICAgICAgICAgICAgIG9nbSA9IGdyb3VwTWF4ZXNbZ2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvZ20gfHwgZi5tYXggPiBvZ20pXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cE1heGVzW2dpZF0gPSBmLm1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZi5wYXJlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIWZiaWQpIHtcbiAgICAgICAgICAgICAgICBpbml0X2ZiaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHBpID0gMDsgcGkgPCBmLnBhcmVudHMubGVuZ3RoOyArK3BpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpZCA9IGYucGFyZW50c1twaV07XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBmYmlkW3BpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsZXJ0KFwiY291bGRuJ3QgZmluZCBcIiArIHBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXAucGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wYXJ0cyA9IFtmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVzaG5ld28oZ3JvdXBlZEZlYXR1cmVzLCBwaWQsIHApO1xuICAgICAgICAgICAgICAgIHB1c2hvKGdyb3VwZWRGZWF0dXJlcywgcGlkLCBmKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3Vwc1twaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1twaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHAuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcC5sYWJlbCB8fCBwLmlkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZHcm91cHMucHVzaChwaWQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9nbSA9IGdyb3VwTWluc1twaWRdO1xuICAgICAgICAgICAgICAgIGlmICghb2dtIHx8IGYubWluIDwgb2dtKVxuICAgICAgICAgICAgICAgICAgICBncm91cE1pbnNbcGlkXSA9IGYubWluO1xuXG4gICAgICAgICAgICAgICAgb2dtID0gZ3JvdXBNYXhlc1twaWRdO1xuICAgICAgICAgICAgICAgIGlmICghb2dtIHx8IGYubWF4ID4gb2dtKVxuICAgICAgICAgICAgICAgICAgICBncm91cE1heGVzW3BpZF0gPSBmLm1heDtcblxuICAgICAgICAgICAgICAgIHZhciBzZ3MgPSBzdXBlclBhcmVudHNPZihwKTtcbiAgICAgICAgICAgICAgICBpZiAoc2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZlN1cGVyR3JvdXAgPSBzZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcCA9IGZiaWRbc2dzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW3Nnc1swXV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBzcC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNwLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHNwLmxhYmVsIHx8IHNwLmlkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGllci5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGllci5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3VwcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZkdyb3Vwcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKGRyYXduKVxuICAgICAgICAgICAgICAgIHB1c2hvKHVuZ3JvdXBlZEZlYXR1cmVzLCBmLnR5cGUsIGYpO1xuICAgICAgICB9IGVsc2UgaWYgKGZTdXBlckdyb3VwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGZHcm91cHMubGVuZ3RoOyArK2cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2lkID0gZkdyb3Vwc1tnXTtcbiAgICAgICAgICAgICAgICBwdXNobmV3byhzdXBlckdyb3VwcywgZlN1cGVyR3JvdXAsIGdpZCk7XG4gICAgICAgICAgICAgICAgZ3JvdXBzVG9TdXBlcnNbZ2lkXSA9IGZTdXBlckdyb3VwO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgICAgICBcbiAgICB9XG5cbiAgICBmb3IgKHZhciBnaWQgaW4gZ3JvdXBlZEZlYXR1cmVzKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tnaWRdO1xuICAgICAgICBpZiAodHlwZW9mKGdyb3VwLm1pbikgIT09ICdudW1iZXInKSBcbiAgICAgICAgICAgIGdyb3VwLm1pbiA9IGdyb3VwTWluc1tnaWRdO1xuICAgICAgICBpZiAodHlwZW9mKGdyb3VwLm1heCkgIT09ICdudW1iZXInKSBcbiAgICAgICAgICAgIGdyb3VwLm1heCA9IGdyb3VwTWF4ZXNbZ2lkXTtcblxuICAgICAgICBpZiAoZ3JvdXBNYXhlc1tnaWRdID49IGRtaW4gJiYgZ3JvdXBNaW5zW2dpZF0gPD0gZG1heClcbiAgICAgICAgICAgIGRyYXduR3JvdXBlZEZlYXR1cmVzW2dpZF0gPSBncm91cGVkRmVhdHVyZXNbZ2lkXTtcbiAgICB9XG5cbiAgICB0aWVyLnVuZ3JvdXBlZEZlYXR1cmVzID0gdW5ncm91cGVkRmVhdHVyZXM7XG4gICAgdGllci5ncm91cGVkRmVhdHVyZXMgPSBkcmF3bkdyb3VwZWRGZWF0dXJlcztcbiAgICB0aWVyLmdyb3VwcyA9IGdyb3VwcztcbiAgICB0aWVyLnN1cGVyR3JvdXBzID0gc3VwZXJHcm91cHM7XG4gICAgdGllci5ncm91cHNUb1N1cGVycyA9IGdyb3Vwc1RvU3VwZXJzO1xuXG4gICAgaWYgKG1pblNjb3JlKSB7XG4gICAgICAgIGlmIChtaW5TY29yZSA+IDApIHtcbiAgICAgICAgICAgIG1pblNjb3JlID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhTY29yZSA8IDApIHtcbiAgICAgICAgICAgIG1heFNjb3JlID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aWVyLmN1cnJlbnRGZWF0dXJlc01pblNjb3JlID0gbWluU2NvcmU7XG4gICAgICAgIHRpZXIuY3VycmVudEZlYXR1cmVzTWF4U2NvcmUgPSBtYXhTY29yZTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc29ydEZlYXR1cmVzOiBzb3J0RmVhdHVyZXNcbiAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIGdseXBocy5qczogY29tcG9uZW50cyB3aGljaCBrbm93IGhvdyB0byBkcmF3IHRoZW1zZWx2ZXNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzcGFucyA9IHJlcXVpcmUoJy4vc3BhbnMnKTtcbiAgICB2YXIgdW5pb24gPSBzcGFucy51bmlvbjtcbiAgICB2YXIgUmFuZ2UgPSBzcGFucy5SYW5nZTtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnROUyA9IHV0aWxzLm1ha2VFbGVtZW50TlM7XG4gICAgdmFyIEFNSU5PX0FDSURfVFJBTlNMQVRJT04gPSB1dGlscy5BTUlOT19BQ0lEX1RSQU5TTEFUSU9OO1xuXG4gICAgdmFyIHN2Z3UgPSByZXF1aXJlKCcuL3N2Zy11dGlscycpO1xuICAgIHZhciBOU19TVkcgPSBzdmd1Lk5TX1NWRztcbiAgICB2YXIgTlNfWExJTksgPSBzdmd1Lk5TX1hMSU5LO1xuICAgIHZhciBTVkdQYXRoID0gc3ZndS5TVkdQYXRoO1xufVxuXG5mdW5jdGlvbiBQYXRoR2x5cGhCYXNlKHN0cm9rZSwgZmlsbCkge1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbn1cblxuUGF0aEdseXBoQmFzZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuZHJhd1BhdGgoZyk7XG5cbiAgICBpZiAodGhpcy5fZmlsbCkge1xuICAgICAgICBnLmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGw7XG4gICAgICAgIGcuZmlsbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3Ryb2tlKSB7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2U7XG4gICAgICAgIGcuc3Ryb2tlKCk7XG4gICAgfVxufVxuXG5QYXRoR2x5cGhCYXNlLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnID0gbmV3IFNWR1BhdGgoKTtcbiAgICB0aGlzLmRyYXdQYXRoKGcpO1xuICAgIFxuICAgIHJldHVybiBtYWtlRWxlbWVudE5TKFxuICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAge2Q6IGcudG9QYXRoRGF0YSgpLFxuICAgICAgICAgZmlsbDogdGhpcy5fZmlsbCB8fCAnbm9uZScsXG4gICAgICAgICBzdHJva2U6IHRoaXMuX3N0cm9rZSB8fCAnbm9uZSd9KTtcbn1cblxuUGF0aEdseXBoQmFzZS5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdGhyb3cgJ2RyYXdQYXRoIG1ldGhvZCBvbiBQYXRoR2x5cGhCYXNlIG11c3QgYmUgb3ZlcnJpZGRlbic7XG59XG5cbmZ1bmN0aW9uIEJveEdseXBoKHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGwsIHN0cm9rZSwgYWxwaGEsIHJhZGl1cykge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xuICAgIHRoaXMuc3Ryb2tlID0gc3Ryb2tlO1xuICAgIHRoaXMuX2FscGhhID0gYWxwaGE7XG4gICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzIHx8IDA7XG59XG5cbkJveEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIHZhciByID0gdGhpcy5fcmFkaXVzO1xuXG4gICAgaWYgKHIgPiAwKSB7XG4gICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgIGcubW92ZVRvKHRoaXMueCArIHIsIHRoaXMueSk7XG4gICAgICAgIGcubGluZVRvKHRoaXMueCArIHRoaXMuX3dpZHRoIC0gciwgdGhpcy55KTtcbiAgICAgICAgZy5hcmNUbyh0aGlzLnggKyB0aGlzLl93aWR0aCwgdGhpcy55LCB0aGlzLnggKyB0aGlzLl93aWR0aCwgdGhpcy55ICsgciwgcik7XG4gICAgICAgIGcubGluZVRvKHRoaXMueCArIHRoaXMuX3dpZHRoLCB0aGlzLnkgKyB0aGlzLl9oZWlnaHQgLSByKTtcbiAgICAgICAgZy5hcmNUbyh0aGlzLnggKyB0aGlzLl93aWR0aCwgdGhpcy55ICsgdGhpcy5faGVpZ2h0LCB0aGlzLnggKyB0aGlzLl93aWR0aCAtIHIsIHRoaXMueSArIHRoaXMuX2hlaWdodCwgcik7XG4gICAgICAgIGcubGluZVRvKHRoaXMueCArIHIsIHRoaXMueSArIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIGcuYXJjVG8odGhpcy54LCB0aGlzLnkgKyB0aGlzLl9oZWlnaHQsIHRoaXMueCwgdGhpcy55ICsgdGhpcy5faGVpZ2h0IC0gciwgcik7XG4gICAgICAgIGcubGluZVRvKHRoaXMueCwgdGhpcy55ICsgcik7XG4gICAgICAgIGcuYXJjVG8odGhpcy54LCB0aGlzLnksIHRoaXMueCArIHIsIHRoaXMueSwgcik7XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGcuc2F2ZSgpO1xuICAgICAgICAgICAgZy5nbG9iYWxBbHBoYSA9IHRoaXMuX2FscGhhO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgICAgICBnLmZpbGxTdHlsZSA9IHRoaXMuZmlsbDtcbiAgICAgICAgICAgIGcuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICAgICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICAgICAgZy5saW5lV2lkdGggPSAwLjU7XG4gICAgICAgICAgICBnLnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGcucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGcuc2F2ZSgpO1xuICAgICAgICAgICAgZy5nbG9iYWxBbHBoYSA9IHRoaXMuX2FscGhhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICAgICAgZy5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XG4gICAgICAgICAgICBnLmZpbGxSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICAgICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICAgICAgZy5saW5lV2lkdGggPSAwLjU7XG4gICAgICAgICAgICBnLnN0cm9rZVJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWxwaGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgZy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJveEdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdyZWN0JywgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICB7eDogdGhpcy54LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy55LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX3dpZHRoLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5zdHJva2UgfHwgJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmZpbGwgfHwgJ25vbmUnfSk7XG4gICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpIHtcbiAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLl9hbHBoYSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG59XG5cbkJveEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy54O1xufVxuXG5Cb3hHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMuX3dpZHRoO1xufVxuXG5Cb3hHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueSArIHRoaXMuX2hlaWdodDtcbn1cblxuXG5mdW5jdGlvbiBHcm91cEdseXBoKGdseXBocywgY29ubmVjdG9yKSB7XG4gICAgdGhpcy5nbHlwaHMgPSBnbHlwaHM7XG4gICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XG4gICAgdGhpcy5oID0gZ2x5cGhzWzBdLmhlaWdodCgpO1xuXG4gICAgdmFyIGNvdkxpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBnID0gMDsgZyA8IGdseXBocy5sZW5ndGg7ICsrZykge1xuICAgICAgICB2YXIgZ2cgPSBnbHlwaHNbZ107XG4gICAgICAgIGNvdkxpc3QucHVzaChuZXcgUmFuZ2UoZ2cubWluKCksIGdnLm1heCgpKSk7XG4gICAgICAgIHRoaXMuaCA9IE1hdGgubWF4KHRoaXMuaCwgZ2cuaGVpZ2h0KCkpO1xuICAgIH1cbiAgICB0aGlzLmNvdmVyYWdlID0gdW5pb24oY292TGlzdCk7XG59XG5cbkdyb3VwR2x5cGgucHJvdG90eXBlLmRyYXdDb25uZWN0b3JzID0gZnVuY3Rpb24oZykge1xuICAgIHZhciByYW5nZXMgPSB0aGlzLmNvdmVyYWdlLnJhbmdlcygpO1xuICAgIGZvciAodmFyIHIgPSAxOyByIDwgcmFuZ2VzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciBnbCA9IHJhbmdlc1tyXTtcbiAgICAgICAgdmFyIGxhc3QgPSByYW5nZXNbciAtIDFdO1xuICAgICAgICBpZiAobGFzdCAmJiBnbC5taW4oKSA+IGxhc3QubWF4KCkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGxhc3QubWF4KCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gZ2wubWluKCk7XG4gICAgICAgICAgICB2YXIgbWlkID0gKHN0YXJ0K2VuZCkvMlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IgPT09ICdoYXQrJykge1xuICAgICAgICAgICAgICAgIGcubW92ZVRvKHN0YXJ0LCB0aGlzLmgvMik7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8obWlkLCAwKTtcbiAgICAgICAgICAgICAgICBnLmxpbmVUbyhlbmQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25uZWN0b3IgPT09ICdoYXQtJykge1xuICAgICAgICAgICAgICAgIGcubW92ZVRvKHN0YXJ0LCB0aGlzLmgvMik7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8obWlkLCB0aGlzLmgpO1xuICAgICAgICAgICAgICAgIGcubGluZVRvKGVuZCwgdGhpcy5oLzIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbm5lY3RvciA9PT0gJ2NvbGxhcHNlZCsnKSB7XG4gICAgICAgICAgICAgICAgZy5tb3ZlVG8oc3RhcnQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgICAgICBnLmxpbmVUbyhlbmQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGcubW92ZVRvKG1pZCAtIDIsICh0aGlzLmgvMikgLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgZy5saW5lVG8obWlkICsgMiwgdGhpcy5oLzIpO1xuICAgICAgICAgICAgICAgICAgICBnLmxpbmVUbyhtaWQgLSAyLCAodGhpcy5oLzIpICsgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbm5lY3RvciA9PT0gJ2NvbGxhcHNlZC0nKSB7XG4gICAgICAgICAgICAgICAgZy5tb3ZlVG8oc3RhcnQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgICAgICBnLmxpbmVUbyhlbmQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGcubW92ZVRvKG1pZCArIDIsICh0aGlzLmgvMikgLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgZy5saW5lVG8obWlkIC0gMiwgdGhpcy5oLzIpO1xuICAgICAgICAgICAgICAgICAgICBnLmxpbmVUbyhtaWQgKyAyLCAodGhpcy5oLzIpICsgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnLm1vdmVUbyhzdGFydCwgdGhpcy5oLzIpO1xuICAgICAgICAgICAgICAgIGcubGluZVRvKGVuZCwgdGhpcy5oLzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3QgPSBnbDtcbiAgICB9XG59XG5cbkdyb3VwR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnLCBvYykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbHlwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbHlwaHNbaV07XG4gICAgICAgIGdsLmRyYXcoZywgb2MpO1xuICAgIH1cblxuICAgIGcuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5kcmF3Q29ubmVjdG9ycyhnKTtcbiAgICBnLnN0cm9rZSgpO1xufVxuXG5Hcm91cEdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdseXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICBnLmFwcGVuZENoaWxkKHRoaXMuZ2x5cGhzW2ldLnRvU1ZHKCkpO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFNWR1BhdGgoKTtcbiAgICB0aGlzLmRyYXdDb25uZWN0b3JzKHApO1xuXG4gICAgdmFyIHBhdGhEYXRhID0gcC50b1BhdGhEYXRhKCk7XG4gICAgaWYgKHBhdGhEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBhdGggPSBtYWtlRWxlbWVudE5TKFxuICAgICAgICAgICAgTlNfU1ZHLCAncGF0aCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAge2Q6IHAudG9QYXRoRGF0YSgpLFxuICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDAuNX0pO1xuICAgICAgICBnLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBnO1xufVxuXG5Hcm91cEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb3ZlcmFnZS5taW4oKTtcbn1cblxuR3JvdXBHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY292ZXJhZ2UubWF4KCk7XG59XG5cbkdyb3VwR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmg7XG59XG5cblxuZnVuY3Rpb24gTGluZUdyYXBoR2x5cGgocG9pbnRzLCBjb2xvciwgaGVpZ2h0KSB7XG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodCB8fCA1MDtcbn1cblxuTGluZUdyYXBoR2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c1swXS54O1xuICAgIC8vIHJldHVybiB0aGlzLnBvaW50c1swXTtcbn07XG5cbkxpbmVHcmFwaEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV0ueDtcbiAgICAvLyByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMl07XG59O1xuXG5MaW5lR3JhcGhHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn1cblxuTGluZUdyYXBoR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnKSB7XG4gICAgZy5zYXZlKCk7XG4gICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgZy5saW5lV2lkdGggPSAyO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihwLCBpKSB7XG4gICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgZy5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBnLmxpbmVUbyhwLngsIHAueSk7XG4gICAgfSk7XG4gICAgZy5zdHJva2UoKTtcbiAgICBnLnJlc3RvcmUoKTtcbn1cblxuTGluZUdyYXBoR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnBvaW50c1tpXS54O1xuICAgICAgICB2YXIgeSA9IHRoaXMucG9pbnRzW2ldLnk7XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoXG4gICAgICAgIE5TX1NWRywgJ3BhdGgnLFxuICAgICAgICBudWxsLFxuICAgICAgICB7ZDogcC50b1BhdGhEYXRhKCksXG4gICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICBzdHJva2U6IHRoaXMuY29sb3IsXG4gICAgICAgICBzdHJva2VXaWR0aDogJzJweCd9KTtcbn1cblxuZnVuY3Rpb24gTGFiZWxsZWRHbHlwaChHTE9CQUxfR0MsIGdseXBoLCB0ZXh0LCB1bm1lYXN1cmVkLCBhbmNob3IsIGFsaWduLCBmb250KSB7XG4gICAgdGhpcy5nbHlwaCA9IGdseXBoO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3IgfHwgJ2xlZnQnO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbiB8fCAnYmVsb3cnO1xuICAgIGlmIChmb250KSB7XG4gICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgR0xPQkFMX0dDLnNhdmUoKTtcbiAgICAgICAgR0xPQkFMX0dDLmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgfVxuICAgIHZhciBtZXRyaWNzID0gR0xPQkFMX0dDLm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgR0xPQkFMX0dDLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0TGVuID0gbWV0cmljcy53aWR0aDtcbiAgICB0aGlzLnRleHRIZWlnaHQgPSA1O1xuICAgIHRoaXMuYnVtcCA9IGdseXBoLmJ1bXA7XG4gICAgdGhpcy5tZWFzdXJlZCA9ICF1bm1lYXN1cmVkO1xufVxuXG5MYWJlbGxlZEdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuZ2x5cGgudG9TVkcoKTtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIFxuICAgIGlmICh0aGlzLmFsaWduID09ICdhYm92ZScpIHtcbiAgICAgICAgY2hpbGQgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBjaGlsZCwge3RyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMCwgXCIgKyAodGhpcy50ZXh0SGVpZ2h0fDAgKyAyKSArIFwiKVwifSk7XG4gICAgICAgIG9wdHMueSA9IHRoaXMudGV4dEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRzLnkgPSB0aGlzLmdseXBoLmhlaWdodCgpICsgMTU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZm9udCkge1xuICAgICAgICBvcHRzLmZvbnRTaXplICA9IDc7XG4gICAgfVxuXG4gICAgaWYgKCdjZW50ZXInID09IHRoaXMuYW5jaG9yKSB7XG4gICAgICAgIG9wdHMueCA9ICh0aGlzLmdseXBoLm1pbigpICsgdGhpcy5nbHlwaC5tYXgoKSAtIHRoaXMudGV4dExlbikgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMueCA9IHRoaXMuZ2x5cGgubWluKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnZycsXG4gICAgICAgIFtjaGlsZCxcbiAgICAgICAgIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIHRoaXMudGV4dCwgb3B0cyldKTtcbn1cblxuTGFiZWxsZWRHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGgubWluKCk7XG59XG5cbkxhYmVsbGVkR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1lYXN1cmVkKVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nbHlwaC5tYXgoKSwgKDEuMCp0aGlzLmdseXBoLm1pbigpKSArIHRoaXMudGV4dExlbiArIDEwKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLmdseXBoLm1heCgpO1xufVxuXG5MYWJlbGxlZEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuZ2x5cGguaGVpZ2h0KCk7XG4gICAgaWYgKHRoaXMubWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxpZ24gPT0gJ2Fib3ZlJykge1xuICAgICAgICAgICAgaCArPSB0aGlzLnRleHRIZWlnaHQgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCArPSAyMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaDtcbn1cblxuTGFiZWxsZWRHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcsIG9jKSB7XG4gICAgaWYgKHRoaXMuYWxpZ24gPT0gJ2Fib3ZlJykge1xuICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgZy50cmFuc2xhdGUoMCwgdGhpcy50ZXh0SGVpZ2h0ICsgMik7XG4gICAgfVxuICAgIHRoaXMuZ2x5cGguZHJhdyhnKTtcbiAgICBpZiAodGhpcy5hbGlnbiA9PSAnYWJvdmUnKSB7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIG9jLnJlZ2lzdGVyR2x5cGgodGhpcyk7XG59XG5cbkxhYmVsbGVkR2x5cGgucHJvdG90eXBlLmRyYXdPdmVybGF5ID0gZnVuY3Rpb24oZywgbWluVmlzaWJsZSwgbWF4VmlzaWJsZSkge1xuICAgIGcuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICBpZiAodGhpcy5mb250KSB7XG4gICAgICAgIGcuc2F2ZSgpO1xuICAgICAgICBnLmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgfVxuICAgIHZhciBwO1xuICAgIGlmICgnY2VudGVyJyA9PSB0aGlzLmFuY2hvcikge1xuICAgICAgICBwID0gKHRoaXMuZ2x5cGgubWluKCkgKyB0aGlzLmdseXBoLm1heCgpIC0gdGhpcy50ZXh0TGVuKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IHRoaXMuZ2x5cGgubWluKCk7XG4gICAgICAgIGlmIChwIDwgbWluVmlzaWJsZSkge1xuICAgICAgICAgICAgcCA9IE1hdGgubWluKG1pblZpc2libGUsIHRoaXMuZ2x5cGgubWF4KCkgLSB0aGlzLnRleHRMZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGcuZmlsbFRleHQodGhpcy50ZXh0LCBwLCB0aGlzLmFsaWduID09ICdhYm92ZScgPyB0aGlzLnRleHRIZWlnaHQgOiB0aGlzLmdseXBoLmhlaWdodCgpICsgMTUpO1xuICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgZy5yZXN0b3JlKCk7XG4gICAgfVxufVxuXG5cblxuZnVuY3Rpb24gQ3Jvc3NHbHlwaCh4LCBoZWlnaHQsIHN0cm9rZSkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG59XG5cbkNyb3NzR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGVpZ2h0LzI7XG4gICAgXG4gICAgZy5iZWdpblBhdGgoKTtcbiAgICBnLm1vdmVUbyh0aGlzLl94LCAwKTtcbiAgICBnLmxpbmVUbyh0aGlzLl94LCB0aGlzLl9oZWlnaHQpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgaGgpO1xuICAgIGcubGluZVRvKHRoaXMuX3ggKyBoaCwgaGgpO1xuXG4gICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZTtcbiAgICBnLmxpbmVXaWR0aCA9IDE7XG5cbiAgICBnLnN0cm9rZSgpO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaCA9IHRoaXMuX2hlaWdodC8yO1xuXG4gICAgdmFyIGcgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIGcubW92ZVRvKHRoaXMuX3gsIDApO1xuICAgIGcubGluZVRvKHRoaXMuX3gsIHRoaXMuX2hlaWdodCk7XG4gICAgZy5tb3ZlVG8odGhpcy5feCAtIGhoLCBoaCk7XG4gICAgZy5saW5lVG8odGhpcy5feCArIGhoLCBoaCk7XG4gICAgXG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoXG4gICAgICAgIE5TX1NWRywgJ3BhdGgnLFxuICAgICAgICBudWxsLFxuICAgICAgICB7ZDogZy50b1BhdGhEYXRhKCksXG4gICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICBzdHJva2U6IHRoaXMuX3N0cm9rZSxcbiAgICAgICAgIHN0cm9rZVdpZHRoOiAnMXB4J30pO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX2hlaWdodC8yO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCArIHRoaXMuX2hlaWdodC8yO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBFeEdseXBoKHgsIGhlaWdodCwgc3Ryb2tlKSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgaGggPSB0aGlzLl9oZWlnaHQvMjtcbiAgICBcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgMCk7XG4gICAgZy5saW5lVG8odGhpcy5feCArIGhoLCB0aGlzLl9oZWlnaHQpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgdGhpcy5faGVpZ2h0KTtcbiAgICBnLmxpbmVUbyh0aGlzLl94ICsgaGgsIDApO1xuXG4gICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZTtcbiAgICBnLmxpbmVXaWR0aCA9IDE7XG5cbiAgICBnLnN0cm9rZSgpO1xufVxuXG5FeEdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaCA9IHRoaXMuX2hlaWdodC8yO1xuXG4gICAgdmFyIGcgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgMCk7XG4gICAgZy5saW5lVG8odGhpcy5feCArIGhoLCB0aGlzLl9oZWlnaHQpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgdGhpcy5faGVpZ2h0KTtcbiAgICBnLmxpbmVUbyh0aGlzLl94ICsgaGgsIDApO1xuICAgIFxuICAgIHJldHVybiBtYWtlRWxlbWVudE5TKFxuICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAge2Q6IGcudG9QYXRoRGF0YSgpLFxuICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UsXG4gICAgICAgICBzdHJva2VXaWR0aDogJzFweCd9KTtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggLSB0aGlzLl9oZWlnaHQvMjtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKyB0aGlzLl9oZWlnaHQvMjtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn1cblxuXG5cbmZ1bmN0aW9uIFRyaWFuZ2xlR2x5cGgoeCwgaGVpZ2h0LCBkaXIsIHdpZHRoLCBmaWxsLCBzdHJva2UpIHtcbiAgICBQYXRoR2x5cGhCYXNlLmNhbGwodGhpcywgc3Ryb2tlLCBmaWxsKTtcblxuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9kaXIgPSBkaXI7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbn1cblxuVHJpYW5nbGVHbHlwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhdGhHbHlwaEJhc2UucHJvdG90eXBlKTtcblxuVHJpYW5nbGVHbHlwaC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGVpZ2h0LzI7XG4gICAgdmFyIGh3ID0gdGhpcy5fd2lkdGgvMjtcblxuICAgIGlmICh0aGlzLl9kaXIgPT09ICdTJykge1xuICAgICAgICBnLm1vdmVUbyh0aGlzLl94LCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94IC0gaHcsIDApO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlyID09PSAnVycpIHtcbiAgICAgICAgZy5tb3ZlVG8odGhpcy5feCArIGh3LCBoaCk7XG4gICAgICAgIGcubGluZVRvKHRoaXMuX3ggLSBodywgMCk7XG4gICAgICAgIGcubGluZVRvKHRoaXMuX3ggLSBodywgdGhpcy5faGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RpciA9PT0gJ0UnKSB7XG4gICAgICAgIGcubW92ZVRvKHRoaXMuX3ggLSBodywgaGgpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIDApO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIHRoaXMuX2hlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZy5tb3ZlVG8odGhpcy5feCAsIDApO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIGcubGluZVRvKHRoaXMuX3ggLSBodywgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG5cbiAgICBnLmNsb3NlUGF0aCgpO1xufVxuXG5UcmlhbmdsZUdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX2hlaWdodC8yO1xufVxuXG5UcmlhbmdsZUdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCArIHRoaXMuX2hlaWdodC8yO1xufVxuXG5UcmlhbmdsZUdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5cblxuXG5mdW5jdGlvbiBEb3RHbHlwaCh4LCBoZWlnaHQsIGZpbGwsIHN0cm9rZSkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG59XG5cbkRvdEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBoaCA9IHRoaXMuX2hlaWdodC8yO1xuICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgZy5hcmModGhpcy5feCwgaGgsIGhoLCAwLCA2LjI5KTtcblxuICAgIGlmICh0aGlzLl9maWxsKSB7XG4gICAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fZmlsbDtcbiAgICAgICAgZy5maWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0cm9rZSkge1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbn1cblxuRG90R2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGVpZ2h0LzI7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoXG4gICAgICAgIE5TX1NWRywgJ2NpcmNsZScsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHtjeDogdGhpcy5feCwgY3k6IGhoLCByOiBoaCxcbiAgICAgICAgIGZpbGw6IHRoaXMuX2ZpbGwgfHwgJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UgfHwgJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxcHgnfSk7XG59XG5cbkRvdEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX2hlaWdodC8yO1xufVxuXG5Eb3RHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKyB0aGlzLl9oZWlnaHQvMjtcbn1cblxuRG90R2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59XG5cblxuZnVuY3Rpb24gUGFkZGVkR2x5cGgoZ2x5cGgsIG1pbnAsIG1heHApIHtcbiAgICB0aGlzLmdseXBoID0gZ2x5cGg7XG4gICAgdGhpcy5fbWluID0gbWlucDtcbiAgICB0aGlzLl9tYXggPSBtYXhwO1xuICAgIGlmIChnbHlwaCkge1xuICAgICAgICB0aGlzLmJ1bXAgPSBnbHlwaC5idW1wO1xuICAgIH1cbn1cblxuUGFkZGVkR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnLCBvYykge1xuICAgIGlmICh0aGlzLmdseXBoKSBcbiAgICAgICAgdGhpcy5nbHlwaC5kcmF3KGcsIG9jKTtcbn1cblxuUGFkZGVkR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ2x5cGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2x5cGgudG9TVkcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJyk7XG4gICAgfVxufVxuXG5QYWRkZWRHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbjtcbn1cblxuUGFkZGVkR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXg7XG59XG5cblBhZGRlZEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5nbHlwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaC5oZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gQUFycm93R2x5cGgobWluLCBtYXgsIGhlaWdodCwgZmlsbCwgc3Ryb2tlLCBvcmkpIHtcbiAgICBQYXRoR2x5cGhCYXNlLmNhbGwodGhpcywgc3Ryb2tlLCBmaWxsKTtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcmkgPSBvcmk7XG59XG5cbkFBcnJvd0dseXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGF0aEdseXBoQmFzZS5wcm90b3R5cGUpO1xuXG5BQXJyb3dHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbjtcbn1cblxuQUFycm93R2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXg7XG59XG5cbkFBcnJvd0dseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5BQXJyb3dHbHlwaC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIG1heFBvcyA9IHRoaXMuX21heDtcbiAgICB2YXIgbWluUG9zID0gdGhpcy5fbWluO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgdmFyIGxJbnNldCA9IDA7XG4gICAgdmFyIHJJbnNldCA9IDA7XG4gICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMuX2hlaWdodCArIDI7XG4gICAgdmFyIGluc3RlcCA9IDAuMzMzMzMzICogdGhpcy5faGVpZ2h0O1xuICAgIHZhciB5ID0gMDtcblxuICAgIGlmICh0aGlzLl9vcmkpIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaSA9PT0gJysnKSB7XG4gICAgICAgICAgICBySW5zZXQgPSAwLjUgKiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fb3JpID09PSAnLScpIHtcbiAgICAgICAgICAgIGxJbnNldCA9IDAuNSAqIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhQb3MgLSBtaW5Qb3MgPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgbWluUG9zID0gKG1heFBvcyArIG1pblBvcyAtIG1pbkxlbmd0aCkgLyAyO1xuICAgICAgICBtYXhQb3MgPSBtaW5Qb3MgKyBtaW5MZW5ndGg7XG4gICAgfVxuXG4gICAgZy5tb3ZlVG8obWluUG9zICsgbEluc2V0LCB5K2luc3RlcCk7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5K2luc3RlcCk7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5KTtcbiAgICBnLmxpbmVUbyhtYXhQb3MsIHkgKyB0aGlzLl9oZWlnaHQvMik7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5K2hlaWdodCk7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5K2luc3RlcCtpbnN0ZXApO1xuICAgIGcubGluZVRvKG1pblBvcyArIGxJbnNldCwgeStpbnN0ZXAraW5zdGVwKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MgKyBsSW5zZXQsIHkraGVpZ2h0KTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MsIHkraGVpZ2h0LzIpO1xuICAgIGcubGluZVRvKG1pblBvcyArIGxJbnNldCwgeSk7XG4gICAgZy5saW5lVG8obWluUG9zICsgbEluc2V0LCB5K2luc3RlcCk7XG59XG5cbmZ1bmN0aW9uIFNwYW5HbHlwaChtaW4sIG1heCwgaGVpZ2h0LCBzdHJva2UpIHtcbiAgICBQYXRoR2x5cGhCYXNlLmNhbGwodGhpcywgc3Ryb2tlLCBudWxsKTtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbn1cblxuU3BhbkdseXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGF0aEdseXBoQmFzZS5wcm90b3R5cGUpO1xuXG5TcGFuR2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9taW59O1xuU3BhbkdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWF4fTtcblNwYW5HbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX2hlaWdodH07XG5cblNwYW5HbHlwaC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIG1pblBvcyA9IHRoaXMuX21pbiwgbWF4UG9zID0gdGhpcy5fbWF4O1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQsIGhoID0gaGVpZ2h0LzI7XG4gICAgZy5tb3ZlVG8obWluUG9zLCBoaCk7XG4gICAgZy5saW5lVG8obWF4UG9zLCBoaCk7XG4gICAgZy5tb3ZlVG8obWluUG9zLCAwKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MsIGhlaWdodCk7XG4gICAgZy5tb3ZlVG8obWF4UG9zLCAwKTtcbiAgICBnLmxpbmVUbyhtYXhQb3MsIGhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIExpbmVHbHlwaChtaW4sIG1heCwgaGVpZ2h0LCBzdHlsZSwgc3RyYW5kLCBzdHJva2UpIHtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuX3N0cmFuZCA9IHN0cmFuZDtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG59XG5cbkxpbmVHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX21pbn07XG5MaW5lR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9tYXh9O1xuTGluZUdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5faGVpZ2h0fTtcblxuTGluZUdseXBoLnByb3RvdHlwZS5kcmF3UGF0aCA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgbWluUG9zID0gdGhpcy5fbWluLCBtYXhQb3MgPSB0aGlzLl9tYXg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodCwgaGggPSBoZWlnaHQvMjtcblxuICAgIGlmICh0aGlzLl9zdHlsZSA9PT0gJ2hhdCcpIHtcbiAgICAgICAgZy5tb3ZlVG8obWluUG9zLCBoaCk7XG4gICAgICAgIGcubGluZVRvKChtaW5Qb3MgKyBtYXhQb3MpLzIsIHRoaXMuX3N0cmFuZCA9PT0gJy0nID8gaGVpZ2h0IDogMCk7XG4gICAgICAgIGcubGluZVRvKG1heFBvcywgaGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGcubW92ZVRvKG1pblBvcywgaGgpO1xuICAgICAgICBnLmxpbmVUbyhtYXhQb3MsIGhoKTtcbiAgICB9XG59XG5cblxuTGluZUdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5kcmF3UGF0aChnKTtcbiAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgIGlmICh0aGlzLl9zdHlsZSA9PT0gJ2Rhc2hlZCcgJiYgZy5zZXRMaW5lRGFzaCkge1xuICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgZy5zZXRMaW5lRGFzaChbM10pO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbn1cblxuTGluZUdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnID0gbmV3IFNWR1BhdGgoKTtcbiAgICB0aGlzLmRyYXdQYXRoKGcpO1xuICAgIFxuICAgIHZhciBvcHRzID0ge2Q6IGcudG9QYXRoRGF0YSgpLFxuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UgfHwgJ25vbmUnfTtcbiAgICBpZiAodGhpcy5fc3R5bGUgPT09ICdkYXNoZWQnKSB7XG4gICAgICAgIG9wdHNbJ3N0cm9rZURhc2hhcnJheSddID0gJzMnO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlRWxlbWVudE5TKFxuICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgbnVsbCwgb3B0c1xuICAgICk7XG59XG5cblxuXG5cblxuZnVuY3Rpb24gUHJpbWVyc0dseXBoKG1pbiwgbWF4LCBoZWlnaHQsIGZpbGwsIHN0cm9rZSkge1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX2ZpbGwgPSBmaWxsO1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbn1cblxuUHJpbWVyc0dseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcblByaW1lcnNHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX21heH07XG5QcmltZXJzR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9oZWlnaHR9O1xuXG5cblByaW1lcnNHbHlwaC5wcm90b3R5cGUuZHJhd1N0ZW1QYXRoID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBtaW5Qb3MgPSB0aGlzLl9taW4sIG1heFBvcyA9IHRoaXMuX21heDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0LCBoaCA9IGhlaWdodC8yO1xuICAgIGcubW92ZVRvKG1pblBvcywgaGgpO1xuICAgIGcubGluZVRvKG1heFBvcywgaGgpO1xufVxuXG5QcmltZXJzR2x5cGgucHJvdG90eXBlLmRyYXdUcmlnc1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIG1pblBvcyA9IHRoaXMuX21pbiwgbWF4UG9zID0gdGhpcy5fbWF4O1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQsIGhoID0gaGVpZ2h0LzI7XG4gICAgZy5tb3ZlVG8obWluUG9zLCAwKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MgKyBoZWlnaHQsIGhoKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MsIGhlaWdodCk7XG4gICAgZy5saW5lVG8obWluUG9zLCAwKTtcbiAgICBnLm1vdmVUbyhtYXhQb3MsIDApO1xuICAgIGcubGluZVRvKG1heFBvcyAtIGhlaWdodCwgaGgpO1xuICAgIGcubGluZVRvKG1heFBvcywgaGVpZ2h0KTtcbiAgICBnLmxpbmVUbyhtYXhQb3MsIDApO1xufVxuXG5cblByaW1lcnNHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuZHJhd1N0ZW1QYXRoKGcpO1xuICAgIGcuc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2U7XG4gICAgZy5zdHJva2UoKTtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuZHJhd1RyaWdzUGF0aChnKTtcbiAgICBnLmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGw7XG4gICAgZy5maWxsKCk7XG59XG5cblByaW1lcnNHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9IG5ldyBTVkdQYXRoKCk7XG4gICAgdGhpcy5kcmF3U3RlbVBhdGgocyk7XG4gICAgdmFyIHQgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIHRoaXMuZHJhd1RyaWdzUGF0aCh0KTtcbiAgICBcbiAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhcbiAgICAgICAgTlNfU1ZHLCAnZycsXG4gICAgICAgIFttYWtlRWxlbWVudE5TKFxuICAgICAgICAgICAgTlNfU1ZHLCAncGF0aCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAge2Q6IHMudG9QYXRoRGF0YSgpLFxuICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlIHx8ICdub25lJ30pLFxuICAgICAgICAgbWFrZUVsZW1lbnROUyhcbiAgICAgICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgIHtkOiB0LnRvUGF0aERhdGEoKSxcbiAgICAgICAgICAgICAgZmlsbDogdGhpcy5fZmlsbCB8fCAnbm9uZSd9KV0pO1xufVxuXG5mdW5jdGlvbiBBcnJvd0dseXBoKG1pbiwgbWF4LCBoZWlnaHQsIGNvbG9yLCBwYXJhbGxlbCwgc3csIG5lKSB7XG4gICAgUGF0aEdseXBoQmFzZS5jYWxsKHRoaXMsIG51bGwsIGNvbG9yKTtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuX3BhcmFsbGVsID0gcGFyYWxsZWw7XG4gICAgdGhpcy5fc3cgPSBzdztcbiAgICB0aGlzLl9uZSA9IG5lO1xufVxuXG5BcnJvd0dseXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGF0aEdseXBoQmFzZS5wcm90b3R5cGUpO1xuXG5BcnJvd0dseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcbkFycm93R2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9tYXh9O1xuQXJyb3dHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX2hlaWdodH07XG5cbkFycm93R2x5cGgucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBtaW4gPSB0aGlzLl9taW4sIG1heCA9IHRoaXMuX21heCwgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIFxuICAgIGlmICh0aGlzLl9wYXJhbGxlbCkge1xuICAgICAgICB2YXIgaGggPSBoZWlnaHQvMjtcbiAgICAgICAgdmFyIGluc3RlcCA9IDAuNCAqIGhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuX3N3KSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4gKyBoaCwgaGVpZ2h0LWluc3RlcCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtaW4gKyBoaCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGcubGluZVRvKG1pbiwgaGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWluICsgaGgsIDApO1xuICAgICAgICAgICAgZy5saW5lVG8obWluICsgaGgsIGluc3RlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4sIGhlaWdodC1pbnN0ZXApO1xuICAgICAgICAgICAgZy5saW5lVG8obWluLCBpbnN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uZSkge1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaGgsIGluc3RlcCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXggLSBoaCwgMCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXgsIGhoKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1heCAtIGhoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaGgsIGhlaWdodCAtIGluc3RlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXgsIGluc3RlcCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXgsIGhlaWdodC1pbnN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pZCA9IChtaW4rbWF4KS8yO1xuICAgICAgICB2YXIgaW5zdGVwID0gMC40KihtYXgtbWluKTtcbiAgICAgICAgdmFyIHRoID0gaGVpZ2h0LzM7XG5cbiAgICAgICAgaWYgKHRoaXMuX25lKSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4gKyBpbnN0ZXAsIHRoKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1pbiwgdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWlkLCAwKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1heCwgdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaW5zdGVwLCB0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4raW5zdGVwLCAwKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1heC1pbnN0ZXAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdykge1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaW5zdGVwLCBoZWlnaHQtdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWF4LCBoZWlnaHQtdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWlkLCBoZWlnaHQpO1xuICAgICAgICAgICAgZy5saW5lVG8obWluLCBoZWlnaHQtdGgpXG4gICAgICAgICAgICBnLmxpbmVUbyhtaW4gKyBpbnN0ZXAsIGhlaWdodC10aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXggLSBpbnN0ZXAsIGhlaWdodCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtaW4gKyBpbnN0ZXAsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZy5jbG9zZVBhdGgoKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gVG9vTWFueUdseXBoKG1pbiwgbWF4LCBoZWlnaHQsIGZpbGwsIHN0cm9rZSkge1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX2ZpbGwgPSBmaWxsO1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbn1cblxuVG9vTWFueUdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcblRvb01hbnlHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX21heH07XG5Ub29NYW55R2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9oZWlnaHR9O1xuXG5Ub29NYW55R2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAncmVjdCcsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAge3g6IHRoaXMuX21pbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fbWF4IC0gdGhpcy5fbWluLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlIHx8ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5fZmlsbCB8fCAnbm9uZSd9KTtcbn1cblxuVG9vTWFueUdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIGlmICh0aGlzLl9maWxsKSB7XG4gICAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fZmlsbDtcbiAgICAgICAgZy5maWxsUmVjdCh0aGlzLl9taW4sIDAsIHRoaXMuX21heCAtIHRoaXMuX21pbiwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0cm9rZSkge1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICBnLnN0cm9rZVJlY3QodGhpcy5fbWluLCAwLCB0aGlzLl9tYXggLSB0aGlzLl9taW4sIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAodmFyIG4gPSAyOyBuIDwgdGhpcy5faGVpZ2h0OyBuICs9IDMpIHtcbiAgICAgICAgICAgIGcubW92ZVRvKHRoaXMuX21pbiwgbik7XG4gICAgICAgICAgICBnLmxpbmVUbyh0aGlzLl9tYXgsIG4pO1xuICAgICAgICB9XG4gICAgICAgIGcuc3Ryb2tlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBUZXh0R2x5cGgoR0xPQkFMX0dDLCBtaW4sIG1heCwgaGVpZ2h0LCBmaWxsLCBzdHJpbmcpIHtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbiAgICB0aGlzLl9zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5fdGV4dExlbiA9IEdMT0JBTF9HQy5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xufVxuXG5UZXh0R2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9taW59O1xuVGV4dEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtyZXR1cm4gTWF0aC5tYXgodGhpcy5fbWF4LCB0aGlzLl9taW4gKyB0aGlzLl90ZXh0TGVuKX07XG5UZXh0R2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9oZWlnaHR9O1xuXG5UZXh0R2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnKSB7XG4gICAgZy5maWxsU3R5bGUgPSB0aGlzLl9maWxsO1xuICAgIGcuZmlsbFRleHQodGhpcy5fc3RyaW5nLCB0aGlzLl9taW4sIHRoaXMuX2hlaWdodCAtIDQpO1xufVxuXG5UZXh0R2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIHRoaXMuX3N0cmluZywge3g6IHRoaXMuX21pbiwgeTogdGhpcy5faGVpZ2h0IC0gNH0pO1xufTtcblxuZnVuY3Rpb24gYW1pbm9UaWxlQ29sb3IoYWEsIHN0YXJ0LCBjb2xvcikge1xuICAgIHZhciBBTFRFUk5BVEVfQ09MT1IgPSB7XG4gICAgICAgICdyZWQnOiAnZGFya3JlZCcsXG4gICAgICAgICdwdXJwbGUnOiAnbWVkaXVtcHVycGxlJyxcbiAgICAgICAgJ2JsdWUnOiAnZGFya2JsdWUnLFxuICAgICAgICAnZ3JlZW4nOiAnZGFya2dyZWVuJ1xuICAgIH07XG4gICAgdmFyIGNvbG9yMiA9IEFMVEVSTkFURV9DT0xPUltjb2xvci50b0xvd2VyQ2FzZSgpXTtcbiAgICB2YXIgdGlsZUNvbG9ycztcbiAgICBpZiAoIWNvbG9yMilcbiAgICAgICAgdGlsZUNvbG9ycyA9IFsncmdiKDczLCA2OCwgMTQ5KScsICdyZ2IoOSwgMCwgMTAzKSddO1xuICAgICAgICAvLyBkZWZhdWx0IHRvIFVDU0MgY29sb3JzXG4gICAgZWxzZVxuICAgICAgICB0aWxlQ29sb3JzID0gW2NvbG9yLCBjb2xvcjJdO1xuXG4gICAgaWYgKGFhID09ICc/JylcbiAgICAgICAgcmV0dXJuICdibGFjayc7XG4gICAgZWxzZSBpZiAoYWEgPT0gJ00nKVxuICAgICAgICByZXR1cm4gJ2dyZWVueWVsbG93JztcbiAgICBlbHNlIGlmIChhYSA9PSAnKicpXG4gICAgICAgIHJldHVybiAnY3JpbXNvbic7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGlsZUNvbG9yc1tzdGFydCAlIDJdO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlQ29tcGxlbWVudChzZXF1ZW5jZSkge1xuICAgIHZhciBzZXFfZGljdCA9IHsnQSc6ICdUJywgJ1QnOiAnQScsICdHJzogJ0MnLCAnQyc6ICdHJ307XG4gICAgdmFyIHJldl9zZXEgPSBzZXF1ZW5jZS5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIHZhciByZXZfY29tcGxfc2VxID0gW107XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCByZXZfc2VxLmxlbmd0aDsgKytiKSB7XG4gICAgICAgIHZhciBiYXNlID0gcmV2X3NlcS5zdWJzdHIoYiwgMSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmV2X2NvbXBsX3NlcS5wdXNoKGJhc2UgaW4gc2VxX2RpY3QgPyBzZXFfZGljdFtiYXNlXSA6ICdOJyk7XG4gICAgfVxuICAgIHJldHVybiByZXZfY29tcGxfc2VxLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBBbWlub0FjaWRHbHlwaChtaW4sIG1heCwgaGVpZ2h0LCBmaWxsLCBzZXEsIG9yaWVudGF0aW9uLCByZWFkZnJhbWUpIHtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbiAgICB0aGlzLl9zZXEgPSBzZXE7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLl9yZWFkZnJhbWUgPSByZWFkZnJhbWU7XG59XG5cbkFtaW5vQWNpZEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcbkFtaW5vQWNpZEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWF4fTtcbkFtaW5vQWNpZEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5faGVpZ2h0fTtcblxuQW1pbm9BY2lkR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnYykge1xuICAgIHZhciBzZXEgPSB0aGlzLl9zZXE7XG4gICAgdmFyIGNvbG9yID0gdGhpcy5fZmlsbDtcblxuICAgIGlmICghc2VxKSByZXR1cm47XG5cbiAgICB2YXIgc2NhbGUgPSAodGhpcy5fbWF4IC0gdGhpcy5fbWluICsgMSkgLyBzZXEubGVuZ3RoO1xuXG4gICAgdmFyIHByZXZPdmVyaGFuZyA9ICgzIC0gdGhpcy5fcmVhZGZyYW1lKSAlIDM7XG4gICAgdmFyIG5leHRPdmVyaGFuZyA9IChzZXEubGVuZ3RoIC0gcHJldk92ZXJoYW5nKSAlIDM7XG4gICAgdmFyIGxlZnRPdmVyaGFuZyA9IHRoaXMuX29yaWVudGF0aW9uID09ICcrJyA/IHByZXZPdmVyaGFuZyA6IG5leHRPdmVyaGFuZztcbiAgICBcbiAgICBpZiAobGVmdE92ZXJoYW5nID4gMCkge1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluLCAwLCBzY2FsZSAqIGxlZnRPdmVyaGFuZywgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwID0gbGVmdE92ZXJoYW5nOyBwIDwgc2VxLmxlbmd0aDsgcCArPSAzKSB7XG4gICAgICAgIHZhciBjb2RvbiA9IHNlcS5zdWJzdHIocCwgMykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09ICctJylcbiAgICAgICAgICAgIGNvZG9uID0gcmV2ZXJzZUNvbXBsZW1lbnQoY29kb24pO1xuICAgICAgICB2YXIgYWEgPSBjb2RvbiBpbiBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OID8gQU1JTk9fQUNJRF9UUkFOU0xBVElPTltjb2Rvbl0gOiAnPyc7XG4gICAgICAgIGNvbG9yID0gY29kb24ubGVuZ3RoID09IDMgPyBhbWlub1RpbGVDb2xvcihhYSwgcCwgdGhpcy5fZmlsbCkgOiB0aGlzLl9maWxsO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluICsgcCAqIHNjYWxlLCAwLCBzY2FsZSAqIGNvZG9uLmxlbmd0aCwgdGhpcy5faGVpZ2h0KTtcblxuICAgICAgICBpZiAoc2NhbGUgPj0gOCAmJiBjb2Rvbi5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KGFhLCB0aGlzLl9taW4gKyAocCsxKSAqIHNjYWxlLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9IFxuICAgIH1cbn1cblxuQW1pbm9BY2lkR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGcgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnKTtcbiAgICB2YXIgc2VxID0gdGhpcy5fc2VxO1xuICAgIHZhciBjb2xvciA9IHRoaXMuX2ZpbGw7XG5cbiAgICBpZiAoIXNlcSlcbiAgICAgICAgcmV0dXJuIGc7XG5cbiAgICB2YXIgc2NhbGUgPSAodGhpcy5fbWF4IC0gdGhpcy5fbWluICsgMSkgLyBzZXEubGVuZ3RoO1xuXG4gICAgdmFyIHByZXZPdmVyaGFuZyA9ICgzIC0gdGhpcy5fcmVhZGZyYW1lKSAlIDM7XG4gICAgdmFyIG5leHRPdmVyaGFuZyA9IChzZXEubGVuZ3RoIC0gcHJldk92ZXJoYW5nKSAlIDM7XG4gICAgdmFyIGxlZnRPdmVyaGFuZyA9IHRoaXMuX29yaWVudGF0aW9uID09ICcrJyA/IHByZXZPdmVyaGFuZyA6IG5leHRPdmVyaGFuZztcblxuICAgIGlmIChsZWZ0T3ZlcmhhbmcgPiAwKSB7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3JlY3QnLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5fbWluLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNjYWxlICogbGVmdE92ZXJoYW5nLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yfSkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBwID0gbGVmdE92ZXJoYW5nOyBwIDwgc2VxLmxlbmd0aDsgcCArPSAzKSB7XG4gICAgICAgIHZhciBjb2RvbiA9IHNlcS5zdWJzdHIocCwgMykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09ICctJylcbiAgICAgICAgICAgIGNvZG9uID0gcmV2ZXJzZUNvbXBsZW1lbnQoY29kb24pO1xuICAgICAgICB2YXIgYWEgPSBjb2RvbiBpbiBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OID8gQU1JTk9fQUNJRF9UUkFOU0xBVElPTltjb2Rvbl0gOiAnPyc7XG4gICAgICAgIGNvbG9yID0gY29kb24ubGVuZ3RoID09IDMgPyBhbWlub1RpbGVDb2xvcihhYSwgcCwgdGhpcy5fZmlsbCkgOiB0aGlzLl9maWxsO1xuICAgICAgICBnLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgbWFrZUVsZW1lbnROUyhOU19TVkcsICdyZWN0JywgbnVsbCwge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuX21pbiArIHAgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzY2FsZSAqIGNvZG9uLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcn0pKTtcblxuICAgICAgICBpZiAoc2NhbGUgPj0gOCAmJiBjb2Rvbi5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3RleHQnLCBhYSwge1xuICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLl9taW4gKyAocCsxKSAqIHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZSd9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGc7XG59O1xuXG52YXIgaXNSZXRpbmEgPSB0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxO1xudmFyIF9fZGFsbGlhbmNlX1NlcXVlbmNlR2x5cGhDYWNoZSA9IHt9O1xudmFyIGFsdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCdeW0FDR1QtXSQnKTtcbnZhciBpc0Nsb3NlVXAgPSBmdW5jdGlvbihzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSA+PSA4O1xufVxuXG5mdW5jdGlvbiBTZXF1ZW5jZUdseXBoKGJhc2VDb2xvcnMsIHN0cmFuZENvbG9yLCBtaW4sIG1heCwgaGVpZ2h0LCBzZXEsIHJlZiwgc2NoZW1lLCBxdWFscywgZmlsbGJnLCBzY2FsZVZlcnRpY2FsKSB7XG4gICAgdGhpcy5iYXNlQ29sb3JzID0gYmFzZUNvbG9ycztcbiAgICB0aGlzLl9zdHJhbmRDb2xvciA9IHN0cmFuZENvbG9yO1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3NlcSA9IHNlcTtcbiAgICB0aGlzLl9yZWYgPSByZWY7XG4gICAgdGhpcy5fc2NoZW1lID0gc2NoZW1lO1xuICAgIHRoaXMuX3F1YWxzID0gcXVhbHM7XG4gICAgdGhpcy5fZmlsbGJnID0gZmlsbGJnO1xuICAgIHRoaXMuX3NjYWxlVmVydGljYWwgPSBzY2FsZVZlcnRpY2FsO1xufVxuXG5TZXF1ZW5jZUdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcblNlcXVlbmNlR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9tYXh9O1xuU2VxdWVuY2VHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX2hlaWdodH07XG5cblxuU2VxdWVuY2VHbHlwaC5wcm90b3R5cGUuYWxwaGFGb3JRdWFsID0gZnVuY3Rpb24ocXVhbCkge1xuICAgIHJldHVybiAwLjEgKyAwLjkqTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigoMS4wICogcXVhbCkgLyAzMC4wLCAxLjApKTtcbn1cblxuU2VxdWVuY2VHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdjKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3NlcTtcbiAgICB2YXIgcmVmID0gdGhpcy5fcmVmO1xuICAgIHZhciBtaXNtYXRjaCA9IHRoaXMuX3NjaGVtZSA9PT0gJ21pc21hdGNoJyB8fCB0aGlzLl9zY2hlbWUgPT09ICdtaXNtYXRjaC1hbGwnO1xuICAgIHZhciBhbGwgPSB0aGlzLl9zY2hlbWUgPT09ICdtaXNtYXRjaC1hbGwnO1xuICAgIFxuICAgIHZhciBzZXFMZW5ndGggPSBzZXEgPyBzZXEubGVuZ3RoIDogKHRoaXMuX21heCAtIHRoaXMuX21pbiArIDEpO1xuICAgIHZhciBzY2FsZSA9ICh0aGlzLl9tYXggLSB0aGlzLl9taW4gKyAxKSAvIHNlcUxlbmd0aDtcblxuICAgIGlmIChtaXNtYXRjaCAmJiAhaXNDbG9zZVVwKHNjYWxlKSkge1xuICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLl9zdHJhbmRDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlVmVydGljYWwpXG4gICAgICAgICAgICBnYy5maWxsUmVjdCh0aGlzLl9taW4sIHNjYWxlLCB0aGlzLl9tYXggLSB0aGlzLl9taW4sIHNjYWxlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluLCB0aGlzLl9oZWlnaHQvNCwgdGhpcy5fbWF4IC0gdGhpcy5fbWluLCB0aGlzLl9oZWlnaHQvMik7XG4gICAgfVxuXG4gICAgXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBzZXFMZW5ndGg7ICsrcCkge1xuICAgICAgICB2YXIgYmFzZSA9IHNlcSA/IHNlcS5zdWJzdHIocCwgMSkudG9VcHBlckNhc2UoKSA6ICdOJztcbiAgICAgICAgXG4gICAgICAgIGlmICghYWx0UGF0dGVybi50ZXN0KGJhc2UpICYmICFpc0Nsb3NlVXAoc2NhbGUpKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5iYXNlQ29sb3JzW2Jhc2VdO1xuXG4gICAgICAgIGlmICh0aGlzLl9xdWFscykge1xuICAgICAgICAgICAgdmFyIHFjID0gdGhpcy5fcXVhbHMuY2hhckNvZGVBdChwKSAtIDMzO1xuICAgICAgICAgICAgdmFyIG9sZEFscGhhID0gZ2MuZ2xvYmFsQWxwaGE7ICAgICAgICAgICAgLy8gTkIgaG9pc3RlZCFcbiAgICAgICAgICAgIGdjLmdsb2JhbEFscGhhID0gdGhpcy5hbHBoYUZvclF1YWwocWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgdmFyIHJlZkJhc2UgPSByZWYgPyByZWYuc3Vic3RyKHAsIDEpLnRvVXBwZXJDYXNlKCkgOiAnTic7XG4gICAgICAgICAgICBpZiAoYmFzZSA9PSAnTicgfHwgcmVmQmFzZSA9PSAnTicpXG4gICAgICAgICAgICAgICAgY29sb3IgPSAnZ3JheSc7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLl9zdHJhbmRDb2xvcjtcblxuICAgICAgICAgICAgaWYgKGFsbClcbiAgICAgICAgICAgICAgICBiYXNlID0gcmVmQmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIHZhciBhbHQgPSBhbHRQYXR0ZXJuLnRlc3QoYmFzZSk7XG4gICAgICAgIGlmICh0aGlzLl9maWxsYmcgfHwgIWlzQ2xvc2VVcChzY2FsZSkgfHwgIWFsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NjYWxlVmVydGljYWwpXG4gICAgICAgICAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluICsgcCpzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluICsgcCpzY2FsZSwgMCwgc2NhbGUsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2xvc2VVcChzY2FsZSkgJiYgYWx0KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY29sb3IgKyAnXycgKyBiYXNlXG4gICAgICAgICAgICB2YXIgaW1nID0gX19kYWxsaWFuY2VfU2VxdWVuY2VHbHlwaENhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JldGluYSkge1xuICAgICAgICAgICAgICAgICAgICBpbWcud2lkdGggPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgaW1nLmhlaWdodCA9IDIwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltZy53aWR0aCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGltZy5oZWlnaHQgPSAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGltZ0djID0gaW1nLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0aW5hKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZ0djLnNjYWxlKDIsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbWdHYy5maWxsU3R5bGUgPSB0aGlzLl9maWxsYmcgPyAnYmxhY2snIDogY29sb3I7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBpbWdHYy5tZWFzdXJlVGV4dChiYXNlKS53aWR0aDtcbiAgICAgICAgICAgICAgICBpbWdHYy5maWxsVGV4dChiYXNlLCAwLjUgKiAoOC4wIC0gdyksIDgpO1xuICAgICAgICAgICAgICAgIF9fZGFsbGlhbmNlX1NlcXVlbmNlR2x5cGhDYWNoZVtrZXldID0gaW1nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGR5ID0gdGhpcy5fc2NhbGVWZXJ0aWNhbCA/IHNjYWxlIDogMDtcbiAgICAgICAgICAgIGlmIChpc1JldGluYSlcbiAgICAgICAgICAgICAgICBnYy5kcmF3SW1hZ2UoaW1nLCB0aGlzLl9taW4gKyBwKnNjYWxlICsgMC41KihzY2FsZS04KSwgZHksIDgsIDEwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBnYy5kcmF3SW1hZ2UoaW1nLCB0aGlzLl9taW4gKyBwKnNjYWxlICsgMC41KihzY2FsZS04KSwgZHkpO1xuICAgICAgICB9IFxuXG4gICAgICAgIGlmICh0aGlzLl9xdWFscykge1xuICAgICAgICAgICAgZ2MuZ2xvYmFsQWxwaGEgPSBvbGRBbHBoYTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuU2VxdWVuY2VHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VxID0gdGhpcy5fc2VxO1xuICAgIHZhciByZWYgPSB0aGlzLl9yZWY7XG4gICAgdmFyIG1pc21hdGNoID0gdGhpcy5fc2NoZW1lID09PSAnbWlzbWF0Y2gnIHx8IHRoaXMuX3NjaGVtZSA9PT0gJ21pc21hdGNoLWFsbCc7XG4gICAgdmFyIGFsbCA9IHRoaXMuX3NjaGVtZSA9PT0gJ21pc21hdGNoLWFsbCc7XG4gICAgdmFyIHNjYWxlID0gKHRoaXMuX21heCAtIHRoaXMuX21pbiArIDEpIC8gdGhpcy5fc2VxLmxlbmd0aDtcbiAgICB2YXIgIGcgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnKTsgXG5cbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHNlcS5sZW5ndGg7ICsrcCkge1xuICAgICAgICB2YXIgYmFzZSA9IHNlcSA/IHNlcS5zdWJzdHIocCwgMSkudG9VcHBlckNhc2UoKSA6ICdOJztcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5iYXNlQ29sb3JzW2Jhc2VdO1xuXG4gICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZWZCYXNlID0gcmVmID8gcmVmLnN1YnN0cihwLCAxKS50b1VwcGVyQ2FzZSgpIDogJ04nO1xuICAgICAgICAgICAgaWYgKGJhc2UgPT0gJ04nIHx8IHJlZkJhc2UgPT0gJ04nKVxuICAgICAgICAgICAgICAgIGNvbG9yID0gJ2dyYXknO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5fc3RyYW5kQ29sb3I7XG5cbiAgICAgICAgICAgIGlmIChhbGwpXG4gICAgICAgICAgICAgICAgYmFzZSA9IHJlZkJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWxwaGEgPSAxLjA7XG4gICAgICAgIGlmICh0aGlzLl9xdWFscykge1xuICAgICAgICAgICAgdmFyIHFjID0gdGhpcy5fcXVhbHMuY2hhckNvZGVBdChwKSAtIDMzO1xuICAgICAgICAgICAgYWxwaGEgPSB0aGlzLmFscGhhRm9yUXVhbChxYyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWx0ID0gYWx0UGF0dGVybi50ZXN0KGJhc2UpO1xuICAgICAgICBpZiAodGhpcy5fZmlsbGJnIHx8ICFpc0Nsb3NlVXAoc2NhbGUpIHx8ICFhbHQpIHtcbiAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgbWFrZUVsZW1lbnROUyhOU19TVkcsICdyZWN0JywgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICB4OnRoaXMuX21pbiArIHAqc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogYWxwaGF9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDbG9zZVVwKHNjYWxlKSAmJiBhbHQpIHtcbiAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgbWFrZUVsZW1lbnROUyhOU19TVkcsICd0ZXh0JywgYmFzZSwge1xuICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLl9taW4gKyAoMC41K3ApKnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB5OiA4LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5fZmlsbGJnID8gJ2JsYWNrJyA6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogYWxwaGF9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZztcbn1cblxuZnVuY3Rpb24gVHJhbnNsYXRlZEdseXBoKGdseXBoLCB4LCB5LCBoZWlnaHQpIHtcbiAgICB0aGlzLmdseXBoID0gZ2x5cGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xufVxuXG5UcmFuc2xhdGVkR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaC5oZWlnaHQoKSArIHRoaXMuX3k7XG4gICAgfVxufVxuXG5UcmFuc2xhdGVkR2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdseXBoLm1pbigpICsgdGhpcy5feDtcbn1cblxuVHJhbnNsYXRlZEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nbHlwaC5tYXgoKSArIHRoaXMuX3g7XG59XG5cblRyYW5zbGF0ZWRHbHlwaC5wcm90b3R5cGUubWluWSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl95O1xufVxuXG5UcmFuc2xhdGVkR2x5cGgucHJvdG90eXBlLm1heFkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feSArIHRoaXMuZ2x5cGguaGVpZ2h0KCk7XG59XG5cblRyYW5zbGF0ZWRHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcsIG8pIHtcbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZSh0aGlzLl94LCB0aGlzLl95KTtcbiAgICB0aGlzLmdseXBoLmRyYXcoZywgbyk7XG4gICAgZy5yZXN0b3JlKCk7XG59XG5cblRyYW5zbGF0ZWRHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9ICB0aGlzLmdseXBoLnRvU1ZHKCk7XG4gICAgcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHRoaXMuX3ggKyAnLCcgKyB0aGlzLl95ICsgJyknKTtcbiAgICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gUG9pbnRHbHlwaCh4LCB5LCBoZWlnaHQsIGZpbGwpIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fZmlsbCA9IGZpbGw7XG59XG5cblBvaW50R2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl94IC0gMjtcbn1cblxuUG9pbnRHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKyAyO1xufVxuXG5Qb2ludEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5Qb2ludEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIGcuc2F2ZSgpO1xuICAgIGcuZ2xvYmFsQWxwaGEgPSAwLjM7XG4gICAgZy5maWxsU3R5bGUgPSB0aGlzLl9maWxsO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgZy5hcmModGhpcy5feCwgdGhpcy5feSwgMS41LCAwLCA2LjI5KTtcbiAgICBnLmZpbGwoKTtcbiAgICBnLnJlc3RvcmUoKTtcbn1cblxuUG9pbnRHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhcbiAgICAgICAgTlNfU1ZHLCAnY2lyY2xlJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAge2N4OiB0aGlzLl94LCBjeTogdGhpcy5feSwgcjogMixcbiAgICAgICAgIGZpbGw6IHRoaXMuX2ZpbGwsXG4gICAgICAgICBzdHJva2U6ICdub25lJ30pO1xufVxuXG5cbmZ1bmN0aW9uIEdyaWRHbHlwaChoZWlnaHQsIHlPZmZzZXQsIHNwYWNpbmcpIHtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgNTA7XG4gICAgdGhpcy55T2Zmc2V0ID0geU9mZnNldCB8fCAwO1xuICAgIHRoaXMuc3BhY2luZyA9IHNwYWNpbmcgfHwgMTA7XG59XG5cbkdyaWRHbHlwaC5wcm90b3R5cGUubm90U2VsZWN0YWJsZSA9IHRydWU7XG5cbkdyaWRHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC0xMDAwMDA7XG59O1xuXG5HcmlkR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxMDAwMDA7XG59O1xuXG5HcmlkR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59XG5cbkdyaWRHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICBnLnNhdmUoKTtcbiAgICBnLnN0cm9rZVN0eWxlID0gJ2JsYWNrJ1xuICAgIGcubGluZVdpZHRoID0gMC4xO1xuXG4gICAgZy5iZWdpblBhdGgoKTtcbiAgICBmb3IgKHZhciB5ID0gdGhpcy55T2Zmc2V0OyB5IDw9IHRoaXMuX2hlaWdodCt0aGlzLnlPZmZzZXQ7IHkgKz0gdGhpcy5zcGFjaW5nKSB7XG4gICAgLy8gZm9yICh2YXIgeSA9IDA7IHkgPD0gdGhpcy5faGVpZ2h0OyB5ICs9IDEwKSB7XG4gICAgICAgIGcubW92ZVRvKC01MDAwLCB5KTtcbiAgICAgICAgZy5saW5lVG8oNTAwMCwgeSk7XG4gICAgfVxuICAgIGcuc3Ryb2tlKCk7XG4gICAgZy5yZXN0b3JlKCk7XG59XG5cbkdyaWRHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IG5ldyBTVkdQYXRoKCk7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gdGhpcy5faGVpZ2h0OyB5ICs9IDEwKSB7XG4gICAgICAgIHAubW92ZVRvKC01MDAwLCB5KTtcbiAgICAgICAgcC5saW5lVG8oNTAwMCwgeSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBtYWtlRWxlbWVudE5TKFxuICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAge2Q6IHAudG9QYXRoRGF0YSgpLFxuICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAgICAgc3Ryb2tlV2lkdGg6ICcwLjFweCd9KTtcbn1cblxuZnVuY3Rpb24gU3RhckdseXBoKHgsIHIsIHBvaW50cywgZmlsbCwgc3Ryb2tlKSB7XG4gICAgUGF0aEdseXBoQmFzZS5jYWxsKHRoaXMsIHN0cm9rZSwgZmlsbCk7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5fciA9IHI7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xufVxuXG5TdGFyR2x5cGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXRoR2x5cGhCYXNlLnByb3RvdHlwZSk7XG5cblN0YXJHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggLSB0aGlzLl9yO1xufVxuXG5TdGFyR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl94ICsgdGhpcy5fcjtcbn1cblxuU3RhckdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMiAqIHRoaXMuX3I7XG59XG5cblN0YXJHbHlwaC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIG1pZFggPSB0aGlzLl94LCBtaWRZID0gdGhpcy5fciwgciA9IHRoaXMuX3I7XG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0aGlzLl9wb2ludHM7ICsrcCkge1xuICAgICAgICB2YXIgdGhldGEgPSAocCAqIDYuMjgpIC8gdGhpcy5fcG9pbnRzO1xuICAgICAgICB2YXIgcHggPSBtaWRYICsgcipNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIHZhciBweSA9IG1pZFkgLSByKk1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgaWYgKHAgPT0gMCkge1xuICAgICAgICAgICAgZy5tb3ZlVG8ocHgsIHB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGcubGluZVRvKHB4LCBweSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhldGEgPSAoKHArMC41KSAqIDYuMjgpIC8gdGhpcy5fcG9pbnRzO1xuICAgICAgICBweCA9IG1pZFggKyAwLjQqcipNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIHB5ID0gbWlkWSAtIDAuNCpyKk1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgZy5saW5lVG8ocHgsIHB5KTtcbiAgICB9XG4gICAgZy5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gUGxpbXNvbGxHbHlwaCh4LCBoZWlnaHQsIG92ZXJoYW5nLCBmaWxsLCBzdHJva2UpIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3ZlcmhhbmcgPSBvdmVyaGFuZztcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG4gICAgdGhpcy5faGggPSBoZWlnaHQgLyAyO1xufVxuXG5QbGltc29sbEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBoaCA9IHRoaXMuX2hlaWdodC8yO1xuICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgZy5hcmModGhpcy5feCwgaGgsIGhoIC0gdGhpcy5fb3ZlcmhhbmcsIDAsIDYuMjkpO1xuICAgIGcubW92ZVRvKHRoaXMuX3gsIDApO1xuICAgIGcubGluZVRvKHRoaXMuX3gsIHRoaXMuX2hlaWdodCk7XG5cbiAgICBpZiAodGhpcy5fZmlsbCkge1xuICAgICAgICBnLmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGw7XG4gICAgICAgIGcuZmlsbCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdHJva2UpIHtcbiAgICAgICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZTtcbiAgICAgICAgZy5zdHJva2UoKTtcbiAgICB9XG59XG5cblBsaW1zb2xsR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGg7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnZycsIFxuICAgICAgICBbbWFrZUVsZW1lbnROUyhOU19TVkcsICdjaXJjbGUnLCBudWxsLCB7Y3g6IHRoaXMuX3gsIGN5OiBoaCwgcjogaGggLSB0aGlzLl9vdmVyaGFuZ30pLFxuICAgICAgICAgbWFrZUVsZW1lbnROUyhOU19TVkcsICdsaW5lJywgbnVsbCwge3gxOiB0aGlzLl94LCB5MTogMCwgeDI6IHRoaXMuX3gsIHkyOiB0aGlzLl9oZWlnaHR9KV0sXG4gICAgICAgIHtmaWxsOiB0aGlzLl9maWxsIHx8ICdub25lJyxcbiAgICAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlIHx8ICdub25lJyxcbiAgICAgICAgIHN0cm9rZVdpZHRoOiAnMXB4J30pO1xufVxuXG5QbGltc29sbEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX2hoO1xufVxuXG5QbGltc29sbEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCArIHRoaXMuX2hoO1xufVxuXG5QbGltc29sbEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5cbmZ1bmN0aW9uIE92ZXJsYXlMYWJlbENhbnZhcygpIHtcbiAgICB0aGlzLm94ID0gMDtcbiAgICB0aGlzLm95ID0gMDtcbiAgICB0aGlzLmdseXBocyA9IFtdO1xufVxuXG5PdmVybGF5TGFiZWxDYW52YXMucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLm94ICs9IHg7XG4gICAgdGhpcy5veSArPSB5O1xufVxuXG5PdmVybGF5TGFiZWxDYW52YXMucHJvdG90eXBlLnJlZ2lzdGVyR2x5cGggPSBmdW5jdGlvbihnKSB7XG4gICAgdGhpcy5nbHlwaHMucHVzaCh7XG4gICAgICAgIHg6IHRoaXMub3gsXG4gICAgICAgIHk6IHRoaXMub3ksXG4gICAgICAgIGdseXBoOiBnXG4gICAgfSk7XG59XG5cblxuT3ZlcmxheUxhYmVsQ2FudmFzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZywgbWluVmlzaWJsZSwgbWF4VmlzaWJsZSkge1xuICAgIGZvciAodmFyIGdpID0gMDsgZ2kgPCB0aGlzLmdseXBocy5sZW5ndGg7ICsrZ2kpIHtcbiAgICAgICAgdmFyIGdnID0gdGhpcy5nbHlwaHNbZ2ldO1xuICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgZy50cmFuc2xhdGUoZ2cueCwgZ2cueSk7XG4gICAgICAgIGdnLmdseXBoLmRyYXdPdmVybGF5KGcsIG1pblZpc2libGUsIG1heFZpc2libGUpO1xuICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgQm94R2x5cGg6IEJveEdseXBoLFxuICAgICAgICBHcm91cEdseXBoOiBHcm91cEdseXBoLFxuICAgICAgICBMaW5lR3JhcGhHbHlwaDogTGluZUdyYXBoR2x5cGgsXG4gICAgICAgIExhYmVsbGVkR2x5cGg6IExhYmVsbGVkR2x5cGgsXG4gICAgICAgIENyb3NzR2x5cGg6IENyb3NzR2x5cGgsXG4gICAgICAgIEV4R2x5cGg6IEV4R2x5cGgsXG4gICAgICAgIFRyaWFuZ2xlR2x5cGg6IFRyaWFuZ2xlR2x5cGgsXG4gICAgICAgIERvdEdseXBoOiBEb3RHbHlwaCxcbiAgICAgICAgUGFkZGVkR2x5cGg6IFBhZGRlZEdseXBoLFxuICAgICAgICBBQXJyb3dHbHlwaDogQUFycm93R2x5cGgsXG4gICAgICAgIFNwYW5HbHlwaDogU3BhbkdseXBoLFxuICAgICAgICBMaW5lR2x5cGg6IExpbmVHbHlwaCxcbiAgICAgICAgUHJpbWVyc0dseXBoOiBQcmltZXJzR2x5cGgsXG4gICAgICAgIEFycm93R2x5cGg6IEFycm93R2x5cGgsXG4gICAgICAgIFRvb01hbnlHbHlwaDogVG9vTWFueUdseXBoLFxuICAgICAgICBUZXh0R2x5cGg6IFRleHRHbHlwaCxcbiAgICAgICAgU2VxdWVuY2VHbHlwaDogU2VxdWVuY2VHbHlwaCxcbiAgICAgICAgQW1pbm9BY2lkR2x5cGg6IEFtaW5vQWNpZEdseXBoLFxuICAgICAgICBUcmFuc2xhdGVkR2x5cGg6IFRyYW5zbGF0ZWRHbHlwaCxcbiAgICAgICAgR3JpZEdseXBoOiBHcmlkR2x5cGgsXG4gICAgICAgIFN0YXJHbHlwaDogU3RhckdseXBoLFxuICAgICAgICBQb2ludEdseXBoOiBQb2ludEdseXBoLFxuICAgICAgICBQbGltc29sbEdseXBoOiBQbGltc29sbEdseXBoLFxuXG4gICAgICAgIE92ZXJsYXlMYWJlbENhbnZhczogT3ZlcmxheUxhYmVsQ2FudmFzXG4gICAgfVxufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gamJqc29uLmpzIC0tIHF1ZXJ5IEpCcm93c2Utc3R5bGUgUkVTVCBkYXRhIHN0b3Jlc1xuLy9cblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xuICAgIHZhciBEQVNTdHlsZSA9IGRhcy5EQVNTdHlsZTtcbiAgICB2YXIgREFTRmVhdHVyZSA9IGRhcy5EQVNGZWF0dXJlO1xuICAgIHZhciBEQVNHcm91cCA9IGRhcy5EQVNHcm91cDtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcblxuICAgIHZhciBzcGFucyA9IHJlcXVpcmUoJy4vc3BhbnMnKTtcbiAgICB2YXIgUmFuZ2UgPSBzcGFucy5SYW5nZTtcbiAgICB2YXIgdW5pb24gPSBzcGFucy51bmlvbjtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gc3BhbnMuaW50ZXJzZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBKQnJvd3NlU3RvcmUoYmFzZSwgcXVlcnkpIHtcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbn1cblxuZnVuY3Rpb24gamJvcmkoc3RyYW5kKSB7XG4gICAgaWYgKHN0cmFuZCA+IDApXG4gICAgICAgIHJldHVybiAnKyc7XG4gICAgZWxzZSBpZiAoc3RyYW5kIDw9IDApXG4gICAgICAgIHJldHVybiAnLSc7XG59XG5cbkpCcm93c2VTdG9yZS5wcm90b3R5cGUuZmVhdHVyZXMgPSBmdW5jdGlvbihzZWdtZW50LCBvcHRzLCBjYWxsYmFjaykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdmFyIHVybCA9IHRoaXMuYmFzZSArICcvZmVhdHVyZXMvJyArIHNlZ21lbnQubmFtZTtcblxuICAgIHZhciBmaWx0ZXJzID0gW107XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgZmlsdGVycy5wdXNoKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoc2VnbWVudC5pc0JvdW5kZWQpIHtcbiAgICAgICAgZmlsdGVycy5wdXNoKCdzdGFydD0nICsgc2VnbWVudC5zdGFydCk7XG4gICAgICAgIGZpbHRlcnMucHVzaCgnZW5kPScgKyBzZWdtZW50LmVuZCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXJsID0gdXJsICsgJz8nICsgZmlsdGVycy5qb2luKCcmJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID49IDMwMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdFcnJvciBjb2RlICcgKyByZXEuc3RhdHVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGpmID0gSlNPTi5wYXJzZShyZXEucmVzcG9uc2UpWydmZWF0dXJlcyddO1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGpmLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IGpmW2ZpXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGYuc2VnbWVudCA9IHNlZ21lbnQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZi5taW4gPSAoalsnc3RhcnQnXSB8IDApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZi5tYXggPSBqWydlbmQnXSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGouc2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuc2NvcmUgPSBqLnNjb3JlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGoubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5sYWJlbCA9IGoubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoai5zdHJhbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICBmLm9yaWVudGF0aW9uID0gamJvcmkoai5zdHJhbmQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGYudHlwZSA9IGoudHlwZSB8fCAndW5rbm93bic7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGouc3ViZmVhdHVyZXMgJiYgai5zdWJmZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmlkID0gai51bmlxdWVJRDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgai5zdWJmZWF0dXJlcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2ogPSBqLnN1YmZlYXR1cmVzW3NpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2YgPSBzaGFsbG93Q29weShmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZi5taW4gPSBzai5zdGFydCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2YubWF4ID0gc2ouZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNmLmdyb3VwcyA9IFtmXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbC5wdXNoKHNmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MucHVzaChuZXcgUmFuZ2Uoc2YubWluLCBzZi5tYXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2oudHlwZSA9PT0gJ0NEUycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNkcy5wdXNoKHNmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhbnMgPSB1bmlvbihibG9ja3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eEdyb3VwID0gc2hhbGxvd0NvcHkoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhHcm91cC50eXBlID0gJ3RyYW5zY3JpcHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5zLnJhbmdlcygpLmZvckVhY2goZnVuY3Rpb24oZXhvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6ICAgICBzZWdtZW50Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46ICAgICAgICAgZXhvbi5taW4oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogICAgICAgICBleG9uLm1heCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb246IGYub3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6ICAgICAgW3R4R3JvdXBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgICd0cmFuc2NyaXB0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bEdyb3VwID0gc2hhbGxvd0NvcHkoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2RzLmZvckVhY2goZnVuY3Rpb24oY2RzRXhvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZHNFeG9uLnR5cGUgPSAndHJhbnNsYXRpb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZHNFeG9uLmdyb3VwcyA9IFt0bEdyb3VwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChjZHNFeG9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmZWF0dXJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICByZXEuc2VuZCgpO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIEpCcm93c2VTdG9yZTogSkJyb3dzZVN0b3JlXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vL1xuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxM1xuLy9cbi8vIGtzcGFjZS5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBBd2FpdGVkID0gdXRpbHMuQXdhaXRlZDtcbiAgICB2YXIgcHVzaG8gPSB1dGlscy5wdXNobztcblxuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgTWFwcGVkRmVhdHVyZVNvdXJjZSA9IHNhLk1hcHBlZEZlYXR1cmVTb3VyY2U7XG4gICAgdmFyIENhY2hpbmdGZWF0dXJlU291cmNlID0gc2EuQ2FjaGluZ0ZlYXR1cmVTb3VyY2U7XG4gICAgdmFyIEJXR0ZlYXR1cmVTb3VyY2UgPSBzYS5CV0dGZWF0dXJlU291cmNlO1xuICAgIHZhciBSZW1vdGVCV0dGZWF0dXJlU291cmNlID0gc2EuUmVtb3RlQldHRmVhdHVyZVNvdXJjZTtcbiAgICB2YXIgQkFNRmVhdHVyZVNvdXJjZSA9IHNhLkJBTUZlYXR1cmVTb3VyY2U7XG4gICAgdmFyIFJlbW90ZUJBTUZlYXR1cmVTb3VyY2UgPSBzYS5SZW1vdGVCQU1GZWF0dXJlU291cmNlO1xuICAgIHZhciBEdW1teVNlcXVlbmNlU291cmNlID0gc2EuRHVtbXlTZXF1ZW5jZVNvdXJjZTtcbiAgICB2YXIgRHVtbXlGZWF0dXJlU291cmNlID0gc2EuRHVtbXlGZWF0dXJlU291cmNlO1xuXG4gICAgdmFyIE92ZXJsYXlGZWF0dXJlU291cmNlID0gcmVxdWlyZSgnLi9vdmVybGF5JykuT3ZlcmxheUZlYXR1cmVTb3VyY2U7XG5cbiAgICB2YXIgc3BhbnMgPSByZXF1aXJlKCcuL3NwYW5zJyk7XG4gICAgdmFyIFJhbmdlID0gc3BhbnMuUmFuZ2U7XG4gICAgdmFyIHVuaW9uID0gc3BhbnMudW5pb247XG4gICAgdmFyIGludGVyc2VjdGlvbiA9IHNwYW5zLmludGVyc2VjdGlvbjtcblxuICAgIHZhciBzYW1wbGUgPSByZXF1aXJlKCcuL3NhbXBsZScpO1xuICAgIHZhciBkb3duc2FtcGxlID0gc2FtcGxlLmRvd25zYW1wbGU7XG4gICAgdmFyIGdldEJhc2VDb3ZlcmFnZSA9IHNhbXBsZS5nZXRCYXNlQ292ZXJhZ2U7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU2VxdWVuY2UgPSBkYXMuREFTU2VxdWVuY2U7XG5cbiAgICB2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gRmV0Y2hQb29sKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnJlcXMgPSBbXTtcbiAgICB0aGlzLmF3YWl0ZWRGZWF0dXJlcyA9IHt9O1xuICAgIHRoaXMucmVxdWVzdHNJc3N1ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5ub3RpZnlSZXF1ZXN0c0lzc3VlZCA9IHJlc29sdmU7XG4gICAgfSk7XG59XG5cbkZldGNoUG9vbC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uKHhocikge1xuICAgIHRoaXMucmVxcy5wdXNoKHhocik7XG59XG5cbkZldGNoUG9vbC5wcm90b3R5cGUuYWJvcnRBbGwgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVxcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLnJlcXNbaV0uYWJvcnQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEtTQ2FjaGVCYXRvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgZmVhdHVyZXMsIHN0YXR1cywgY292ZXJhZ2UpIHtcbiAgICB0aGlzLmNociA9IGNocjtcbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgICB0aGlzLmNvdmVyYWdlID0gY292ZXJhZ2U7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcyB8fCBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbn1cblxuS1NDYWNoZUJhdG9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNociArIFwiOlwiICsgdGhpcy5taW4gKyBcIi4uXCIgKyB0aGlzLm1heCArIFwiO3NjYWxlPVwiICsgdGhpcy5zY2FsZTtcbn1cblxuZnVuY3Rpb24gS25vd25TcGFjZSh0aWVyTWFwLCBjaHIsIG1pbiwgbWF4LCBzY2FsZSwgc2VxU291cmNlKSB7XG4gICAgdGhpcy50aWVyTWFwID0gdGllck1hcDtcbiAgICB0aGlzLmNociA9IGNocjtcbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5zZXFTb3VyY2UgPSBzZXFTb3VyY2UgfHwgbmV3IER1bW15U2VxdWVuY2VTb3VyY2UoKTtcbiAgICB0aGlzLnZpZXdDb3VudCA9IDA7XG5cbiAgICB0aGlzLmZlYXR1cmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubGF0ZXN0Vmlld3MgPSB7fTtcbn1cblxuS25vd25TcGFjZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xufVxuXG5Lbm93blNwYWNlLnByb3RvdHlwZS5iZXN0Q2FjaGVPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICB2YXIgYmF0b24gPSB0aGlzLmZlYXR1cmVDYWNoZVt0aGlzLnRpZXJNYXBbMF1dO1xuICAgIGlmIChiYXRvbikge1xuICAgICAgICByZXR1cm4gYmF0b247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5Lbm93blNwYWNlLnByb3RvdHlwZS5yZXRyaWV2ZUZlYXR1cmVzID0gZnVuY3Rpb24odGllcnMsIGNociwgbWluLCBtYXgsIHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlICE9IHNjYWxlKSB7XG4gICAgICAgIHRocm93IFwicmV0cmlldmVGZWF0dXJlcyBjYWxsZWQgd2l0aCBzaWxseSBzY2FsZVwiO1xuICAgIH1cblxuICAgIGlmIChjaHIgIT0gdGhpcy5jaHIpIHtcbiAgICAgICAgdGhyb3cgXCJDYW4ndCBleHRlbmQgS25vd24gU3BhY2UgdG8gYSBuZXcgY2hyb21vc29tZVwiO1xuICAgIH1cbiAgICBpZiAobWluIDwgMSkge1xuICAgICAgICBtaW4gPSAxO1xuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcblxuICAgIGlmICh0aGlzLnBvb2wpIHtcbiAgICAgICAgdGhpcy5wb29sLmFib3J0QWxsKCk7XG4gICAgfVxuICAgIHRoaXMucG9vbCA9IG5ldyBGZXRjaFBvb2woKTtcbiAgICB0aGlzLmF3YWl0ZWRTZXEgPSBuZXcgQXdhaXRlZCgpO1xuICAgIHRoaXMuc2VxV2FzRmV0Y2hlZCA9IGZhbHNlO1xuICAgIHRoaXMudmlld0NvdW50Kys7XG5cbiAgICB0aGlzLnN0YXJ0RmV0Y2hlc0ZvclRpZXJzKHRpZXJzKTtcbiAgICB0aGlzLnBvb2wubm90aWZ5UmVxdWVzdHNJc3N1ZWQoKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyRmVhdHVyZXMoZmVhdHVyZXMsIG1pbiwgbWF4KSB7XG4gICAgdmFyIGZmID0gW107XG4gICAgdmFyIGZlYXR1cmVzQnlHcm91cCA9IHt9O1xuXG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2ZpXTtcbiAgICAgICAgaWYgKCFmLm1pbiB8fCAhZi5tYXgpIHtcbiAgICAgICAgICAgIGZmLnB1c2goZik7XG4gICAgICAgIH0gZWxzZSBpZiAoZi5ncm91cHMgJiYgZi5ncm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcHVzaG8oZmVhdHVyZXNCeUdyb3VwLCBmLmdyb3Vwc1swXS5pZCwgZik7XG4gICAgICAgIH0gZWxzZSBpZiAoZi5taW4gPD0gbWF4ICYmIGYubWF4ID49IG1pbikge1xuICAgICAgICAgICAgZmYucHVzaChmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGdpZCBpbiBmZWF0dXJlc0J5R3JvdXApIHtcbiAgICAgICAgdmFyIGdmID0gZmVhdHVyZXNCeUdyb3VwW2dpZF07XG4gICAgICAgIHZhciBnbWluID0gMTAwMDAwMDAwMDAwLCBnbWF4ID0gLTEwMDAwMDAwMDAwMDtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGdmLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgdmFyIGYgPSBnZltmaV07XG4gICAgICAgICAgICBnbWluID0gTWF0aC5taW4oZ21pbiwgZi5taW4pO1xuICAgICAgICAgICAgZ21heCA9IE1hdGgubWF4KGdtYXgsIGYubWF4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ21pbiA8PSBtYXggfHwgZ21heCA+PSBtaW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBnZi5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICBmZi5wdXNoKGdmW2ZpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmY7XG59XG5cbktub3duU3BhY2UucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbih0aWVyKSB7XG4gICAgaWYgKCF0aGlzLnBvb2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmVhdHVyZUNhY2hlW3RpZXJdID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0RmV0Y2hlc0ZvclRpZXJzKFt0aWVyXSk7XG59XG5cbktub3duU3BhY2UucHJvdG90eXBlLnN0YXJ0RmV0Y2hlc0ZvclRpZXJzID0gZnVuY3Rpb24odGllcnMpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgdmFyIGF3YWl0ZWRTZXEgPSB0aGlzLmF3YWl0ZWRTZXE7XG4gICAgdmFyIG5lZWRTZXEgPSBmYWxzZTtcblxuICAgIHZhciBnZXg7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRpZXJzLmxlbmd0aDsgKyt0KSB7XG4gICAgICAgIHZhciB0aWVyUmVuZGVyZXIgPSB0aWVyc1t0XS5icm93c2VyLmdldFRpZXJSZW5kZXJlcih0aWVyc1t0XSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydEZldGNoZXNGb3IodGllcnNbdF0sIGF3YWl0ZWRTZXEpKSB7XG4gICAgICAgICAgICAgICAgbmVlZFNlcSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB2YXIgdGllciA9IHRpZXJzW3RdO1xuXG4gICAgICAgICAgICB0aWVyLmN1cnJlbnRGZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgdGllci5jdXJyZW50U2VxdWVuY2UgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGZldGNoaW5nIHRpZXIgc291cmNlJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleCk7XG4gICAgICAgICAgICBnZXggPSBleDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4LnN0YWNrKTtcbiAgICAgICAgICAgIHRpZXJSZW5kZXJlci5yZW5kZXJUaWVyKGV4LCB0aWVyKTtcbiAgICAgICAgICAgIHRpZXIud2FzUmVuZGVyZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkU2VxICYmICF0aGlzLnNlcVdhc0ZldGNoZWQpIHtcbiAgICAgICAgdGhpcy5zZXFXYXNGZXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNtaW4gPSB0aGlzLm1pbiwgc21heCA9IHRoaXMubWF4O1xuXG4gICAgICAgIGlmICh0aGlzLmNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jcy5zdGFydCA8PSBzbWluICYmIHRoaXMuY3MuZW5kID49IHNtYXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkU2VxO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNzLnN0YXJ0ID09IHNtaW4gJiYgdGhpcy5jcy5lbmQgPT0gc21heCkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRTZXEgPSB0aGlzLmNzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFNlcSA9IG5ldyBEQVNTZXF1ZW5jZSh0aGlzLmNzLm5hbWUsIHNtaW4sIHNtYXgsIHRoaXMuY3MuYWxwaGFiZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNzLnNlcS5zdWJzdHJpbmcoc21pbiAtIHRoaXMuY3Muc3RhcnQsIHNtYXggKyAxIC0gdGhpcy5jcy5zdGFydCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXRlZFNlcS5wcm92aWRlKGNhY2hlZFNlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlcVNvdXJjZS5mZXRjaCh0aGlzLmNociwgc21pbiwgc21heCwgdGhpcy5wb29sLCBmdW5jdGlvbihlcnIsIHNlcSkge1xuICAgICAgICAgICAgaWYgKHNlcSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpc0IuY3MgfHwgKHNtaW4gPD0gdGhpc0IuY3Muc3RhcnQgJiYgc21heCA+PSB0aGlzQi5jcy5lbmQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzbWluID49IHRoaXNCLmNzLmVuZCkgfHwgKHNtYXggPD0gdGhpc0IuY3Muc3RhcnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICgoc21heCAtIHNtaW4pID4gKHRoaXNCLmNzLmVuZCAtIHRoaXNCLmNzLnN0YXJ0KSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5jcyA9IHNlcTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXRlZFNlcS5wcm92aWRlKHNlcSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXF1ZW5jZSBsb2FkaW5nIGZhaWxlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgYXdhaXRlZFNlcS5wcm92aWRlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V4KVxuICAgICAgICB0aHJvdyBnZXg7XG59XG5cbktub3duU3BhY2UucHJvdG90eXBlLnN0YXJ0RmV0Y2hlc0ZvciA9IGZ1bmN0aW9uKHRpZXIsIGF3YWl0ZWRTZXEpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgdmFyIHZpZXdJRCA9IHRoaXMudmlld0NvdW50O1xuICAgIHZhciBzb3VyY2UgPSB0aWVyLmdldFNvdXJjZSgpIHx8IG5ldyBEdW1teUZlYXR1cmVTb3VyY2UoKTtcbiAgICB2YXIgbmVlZHNTZXEgPSB0aWVyLm5lZWRzU2VxdWVuY2UodGhpcy5zY2FsZSk7XG4gICAgdmFyIGJhdG9uID0gdGhpc0IuZmVhdHVyZUNhY2hlW3RpZXJdO1xuICAgIHZhciBzdHlsZUZpbHRlcnMgPSB0aWVyLmdldEFjdGl2ZVN0eWxlRmlsdGVycyh0aGlzLnNjYWxlKTtcbiAgICB2YXIgd2FudGVkVHlwZXM7XG4gICAgaWYgKHN0eWxlRmlsdGVycylcbiAgICAgICAgd2FudGVkVHlwZXMgPSBzdHlsZUZpbHRlcnMudHlwZUxpc3QoKTtcbiAgICB2YXIgY2hyID0gdGhpcy5jaHIsIG1pbiA9IHRoaXMubWluLCBtYXggPSB0aGlzLm1heDtcblxuXG4gICAgaWYgKHdhbnRlZFR5cGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmF0b24gJiYgYmF0b24uY2hyID09PSB0aGlzLmNociAmJiBiYXRvbi5taW4gPD0gbWluICYmIGJhdG9uLm1heCA+PSBtYXgpIHtcbiAgICAgICAgdmFyIGNhY2hlZEZlYXR1cmVzID0gYmF0b24uZmVhdHVyZXM7XG4gICAgICAgIGlmIChiYXRvbi5taW4gPCBtaW4gfHwgYmF0b24ubWF4ID4gbWF4KSB7XG4gICAgICAgICAgICBjYWNoZWRGZWF0dXJlcyA9IGZpbHRlckZlYXR1cmVzKGNhY2hlZEZlYXR1cmVzLCBtaW4sIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzQi5wcm92aXNpb24odGllciwgYmF0b24uY2hyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uKGJhdG9uLmNvdmVyYWdlLCBuZXcgUmFuZ2UobWluLCBtYXgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdG9uLnNjYWxlLCB3YW50ZWRUeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEZlYXR1cmVzLCBiYXRvbi5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1NlcSA/IGF3YWl0ZWRTZXEgOiBudWxsKTtcblxuICAgICAgICB2YXIgYXZhaWxhYmxlU2NhbGVzID0gc291cmNlLmdldFNjYWxlcygpO1xuXG4gICAgICAgIGlmICghdGllci5kYXNTb3VyY2UucmVmZXRjaE9uWm9vbSAmJiAoYmF0b24uc2NhbGUgPD0gdGhpcy5zY2FsZSB8fCAhYXZhaWxhYmxlU2NhbGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZWRzU2VxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5pbnN0cnVtZW50KVxuICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgIGZldGNoICcgKyB2aWV3SUQgKyAnICgnICsgbWluICsgJywgJyArIG1heCArICcpJyk7XG5cblxuICAgIHNvdXJjZS5mZXRjaChjaHIsIG1pbiwgbWF4LCB0aGlzLnNjYWxlLCB3YW50ZWRUeXBlcywgdGhpcy5wb29sLCBmdW5jdGlvbihzdGF0dXMsIGZlYXR1cmVzLCBzY2FsZSwgY292ZXJhZ2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5pbnN0cnVtZW50KVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbmlzaGluZyBmZXRjaCAnICsgdmlld0lEKTtcblxuICAgICAgICB2YXIgbGF0ZXN0Vmlld0lEID0gdGhpc0IubGF0ZXN0Vmlld3NbdGllcl0gfHwgLTE7XG4gICAgICAgIGlmICh0aGlzQi5jYW5jZWxsZWQgfHwgbGF0ZXN0Vmlld0lEID4gdmlld0lEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvdmVyYWdlKSB7XG4gICAgICAgICAgICBjb3ZlcmFnZSA9IG5ldyBSYW5nZShtaW4sIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJhdG9uIHx8IChtaW4gPCBiYXRvbi5taW4pIHx8IChtYXggPiBiYXRvbi5tYXgpKSB7ICAgICAgICAgLy8gRklYTUUgc2hvdWxkIGJlIG1lcmdpbmcgaW4gc29tZSBjYXNlcz9cbiAgICAgICAgICAgIHRoaXNCLmZlYXR1cmVDYWNoZVt0aWVyXSA9IG5ldyBLU0NhY2hlQmF0b24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIGZlYXR1cmVzLCBzdGF0dXMsIGNvdmVyYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNCLmxhdGVzdFZpZXdzW3RpZXJdID0gdmlld0lEO1xuICAgICAgICB0aGlzQi5wcm92aXNpb24odGllciwgY2hyLCBjb3ZlcmFnZSwgc2NhbGUsIHdhbnRlZFR5cGVzLCBmZWF0dXJlcywgc3RhdHVzLCBuZWVkc1NlcSA/IGF3YWl0ZWRTZXEgOiBudWxsKTtcbiAgICB9LCBzdHlsZUZpbHRlcnMpO1xuICAgIHJldHVybiBuZWVkc1NlcTtcbn1cblxuS25vd25TcGFjZS5wcm90b3R5cGUucHJvdmlzaW9uID0gZnVuY3Rpb24odGllciwgY2hyLCBjb3ZlcmFnZSwgYWN0dWFsU2NhbGUsIHdhbnRlZFR5cGVzLCBmZWF0dXJlcywgc3RhdHVzLCBhd2FpdGVkU2VxKSB7XG4gICAgdmFyIHRpZXJSZW5kZXJlciA9IHRpZXIuYnJvd3Nlci5nZXRUaWVyUmVuZGVyZXIodGllcik7XG4gICAgaWYgKHN0YXR1cykge1xuICAgICAgICB0aWVyLnNldEZlYXR1cmVzKGNociwgY292ZXJhZ2UsIGFjdHVhbFNjYWxlLCBbXSwgbnVsbCk7XG4gICAgICAgIGlmICghZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKHN0YXR1cyk7XG4gICAgICAgICAgICBzdGF0dXMgPSBcIkVycm9yIGZldGNoaW5nIGRhdGE6IFwiICsgc3RhdHVzICsgXCI7IHNlZSBicm93c2VyIGNvbnNvbGVcIjtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZmV0Y2hpbmcgZGF0YSBmb3IgdGllciBcIiArIHRpZXIuZGFzU291cmNlLm5hbWUgKyBcIjpcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aWVyLmRhc1NvdXJjZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0YWNrIHRyYWNlOlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spXG4gICAgICAgIH1cbiAgICAgICAgdGllclJlbmRlcmVyLnJlbmRlclRpZXIoc3RhdHVzLCB0aWVyKTtcbiAgICAgICAgdGllci53YXNSZW5kZXJlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXlEb3duc2FtcGxlID0gZmFsc2U7XG4gICAgICAgIHZhciBuZWVkQmFzZUNvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIHZhciBzcmMgPSB0aWVyLmdldFNvdXJjZSgpO1xuICAgICAgICB3aGlsZSAoTWFwcGVkRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzcmMpIHx8XG4gICAgICAgICAgICAgICBDYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzcmMpIHx8XG4gICAgICAgICAgICAgICBPdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzcmMpKSB7XG5cbiAgICAgICAgICAgIGlmIChPdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnNvdXJjZXNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yoc3JjKSB8fFxuICAgICAgICAgICAgUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzcmMpIHx8XG4gICAgICAgICAgICBCQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHNyYykgfHxcbiAgICAgICAgICAgIFJlbW90ZUJBTUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yoc3JjKSkge1xuXG4gICAgICAgICAgICBtYXlEb3duc2FtcGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3JjLm9wdHMgfHwgKCFzcmMub3B0cy5mb3JjZVJlZHVjdGlvbiAmJiAhc3JjLm9wdHMubm9Eb3duc2FtcGxlKSkge1xuICAgICAgICAgICAgaWYgKC8qIChhY3R1YWxTY2FsZSA8ICh0aGlzLnNjYWxlLzIpICYmIGZlYXR1cmVzLmxlbmd0aCA+IDIwMCkgIHx8ICovXG4gICAgICAgICAgICAgICAgKG1heURvd25zYW1wbGUgJiYgd2FudGVkVHlwZXMgJiYgd2FudGVkVHlwZXMubGVuZ3RoID09IDEgJiYgd2FudGVkVHlwZXMuaW5kZXhPZignZGVuc2l0eScpID49IDApKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gZG93bnNhbXBsZShmZWF0dXJlcywgdGhpcy5zY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2FudGVkVHlwZXMgJiYgd2FudGVkVHlwZXMubGVuZ3RoID09IDEgJiYgd2FudGVkVHlwZXMuaW5kZXhPZignYmFzZS1jb3ZlcmFnZScpID49IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEJhc2UtY29tcG9zaXRpb24gY292ZXJhZ2UgdHJhY2tcbiAgICAgICAgICAgIG5lZWRCYXNlQ29tcG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoYXdhaXRlZFNlcSkge1xuICAgICAgICAgICAgYXdhaXRlZFNlcS5hd2FpdChmdW5jdGlvbihzZXEpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVlZEJhc2VDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IGdldEJhc2VDb3ZlcmFnZShmZWF0dXJlcywgc2VxLCB0aWVyLmJyb3dzZXIuYmFzZUNvbG9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpZXIuc2V0RmVhdHVyZXMoY2hyLCBjb3ZlcmFnZSwgYWN0dWFsU2NhbGUsIGZlYXR1cmVzLCBzZXEpO1xuICAgICAgICAgICAgICAgIHRpZXJSZW5kZXJlci5yZW5kZXJUaWVyKHN0YXR1cywgdGllcik7XG4gICAgICAgICAgICAgICAgdGllci53YXNSZW5kZXJlZCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpZXIuc2V0RmVhdHVyZXMoY2hyLCBjb3ZlcmFnZSwgYWN0dWFsU2NhbGUsIGZlYXR1cmVzKTtcbiAgICAgICAgICAgIHRpZXJSZW5kZXJlci5yZW5kZXJUaWVyKHN0YXR1cywgdGllcik7XG4gICAgICAgICAgICB0aWVyLndhc1JlbmRlcmVkKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgS25vd25TcGFjZTogS25vd25TcGFjZVxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDExXG4vL1xuLy8gbGgzdXRpbHMuanM6IGNvbW1vbiBzdXBwb3J0IGZvciBsaDMncyBmaWxlIGZvcm1hdHNcbi8vXG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGpzemxpYiA9IHJlcXVpcmUoJ2pzemxpYicpO1xuICAgIHZhciBqc3psaWJfaW5mbGF0ZV9idWZmZXIgPSBqc3psaWIuaW5mbGF0ZUJ1ZmZlcjtcbiAgICB2YXIgYXJyYXlDb3B5ID0ganN6bGliLmFycmF5Q29weTtcbn1cblxuZnVuY3Rpb24gVm9iKGIsIG8pIHtcbiAgICB0aGlzLmJsb2NrID0gYjtcbiAgICB0aGlzLm9mZnNldCA9IG87XG59XG5cblZvYi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmJsb2NrICsgJzonICsgdGhpcy5vZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRWb2IoYmEsIG9mZnNldCwgYWxsb3daZXJvKSB7XG4gICAgdmFyIGJsb2NrID0gKChiYVtvZmZzZXQrNl0gJiAweGZmKSAqIDB4MTAwMDAwMDAwKSArICgoYmFbb2Zmc2V0KzVdICYgMHhmZikgKiAweDEwMDAwMDApICsgKChiYVtvZmZzZXQrNF0gJiAweGZmKSAqIDB4MTAwMDApICsgKChiYVtvZmZzZXQrM10gJiAweGZmKSAqIDB4MTAwKSArICgoYmFbb2Zmc2V0KzJdICYgMHhmZikpO1xuICAgIHZhciBiaW50ID0gKGJhW29mZnNldCsxXSA8PCA4KSB8IChiYVtvZmZzZXRdKTtcbiAgICBpZiAoYmxvY2sgPT0gMCAmJiBiaW50ID09IDAgJiYgIWFsbG93WmVybykge1xuICAgICAgICByZXR1cm4gbnVsbDsgIC8vIFNob3VsZCBvbmx5IGhhcHBlbiBpbiB0aGUgbGluZWFyIGluZGV4P1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVm9iKGJsb2NrLCBiaW50KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVuYmd6ZihkYXRhLCBsaW0pIHtcbiAgICBsaW0gPSBNYXRoLm1pbihsaW0gfHwgMSwgZGF0YS5ieXRlTGVuZ3RoIC0gNTApO1xuICAgIHZhciBvQmxvY2tMaXN0ID0gW107XG4gICAgdmFyIHB0ciA9IFswXTtcbiAgICB2YXIgdG90YWxTaXplID0gMDtcblxuICAgIHdoaWxlIChwdHJbMF0gPCBsaW0pIHtcbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgcHRyWzBdLCAxMik7IC8vIEZJWE1FIGlzIHRoaXMgZW5vdWdoIGZvciBhbGwgY3JlZGlibGUgQkdaRiBibG9jayBoZWFkZXJzP1xuICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcbiAgICAgICAgLy8gZGxvZygneGxlblsnICsgKHB0clswXSkgKyddPScgKyB4bGVuKTtcbiAgICAgICAgdmFyIHVuYyA9IGpzemxpYl9pbmZsYXRlX2J1ZmZlcihkYXRhLCAxMiArIHhsZW4gKyBwdHJbMF0sIE1hdGgubWluKDY1NTM2LCBkYXRhLmJ5dGVMZW5ndGggLSAxMiAtIHhsZW4gLSBwdHJbMF0pLCBwdHIpO1xuICAgICAgICBwdHJbMF0gKz0gODtcbiAgICAgICAgdG90YWxTaXplICs9IHVuYy5ieXRlTGVuZ3RoO1xuICAgICAgICBvQmxvY2tMaXN0LnB1c2godW5jKTtcbiAgICB9XG5cbiAgICBpZiAob0Jsb2NrTGlzdC5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gb0Jsb2NrTGlzdFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTtcbiAgICAgICAgdmFyIGN1cnNvciA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb0Jsb2NrTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShvQmxvY2tMaXN0W2ldKTtcbiAgICAgICAgICAgIGFycmF5Q29weShiLCAwLCBvdXQsIGN1cnNvciwgYi5sZW5ndGgpO1xuICAgICAgICAgICAgY3Vyc29yICs9IGIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuYnVmZmVyO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gQ2h1bmsobWludiwgbWF4dikge1xuICAgIHRoaXMubWludiA9IG1pbnY7IHRoaXMubWF4diA9IG1heHY7XG59XG5cblxuLy9cbi8vIEJpbm5pbmcgKHRyYW5zbGl0ZXJhdGVkIGZyb20gU0FNMS4zIHNwZWMpXG4vL1xuXG4vKiBjYWxjdWxhdGUgYmluIGdpdmVuIGFuIGFsaWdubWVudCBjb3ZlcmluZyBbYmVnLGVuZCkgKHplcm8tYmFzZWQsIGhhbGYtY2xvc2UtaGFsZi1vcGVuKSAqL1xuZnVuY3Rpb24gcmVnMmJpbihiZWcsIGVuZClcbntcbiAgICAtLWVuZDtcbiAgICBpZiAoYmVnPj4xNCA9PSBlbmQ+PjE0KSByZXR1cm4gKCgxPDwxNSktMSkvNyArIChiZWc+PjE0KTtcbiAgICBpZiAoYmVnPj4xNyA9PSBlbmQ+PjE3KSByZXR1cm4gKCgxPDwxMiktMSkvNyArIChiZWc+PjE3KTtcbiAgICBpZiAoYmVnPj4yMCA9PSBlbmQ+PjIwKSByZXR1cm4gKCgxPDw5KS0xKS83ICsgKGJlZz4+MjApO1xuICAgIGlmIChiZWc+PjIzID09IGVuZD4+MjMpIHJldHVybiAoKDE8PDYpLTEpLzcgKyAoYmVnPj4yMyk7XG4gICAgaWYgKGJlZz4+MjYgPT0gZW5kPj4yNikgcmV0dXJuICgoMTw8MyktMSkvNyArIChiZWc+PjI2KTtcbiAgICByZXR1cm4gMDtcbn1cblxuLyogY2FsY3VsYXRlIHRoZSBsaXN0IG9mIGJpbnMgdGhhdCBtYXkgb3ZlcmxhcCB3aXRoIHJlZ2lvbiBbYmVnLGVuZCkgKHplcm8tYmFzZWQpICovXG52YXIgTUFYX0JJTiA9ICgoKDE8PDE4KS0xKS83KTtcbmZ1bmN0aW9uIHJlZzJiaW5zKGJlZywgZW5kKSBcbntcbiAgICB2YXIgaSA9IDAsIGssIGxpc3QgPSBbXTtcbiAgICAtLWVuZDtcbiAgICBsaXN0LnB1c2goMCk7XG4gICAgZm9yIChrID0gMSArIChiZWc+PjI2KTsgayA8PSAxICsgKGVuZD4+MjYpOyArK2spIGxpc3QucHVzaChrKTtcbiAgICBmb3IgKGsgPSA5ICsgKGJlZz4+MjMpOyBrIDw9IDkgKyAoZW5kPj4yMyk7ICsraykgbGlzdC5wdXNoKGspO1xuICAgIGZvciAoayA9IDczICsgKGJlZz4+MjApOyBrIDw9IDczICsgKGVuZD4+MjApOyArK2spIGxpc3QucHVzaChrKTtcbiAgICBmb3IgKGsgPSA1ODUgKyAoYmVnPj4xNyk7IGsgPD0gNTg1ICsgKGVuZD4+MTcpOyArK2spIGxpc3QucHVzaChrKTtcbiAgICBmb3IgKGsgPSA0NjgxICsgKGJlZz4+MTQpOyBrIDw9IDQ2ODEgKyAoZW5kPj4xNCk7ICsraykgbGlzdC5wdXNoKGspO1xuICAgIHJldHVybiBsaXN0O1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHVuYmd6ZjogdW5iZ3pmLFxuICAgICAgICByZWFkVm9iOiByZWFkVm9iLFxuICAgICAgICByZWcyYmluOiByZWcyYmluLFxuICAgICAgICByZWcyYmluczogcmVnMmJpbnMsXG4gICAgICAgIENodW5rOiBDaHVua1xuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gbWVtc3RvcmUuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgZGFsbGlhbmNlX3JlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnkgPSBzYS5yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5O1xuICAgIHZhciBkYWxsaWFuY2VfbWFrZVBhcnNlciA9IHNhLm1ha2VQYXJzZXI7XG4gICAgdmFyIEZlYXR1cmVTb3VyY2VCYXNlID0gc2EuRmVhdHVyZVNvdXJjZUJhc2U7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xuICAgIHZhciBEQVNTdHlsZSA9IGRhcy5EQVNTdHlsZTtcbiAgICB2YXIgREFTRmVhdHVyZSA9IGRhcy5EQVNGZWF0dXJlO1xuICAgIHZhciBEQVNHcm91cCA9IGRhcy5EQVNHcm91cDtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgQXdhaXRlZCA9IHV0aWxzLkF3YWl0ZWQ7XG4gICAgdmFyIHRleHRYSFIgPSB1dGlscy50ZXh0WEhSO1xufVxuXG5mdW5jdGlvbiBNZW1TdG9yZSgpIHtcbiAgICB0aGlzLmZlYXR1cmVzQnlDaHIgPSB7fTtcbiAgICB0aGlzLm1heExlbmd0aCA9IDE7XG4gICAgdGhpcy5jaHJSaW5nID0gbnVsbDtcbn1cblxuTWVtU3RvcmUucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICB2YXIgZGlydHkgPSB7fTtcbiAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHZhciBmID0gZmVhdHVyZXNbZmldO1xuICAgICAgICB2YXIgY2hyID0gZi5zZWdtZW50IHx8IGYuY2hyO1xuICAgICAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICAgICAgaWYgKCFmYSkge1xuICAgICAgICAgICAgZmEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNCeUNocltjaHJdID0gZmE7XG4gICAgICAgIH1cbiAgICAgICAgZmEucHVzaChmKTtcbiAgICAgICAgZGlydHlbY2hyXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGxlbiA9IGYubWF4IC0gZi5taW4gKyAxO1xuICAgICAgICBpZiAobGVuID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1heExlbmd0aCA9IGxlbjtcbiAgICB9XG5cbiAgICBmb3IgKGNociBpbiBkaXJ0eSkge1xuICAgICAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICAgICAgZmEuc29ydChmdW5jdGlvbihmMSwgZjIpIHtcbiAgICAgICAgICAgIHZhciBkID0gZjEubWluIC0gZjIubWluO1xuICAgICAgICAgICAgaWYgKGQgIT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIHJldHVybiBmMS5tYXggLSBmMi5tYXg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNoclJpbmcgPSBudWxsO1xufVxuXG5NZW1TdG9yZS5wcm90b3R5cGUuX2luZGV4Rm9yID0gZnVuY3Rpb24oZmEsIHApIHtcbiAgICB2YXIgbGIgPSAwLCB1YiA9IGZhLmxlbmd0aDtcbiAgICB3aGlsZSAodWIgPiBsYikge1xuICAgICAgICB2YXIgbWlkID0gKChsYiArIHViKS8yKXwwO1xuICAgICAgICBpZiAobWlkID49IGZhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYS5sZW5ndGg7XG4gICAgICAgIHZhciBtZyA9IGZhW21pZF07XG4gICAgICAgIGlmIChwIDwgbWcubWluKSB7XG4gICAgICAgICAgICB1YiA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxiID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdWI7XG59XG5cbk1lbVN0b3JlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICBpZiAoIWZhKSB7XG4gICAgICAgIGlmIChjaHIuaW5kZXhPZignY2hyJykgPT0gMClcbiAgICAgICAgICAgIGZhID0gdGhpcy5mZWF0dXJlc0J5Q2hyW2Noci5zdWJzdHJpbmcoMyldO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmYSA9IHRoaXMuZmVhdHVyZXNCeUNoclsnY2hyJyArIGNocl07XG4gICAgfVxuICAgIGlmICghZmEpXG4gICAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBtaW5pID0gTWF0aC5tYXgoMCwgdGhpcy5faW5kZXhGb3IoZmEsIG1pbiAtIHRoaXMubWF4TGVuZ3RoIC0gMSkpO1xuICAgIHZhciBtYXhpID0gTWF0aC5taW4oZmEubGVuZ3RoIC0gMSwgdGhpcy5faW5kZXhGb3IoZmEsIG1heCkpO1xuXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGZpID0gbWluaTsgZmkgPD0gbWF4aTsgKytmaSkge1xuICAgICAgICB2YXIgZiA9IGZhW2ZpXTtcbiAgICAgICAgaWYgKGYubWluIDw9IG1heCAmJiBmLm1heCA+PSBtaW4pXG4gICAgICAgICAgICByZXMucHVzaChmKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuTWVtU3RvcmUucHJvdG90eXBlLmZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIpIHtcbiAgICBpZiAodGhpcy5jaHJSaW5nID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaHJSaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGNociBpbiB0aGlzLmZlYXR1cmVzQnlDaHIpIHtcbiAgICAgICAgICAgIHRoaXMuY2hyUmluZy5wdXNoKGNocik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHJSaW5nLnNvcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICBpZiAoIWZhKSB7XG4gICAgICAgIGlmIChjaHIuaW5kZXhPZignY2hyJykgPT0gMCkge1xuICAgICAgICAgICAgY2hyID0gY2hyLnN1YnN0cmluZygzKTtcbiAgICAgICAgICAgIGZhID0gdGhpcy5mZWF0dXJlc0J5Q2hyW2Nocl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSAnY2hyJyArIGNocjtcbiAgICAgICAgICAgIGZhID0gdGhpcy5mZWF0dXJlc0J5Q2hyW2Nocl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmYSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX2luZGV4Rm9yKGZhLCBwb3MpLCBmYS5sZW5ndGggLSAxKSk7XG4gICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgd2hpbGUgKGkgPCBmYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmFbaSsrXTtcbiAgICAgICAgICAgIGlmIChmLm1pbiA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hySW5kID0gdGhpcy5jaHJSaW5nLmluZGV4T2YoY2hyKSArIDE7XG4gICAgICAgIGlmIChjaHJJbmQgPj0gdGhpcy5jaHJSaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGNockluZCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmROZXh0RmVhdHVyZSh0aGlzLmNoclJpbmdbY2hySW5kXSwgMCwgZGlyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZhW2ktLV07XG4gICAgICAgICAgICBpZiAoZi5tYXggPCBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNockluZCA9IHRoaXMuY2hyUmluZy5pbmRleE9mKGNocikgLSAxO1xuICAgICAgICBpZiAoY2hySW5kIDwgMClcbiAgICAgICAgICAgIGNockluZCA9IHRoaXMuY2hyUmluZy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kTmV4dEZlYXR1cmUodGhpcy5jaHJSaW5nW2NockluZF0sIDEwMDAwMDAwMDAwLCBkaXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gTWVtU3RvcmVGZWF0dXJlU291cmNlKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIEZlYXR1cmVTb3VyY2VCYXNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdG9yZUhvbGRlciA9IG5ldyBBd2FpdGVkKCk7XG4gICAgdGhpcy5wYXJzZXIgPSBkYWxsaWFuY2VfbWFrZVBhcnNlcihzb3VyY2UucGF5bG9hZCk7XG4gICAgaWYgKCF0aGlzLnBhcnNlcikge1xuICAgICAgICB0aHJvdyBcIlVuc3VwcG9ydGVkIG1lbXN0b3JlIHBheWxvYWQ6IFwiICsgc291cmNlLnBheWxvYWQ7XG4gICAgfVxuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLl9sb2FkKGZ1bmN0aW9uKHJlc3AsIGVycikge1xuICAgICAgICBpZiAoIXJlc3ApIHtcbiAgICAgICAgICAgIHRoaXNCLmVycm9yID0gZXJyIHx8IFwiTm8gZGF0YVwiXG4gICAgICAgICAgICB0aGlzQi5zdG9yZUhvbGRlci5wcm92aWRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gbmV3IE1lbVN0b3JlKCk7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHJlc3Auc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXNCLnBhcnNlci5jcmVhdGVTZXNzaW9uKGZ1bmN0aW9uKGYpIHtmZWF0dXJlcy5wdXNoKGYpfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgbGluZXMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaV07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnBhcnNlKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlc3Npb24uZmx1c2goKTtcblxuICAgICAgICAgICAgc3RvcmUuYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xuXG4gICAgICAgICAgICB0aGlzQi5zdG9yZUhvbGRlci5wcm92aWRlKHN0b3JlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUpO1xuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zb3VyY2UuYmxvYikge1xuICAgICAgICB2YXIgciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soci5yZXN1bHQsIHIuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHIucmVhZEFzVGV4dCh0aGlzLnNvdXJjZS5ibG9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UuY3JlZGVudGlhbHMpXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHtjcmVkZW50aWFscyA6IHRoaXMuc291cmNlLmNyZWRlbnRpYWxzfTtcbiAgICAgICAgdGV4dFhIUih0aGlzLnNvdXJjZS51cmksIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9XG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNudCkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5zdG9yZUhvbGRlci5hd2FpdChmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBmID0gc3RvcmUuZmV0Y2goY2hyLCBtaW4sIG1heCk7XG4gICAgICAgICAgICByZXR1cm4gY250KG51bGwsIGYsIDEwMDAwMDAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY250KHRoaXNCLmVycm9yKVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyICYmIHRoaXMucGFyc2VyLmdldFN0eWxlU2hlZXQpXG4gICAgICAgIHRoaXMucGFyc2VyLmdldFN0eWxlU2hlZXQoY2FsbGJhY2spXG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZJUHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBhcnNlciAmJiB0aGlzLnBhcnNlci5nZXREZWZhdWx0RklQcylcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RGVmYXVsdEZJUHMoY2FsbGJhY2spO1xufVxuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxMDAwMDAwMDA7XG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmluZE5leHRGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBwb3MsIGRpciwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuc3RvcmVIb2xkZXIuYXdhaXQoZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soc3RvcmUuZmluZE5leHRGZWF0dXJlKGNociwgcG9zLCBkaXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0aGlzQi5lcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYXBzID0ge2xlYXA6IHRydWV9O1xuICAgIHJldHVybiBjYXBzO1xufVxuXG5kYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSgnbWVtc3RvcmUnLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4ge2ZlYXR1cmVzOiBuZXcgTWVtU3RvcmVGZWF0dXJlU291cmNlKHNvdXJjZSl9O1xufSk7XG4iLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZHJhd1NlcVRpZXIgfSBmcm9tIFwiLi9zZXF1ZW5jZS1kcmF3LmpzXCI7XG5cbmltcG9ydCB7IEdyaWRHbHlwaCB9IGZyb20gXCIuL2dseXBocy5qc1wiO1xuXG5pbXBvcnQgKiBhcyBEZWZhdWx0UmVuZGVyZXIgZnJvbSBcIi4vZGVmYXVsdC1yZW5kZXJlclwiO1xuXG5pbXBvcnQgKiBhcyBSIGZyb20gXCJyYW1kYVwiO1xuXG5leHBvcnQgeyByZW5kZXJUaWVyLCBkcmF3VGllciB9O1xuXG5cbi8qIFJlbmRlcnMgbXVsdGlwbGUgdGllcnMgaW4gYSBzaW5nbGUgdHJhY2suXG4gICBXb3JrcyBieSBzaW1wbHkgZHJhd2luZyBzZXZlcmFsIHRpZXJzIHRvIGEgc2luZ2xlIGNhbnZhcy5cbiAgIEFjdHVhbCByZW5kZXJpbmcgaXMgZG9uZSB1c2luZyBkZWZhdWx0LXJlbmRlcmVyLmVzNi5cbiAgIEEgbXVsdGktdGllciByZW5kZXJlciBpcyBjb25maWd1cmVkIGJ5IGFkZGluZyB0aGUgZm9sbG93aW5nIHRvIGEgdGllcidzXG4gICBjb25maWd1cmF0aW9uOlxuICAgcmVuZGVyZXI6ICdtdWx0aScsXG4gICBtdWx0aToge1xuICAgICAgIG11bHRpX2lkOiBcIm11bHRpXzFcIixcbiAgIH1cblxuICAgQWxsIHN1YnRpZXJzIHdpdGggdGhlIFwibXVsdGlfMVwiIG11bHRpX2lkIHdpbGwgYmUgZHJhd24gdG8gdGhpcyB0aWVyJ3MgY2FudmFzLlxuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRpZXIoc3RhdHVzLCB0aWVyKSB7XG4gICAgZHJhd1RpZXIodGllcik7XG4gICAgdGllci51cGRhdGVTdGF0dXMoc3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gZHJhd1RpZXIobXVsdGlUaWVyKSB7XG4gICAgbGV0IG11bHRpQ29uZmlnID0gbXVsdGlUaWVyLmRhc1NvdXJjZS5tdWx0aTtcbiAgICBsZXQgZ2V0U3ViQ29uZmlnID0gdCA9PiB0LmRhc1NvdXJjZS5zdWI7XG5cbiAgICBtdWx0aVRpZXIuZ2x5cGhDYWNoZU9yaWdpbiA9IG11bHRpVGllci5icm93c2VyLnZpZXdTdGFydDtcblxuICAgIG11bHRpVGllci5zdWJ0aWVycyA9IFtdO1xuXG4gICAgLy8gUGFkZGluZyBpcyB1c2VkIGZvciBmaW5kaW5nIHRoZSBjb3JyZWN0IGNhbnZhcyBzaXplIGFuZCBtdXN0IGJlIHNldFxuICAgIGlmICghbXVsdGlUaWVyLnBhZGRpbmcpXG4gICAgICAgIG11bHRpVGllci5wYWRkaW5nID0gMztcblxuICAgIGxldCBjYW52YXMgPSBtdWx0aVRpZXIudmlld3BvcnQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCByZXRpbmEgPSBtdWx0aVRpZXIuYnJvd3Nlci5yZXRpbmEgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxO1xuICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgY2FudmFzLnNjYWxlKDIsIDIpO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBvdXQgb25seSB0aWVycyB0aGF0IGFyZSB0byBiZSBkcmF3biBpbiB0aGlzIG11bHRpdGllcixcbiAgICAvLyBhbmQgYWxzbyBoYXZlIGZldGNoZWQgZGF0YS5cbiAgICBsZXQgdGllcnMgPSBtdWx0aVRpZXIuYnJvd3Nlci50aWVycy5cbiAgICAgICAgICAgIGZpbHRlcih0aWVyID0+IHR5cGVvZihnZXRTdWJDb25maWcodGllcikpID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgZ2V0U3ViQ29uZmlnKHRpZXIpLm11bHRpX2lkID09PSBtdWx0aUNvbmZpZy5tdWx0aV9pZCAmJlxuICAgICAgICAgICAgICAgICAgICh0aWVyLmN1cnJlbnRGZWF0dXJlcyB8fCB0aWVyLmN1cnJlbnRTZXF1ZW5jZSkpO1xuXG4gICAgLy8gVGhlIHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gdGhlIHRvcCBvZiB0aGUgY2FudmFzIHRvIGEgc3VidGllclxuICAgIGxldCBtaW5PZmZzZXQgPSBSLnBpcGUoXG4gICAgICAgIFIubWFwKHRpZXIgPT4gdGllci5kYXNTb3VyY2Uuc3ViLm9mZnNldCksXG4gICAgICAgIFIucmVkdWNlKChhY2MsIG9mZnNldCkgPT4gb2Zmc2V0IDwgYWNjID8gb2Zmc2V0IDogYWNjLCAwKVxuICAgICkodGllcnMpO1xuXG5cbiAgICB0aWVycy5mb3JFYWNoKHRpZXIgPT4ge1xuICAgICAgICBpZiAodGllci5zZXF1ZW5jZVNvdXJjZSkge1xuICAgICAgICAgICAgZHJhd1NlcVRpZXIodGllciwgdGllci5jdXJyZW50U2VxdWVuY2UpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGllci5jdXJyZW50RmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGlmICh0aWVyLmRhc1NvdXJjZS5yZW5kZXJlciAhPT0gXCJzdWJcIiAmJiB0aWVyLmRhc1NvdXJjZS5yZW5kZXJlciAhPT0gXCJtdWx0aVwiKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRpZXIuYnJvd3Nlci5nZXRUaWVyUmVuZGVyZXIodGllcik7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucHJlcGFyZVN1YnRpZXJzKHRpZXIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIERlZmF1bHRSZW5kZXJlci5wcmVwYXJlU3VidGllcnModGllciwgY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGllci5zdWJ0aWVycy5mb3JFYWNoKHN0ID0+IHN0Lm9mZnNldCA9IHRpZXIuZGFzU291cmNlLnN1Yi5vZmZzZXQpO1xuXG4gICAgICAgICAgICBtdWx0aVRpZXIuc3VidGllcnMgPSBtdWx0aVRpZXIuc3VidGllcnMuY29uY2F0KHRpZXIuc3VidGllcnMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgY2FudmFzIHNob3VsZCBmaXQgYWxsIHN1YnRpZXJzLCBpbmNsdWRpbmcgb2Zmc2V0cywgYnV0IG5vIG1vcmVcbiAgICBsZXQgY2FudmFzSGVpZ2h0ID0gUi5waXBlKFxuICAgICAgICBSLm1hcCh0aWVyID0+XG4gICAgICAgICAgICAgIFIubWFwKHN1YnRpZXIgPT4gc3VidGllci5oZWlnaHQgKyBnZXRTdWJDb25maWcodGllcikub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICB0aWVyLnN1YnRpZXJzKSksXG4gICAgICAgIFIuZmxhdHRlbixcbiAgICAgICAgUi5yZWR1Y2UoKGFjYywgaCkgPT4gaCA+IGFjYyA/IGggOiBhY2MsIC1JbmZpbml0eSksXG4gICAgICAgIFIuYWRkKC1taW5PZmZzZXQpXG4gICAgKSh0aWVycyk7XG5cbiAgICBwcmVwYXJlVmlld3BvcnQobXVsdGlUaWVyLCBjYW52YXMsIHJldGluYSwgY2FudmFzSGVpZ2h0LCB0cnVlKTtcblxuICAgIHRpZXJzLnNvcnQoKHQxLCB0MikgPT4gZ2V0U3ViQ29uZmlnKHQxKS56ID4gZ2V0U3ViQ29uZmlnKHQyKS56KTtcblxuXG4gICAgdGllcnMuZm9yRWFjaCh0aWVyID0+IHtcbiAgICAgICAgLy8gTmVlZCB0byBzYXZlIGFuZCByZXN0b3JlIGNhbnZhcyB0byBtYWtlIHN1cmUgdGhhdCB0aGUgc3VidGllcnMgYXJlXG4gICAgICAgIC8vIGRyYXduIG9uIHRvcCBvZiBvbmUgYW5vdGhlciwgaWYgbm90IHNoaWZ0ZWQuLi5cbiAgICAgICAgY2FudmFzLnNhdmUoKTtcblxuICAgICAgICAvLyBiZXR0ZXIgdG8gdHJhbnNsYXRlIGhlcmUgdGhhbiBzaG92ZSBhIHlvZmZzZXQgZGVlcCBpbiB0aGUgcmVuZGVyZXJcbiAgICAgICAgY2FudmFzLnRyYW5zbGF0ZSgwLCBnZXRTdWJDb25maWcodGllcikub2Zmc2V0KTtcblxuICAgICAgICBEZWZhdWx0UmVuZGVyZXIucGFpbnQodGllciwgY2FudmFzLCByZXRpbmEpO1xuXG4gICAgICAgIGNhbnZhcy5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAobXVsdGlDb25maWcuZ3JpZCkge1xuICAgICAgICBsZXQgZ3JpZCA9IG5ldyBHcmlkR2x5cGgoY2FudmFzSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlDb25maWcuZ3JpZF9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUNvbmZpZy5ncmlkX3NwYWNpbmcpO1xuICAgICAgICBncmlkLmRyYXcoY2FudmFzKTtcbiAgICB9XG5cbiAgICBtdWx0aVRpZXIuZHJhd092ZXJsYXkoKTtcblxuICAgIGlmIChtdWx0aUNvbmZpZy5xdWFudCkge1xuICAgICAgICBsZXQgcXVhbnRDYW52YXMgPSBEZWZhdWx0UmVuZGVyZXIuY3JlYXRlUXVhbnRPdmVybGF5KG11bHRpVGllciwgY2FudmFzSGVpZ2h0K211bHRpVGllci5wYWRkaW5nKjIsIHJldGluYSk7XG4gICAgICAgIHF1YW50Q2FudmFzLnNhdmUoKTtcbiAgICAgICAgRGVmYXVsdFJlbmRlcmVyLnBhaW50UXVhbnQocXVhbnRDYW52YXMsIG11bHRpVGllciwgbXVsdGlDb25maWcucXVhbnQsIDEwKTtcbiAgICAgICAgcXVhbnRDYW52YXMucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YobXVsdGlUaWVyLmRhc1NvdXJjZS5kcmF3Q2FsbGJhY2spID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FudmFzLnNhdmUoKTtcbiAgICAgICAgbXVsdGlUaWVyLmRhc1NvdXJjZS5kcmF3Q2FsbGJhY2soY2FudmFzLCBtdWx0aVRpZXIpO1xuICAgICAgICBjYW52YXMucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIG11bHRpVGllci5vcmlnaW5IYXh4ID0gMDtcbiAgICBtdWx0aVRpZXIuYnJvd3Nlci5hcnJhbmdlVGllcnMoKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVZpZXdwb3J0KHRpZXIsIGNhbnZhcywgcmV0aW5hLCBjYW52YXNIZWlnaHQsIGNsZWFyPXRydWUpIHtcbiAgICBjYW52YXMuc2F2ZSgpO1xuICAgIGxldCBkZXNpcmVkV2lkdGggPSB0aWVyLmJyb3dzZXIuZmVhdHVyZVBhbmVsV2lkdGggKyAyMDAwO1xuICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgZGVzaXJlZFdpZHRoICo9IDI7XG4gICAgfVxuXG4gICAgbGV0IGZwdyA9IHRpZXIudmlld3BvcnQud2lkdGh8MDtcbiAgICBpZiAoZnB3IDwgZGVzaXJlZFdpZHRoIC0gNTApIHtcbiAgICAgICAgdGllci52aWV3cG9ydC53aWR0aCA9IGZwdyA9IGRlc2lyZWRXaWR0aDtcbiAgICB9XG5cbiAgICBjYW52YXNIZWlnaHQgKz0gMip0aWVyLnBhZGRpbmc7XG4gICAgY2FudmFzSGVpZ2h0ID0gTWF0aC5tYXgoY2FudmFzSGVpZ2h0LCB0aWVyLmJyb3dzZXIubWluVGllckhlaWdodCk7XG5cbiAgICBpZiAoY2FudmFzSGVpZ2h0ICE9IHRpZXIudmlld3BvcnQuaGVpZ2h0KSB7XG4gICAgICAgIHRpZXIudmlld3BvcnQuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgICAgIHRpZXIudmlld3BvcnQuaGVpZ2h0ICo9IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aWVyLnZpZXdwb3J0SG9sZGVyLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgdGllci52aWV3cG9ydC5zdHlsZS53aWR0aCA9IHJldGluYSA/ICgnJyArIChmcHcvMikgKyAncHgnKSA6ICgnJyArIGZwdyArICdweCcpO1xuICAgIHRpZXIudmlld3BvcnQuc3R5bGUuaGVpZ2h0ID0gJycgKyBjYW52YXNIZWlnaHQgKyAncHgnO1xuICAgIHRpZXIubGF5b3V0SGVpZ2h0ID0gIE1hdGgubWF4KGNhbnZhc0hlaWdodCwgdGllci5icm93c2VyLm1pblRpZXJIZWlnaHQpO1xuXG4gICAgdGllci51cGRhdGVIZWlnaHQoKTtcbiAgICB0aWVyLm5vcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgaWYgKGNsZWFyKSB7XG4gICAgICAgIERlZmF1bHRSZW5kZXJlci5jbGVhclZpZXdwb3J0KGNhbnZhcywgZnB3LCBjYW52YXNIZWlnaHQpO1xuICAgIH1cblxuICAgIERlZmF1bHRSZW5kZXJlci5kcmF3VW5tYXBwZWQodGllciwgY2FudmFzLCBjYW52YXNIZWlnaHQpO1xuXG4gICAgY2FudmFzLnJlc3RvcmUoKTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTRcbi8vXG4vLyBtZW1zdG9yZS5qc1xuLy9cblxuZnVuY3Rpb24gZm9ybWF0TG9uZ0ludChuKSB7XG4gICAgcmV0dXJuIChufDApLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJywnKVxufVxuXG5mdW5jdGlvbiBmb3JtYXRRdWFudExhYmVsKHYpIHtcbiAgICB2YXIgdCA9ICcnICsgdjtcbiAgICB2YXIgZG90ID0gdC5pbmRleE9mKCcuJyk7XG4gICAgaWYgKGRvdCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRvdFRocmVzaG9sZCA9IDI7XG4gICAgICAgIGlmICh0LnN1YnN0cmluZygwLCAxKSA9PSAnLScpIHtcbiAgICAgICAgICAgICsrZG90VGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvdCA+PSBkb3RUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnN1YnN0cmluZygwLCBkb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHQuc3Vic3RyaW5nKDAsIGRvdCArIDIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGZvcm1hdExvbmdJbnQ6IGZvcm1hdExvbmdJbnQsXG4gICAgICAgIGZvcm1hdFF1YW50TGFiZWw6IGZvcm1hdFF1YW50TGFiZWxcbiAgICB9O1xufSIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyBvdmVybGF5LmpzOiBmZWF0dXJlc291cmNlcyBjb21wb3NlZCBmcm9tIG11bHRpcGxlIHVuZGVybHlpbmcgc291cmNlc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuICAgIHZhciBhcnJheUluZGV4T2YgPSB1dGlscy5hcnJheUluZGV4T2Y7XG59XG5cbmZ1bmN0aW9uIE92ZXJsYXlGZWF0dXJlU291cmNlKHNvdXJjZXMsIG9wdHMpIHtcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMucmVhZGluZXNzTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmJ1c2luZXNzID0gW107XG4gICAgdGhpcy5yZWFkaW5lc3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuaW5pdE4oaSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihvcHRzLm1lcmdlKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm1lcmdlID0gb3B0cy5tZXJnZTtcbiAgICB9IGVsc2UgaWYgKG9wdHMubWVyZ2UgPT0gJ2NvbmNhdCcpIHtcbiAgICAgICAgdGhpcy5tZXJnZSA9IE92ZXJsYXlGZWF0dXJlU291cmNlX21lcmdlX2NvbmNhdDtcbiAgICB9IGVsc2UgaWYgKG9wdHMubWVyZ2UgPT0gJ2FsdGVybmF0ZXMnKSB7XG4gICAgICAgIHRoaXMubWVyZ2UgPSBPdmVybGF5RmVhdHVyZVNvdXJjZV9tZXJnZV9jb25jYXQ7XG4gICAgICAgIHRoaXMuZmlsdGVyRGlzcGF0Y2hPbk1ldGhvZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZXJnZSA9IE92ZXJsYXlGZWF0dXJlU291cmNlX21lcmdlX2J5S2V5O1xuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmluaXROID0gZnVuY3Rpb24obikge1xuICAgIHZhciBzID0gdGhpcy5zb3VyY2VzW25dO1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5idXNpbmVzc1tuXSA9IDA7XG5cbiAgICBpZiAocy5hZGRBY3Rpdml0eUxpc3RlbmVyKSB7XG4gICAgICAgIHMuYWRkQWN0aXZpdHlMaXN0ZW5lcihmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICB0aGlzQi5idXNpbmVzc1tuXSA9IGI7XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHMuYWRkQ2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgcy5hZGRDaGFuZ2VMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeUNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHMuYWRkUmVhZGluZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgcy5hZGRSZWFkaW5lc3NMaXN0ZW5lcihmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICB0aGlzQi5yZWFkaW5lc3Nbbl0gPSByO1xuICAgICAgICAgICAgdGhpc0Iubm90aWZ5UmVhZGluZXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmFkZFJlYWRpbmVzc0xpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHRoaXMucmVhZGluZXNzTGlzdGVuZXJzLnB1c2gobCk7XG4gICAgdGhpcy5ub3RpZnlSZWFkaW5lc3NMaXN0ZW5lcihsKTtcbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnJlbW92ZVJlYWRpbmVzc0xpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy5yZWFkaW5lc3NMaXN0ZW5lcnMsIGwpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5ub3RpZnlSZWFkaW5lc3MgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVhZGluZXNzTGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMubm90aWZ5UmVhZGluZXNzTGlzdGVuZXIodGhpcy5yZWFkaW5lc3NMaXN0ZW5lcnNbaV0pO1xuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLm5vdGlmeVJlYWRpbmVzc0xpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHZhciByID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVhZGluZXNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWRpbmVzc1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByID0gdGhpcy5yZWFkaW5lc3NbaV07IGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGwocik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5hZGRBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMucHVzaChsKTtcbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnJlbW92ZUFjdGl2aXR5TGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLCBsKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5ub3RpZnlBY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBidXN5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVzaW5lc3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnVzeSArPSB0aGlzLmJ1c2luZXNzW2ldO1xuICAgIH1cblxuICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVyc1tsaV0oYnVzeSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuYWRkQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLmNoYW5nZUxpc3RlbmVycywgbCk7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLm5vdGlmeUNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0aGlzLmNoYW5nZUxpc3RlbmVycy5sZW5ndGg7ICsrbGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzW2xpXSh0aGlzLmJ1c3kpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZXNbMF0uZ2V0U2NhbGVzKCk7XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzWzBdLmdldFN0eWxlU2hlZXQoY2FsbGJhY2spO1xufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuY2FwYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhcHMgPSB7fTtcbiAgICB2YXIgczAgPSB0aGlzLnNvdXJjZXNbMF07XG4gICAgaWYgKHMwLmNhcGFiaWxpdGllcykgXG4gICAgICAgIGNhcHMgPSBzaGFsbG93Q29weShzMC5jYXBhYmlsaXRpZXMoKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc2kgPSB0aGlzLnNvdXJjZXNbaV07XG4gICAgICAgIGlmIChzaS5jYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIHZhciBjbyA9IHNpLmNhcGFiaWxpdGllcygpO1xuICAgICAgICAgICAgaWYgKGNvLnNlYXJjaCkge1xuICAgICAgICAgICAgICAgIGNhcHMuc2VhcmNoID0gY28uc2VhcmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhcHM7XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoX3NvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGhpcy5zb3VyY2VzW2ldLCAnc2VhcmNoJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNbaV0uc2VhcmNoKHF1ZXJ5LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2ssIHN0eWxlRmlsdGVycykge1xuICAgIHZhciBzb3VyY2VzO1xuICAgIGlmICh0aGlzLmZpbHRlckRpc3BhdGNoT25NZXRob2QpIHtcbiAgICAgICAgc291cmNlcyA9IFtdO1xuICAgICAgICB2YXIgc2ZsID0gc3R5bGVGaWx0ZXJzLmxpc3QoKTtcbiAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHRoaXMuc291cmNlcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbc2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IHNmbC5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gc2ZsW2ZpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlci5tZXRob2QgfHwgZmlsdGVyLm1ldGhvZCA9PSBzb3VyY2UubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlcyA9IHRoaXMuc291cmNlcztcbiAgICB9XG5cbiAgICB2YXIgYmF0b24gPSBuZXcgT3ZlcmxheUJhdG9uKHRoaXMsIGNhbGxiYWNrLCBzb3VyY2VzKTtcbiAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc291cmNlcy5sZW5ndGg7ICsrc2kpIHtcblx0ICAgdGhpcy5mZXRjaE4oYmF0b24sIHNpLCBzb3VyY2VzW3NpXSwgY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBzdHlsZUZpbHRlcnMpO1xuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoTiA9IGZ1bmN0aW9uKGJhdG9uLCBzaSwgc291cmNlLCBjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIHN0eWxlRmlsdGVycykge1xuICAgIC8vIEZJWE1FIHNob3VsZCB3ZSB0cnkgdG8gcHJ1bmUgc3R5bGVGaWx0ZXJzP1xuICAgIHNvdXJjZS5mZXRjaChjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGZ1bmN0aW9uKHN0YXR1cywgZmVhdHVyZXMsIHNjYWxlKSB7XG5cdCAgIHJldHVybiBiYXRvbi5jb21wbGV0ZWQoc2ksIHN0YXR1cywgZmVhdHVyZXMsIHNjYWxlKTtcbiAgICB9LCBzdHlsZUZpbHRlcnMpO1xufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUucXVhbnRGaW5kTmV4dEZlYXR1cmUgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCB0aHJlc2hvbGQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc1swXS5xdWFudEZpbmROZXh0RmVhdHVyZShjaHIsIHBvcywgZGlyLCB0aHJlc2hvbGQsIGNhbGxiYWNrKTtcbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc1swXS5maW5kTmV4dEZlYXR1cmUoY2hyLCBwb3MsIGRpciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBPdmVybGF5QmF0b24oc291cmNlLCBjYWxsYmFjaywgc291cmNlcykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMuY291bnQgPSBzb3VyY2VzLmxlbmd0aDtcblxuICAgIHRoaXMucmV0dXJuQ291bnQgPSAwO1xuICAgIHRoaXMuc3RhdHVzQ291bnQgPSAwO1xuICAgIHRoaXMucmV0dXJucyA9IFtdO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBbXVxuICAgIHRoaXMuc3RhdHVzZXMgPSBbXTtcbiAgICB0aGlzLnNjYWxlID0gbnVsbDtcbn1cblxuT3ZlcmxheUJhdG9uLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbihpbmRleCwgc3RhdHVzLCBmZWF0dXJlcywgc2NhbGUpIHtcbiAgICBpZiAodGhpcy5zY2FsZSA9PSBudWxsIHx8IGluZGV4ID09IDApIFxuXHQgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICBpZiAodGhpcy5yZXR1cm5zW2luZGV4XSlcblx0ICAgdGhyb3cgJ011bHRpcGxlIHJldHVybnMgZm9yIHNvdXJjZSAnICsgaW5kZXg7XG5cbiAgICB0aGlzLnJldHVybnNbaW5kZXhdID0gdHJ1ZTtcbiAgICB0aGlzLnJldHVybkNvdW50Kys7XG5cbiAgICB0aGlzLmZlYXR1cmVzW2luZGV4XSA9IGZlYXR1cmVzO1xuXG4gICAgaWYgKHN0YXR1cykge1xuICAgIFx0dGhpcy5zdGF0dXNlc1tpbmRleF0gPSBzdGF0dXM7XG4gICAgXHR0aGlzLnN0YXR1c0NvdW50Kys7XG4gICAgfVxuXG5cbiAgICBpZiAodGhpcy5yZXR1cm5Db3VudCA9PSB0aGlzLmNvdW50KSB7XG4gICAgXHRpZiAodGhpcy5zdGF0dXNDb3VudCA+IDApIHtcbiAgICBcdCAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgIFx0ICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLmNvdW50OyArK3NpKSB7XG4gICAgICAgIFx0XHR2YXIgcyA9IHRoaXMuc3RhdHVzZXNbc2ldO1xuICAgICAgICBcdFx0aWYgKHMpIHtcbiAgICAgICAgXHRcdCAgICBpZiAobWVzc2FnZS5sZW5ndGggPiAwKSBcbiAgICAgICAgXHRcdFx0bWVzc2FnZSArPSAnLCAnO1xuICAgICAgICBcdFx0ICAgIG1lc3NhZ2UgKz0gcztcbiAgICAgICAgXHRcdH1cbiAgICBcdCAgICB9XG4gICAgXHQgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2sobWVzc2FnZSwgbnVsbCwgdGhpcy5zY2FsZSk7XG4gICAgXHR9IGVsc2Uge1xuICAgIFx0ICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgdGhpcy5zb3VyY2UubWVyZ2UodGhpcy5mZWF0dXJlcywgdGhpcy5zb3VyY2VzKSwgdGhpcy5zY2FsZSk7XG4gICAgXHR9XG4gICAgfVxufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZJUHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zb3VyY2VzW3NpXTtcbiAgICAgICAgaWYgKHMuZ2V0RGVmYXVsdEZJUHMpXG4gICAgICAgICAgICBzLmdldERlZmF1bHRGSVBzKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5rZXlGb3JGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHJldHVybiAnJyArIGZlYXR1cmUubWluICsgJy4uJyArIGZlYXR1cmUubWF4O1xufVxuXG5mdW5jdGlvbiBPdmVybGF5RmVhdHVyZVNvdXJjZV9tZXJnZV9ieUtleShmZWF0dXJlU2V0cykge1xuICAgIHZhciBvbWFwcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgZnNpID0gMTsgZnNpIDwgZmVhdHVyZVNldHMubGVuZ3RoOyArK2ZzaSkge1xuICAgICAgICB2YXIgb20gPSB7fTtcbiAgICAgICAgdmFyIG9mID0gZmVhdHVyZVNldHNbZnNpXTtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IG9mLmxlbmd0aDsgKytmaSkge1xuICAgIFx0ICAgb21bdGhpcy5rZXlGb3JGZWF0dXJlKG9mW2ZpXSldID0gb2ZbZmldO1xuICAgICAgICB9XG4gICAgICAgIG9tYXBzLnB1c2gob20pO1xuICAgIH1cblxuXG4gICAgdmFyIG1mID0gW107XG4gICAgdmFyIGZsID0gZmVhdHVyZVNldHNbMF07XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZsLmxlbmd0aDsgKytmaSkge1xuICAgIFx0dmFyIGYgPSBmbFtmaV07XG5cbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IG9tYXBzLmxlbmd0aDsgKytvaSkge1xuICAgICAgICAgICAgdmFyIG9tID0gb21hcHNbb2ldO1xuICAgICAgICBcdG9mID0gb21bdGhpcy5rZXlGb3JGZWF0dXJlKGYpXVxuICAgICAgICBcdGlmIChvZikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT09ICdzY29yZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuc2NvcmUyID0gb2Yuc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ21pbicgfHwgayA9PT0gJ21heCcgfHwgayA9PT0gJ3NlZ21lbnQnIHx8IGsgPT09ICdfY2FjaGVkU3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmW2tdID0gb2Zba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFx0fVxuICAgICAgICB9XG4gICAgXHRtZi5wdXNoKGYpO1xuICAgIH1cbiAgICByZXR1cm4gbWY7XG59XG5cbmZ1bmN0aW9uIE92ZXJsYXlGZWF0dXJlU291cmNlX21lcmdlX2NvbmNhdChmZWF0dXJlU2V0cywgc291cmNlcykge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAodmFyIGZzaSA9IDA7IGZzaSA8IGZlYXR1cmVTZXRzLmxlbmd0aDsgKytmc2kpIHtcbiAgICAgICAgdmFyIGZzID0gZmVhdHVyZVNldHNbZnNpXTtcbiAgICAgICAgdmFyIG5hbWUgPSBzb3VyY2VzW2ZzaV0ubmFtZTtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmc1tmaV07XG4gICAgICAgICAgICBmLm1ldGhvZCA9IG5hbWU7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gX3NvdXJjZUFkYXB0ZXJJc0NhcGFibGUocywgY2FwKSB7XG4gICAgaWYgKCFzLmNhcGFiaWxpdGllcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2UgXG4gICAgICAgIHJldHVybiBzLmNhcGFiaWxpdGllcygpW2NhcF07XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgT3ZlcmxheUZlYXR1cmVTb3VyY2U6IE92ZXJsYXlGZWF0dXJlU291cmNlXG4gICAgfTtcbn1cblxuXG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gYmVkd2lnLmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgVVJMRmV0Y2hhYmxlID0gYmluLlVSTEZldGNoYWJsZTtcbiAgICB2YXIgQmxvYkZldGNoYWJsZSA9IGJpbi5CbG9iRmV0Y2hhYmxlO1xuICAgIHZhciByZWFkSW50ID0gYmluLnJlYWRJbnQ7XG5cbiAgICB2YXIgYmJpID0gcmVxdWlyZSgnLi9iaWd3aWcnKTtcbiAgICB2YXIgQklHX1dJR19NQUdJQyA9IGJiaS5CSUdfV0lHX01BR0lDO1xuICAgIHZhciBCSUdfQkVEX01BR0lDID0gYmJpLkJJR19CRURfTUFHSUM7XG5cbiAgICB2YXIgbGgzdXRpbHMgPSByZXF1aXJlKCcuL2xoM3V0aWxzJyk7XG4gICAgdmFyIHVuYmd6ZiA9IGxoM3V0aWxzLnVuYmd6ZjtcblxuICAgIHZhciBiYW0gPSByZXF1aXJlKCcuL2JhbScpO1xuICAgIHZhciBCQU1fTUFHSUMgPSBiYW0uQkFNX01BR0lDO1xuICAgIHZhciBCQUlfTUFHSUMgPSBiYW0uQkFJX01BR0lDO1xuXG4gICAgdmFyIHRiaSA9IHJlcXVpcmUoJy4vdGFiaXgnKTtcbiAgICB2YXIgVEFCSVhfTUFHSUMgPSB0YmkuVEFCSVhfTUFHSUM7XG5cbiAgICB2YXIgRW5jb2RlRmV0Y2hhYmxlID0gcmVxdWlyZSgnLi9lbmNvZGUnKS5FbmNvZGVGZXRjaGFibGU7XG59XG5cbmZ1bmN0aW9uIHByb2JlUmVzb3VyY2Uoc291cmNlLCBsaXN0ZW5lciwgcmV0cnkpIHtcbiAgICB2YXIgQkVEX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ15cXFxcdytcXFxcc1swLTldK1xcXFxzWzAtOV0rLiokJyk7XG4gICAgdmFyIEtWX1JFR0VYUD0vKFtePV0rKT1cXFwiPyhbXlxcXCJdKylcXFwiPy87XG4gICAgdmFyIFZDRkhFQURfUkUgPSAvXiMjXFxzKmZpbGVmb3JtYXQ9VkNGdjRcXC4uKy87XG5cbiAgICB2YXIgZmV0Y2hhYmxlO1xuICAgIGlmIChzb3VyY2UuYmxvYilcbiAgICAgICAgZmV0Y2hhYmxlID0gbmV3IEJsb2JGZXRjaGFibGUoc291cmNlLmJsb2IpO1xuICAgIGVsc2UgaWYgKHNvdXJjZS50cmFuc3BvcnQgPT0gJ2VuY29kZScpXG4gICAgICAgIGZldGNoYWJsZSA9IG5ldyBFbmNvZGVGZXRjaGFibGUoc291cmNlLnVyaSk7XG4gICAgZWxzZVxuICAgICAgICBmZXRjaGFibGUgPSBuZXcgVVJMRmV0Y2hhYmxlKHNvdXJjZS51cmksIHtjcmVkZW50aWFsczogc291cmNlLmNyZWRlbnRpYWxzfSk7XG5cbiAgICBmZXRjaGFibGUuc2xpY2UoMCwgMTw8MTYpLnNhbHRlZCgpLmZldGNoKGZ1bmN0aW9uKHJlc3VsdCwgZXJyb3IpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghcmV0cnkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UuY3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb2JlUmVzb3VyY2Uoc291cmNlLCBsaXN0ZW5lciwgdHJ1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgXCJDb3VsZG4ndCBmZXRjaCBkYXRhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgICAgICAgdmFyIGxhID0gbmV3IFVpbnQzMkFycmF5KHJlc3VsdCwgMCwgMSk7XG4gICAgICAgIHZhciBtYWdpYyA9IGxhWzBdO1xuICAgICAgICBpZiAobWFnaWMgPT0gQklHX1dJR19NQUdJQyB8fCBtYWdpYyA9PSBCSUdfQkVEX01BR0lDKSB7XG4gICAgICAgICAgICBzb3VyY2UudGllcl90eXBlID0gJ2J3Zyc7XG4gICAgICAgICAgICB2YXIgbmFtZUV4dHJhY3RQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnLz8oW14vXSs/KSguYnd8LmJifC5iaWdXaWd8LmJpZ0JlZCk/JCcpO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbmFtZUV4dHJhY3RQYXR0ZXJuLmV4ZWMoc291cmNlLnVyaSB8fCBzb3VyY2UuYmxvYi5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5uYW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hZ2ljID09IEJBSV9NQUdJQykge1xuICAgICAgICAgICAgc291cmNlLnRpZXJfdHlwZSA9ICdiYWknO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFbMF0gPT0gMzEgfHwgYmFbMV0gPT0gMTM5KSB7XG4gICAgICAgICAgICB2YXIgdW5jID0gdW5iZ3pmKHJlc3VsdCk7XG4gICAgICAgICAgICB2YXIgdW5jYmEgPSBuZXcgVWludDhBcnJheSh1bmMpO1xuICAgICAgICAgICAgbWFnaWMgPSByZWFkSW50KHVuY2JhLCAwKTtcbiAgICAgICAgICAgIGlmIChtYWdpYyA9PSBCQU1fTUFHSUMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UudGllcl90eXBlID0gJ2JhbSc7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVFeHRyYWN0UGF0dGVybiA9IG5ldyBSZWdFeHAoJy8/KFteL10rPykoLmJhbSk/JCcpO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG5hbWVFeHRyYWN0UGF0dGVybi5leGVjKHNvdXJjZS51cmkgfHwgc291cmNlLmJsb2IubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5uYW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hZ2ljID09IFRBQklYX01BR0lDKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnRpZXJfdHlwZSA9ICd0YWJpeC1pbmRleCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hZ2ljID09IDB4Njk2NjIzMjMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UudGllcl90eXBlID0gJ3RhYml4JztcbiAgICAgICAgICAgICAgICBzb3VyY2UucGF5bG9hZCA9ICd2Y2YnO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lRXh0cmFjdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCcvPyhbXi9dKz8pKC52Y2YpPyguZ3opPyQnKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBuYW1lRXh0cmFjdFBhdHRlcm4uZXhlYyhzb3VyY2UudXJpIHx8IHNvdXJjZS5ibG9iLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UubmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbWFnaWMgPSAnICsgbWFnaWMudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIFwiVW5zdXBwb3J0ZWQgZm9ybWF0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhKTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG5cbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwICYmIFZDRkhFQURfUkUudGVzdChsaW5lc1swXSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UudGllcl90eXBlID0gJ21lbXN0b3JlJztcbiAgICAgICAgICAgICAgICBzb3VyY2UucGF5bG9hZCA9ICd2Y2YnO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lRXh0cmFjdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCcvPyhbXi9dKz8pKFxcLnZjZik/JCcpO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG5hbWVFeHRyYWN0UGF0dGVybi5leGVjKHNvdXJjZS51cmkgfHwgc291cmNlLmJsb2IubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmICFzb3VyY2UubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UubmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IGxpbmVzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbbGldLnJlcGxhY2UoJ1xccicsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCdicm93c2VyJykgPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCd0cmFjaycpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heWJlVHlwZSA9ICdiZWQnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rcyA9IGxpbmUuc3BsaXQoL1xccy8pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0aSA9IDE7IHRpIDwgdG9rcy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gS1ZfUkVHRVhQLmV4ZWModG9rc1t0aV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobVsxXSA9PSAndHlwZScgJiYgbVsyXSA9PSAnd2lnZ2xlXzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlVHlwZSA9ICd3aWcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtWzBdID09ICduYW1lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UubmFtZSA9IG1bMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUHJvYmVCZWRXaWcoc291cmNlLCBtYXliZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCdmaXhlZFN0ZXAnKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFByb2JlQmVkV2lnKHNvdXJjZSwgJ3dpZycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCd2YXJpYWJsZVN0ZXAnKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFByb2JlQmVkV2lnKHNvdXJjZSwgJ3dpZycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoQkVEX1JFR0VYUC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFByb2JlQmVkV2lnKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBcIlVuc3VwcG9ydGVkIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgIH0sIHt0aW1lb3V0OiAxNTAwfSk7ICAvLyBUaW1lb3V0IHRvIGNhdGNoIG1peGVkLW9yaWdpbiBjYXNlIG9uIENocm9taXVtLlxufVxuXG5mdW5jdGlvbiBmaW5pc2hQcm9iZUJlZFdpZyhzb3VyY2UsIG1heWJlVHlwZSkge1xuICAgIHNvdXJjZS50aWVyX3R5cGUgPSAnbWVtc3RvcmUnO1xuICAgIHZhciBuYW1lRXh0cmFjdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCcvPyhbXi9dKz8pKC4oYmVkfHdpZykpPyQnKTtcbiAgICB2YXIgbWF0Y2ggPSBuYW1lRXh0cmFjdFBhdHRlcm4uZXhlYyhzb3VyY2UudXJpIHx8IHNvdXJjZS5ibG9iLm5hbWUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXNvdXJjZS5uYW1lKVxuICAgICAgICAgICAgc291cmNlLm5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgaWYgKCFtYXliZVR5cGUgJiYgbWF0Y2hbM10pIHtcbiAgICAgICAgICAgIG1heWJlVHlwZSA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5wYXlsb2FkID0gbWF5YmVUeXBlIHx8ICdiZWQnO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHByb2JlUmVzb3VyY2U6IHByb2JlUmVzb3VyY2VcbiAgICB9O1xufVxuIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuXG5cbmltcG9ydCB7IHJlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnksXG4gICAgICAgICBtYWtlUGFyc2VyLFxuICAgICAgICAgRmVhdHVyZVNvdXJjZUJhc2VcbiAgICAgICB9IGZyb20gXCIuL3NvdXJjZWFkYXB0ZXJzLmpzXCI7XG5cbmltcG9ydCB7IERBU1N0eWxlc2hlZXQsXG4gICAgICAgICBEQVNTdHlsZSxcbiAgICAgICAgIERBU0ZlYXR1cmUsXG4gICAgICAgICBEQVNHcm91cFxuICAgICAgIH0gZnJvbSBcIi4vZGFzLmpzXCI7XG5cbmltcG9ydCAqIGFzIENzdiBmcm9tIFwiLi9jc3YuZXM2XCI7XG5cbmNsYXNzIFF0bE1hcFNvdXJjZSBleHRlbmRzIEZlYXR1cmVTb3VyY2VCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnF0bENzdiA9IENzdi5sb2FkQ3N2KHNvdXJjZS51cmksIHttb2RlOiBcImZpbGVcIn0sIGZ1bmN0aW9uKCkge30pO1xuXG4gICAgfVxuXG4gICAgZmV0Y2goY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY21NaW4gPSBtaW4gLyAxMDAwMDAwO1xuICAgICAgICBsZXQgY21NYXggPSBtYXggLyAxMDAwMDAwO1xuXG4gICAgICAgIGxldCBmZWF0dXJlcyA9IFtdO1xuICAgICAgICBsZXQgcHJldlBvcyA9IDA7XG5cbiAgICAgICAgdGhpcy5xdGxDc3YuZmV0Y2goKHJlc3VsdHMsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocm93W1wiQ2hyXCJdID09PSBjaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSBuZXcgREFTRmVhdHVyZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc2VnbWVudCA9IGNocjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IHJvd1tcIk1iXCJdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubWluID0gcG9zICogMTAwMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5tYXggPSBwb3MgKiAxMDAwMDAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dbXCJMUlNcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc2NvcmUgPSByb3dbXCJMUlNcIl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocm93W1wiTE9EXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnNjb3JlID0gcm93W1wiTE9EXCJdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmVhdHVyZXMsIDEpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxucmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSgncXRsJywgc291cmNlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmZWF0dXJlczogbmV3IFF0bE1hcFNvdXJjZShzb3VyY2UpXG4gICAgfTtcbn0pO1xuIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuXG5pbXBvcnQgeyByZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5LFxuICAgICAgICAgRmVhdHVyZVNvdXJjZUJhc2VcbiAgICAgICB9IGZyb20gXCIuL3NvdXJjZWFkYXB0ZXJzLmpzXCI7XG5cbmltcG9ydCB7IERBU0ZlYXR1cmVcbiAgICAgICB9IGZyb20gXCIuL2Rhcy5qc1wiO1xuXG5pbXBvcnQgKiBhcyBDc3YgZnJvbSBcIi4vY3N2LmVzNlwiO1xuXG5pbXBvcnQgKiBhcyBSIGZyb20gXCJyYW1kYVwiO1xuXG5cbmNsYXNzIFJxdGxHZW5vdHlwZVNvdXJjZSBleHRlbmRzIEZlYXR1cmVTb3VyY2VCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5VUklCYXNlID0gc291cmNlLlVSSUJhc2U7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IG51bGw7XG4gICAgfVxuXG4gICAgZmV0Y2hDb250cm9sKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh0aGlzLnNvdXJjZS5jb250cm9sKTtcblxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvdXJjZS5jb250cm9sVVJJKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgICAgICAgcmVxLm9wZW4oXCJHRVRcIiwgdGhpcy5zb3VyY2UuY29udHJvbFVSSSk7XG5cbiAgICAgICAgICAgICAgICByZXEub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZShKU09OLnBhcnNlKHJlcS5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciB3aGVuIGZldGNoaW5nIGNvbnRyb2wgZmlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25maWd1cmUoY29udHJvbCkge1xuICAgICAgICBpZiAoIWNvbnRyb2wuZ2VubyB8fFxuICAgICAgICAgICAgIWNvbnRyb2wuZ21hcCkge1xuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJSUVRMIGNvbnRyb2wgbWlzY29uZmlndXJlZFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICAgIHRoaXMuZ2Vub0NzdiA9IENzdi5sb2FkQ3N2KHRoaXMuVVJJQmFzZSArIHRoaXMuY29udHJvbC5nZW5vKTtcbiAgICAgICAgdGhpcy5nbWFwQ3N2ID0gQ3N2LmxvYWRDc3YodGhpcy5VUklCYXNlICsgdGhpcy5jb250cm9sLmdtYXApO1xuICAgICAgICB0aGlzLmFsbGVsZXMgPSB0aGlzLmNvbnRyb2wuYWxsZWxlcztcbiAgICAgICAgdGhpcy5nZW5vdHlwZXMgPSB0aGlzLmNvbnRyb2wuZ2Vub3R5cGVzO1xuXG4gICAgICAgIHRoaXMudHJhbnNwb3NlZCA9IFIuZGVmYXVsdFRvKHRydWUsIHRoaXMuc291cmNlLnRyYW5zcG9zZWQpO1xuICAgICAgICB0aGlzLm1hcmtlclBvc2l0aW9ucyA9IHt9O1xuICAgIH1cblxuXG4gICAgZmV0Y2hHbWFwKGNociwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ21hcENzdi5mZXRjaCgocmVzdWx0cywgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgc29ydGVkID0gcmVzdWx0cy5zb3J0KChyMSwgcjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIxLmNociA8IHIyLmNocikgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyMS5jaHIgPiByMi5jaHIpIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiByMS5NYiAtIHIyLk1iO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc29ydGVkLm1hcCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hyID0gcm93LmNocjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbiA9IHJvdy5NYjtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWluICogMTAwMDAwMCArIDEwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4ID0gbWluICsgMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgc29ydGVkLmxlbmd0aC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFJvdyA9IHNvcnRlZFtpbmRleCsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Um93LmNociA9PT0gcm93LmNocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG5leHRSb3cuTWI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWF4ICogMTAwMDAwMCAtIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VyUG9zaXRpb25zW3Jvdy5tYXJrZXJdID0ge2NociwgbWluLCBtYXh9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjaHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmZXRjaEdlbm8oY2hyLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nZW5vQ3N2LmZldGNoKChyZXN1bHRzLCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCByb3cgaG9sZHMgdGhlIG1hcmtlciBhcyB3ZWxsIGFzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGdlbm90eXBlcyBmb3IgYWxsIGluZGl2aWR1YWxzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtlciA9IHJvdy5tYXJrZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gdGhpcy5tYXJrZXJQb3NpdGlvbnNbbWFya2VyXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiwgZm9yIGVhY2ggbWFya2VyLCBhZGQgYWxsIHRoZSBpbmRpdmlkdWFscy5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChpbmRJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpbmRJZCAhPT0gXCJpZFwiIHx8IGluZElkICE9PSBcIm1hcmtlclwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtlclBvc2l0aW9uc1ttYXJrZXJdLmNociA9PT0gY2hyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlID0gbmV3IERBU0ZlYXR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5sYWJlbCA9IG1hcmtlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS50eXBlID0gaW5kSWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5tZXRob2QgPSByb3dbaW5kSWRdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc2VnbWVudCA9IGNocjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5taW4gPSBwb3MubWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLm1heCA9IHBvcy5tYXg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2UgZWFjaCBrZXkgaW4gdGhlIHJlc3VsdHMgaXMgYSBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyb3cpLm1hcChtYXJrZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgIT09IFwiaWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZSA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubWV0aG9kID0gcm93W21hcmtlcl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IHRoaXMubWFya2VyUG9zaXRpb25zW21hcmtlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubWluID0gcG9zLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5tYXggPSBwb3MubWF4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmVhdHVyZXMsIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgZmV0Y2goY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZldGNoaW5nIGdlbm90eXBlIHRyYWNrXCIpO1xuXG4gICAgICAgIGxldCBjbU1pbiA9IG1pbiAvIDEwMDAwMDA7XG4gICAgICAgIGxldCBjbU1heCA9IG1heCAvIDEwMDAwMDA7XG5cblxuICAgICAgICBpZiAodGhpcy5jb250cm9sID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoQ29udHJvbChjaHIsIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuZmV0Y2hHbWFwKGNociwgY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuZmV0Y2hHZW5vKGNociwgY2FsbGJhY2spKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMuZmV0Y2hHbWFwKGNociwgY2FsbGJhY2spXG4gICAgICAgICAgICB0aGlzLmZldGNoR2VubyhjaHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyAudGhlbigoKSA9PiB0aGlzLmZldGNoR2VubyhjaHIsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuXG5yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5KCdycXRsLWdlbm90eXBlJywgc291cmNlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmZWF0dXJlczogbmV3IFJxdGxHZW5vdHlwZVNvdXJjZShzb3VyY2UpXG4gICAgfTtcbn0pO1xuIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgUnVsZXIsIHJ1bGVyRHJhd0NhbGxiYWNrIH07XG5cblxuZnVuY3Rpb24gUnVsZXIob3B0aW9ucykge1xuICAgIGxldCBzZWxmID0gdGhpcztcblxuICAgIHNlbGYudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHNlbGYubWluID0gb3B0aW9ucy5taW47XG4gICAgc2VsZi5tYXggPSBvcHRpb25zLm1heDtcbiAgICBzZWxmLndpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICBzZWxmLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblxuICAgIE9iamVjdC5rZXlzKHNlbGYpLm1hcChrZXkgPT4ge1xuICAgICAgICBpZiAoc2VsZltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogUnVsZXIgb3B0aW9uIFwiICsga2V5ICsgXCIgbm90IHNldFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5SdWxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSdWxlcjtcblxuZnVuY3Rpb24gcnVsZXJEcmF3Q2FsbGJhY2soY2FudmFzLCB0aWVyKSB7XG4gICAgbGV0IHJ1bGVycyA9IHRpZXIuZGFzU291cmNlLnJ1bGVycztcblxuICAgIGlmICghcnVsZXJzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGllciB1c2VzIHJ1bGVyIGNhbGxiYWNrIGJ1dCBoYXMgbm8gcnVsZXJzIVwiKTtcbiAgICB9IGVsc2UgaWYgKCEocnVsZXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicnVsZXJzLmpzOiAncnVsZXJzJyBzaG91bGQgYmUgYW4gQXJyYXlcIik7XG4gICAgfVxuXG5cbiAgICBydWxlcnMubWFwKHIgPT4ge1xuICAgICAgICBsZXQgcnVsZXJZID0gKChyLm1heCAtIHIudmFsdWUpICogci5oZWlnaHQpO1xuICAgICAgICBsZXQgdmlld1dpZHRoID0gdGllci52aWV3cG9ydC53aWR0aDtcbiAgICAgICAgbGV0IG9sZExpbmVXaWR0aCA9IGNhbnZhcy5saW5lV2lkdGg7XG5cbiAgICAgICAgY2FudmFzLnN0cm9rZVN0eWxlID0gci5jb2xvcjtcbiAgICAgICAgY2FudmFzLmJlZ2luUGF0aCgpO1xuICAgICAgICBjYW52YXMubW92ZVRvKC12aWV3V2lkdGgsIHJ1bGVyWSArIHIub2Zmc2V0KTtcbiAgICAgICAgLy8gT3RoZXIgcGFydHMgb2YgdGhlIGNvZGUgcmVseSBvbiBub3QgaGF2aW5nIGNoYW5nZWQgdGhlIGxpbmVXaWR0aC4uLlxuICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIGNoYW5nZSBpdCBiYWNrIHdoZW4gd2UncmUgZG9uZS5cbiAgICAgICAgY2FudmFzLmxpbmVXaWR0aCA9IHIud2lkdGg7XG4gICAgICAgIGNhbnZhcy5saW5lVG8oMip2aWV3V2lkdGgsIHJ1bGVyWSArIHIub2Zmc2V0KTtcbiAgICAgICAgY2FudmFzLnN0cm9rZSgpO1xuICAgICAgICBjYW52YXMubGluZVdpZHRoID0gb2xkTGluZVdpZHRoO1xuICAgIH0pO1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIHNhbXBsZS5qczogZG93bnNhbXBsaW5nIG9mIHF1YW50aXRhdGl2ZSBmZWF0dXJlc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU0ZlYXR1cmUgPSBkYXMuREFTRmVhdHVyZTtcblxuICAgIHZhciBwYXJzZUNpZ2FyID0gcmVxdWlyZSgnLi9jaWdhcicpLnBhcnNlQ2lnYXI7XG5cbiAgICB2YXIgc2hhbGxvd0NvcHkgPSByZXF1aXJlKCcuL3V0aWxzJykuc2hhbGxvd0NvcHk7XG59XG5cbnZhciBfX0RTX1NDQUxFUyA9IFsxLCAyLCA1XTtcblxuZnVuY3Rpb24gZHNfc2NhbGUobikge1xuICAgIHJldHVybiBfX0RTX1NDQUxFU1tuICUgX19EU19TQ0FMRVMubGVuZ3RoXSAqIE1hdGgucG93KDEwLCAobiAvIF9fRFNfU0NBTEVTLmxlbmd0aCl8MCk7XG59XG5cblxuZnVuY3Rpb24gRFNCaW4oc2NhbGUsIG1pbiwgbWF4KSB7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMudG90ID0gMDtcbiAgICB0aGlzLmNudCA9IDA7XG4gICAgdGhpcy5oYXNTY29yZSA9IGZhbHNlO1xuICAgIHRoaXMubWluID0gbWluOyB0aGlzLm1heCA9IG1heDtcbiAgICB0aGlzLmZlYXR1cmVzID0gW107XG59XG5cbmZ1bmN0aW9uIF9mZWF0dXJlT3JkZXIoYSwgYikge1xuICAgIGlmIChhLm1pbiA8IGIubWluKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEubWluID4gYi5taW4pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLm1heCA8IGIubWF4KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGIubWF4ID4gYS5tYXgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuXG5EU0Jpbi5wcm90b3R5cGUuc2NvcmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jbnQgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGFzU2NvcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90IC8gdGhpcy5jbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICAgICAgZmVhdHVyZXMuc29ydChfZmVhdHVyZU9yZGVyKTtcblxuICAgICAgICB2YXIgbWF4U2VlbiA9IC0xMDAwMDAwMDAwMDtcbiAgICAgICAgdmFyIGNvdj0wLCBsYXA9MDtcblxuICAgICAgICBmb3IgKHZhciBmaSA9IDE7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2ZpXTtcbiAgICAgICAgICAgIHZhciBsTWluID0gTWF0aC5tYXgoZi5taW4sIHRoaXMubWluKTtcbiAgICAgICAgICAgIHZhciBsTWF4ID0gTWF0aC5taW4oZi5tYXgsIHRoaXMubWF4KTtcbiAgICAgICAgICAgIGxhcCArPSAobE1heCAtIGxNaW4gKyAxKTtcblxuICAgICAgICAgICAgaWYgKGxNaW4gPiBtYXhTZWVuKSB7XG4gICAgICAgICAgICAgICAgY292ICs9IGxNYXggLSBsTWluICsgMTtcbiAgICAgICAgICAgICAgICBtYXhTZWVuID0gbE1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxNYXggPiBtYXhTZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdiArPSAobE1heCAtIG1heFNlZW4pO1xuICAgICAgICAgICAgICAgICAgICBtYXhTZWVuID0gbE1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY292ID4gMClcbiAgICAgICAgICAgIHJldHVybiAoMS4wICogbGFwKSAvIGNvdjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuXG5EU0Jpbi5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoZi5zY29yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudG90ICs9IGYuc2NvcmU7XG4gICAgICAgIHRoaXMuaGFzU2NvcmUgPSB0cnVlXG4gICAgfVxuXG4gICAgKyt0aGlzLmNudDtcbiAgICB0aGlzLmZlYXR1cmVzLnB1c2goZik7XG59XG5cbmZ1bmN0aW9uIGRvd25zYW1wbGUoZmVhdHVyZXMsIHRhcmdldFJleikge1xuICAgIHZhciBzbiA9IDA7XG4gICAgd2hpbGUgKGRzX3NjYWxlKHNuICsgMSkgPCB0YXJnZXRSZXopIHtcbiAgICAgICAgKytzbjtcbiAgICB9XG4gICAgdmFyIHNjYWxlID0gZHNfc2NhbGUoc24pO1xuXG4gICAgdmFyIGJpblRvdHMgPSBbXTtcbiAgICB2YXIgbWF4QmluID0gLTEwMDAwMDAwMDAwO1xuICAgIHZhciBtaW5CaW4gPSAxMDAwMDAwMDAwMDtcbiAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHZhciBmID0gZmVhdHVyZXNbZmldO1xuICAgICAgICBpZiAoZi5ncm91cHMgJiYgZi5ncm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG93bnNhbXBsZSBjb21wbGV4IGZlYXR1cmVzICg/KVxuICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbkxhcCA9IChmLm1pbiAvIHNjYWxlKXwwO1xuICAgICAgICB2YXIgbWF4TGFwID0gKGYubWF4IC8gc2NhbGUpfDA7XG4gICAgICAgIG1heEJpbiA9IE1hdGgubWF4KG1heEJpbiwgbWF4TGFwKTtcbiAgICAgICAgbWluQmluID0gTWF0aC5taW4obWluQmluLCBtaW5MYXApO1xuICAgICAgICBmb3IgKHZhciBiID0gbWluTGFwOyBiIDw9IG1heExhcDsgKytiKSB7XG4gICAgICAgICAgICB2YXIgYm0gPSBiaW5Ub3RzW2JdO1xuICAgICAgICAgICAgaWYgKCFibSkge1xuICAgICAgICAgICAgICAgIGJtID0gbmV3IERTQmluKHNjYWxlLCBiICogc2NhbGUsIChiICsgMSkgKiBzY2FsZSAtIDEpO1xuICAgICAgICAgICAgICAgIGJpblRvdHNbYl0gPSBibTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJtLmZlYXR1cmUoZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2FtcGxlZEZlYXR1cmVzID0gW107XG4gICAgZm9yICh2YXIgYiA9IG1pbkJpbjsgYiA8PSBtYXhCaW47ICsrYikge1xuICAgICAgICB2YXIgYm0gPSBiaW5Ub3RzW2JdO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICAgIHZhciBmID0gbmV3IERBU0ZlYXR1cmUoKTtcbiAgICAgICAgICAgIGYuc2VnbWVudCA9IGZlYXR1cmVzWzBdLnNlZ21lbnQ7XG4gICAgICAgICAgICBmLm1pbiA9IChiICogc2NhbGUpICsgMTtcbiAgICAgICAgICAgIGYubWF4ID0gKGIgKyAxKSAqIHNjYWxlO1xuICAgICAgICAgICAgZi5zY29yZSA9IGJtLnNjb3JlKCk7XG4gICAgICAgICAgICBmLnR5cGUgPSAnZGVuc2l0eSc7XG4gICAgICAgICAgICBzYW1wbGVkRmVhdHVyZXMucHVzaChmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZnRlckRTID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gc2FtcGxlZEZlYXR1cmVzO1xufVxuXG4vKiogRGF0YSBzdHJ1Y3R1cmUgdG8gc3RvcmUgaW5mb3JtYXRpb24gZm9yXG5hIGJhc2UgcG9zaXRpb246XG5cbnBvczogcG9zaXRpb24gb2YgdGhlIGJhc2UuXG4qL1xuZnVuY3Rpb24gQmFzZUJpbihwb3MpIHtcblxuICAgIHRoaXMuX3BvcyA9IHBvcztcbiAgICB0aGlzLl9iYXNlcyA9IHt9O1xuICAgIHRoaXMuX3RvdGFsQ291bnQgPSAwO1xufVxuXG4vKiogS2VlcCByZWNvcmQgZm9yIGluY2lkZW5jZSBvZiBhIGJhc2UsXG53aXRoIHJlbGF0ZWQgcXVhbCBzY29yZSBhbmQgc3RyYW5kIGZvciBhIHBvc2l0aW9uLlxuXG5QYXJhbXNcbiAgICBiYXNlOiBiYXNlIChlLmcgQSwgVCwgRywgQywgTikgb2JzZXJ2ZWQgYXQgcG9zaXRpb24uXG4gICAgcXVhbDogbnVtZXJpYyBxdWFsaXR5IHNjb3JlLlxuICAgIHN0cmFuZDogJysnIG9yICctJy5cbiovXG5CYXNlQmluLnByb3RvdHlwZS5yZWNvcmRCYXNlID0gZnVuY3Rpb24oYmFzZSwgcXVhbCwgc3RyYW5kKSB7XG4gICAgaWYgKCF0aGlzLl9iYXNlc1tiYXNlXSkge1xuICAgICAgICB2YXIgc3RyYW5kQ29tcG9zaXRpb24gPSB7JysnOiAwLCAnLSc6IDB9O1xuICAgICAgICBzdHJhbmRDb21wb3NpdGlvbltzdHJhbmRdKys7XG4gICAgICAgIHRoaXMuX2Jhc2VzW2Jhc2VdID0ge1xuICAgICAgICAgICAgY250OiAxLFxuICAgICAgICAgICAgdG90YWxRdWFsOiBxdWFsLFxuICAgICAgICAgICAgc3RyYW5kQ250OiBzdHJhbmRDb21wb3NpdGlvblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlQ29tcG9zaXRpb24gPSB0aGlzLl9iYXNlc1tiYXNlXTtcbiAgICAgICAgYmFzZUNvbXBvc2l0aW9uLmNudCsrO1xuICAgICAgICBiYXNlQ29tcG9zaXRpb24udG90YWxRdWFsICs9IHF1YWw7XG4gICAgICAgIGJhc2VDb21wb3NpdGlvbi5zdHJhbmRDbnRbc3RyYW5kXSsrO1xuICAgIH1cbiAgICB0aGlzLl90b3RhbENvdW50Kys7XG59O1xuXG4vKiogUmV0dXJucyBjb3VudCBvZiB0b3RhbCBudW1iZXIgb2YgYmFzZXMgb2JzZXJ2ZWQgYXQgcG9zaXRpb24gKi9cbkJhc2VCaW4ucHJvdG90eXBlLnRvdGFsQ291bnQgPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fdG90YWxDb3VudDt9O1xuXG4vKiogUmV0dXJucyB0aGUgYmFzZSBwb3NpdGlvbiAqL1xuQmFzZUJpbi5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX3Bvczt9O1xuXG4vKiogQ3JlYXRlcyBhIGxpc3Qgb2YgdGFnLCBpbmZvIHBhaXJzIGluIHRoZSBmb3JtXG5bdGFnXT1baW5mb10gZm9yIGVhY2ggYmFzZSwgZm9yIHVzZSBpbiBmZWF0dXJlLXBvcHVwICovXG5CYXNlQmluLnByb3RvdHlwZS5pbmZvTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmZvID0gW107XG4gICAgdmFyIHRvdGFsQ291bnQgPSB0aGlzLl90b3RhbENvdW50O1xuICAgIHZhciB0b3RhbENvdW50U3RyID0gXCJEZXB0aD1cIiArIHRvdGFsQ291bnQudG9TdHJpbmcoKTtcbiAgICBpbmZvLnB1c2godG90YWxDb3VudFN0cik7XG4gICAgZm9yICh2YXIgYmFzZSBpbiB0aGlzLl9iYXNlcykge1xuICAgICAgICB2YXIgYmFzZUNvbXBvc2l0aW9uID0gdGhpcy5fYmFzZXNbYmFzZV07XG4gICAgICAgIHZhciBiYXNlQ250ID0gYmFzZUNvbXBvc2l0aW9uLmNudDtcbiAgICAgICAgdmFyIGJhc2VQZXJjZW50YWdlID0gKGJhc2VDbnQgKiAxMDAgLyB0b3RhbENvdW50KTsgXG4gICAgICAgIHZhciBwbHVzU3RyYW5kQ250ID0gYmFzZUNvbXBvc2l0aW9uLnN0cmFuZENudFsnKyddO1xuICAgICAgICB2YXIgbWludXNTdHJhbmRDbnQgPSBiYXNlQ29tcG9zaXRpb24uc3RyYW5kQ250WyctJ107XG4gICAgICAgIHZhciBtZWFuUXVhbCA9IGJhc2VDb21wb3NpdGlvbi50b3RhbFF1YWwvYmFzZUNudDtcblxuICAgICAgICB2YXIgYmFzZUluZm9TdHJpbmcgPSBbYmFzZSwgJz0nLCBiYXNlQ250LCAnICgnLCBiYXNlUGVyY2VudGFnZS50b0ZpeGVkKDApLCAnJSwgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdXNTdHJhbmRDbnQsICcgKywgJywgbWludXNTdHJhbmRDbnQsICcgLSwgUXVhbDogJywgbWVhblF1YWwudG9GaXhlZCgwKSwgJyknXTtcbiAgICAgICAgaW5mby5wdXNoKGJhc2VJbmZvU3RyaW5nLmpvaW4oJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG59O1xuXG4vKiogUmV0dXJuIGEgbGlzdCBvZiBvYmplY3RzIGZvciBjcmVhdGluZyBhXG5oaXN0b2dyYW0gc2hvd2luZyBjb21wb3NpdGlvbiBvZiBkaWZmZXJlbnQgYmFzZXMgYXQgYVxuZ2l2ZW4gbG9jYXRpb24uXG5cbkN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXMgaGFja3k6IHRoZSBsb2dpYyBpbnZvbHZlc1xub3ZlcmxheWluZyBCb3hHbHlwaHMgb24gdG9wIG9mIGVhY2ggb3RoZXIsIHRodXMgdGhlIHNjb3JlXG5pcyBub3QgbWVhbmluZ2Z1bCwgYnV0IG9ubHkgdXNlZCB0byBtYW5pcHVsYXRlIGhlaWdodC5cblxuUGFyYW1zOlxuICByZWY6IHJlZmVyZW5jZSBiYXNlIGF0IHBvc2l0aW9uXG4gIHRocmVzaG9sZDogdmFsdWUgYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyBtaW4gYWxsZWxlIGZyZXF1ZW5jeVxuICAgICAgICAgICAgICBiZWxvdyB3aGljaCB0aGUgYWxsZWxlIHdpbGwgYmUgaWdub3JlZCBpbiBoaXN0b2dyYW0uXG4gICAgICAgICAgICAgIChpbnRlcnByZXRlZCBhcyBub2lzZSlcbiAgICAgICAgICAgICAgU2ltaWxhciB0byAnYWxsZWxlIHRocmVzaG9sZCcgcGFyYW1ldGVyIGluIElHVlxuXG5SZXR1cm5zIGEgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgMiBwcm9wZXJ0aWVzXG4gICAgYmFzZTogc3VjaCBhcyBBLCBULCBHLCBDLCBOLCAtIChkZWwpXG4gICAgc2NvcmU6IGEgbnVtZXJpYyBzY29yZSBmb3IgZGV0ZXJtaW5pbmcgaGVpZ2h0IG9mIGhpc3RvZ3JhbVxuVGhlIGxpc3QgaXMgb3JkZXJlZCBzdWNoIHRoYXQgYSBwcmVjZWVkaW5nIG9iamVjdCBhbHdheXMgaGF2ZSBhXG5zY29yZSA+PSB0aGUgY3VycmVudCBvYmplY3QsIGFuZCB0aGUgcmVmIGJhc2Ugd2lsbCBiZSB0aGUgbGFzdCBpdGVtLlxuXG5FeGFtcGxlOiBUaGVyZSBhcmUgNTAgVCdzIGFuZCA0MCBBJ3MgKHRvdGFsIGRlcHRoID0gOTApXG5hdCBhIGJhc2Ugd2hlcmUgcmVmPUEuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVyblxuW1Q6IDkwLCBBOiA0MF0uIFdoZW4gY3JlYXRpbmcgYSBoaXN0b2dyYW0gd2l0aCBvdmVybGFwLFxudGhpcyB3aWxsIGdpdmUgYW4gYXBwZWFyYW5jZSBvZiA0MCBBJ3MgKGJvdHRvbSkgYW5kIDUwIFQncyAodG9wKTpcbiMjIyMjIyNcbiMgIFQgICNcbiMgIFQgICNcbiMgIFQgICNcbiMgIFQgICNcbiMgIFQgICNcbiMjIyMjIyNcbiMgIEEgICNcbiMgIEEgICNcbiMgIEEgICNcbiMgIEEgICNcbiMjIyMjIyNcbiovXG5CYXNlQmluLnByb3RvdHlwZS5iYXNlU2NvcmVMaXN0ID0gZnVuY3Rpb24ocmVmLCB0aHJlc2hvbGQpIHtcbiAgICB2YXIgYmFzZVNjb3JlTGlzdCA9IFtdO1xuICAgIHZhciB0b3RhbENvdW50ID0gdGhpcy5fdG90YWxDb3VudDtcbiAgICB2YXIgbWluQ291bnQgPSB0aHJlc2hvbGQgKiB0b3RhbENvdW50O1xuICAgIGZvciAodmFyIGJhc2UgaW4gdGhpcy5fYmFzZXMpIHtcbiAgICAgICAgdmFyIGJhc2VDb3VudCA9IHRoaXMuX2Jhc2VzW2Jhc2VdLmNudDtcbiAgICAgICAgaWYgKGJhc2VDb3VudCA8IG1pbkNvdW50IHx8IGJhc2UgPT0gcmVmKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBiYXNlU2NvcmVQYWlyID0ge2Jhc2U6IGJhc2UsIHNjb3JlOiB0b3RhbENvdW50fTtcbiAgICAgICAgYmFzZVNjb3JlTGlzdC5wdXNoKGJhc2VTY29yZVBhaXIpO1xuICAgICAgICB0b3RhbENvdW50IC09IGJhc2VDb3VudDtcbiAgICB9XG4gICAgYmFzZVNjb3JlTGlzdC5wdXNoKHtiYXNlOiByZWYsIHNjb3JlOiB0b3RhbENvdW50fSk7XG4gICAgcmV0dXJuIGJhc2VTY29yZUxpc3Q7XG59O1xuXG4vKiogR2VuZXJhdGVzIGFuIGFsaWduZWQgcmVhZCBmcm9tIHRoZSByYXcgc2VxdWVuY2Ugb2YgYSBCQU0gcmVjb3JkXG51c2luZyBnaXZlbiBjaWdhciBzdHJpbmcuXG5cblBhcmFtczpcbiAgcmF3c2VxOiB1bmFsaWduZWQgcmVhZCBzZXF1ZW5jZSBmcm9tIEJhbSByZWNvcmRcbiAgcmF3cXVhbHM6IHVuYWxpZ25lZCByZWFkIHF1YWxzIGZyb20gQmFtIHJlY29yZFxuICBjaWdhcjogQmFtIGNpZ2FyIHN0cmluZyBmcm9tIEJhbSByZWNvcmRcblxuUmV0dXJucyBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXM6XG4gIHNlcTogc3RyaW5nIGNvbnRhaW5pbmcgYWxpZ25lZCByZWFkXG4gIHF1YWxzOiBzdHJpbmcgY29udGFpbmluZyBwcmludGFibGUtY2hhcmFjdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICBvZiBzZXF1ZW5jaW5nIHF1YWxpdHkgc2NvcmVcbiovXG5mdW5jdGlvbiBhbGlnblNlcVVzaW5nQ2lnYXIocmF3c2VxLCByYXdxdWFscywgY2lnYXIpIHtcbiAgICB2YXIgb3BzID0gcGFyc2VDaWdhcihjaWdhcik7XG4gICAgdmFyIHNlcSA9IFtdO1xuICAgIHZhciBxdWFscyA9IFtdO1xuICAgIHZhciBjdXJzb3IgPSAwO1xuICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBvcHMubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgIHZhciBjbyA9IG9wc1tjaV07XG4gICAgICAgIGlmIChjby5vcCA9PSAnTScpIHtcbiAgICAgICAgICAgIHNlcS5wdXNoKHJhd3NlcS5zdWJzdHIoY3Vyc29yLCBjby5jbnQpKTtcbiAgICAgICAgICAgIHF1YWxzLnB1c2gocmF3cXVhbHMuc3Vic3RyKGN1cnNvciwgY28uY250KSk7XG4gICAgICAgICAgICBjdXJzb3IgKz0gY28uY250O1xuICAgICAgICB9IGVsc2UgaWYgKGNvLm9wID09ICdEJykge1xuICAgICAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IGNvLmNudDsgKytvaSkge1xuICAgICAgICAgICAgICAgIHNlcS5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgcXVhbHMucHVzaCgnWicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvLm9wID09ICdJJykge1xuICAgICAgICAgICAgY3Vyc29yICs9IGNvLmNudDtcbiAgICAgICAgfSBlbHNlIGlmIChjby5vcCA9PSAnUycpIHtcbiAgICAgICAgICAgIGN1cnNvciArPSBjby5jbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndW5rbm93biBjaWdvcCcgKyBjby5vcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHByb2Nlc3NlZFNlcSA9IHtzZXE6IHNlcS5qb2luKCcnKSwgcXVhbHM6IHF1YWxzLmpvaW4oJycpfTtcbiAgICByZXR1cm4gcHJvY2Vzc2VkU2VxO1xufVxuXG4vKiogQ29uc3RydWN0cyB0aGUgcmVmZXJlbmNlIHNlcXVlbmNlIGZvciBhIGdpdmVuIHdpbmRvdy5cblxuUGFyYW1zXG4gICAgY3VycmVudFNlcXVlbmNlOiBEYXNTZXF1ZW5jZSBvYmplY3QgY29udGFpbmluZyByZWYgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgIGluIGN1cnJlbnQgYnJvd3NlciB2aWV3LlxuICAgIG1pbiwgbWF4OiBtaW4gYW5kIG1heCBwb3NpdGlvbiBmb3Igd2luZG93LlxuXG5SZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHJlZnNlcSwgcGFkZGVkIHdpdGggJ04nIHdoZXJlIHNlcXVlbmNlIGlzIG5vdFxuICAgIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRSZWZTZXEoY3VycmVudFNlcXVlbmNlLCBtaW4sIG1heCkge1xuICAgIHZhciByZWZTZXEgPSBbXTtcbiAgICBpZiAoY3VycmVudFNlcXVlbmNlKSB7XG4gICAgICAgIHZhciBjc1N0YXJ0ID0gY3VycmVudFNlcXVlbmNlLnN0YXJ0fDA7XG4gICAgICAgIHZhciBjc0VuZCA9IGN1cnJlbnRTZXF1ZW5jZS5lbmR8MDtcbiAgICAgICAgaWYgKGNzU3RhcnQgPD0gbWF4ICYmIGNzRW5kID49IG1pbikge1xuICAgICAgICAgICAgdmFyIHNmTWluID0gTWF0aC5tYXgobWluLCBjc1N0YXJ0KTtcbiAgICAgICAgICAgIHZhciBzZk1heCA9IE1hdGgubWluKG1heCwgY3NFbmQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNmTWluIC0gbWluOyBpKyspXG4gICAgICAgICAgICAgICAgcmVmU2VxLnB1c2goJ04nKTtcbiAgICAgICAgICAgIHJlZlNlcS5wdXNoKGN1cnJlbnRTZXF1ZW5jZS5zZXEuc3Vic3RyKHNmTWluIC0gY3NTdGFydCwgc2ZNYXggLSBzZk1pbiArIDEpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4IC0gc2ZNYXg7IGkrKylcbiAgICAgICAgICAgICAgICByZWZTZXEucHVzaCgnTicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZTZXEuam9pbignJyk7XG59XG5cbi8qKiBDb25zdHJ1Y3RzIGZlYXR1cmVzIG5lY2Vzc2FyeSBmb3IgYSBjb3ZlcmFnZSB0cmFjayBzaG93aW5nXG5iYXNlIGNvbXBvc2l0aW9uIGZvciBCQU0gcmVhZHNcblxuUGFyYW1zXG4gICAgZmVhdHVyZXM6IGEgbGlzdCBvZiBmZWF0dXJlcyBmcm9tIEJBTSByZWNvcmRzLlxuICAgIGN1cnJlbnRSZWZTZXE6IGEgREFTU2VxdWVuY2Ugb2JqZWN0IGNvbnRhaW5pbmcgcmVmZXJlbmNlIHNlcXVlbmNlLlxuICAgIGJhc2VDb2xvcnM6IGFuIG9iamVjdCBtYXBwaW5nIGJhc2UgdG8gZGVzaXJlZCBjb2xvcnMuXG5cblJldHVybnMgYSBsaXN0IG9mIGZlYXR1cmVzIG9mIHR5cGUgYmFzZS1jb3ZlcmFnZS5cbiovXG5mdW5jdGlvbiBnZXRCYXNlQ292ZXJhZ2UoZmVhdHVyZXMsIGN1cnJlbnRSZWZTZXEsIGJhc2VDb2xvcnMpIHtcbiAgICB2YXIgbWluQmluID0gbnVsbDtcbiAgICB2YXIgbWF4QmluID0gbnVsbDtcblxuICAgIHZhciBhbGxCaW5zID0gW107XG5cbiAgICAvLyBQb3B1bGF0ZSBCYXNlQmluc1xuICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmZWF0dXJlcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgdmFyIGYgPSBmZWF0dXJlc1tmaV07XG4gICAgICAgIGlmIChmLmdyb3VwcyAmJiBmLmdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBkb3duc2FtcGxlIGNvbXBsZXggZmVhdHVyZXNcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvY2Vzc2VkU2VxID0gYWxpZ25TZXFVc2luZ0NpZ2FyKGYuc2VxLCBmLnF1YWxzLCBmLmNpZ2FyKTtcbiAgICAgICAgdmFyIHNlcSA9IHByb2Nlc3NlZFNlcS5zZXE7XG4gICAgICAgIHZhciBxdWFscyA9IHByb2Nlc3NlZFNlcS5xdWFscztcbiAgICAgICAgdmFyIHN0cmFuZCA9IGYub3JpZW50YXRpb247XG4gICAgICAgIHZhciBtaW5Gb3JGZWF0dXJlID0gZi5taW4gfHwgMDtcbiAgICAgICAgdmFyIG1heEZvckZlYXR1cmUgPSBmLm1heCB8fCAwO1xuICAgICAgICB2YXIgaW5kID0gMDtcblxuICAgICAgICBmb3IgKHZhciBiID0gbWluRm9yRmVhdHVyZTsgYiA8PSBtYXhGb3JGZWF0dXJlOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBibSA9IGFsbEJpbnNbYl07XG4gICAgICAgICAgICBpZiAoIWJtKSB7XG4gICAgICAgICAgICAgICAgYm0gPSBuZXcgQmFzZUJpbihiKTtcbiAgICAgICAgICAgICAgICBhbGxCaW5zW2JdID0gYm07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmFzZSA9IHNlcS5jaGFyQXQoaW5kKTtcbiAgICAgICAgICAgIHZhciBxdWFsID0gcXVhbHMuY2hhckNvZGVBdChpbmQpIC0gMzM7IC8vIEdlbmVyYXRlIG51bWVyaWMgcXVhbCBzY29yZVxuICAgICAgICAgICAgYm0ucmVjb3JkQmFzZShiYXNlLCBxdWFsLCBzdHJhbmQpO1xuICAgICAgICAgICAgaW5kKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1pbkJpbilcbiAgICAgICAgICAgIG1pbkJpbiA9IG1pbkZvckZlYXR1cmU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1pbkJpbiA9IE1hdGgubWluKG1pbkJpbiwgbWluRm9yRmVhdHVyZSk7XG4gICAgICAgIGlmICghbWF4QmluKVxuICAgICAgICAgICAgbWF4QmluID0gbWF4Rm9yRmVhdHVyZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF4QmluID0gTWF0aC5tYXgobWF4QmluLCBtYXhGb3JGZWF0dXJlKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBjb3ZlcmFnZSBmZWF0dXJlc1xuICAgIHZhciByZWZTZXEgPSBnZXRSZWZTZXEoY3VycmVudFJlZlNlcSwgbWluQmluLCBtYXhCaW4pO1xuICAgIHZhciBiYXNlRmVhdHVyZXMgPSBbXTtcbiAgICB2YXIgaW5kID0gMDtcbiAgICBmb3IgKHZhciBiID0gbWluQmluOyBiIDw9IG1heEJpbjsgKytiKSB7XG4gICAgICAgIHZhciBibSA9IGFsbEJpbnNbYl07XG4gICAgICAgIGlmIChibSkge1xuICAgICAgICAgICAgdmFyIGYgPSBuZXcgREFTRmVhdHVyZSgpO1xuICAgICAgICAgICAgZi5zZWdtZW50ID0gZmVhdHVyZXNbMF0uc2VnbWVudDtcbiAgICAgICAgICAgIGYubWluID0gYm0ucG9zKCk7XG4gICAgICAgICAgICBmLm1heCA9IGYubWluO1xuICAgICAgICAgICAgZi5ub3RlcyA9IFtdO1xuICAgICAgICAgICAgZi5ub3RlcyA9IGYubm90ZXMuY29uY2F0KGJtLmluZm9MaXN0KCkpO1xuICAgICAgICAgICAgZi50eXBlID0gJ2Jhc2UtY292ZXJhZ2UnO1xuICAgICAgICAgICAgZi5zdXBwcmVzc1Njb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChyZWZTZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmQmFzZSA9IHJlZlNlcS5jaGFyQXQoaW5kKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmU3RyaW5nID0gJ1JlZj0nICsgcmVmQmFzZTtcbiAgICAgICAgICAgICAgICBmLm5vdGVzLnVuc2hpZnQocmVmU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVNjb3JlTGlzdCA9IGJtLmJhc2VTY29yZUxpc3QocmVmQmFzZSwgMC4yKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaGlmdCAwLjIgdGhyZXNob2xkIHRvIGEgY29uZmlnIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZVNjb3JlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IGJhc2VTY29yZUxpc3RbaV0uYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gYmFzZVNjb3JlTGlzdFtpXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZCYXNlID0gc2hhbGxvd0NvcHkoZik7XG4gICAgICAgICAgICAgICAgICAgIGZCYXNlLnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbG9yIGJ5IGJhc2VDb2xvciB3aGVuIG1pc21hdGNoIG9jY3Vyc1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIEJveEdseXBoIHRvIENPTE9SMSBpbiBzdHlsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVNjb3JlTGlzdC5sZW5ndGggPiAxIHx8IGJhc2UgIT0gcmVmQmFzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZCYXNlLml0ZW1SZ2IgPSBiYXNlQ29sb3JzW2Jhc2VdO1xuXG4gICAgICAgICAgICAgICAgICAgIGJhc2VGZWF0dXJlcy5wdXNoKGZCYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIHJlZlNlcSwgb25seSBzaG93IGNvdmVyYWdlIGhlaWdodC5cbiAgICAgICAgICAgICAgICBiYXNlRmVhdHVyZXMucHVzaChmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmQgKys7XG4gICAgfVxuICAgIHJldHVybiBiYXNlRmVhdHVyZXM7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZG93bnNhbXBsZTogZG93bnNhbXBsZSxcbiAgICAgICAgZ2V0QmFzZUNvdmVyYWdlOiBnZXRCYXNlQ292ZXJhZ2VcbiAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMVxuLy9cbi8vIGJpbi5qcyBnZW5lcmFsIGJpbmFyeSBkYXRhIHN1cHBvcnRcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi9jYnJvd3NlcicpO1xuICAgIHZhciBCcm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xuXG4gICAgdmFyIGJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG4gICAgdmFyIFVSTEZldGNoYWJsZSA9IGJpbi5VUkxGZXRjaGFibGU7XG5cbiAgICB2YXIgY29ubmVjdFRyaXggPSByZXF1aXJlKCcuL3RyaXgnKS5jb25uZWN0VHJpeDtcbn1cblxudmFyIFJFR0lPTl9QQVRURVJOID0gL14oW1xcZCssXFx3LFxcLixcXF8sXFwtXSspW1xcczpdKyhbMC05LFxcLl0rPykoW0trTW1HZ10pPygoLXxcXC5cXC58XFxzKSsoWzAtOSxcXC5dKykoW0trTW1HZ10pPyk/JC87XG5cbmZ1bmN0aW9uIHBhcnNlTG9jQ2FyZGluYWwobiwgbSkge1xuICAgIHZhciBpID0gcGFyc2VGbG9hdChuLnJlcGxhY2UoLywvZywgJycpKTtcbiAgICBpZiAobSA9PT0gJ2snIHx8IG0gPT09ICdLJykge1xuICAgICAgICByZXR1cm4gKGkgKiAxMDAwKXwwO1xuICAgIH0gZWxzZSBpZiAobSA9PSAnbScgfHwgbSA9PT0gJ00nKSB7XG4gICAgICAgIHJldHVybiAoaSAqIDEwMDAwMDApfDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl8MDtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKGcsIHN0YXR1c0NhbGxiYWNrLCBvcHRzKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgc3JQYWRkaW5nID0gb3B0cy5wYWRkaW5nIHx8IHRoaXMuZGVmYXVsdFNlYXJjaFJlZ2lvblBhZGRpbmc7XG4gICAgXG4gICAgdmFyIG0gPSBSRUdJT05fUEFUVEVSTi5leGVjKGcpO1xuXG4gICAgaWYgKG0pIHtcbiAgICAgICAgdmFyIGNociA9IG1bMV0sIHN0YXJ0LCBlbmQ7XG4gICAgICAgIGlmIChtWzZdKSB7XG4gICAgICAgICAgICBzdGFydCA9IHBhcnNlTG9jQ2FyZGluYWwobVsyXSwgIG1bM10pO1xuICAgICAgICAgICAgZW5kID0gcGFyc2VMb2NDYXJkaW5hbChtWzZdLCBtWzddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgICAgIHN0YXJ0ID0gKHBhcnNlTG9jQ2FyZGluYWwobVsyXSwgbVszXSkgLSAod2lkdGgvMikpfDA7XG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIHdpZHRoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldExvY2F0aW9uKGNociwgc3RhcnQsIGVuZCwgc3RhdHVzQ2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZyB8fCBnLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VhcmNoQ291bnQgPSAwO1xuICAgICAgICB2YXIgZm91bmRMYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBzZWFyY2hDYWxsYmFjayA9IGZ1bmN0aW9uKGZvdW5kLCBlcnIpIHtcbiAgICAgICAgICAgIC0tc2VhcmNoQ291bnQ7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1c0NhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmQpIGZvdW5kID0gW107XG4gICAgICAgICAgICB2YXIgbWluID0gNTAwMDAwMDAwLCBtYXggPSAtMTAwMDAwMDAwO1xuICAgICAgICAgICAgdmFyIG5jaHIgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZvdW5kLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gZm91bmRbZmldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG5jaHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuY2hyID0gZi5zZWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGYubWluKTtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGYubWF4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuY2hyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaENvdW50ID09IDAgJiYgIWZvdW5kTGF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXNDYWxsYmFjayhcIm5vIG1hdGNoIGZvciAnXCIgKyBnICsgXCInXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3VuZExhdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzQi5oaWdobGlnaHRSZWdpb24obmNociwgbWluLCBtYXgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1pZCA9ICgobWF4K21pbikvMil8MFxuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nID0gTWF0aC5tYXgoc3JQYWRkaW5nLCAoMC4zICogKG1heCAtIG1pbiArIDEpKXwwKTtcbiAgICAgICAgICAgICAgICB0aGlzQi5zZXRMb2NhdGlvbihuY2hyLCBtaW4gLSBwYWRkaW5nLCBtYXggKyBwYWRkaW5nLCBzdGF0dXNDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9Ucml4U2VhcmNoID0gZnVuY3Rpb24odGllciwgdHJpeCkge1xuICAgICAgICAgICAgdHJpeC5sb29rdXAoZywgZnVuY3Rpb24ocmVzdWx0LCBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpZXIuZmVhdHVyZVNvdXJjZS5zZWFyY2goZywgc2VhcmNoQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaXQgPSByZXN1bHRbMV0uc3BsaXQoJywnKVswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpZXIuZmVhdHVyZVNvdXJjZS5zZWFyY2goaGl0LCBzZWFyY2hDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWFyY2hFbmRwb2ludCkge1xuICAgICAgICAgICAgc2VhcmNoQ291bnQgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9EYXNTZWFyY2godGhpc0Iuc2VhcmNoRW5kcG9pbnQsIGcsIHNlYXJjaENhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKHRpZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0Iuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdzZWFyY2gnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGllci5kYXNTb3VyY2UudHJpeFVSSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytzZWFyY2hDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aWVyLnRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1RyaXhTZWFyY2godGllciwgdGllci50cml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl4ID0gbmV3IFVSTEZldGNoYWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGllci5kYXNTb3VyY2UudHJpeFVSSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWRlbnRpYWxzOiB0aWVyLmRhc1NvdXJjZS5jcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyOiB0aWVyLmRhc1NvdXJjZS5yZXNvbHZlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl4eCA9IG5ldyBVUkxGZXRjaGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZXIuZGFzU291cmNlLnRyaXh4VVJJIHx8ICh0aWVyLmRhc1NvdXJjZS50cml4VVJJICsgJ3gnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWRlbnRpYWxzOiB0aWVyLmRhc1NvdXJjZS5jcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyOiB0aWVyLmRhc1NvdXJjZS5yZXNvbHZlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFRyaXgoaXgsIGl4eCwgZnVuY3Rpb24odHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWVyLnRyaXggPSB0cml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1RyaXhTZWFyY2godGllciwgdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3NlYXJjaENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGllci5mZWF0dXJlU291cmNlLnNlYXJjaChnLCBzZWFyY2hDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpZXIuZGFzU291cmNlLnByb3ZpZGVzX3NlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICArK3NlYXJjaENvdW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5kb0Rhc1NlYXJjaCh0aWVyLmRhc1NvdXJjZSwgZywgc2VhcmNoQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKHRoaXMudGllcnNbdGldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuZG9EYXNTZWFyY2ggPSBmdW5jdGlvbihzb3VyY2UsIGcsIHNlYXJjaENhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICBzb3VyY2UuZmVhdHVyZXMobnVsbCwge2dyb3VwOiBnLCB0eXBlOiAndHJhbnNjcmlwdCd9LCBmdW5jdGlvbihmb3VuZCkge1xuICAgICAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IFtdO1xuICAgICAgICB2YXIgbWluID0gNTAwMDAwMDAwLCBtYXggPSAtMTAwMDAwMDAwO1xuICAgICAgICB2YXIgbmNociA9IG51bGw7XG5cbiAgICAgICAgdmFyIGZvdW5kMiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZm91bmQubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZvdW5kW2ZpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGYubGFiZWwudG9Mb3dlckNhc2UoKSAhPSBnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5iZWNhdXNlIERhenpsZSBjYW4gcmV0dXJuIHNwdXJpb3VzIG92ZXJsYXBwaW5nIGZlYXR1cmVzLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQyLnB1c2goZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VhcmNoQ2FsbGJhY2soZm91bmQyKTtcbiAgICB9LCBmYWxzZSk7XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEyXG4vL1xuLy8gc2VxdWVuY2UtZHJhdy5qczogcmVuZGVyZXJzIGZvciBzZXF1ZW5jZS1yZWxhdGVkIGRhdGFcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgZm9ybWF0TG9uZ0ludCA9IHV0aWxzLmZvcm1hdExvbmdJbnQ7XG4gICAgdmFyIG1ha2VFbGVtZW50TlMgPSB1dGlscy5tYWtlRWxlbWVudE5TO1xuXG4gICAgdmFyIHN2Z3UgPSByZXF1aXJlKCcuL3N2Zy11dGlscycpO1xuICAgIHZhciBOU19TVkcgPSBzdmd1Lk5TX1NWRztcbiAgICB2YXIgTlNfWExJTksgPSBzdmd1Lk5TX1hMSU5LO1xuICAgIHZhciBTVkdQYXRoID0gc3ZndS5TVkdQYXRoO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdExvbmdJbnQgPSBuZi5mb3JtYXRMb25nSW50O1xufVxuXG52YXIgTUlOX1RJTEUgPSAxMDA7XG52YXIgcnVsZXJUaWxlQ29sb3JzID0gWydibGFjaycsICd3aGl0ZSddO1xuXG52YXIgc3RlcHMgPSBbMSwyLDVdO1xuXG5cbnZhciBOU19TVkcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG5cbmZ1bmN0aW9uIHRpbGVTaXplRm9yU2NhbGUoc2NhbGUsIG1pbilcbntcbiAgICBpZiAoIW1pbikge1xuICAgICAgICBtaW4gPSBNSU5fVElMRTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cyhwKSB7XG4gICAgICAgIHJldHVybiBzdGVwc1twICUgc3RlcHMubGVuZ3RoXSAqIE1hdGgucG93KDEwLCAocCAvIHN0ZXBzLmxlbmd0aCl8MCk7XG4gICAgfVxuICAgIHZhciBwb3cgPSBzdGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKHNjYWxlICogdHMocG93KSA8IG1pbikge1xuICAgICAgICArK3BvdztcbiAgICB9XG4gICAgcmV0dXJuIHRzKHBvdyk7XG59XG5cbmZ1bmN0aW9uIGRyYXdTZXFUaWVyKHRpZXIsIHNlcSkge1xuICAgIHZhciBnYyA9IHRpZXIudmlld3BvcnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgcmV0aW5hID0gdGllci5icm93c2VyLnJldGluYSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG4gICAgdmFyIGRlc2lyZWRXaWR0aCA9IHRpZXIuYnJvd3Nlci5mZWF0dXJlUGFuZWxXaWR0aCArIDIwMDA7XG4gICAgaWYgKHJldGluYSkge1xuICAgICAgICBkZXNpcmVkV2lkdGggKj0gMjtcbiAgICB9XG4gICAgdmFyIGZwdyA9IHRpZXIudmlld3BvcnQud2lkdGh8MDsgLy8gdGhpcy5icm93c2VyLmZlYXR1cmVQYW5lbFdpZHRoO1xuICAgIGlmIChmcHcgPCBkZXNpcmVkV2lkdGggLSA1MCkge1xuICAgICAgICB0aWVyLnZpZXdwb3J0LndpZHRoID0gZnB3ID0gZGVzaXJlZFdpZHRoO1xuICAgIH1cblxuICAgIHZhciBoZWlnaHQgPSA1MDtcbiAgICBpZiAoc2VxICYmIHNlcS5zZXEpIHtcbiAgICAgICAgaGVpZ2h0ICs9IDI1O1xuICAgIH1cblxuICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKHJldGluYSkgXG4gICAgICAgIGNhbnZhc0hlaWdodCAqPSAyO1xuXG4gICAgdGllci52aWV3cG9ydC5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgdGllci52aWV3cG9ydC5zdHlsZS5oZWlnaHQgPSAnJyArIGhlaWdodCArICdweCc7XG4gICAgdGllci52aWV3cG9ydC5zdHlsZS53aWR0aCA9IHJldGluYSA/ICgnJyArIChmcHcvMikgKyAncHgnKSA6ICgnJyArIGZwdyArICdweCcpO1xuICAgIHRpZXIubGF5b3V0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRpZXIudXBkYXRlSGVpZ2h0KCk7XG5cbiAgICBcbiAgICBpZiAodGllci5iYWNrZ3JvdW5kKSB7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IHRpZXIuYmFja2dyb3VuZDtcbiAgICAgICAgZ2MuZmlsbFJlY3QoMCwgMCwgZnB3LCB0aWVyLnZpZXdwb3J0LmhlaWdodCk7XG4gICAgfVxuICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgZ2Muc2NhbGUoMiwgMik7XG4gICAgfVxuXG4gICAgZ2MudHJhbnNsYXRlKDEwMDAsMCk7XG4gICAgZHJhd1NlcVRpZXJHQyh0aWVyLCBzZXEsIGdjKTtcbiAgICB0aWVyLm5vcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuICAgIHRpZXIudmlld3BvcnRIb2xkZXIuc3R5bGUubGVmdCA9ICctMTAwMHB4Jztcbn1cblxuZnVuY3Rpb24gZHJhd1NlcVRpZXJHQyh0aWVyLCBzZXEsIGdjKVxue1xuICAgIHZhciBzY2FsZSA9IHRpZXIuYnJvd3Nlci5zY2FsZSwga25vd25TdGFydCA9IHRpZXIuYnJvd3Nlci52aWV3U3RhcnQgLSAoMTAwMC9zY2FsZSl8MCwga25vd25FbmQgPSB0aWVyLmJyb3dzZXIudmlld0VuZCArICgyMDAwL3NjYWxlKSwgY3VycmVudFNlcU1heCA9IHRpZXIuYnJvd3Nlci5jdXJyZW50U2VxTWF4O1xuXG4gICAgdmFyIHNlcVRpZXJNYXggPSBrbm93bkVuZDtcbiAgICBpZiAoY3VycmVudFNlcU1heCA+IDAgJiYgY3VycmVudFNlcU1heCA8IGtub3duRW5kKSB7XG4gICAgICAgIHNlcVRpZXJNYXggPSBjdXJyZW50U2VxTWF4O1xuICAgIH1cbiAgICB2YXIgdGlsZSA9IHRpbGVTaXplRm9yU2NhbGUoc2NhbGUpO1xuICAgIHZhciBwb3MgPSBNYXRoLm1heCgwLCAoKGtub3duU3RhcnQgLyB0aWxlKXwwKSAqIHRpbGUpO1xuICAgIFxuICAgIHZhciBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgd2hpbGUgKHBvcyA8PSBzZXFUaWVyTWF4KSB7XG5cdFx0Z2MuZmlsbFN0eWxlID0gKChwb3MgLyB0aWxlKSAlIDIgPT0gMCkgPyAnd2hpdGUnIDogJ2JsYWNrJztcblx0XHRnYy5zdHJva2VTdHlsZSA9ICdibGFjayc7XG5cdFx0Z2MuZmlsbFJlY3QoKHBvcyAtIG9yaWdpbikgKiBzY2FsZSxcblx0XHRcdCAgICA4LFxuXHRcdFx0ICAgIHRpbGUqc2NhbGUsXG5cdFx0XHQgICAgMyk7XG5cdFx0Z2Muc3Ryb2tlUmVjdCgocG9zIC0gb3JpZ2luKSAqIHNjYWxlLFxuXHRcdFx0ICAgICAgOCxcblx0XHRcdCAgICAgIHRpbGUqc2NhbGUsXG5cdFx0XHQgICAgICAzKTtcblxuXHRcdGdjLmZpbGxTdHlsZSA9ICdibGFjayc7XG5cdFx0Z2MuZmlsbFRleHQoZm9ybWF0TG9uZ0ludChwb3MpLCAoKHBvcyAtIG9yaWdpbikgKiBzY2FsZSksIDIyKTtcblx0XHRcblxuXHRcdHBvcyArPSB0aWxlO1xuICAgIH1cblxuICAgIGlmIChzZXEgJiYgc2VxLnNlcSkge1xuXHRcdGZvciAodmFyIHAgPSBrbm93blN0YXJ0OyBwIDw9IGtub3duRW5kOyArK3ApIHtcblx0XHQgICAgaWYgKHAgPj0gc2VxLnN0YXJ0ICYmIHAgPD0gc2VxLmVuZCkge1xuXHRcdFx0XHR2YXIgYmFzZSA9IHNlcS5zZXEuc3Vic3RyKHAgLSBzZXEuc3RhcnQsIDEpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdHZhciBjb2xvciA9IHRpZXIuYnJvd3Nlci5iYXNlQ29sb3JzW2Jhc2VdO1xuXHRcdFx0XHRpZiAoIWNvbG9yKSB7XG5cdFx0ICAgICAgICAgICAgY29sb3IgPSAnZ3JheSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnYy5maWxsU3R5bGUgPSBjb2xvcjtcblxuXHRcdFx0XHRpZiAoc2NhbGUgPj0gOCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IGdjLm1lYXN1cmVUZXh0KGJhc2UpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzY2FsZS13KTtcblx0XHRcdFx0ICAgIGdjLmZpbGxUZXh0KGJhc2UsIChwIC0gb3JpZ2luKSAqIHNjYWxlICsgKChzY2FsZS13KSowLjUpICwgNTIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQgICAgZ2MuZmlsbFJlY3QoKHAgLSBvcmlnaW4pICogc2NhbGUsIDQyLCBzY2FsZSwgMTIpOyBcblx0XHRcdFx0fVxuXHRcdCAgICB9XG5cdFx0fVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3ZnU2VxVGllcih0aWVyLCBzZXEpIHtcbiAgICB2YXIgc2NhbGUgPSB0aWVyLmJyb3dzZXIuc2NhbGUsIGtub3duU3RhcnQgPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0IC0gKDEwMDAvc2NhbGUpfDAsIGtub3duRW5kID0gdGllci5icm93c2VyLnZpZXdFbmQgKyAoMjAwMC9zY2FsZSksIGN1cnJlbnRTZXFNYXggPSB0aWVyLmJyb3dzZXIuY3VycmVudFNlcU1heDtcblxuICAgIHZhciBmcHcgPSB0aWVyLnZpZXdwb3J0LndpZHRofDA7IFxuXG4gICAgdmFyIHNlcVRpZXJNYXggPSBrbm93bkVuZDtcbiAgICBpZiAoY3VycmVudFNlcU1heCA+IDAgJiYgY3VycmVudFNlcU1heCA8IGtub3duRW5kKSB7XG4gICAgICAgIHNlcVRpZXJNYXggPSBjdXJyZW50U2VxTWF4O1xuICAgIH1cbiAgICB2YXIgdGlsZSA9IHRpbGVTaXplRm9yU2NhbGUoc2NhbGUpO1xuICAgIHZhciBwb3MgPSBNYXRoLm1heCgwLCAoKGtub3duU3RhcnQgLyB0aWxlKXwwKSAqIHRpbGUpO1xuICAgIFxuICAgIHZhciBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgdmFyICBnID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJywgW10sIHtmb250U2l6ZTogJzhwdCd9KTsgXG4gICAgd2hpbGUgKHBvcyA8PSBzZXFUaWVyTWF4KSB7XG4gICAgXHRnLmFwcGVuZENoaWxkKFxuICAgIFx0ICAgIG1ha2VFbGVtZW50TlMoXG4gICAgXHRcdE5TX1NWRywgJ3JlY3QnLFxuICAgIFx0XHRudWxsLFxuICAgIFx0XHR7eDogKHBvcy1vcmlnaW4pKnNjYWxlLFxuICAgIFx0XHQgeTogOCxcbiAgICBcdFx0IHdpZHRoOiB0aWxlKnNjYWxlLFxuICAgIFx0XHQgaGVpZ2h0OiAzLFxuICAgIFx0XHQgZmlsbDogKChwb3MgLyB0aWxlKSAlIDIgPT0gMCkgPyAnd2hpdGUnIDogJ2JsYWNrJyxcbiAgICBcdFx0IHN0cm9rZTogJ2JsYWNrJ30pKTtcblxuICAgIFx0Zy5hcHBlbmRDaGlsZChcbiAgICBcdCAgICBtYWtlRWxlbWVudE5TKFxuICAgIFx0XHROU19TVkcsICd0ZXh0JyxcbiAgICBcdFx0Zm9ybWF0TG9uZ0ludChwb3MpLFxuICAgIFx0XHR7eDogKHBvcy1vcmlnaW4pKnNjYWxlLFxuICAgIFx0XHQgeTogMjgsXG4gICAgXHRcdCBmaWxsOiAnYmxhY2snLCBzdHJva2U6ICdub25lJ30pKTtcbiAgICBcdFxuICAgIFx0cG9zICs9IHRpbGU7XG4gICAgfVxuXG4gICAgaWYgKHNlcSAmJiBzZXEuc2VxKSB7XG4gICAgXHRmb3IgKHZhciBwID0ga25vd25TdGFydDsgcCA8PSBrbm93bkVuZDsgKytwKSB7XG4gICAgXHQgICAgaWYgKHAgPj0gc2VxLnN0YXJ0ICYmIHAgPD0gc2VxLmVuZCkge1xuICAgICAgICBcdFx0dmFyIGJhc2UgPSBzZXEuc2VxLnN1YnN0cihwIC0gc2VxLnN0YXJ0LCAxKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBcdFx0dmFyIGNvbG9yID0gdGllci5icm93c2VyLmJhc2VDb2xvcnNbYmFzZV07XG4gICAgICAgIFx0XHRpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gJ2dyYXknO1xuICAgICAgICBcdFx0fVxuXG4gICAgICAgIFx0XHRpZiAoc2NhbGUgPj0gOCkge1xuICAgICAgICBcdFx0ICAgIGcuYXBwZW5kQ2hpbGQoXG4gICAgICAgIFx0XHRcdG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIGJhc2UsIHtcbiAgICAgICAgXHRcdFx0ICAgIHg6ICgwLjUrcC1vcmlnaW4pKnNjYWxlLFxuICAgICAgICBcdFx0XHQgICAgeTogNTIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgXHRcdFx0ICAgIGZpbGw6IGNvbG9yfSkpO1xuICAgICAgICBcdFx0fSBlbHNlIHtcbiAgICAgICAgXHRcdCAgICBnLmFwcGVuZENoaWxkKFxuICAgICAgICBcdFx0XHRtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3JlY3QnLCBudWxsLCB7XG4gICAgICAgIFx0XHRcdCAgICB4OiAocCAtIG9yaWdpbikqc2NhbGUsXG4gICAgICAgIFx0XHRcdCAgICB5OiA0MixcbiAgICAgICAgXHRcdFx0ICAgIHdpZHRoOiBzY2FsZSxcbiAgICAgICAgXHRcdFx0ICAgIGhlaWdodDogMTIsXG4gICAgICAgIFx0ICAgICAgICAgICAgZmlsbDogY29sb3J9KSk7XG5cbiAgICAgICAgXHRcdH1cbiAgICBcdCAgICB9XG4gICAgXHR9XG4gICAgfSBcblxuICAgIHJldHVybiBnO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRyYXdTZXFUaWVyOiBkcmF3U2VxVGllcixcbiAgICAgICAgZHJhd1NlcVRpZXJHQzogZHJhd1NlcVRpZXJHQyxcbiAgICAgICAgc3ZnU2VxVGllcjogc3ZnU2VxVGllclxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gc2Vzc2lvbi5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciBzYyA9IHJlcXVpcmUoJy4vc291cmNlY29tcGFyZScpO1xuICAgIHZhciBzb3VyY2VEYXRhVVJJID0gc2Muc291cmNlRGF0YVVSSTtcbiAgICB2YXIgc291cmNlc0FyZUVxdWFsID0gc2Muc291cmNlc0FyZUVxdWFsO1xuXG4gICAgdmFyIFZFUlNJT04gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWluaUpTT05pZnkgPSB1dGlscy5taW5pSlNPTmlmeTtcblxuICAgIHZhciBzaGExID0gcmVxdWlyZSgnLi9zaGExJyk7XG4gICAgdmFyIGhleF9zaGExID0gc2hhMS5oZXhfc2hhMTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubnVrZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctY2hyJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmlldy1zdGFydCddO1xuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctZW5kJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuY3VycmVudC1zZXEtbGVuZ3RoJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuc2hvd2luZy1hbHQtem9vbSddO1xuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNhdmVkLXpvb20nXTtcblxuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNvdXJjZXMnXTtcbiAgICBkZWxldGUgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5odWJzJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmVyc2lvbiddO1xuXG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcucmV2ZXJzZS1zY3JvbGxpbmcnXTtcbiAgICBkZWxldGUgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5yZXZlcnNlLWtleS1zY3JvbGxpbmcnXTtcbiAgICBkZWxldGUgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5ydWxlci1sb2NhdGlvbiddO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5zdG9yZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcmVWaWV3U3RhdHVzKCk7XG4gICAgdGhpcy5zdG9yZVRpZXJTdGF0dXMoKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuc3RvcmVWaWV3U3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmNvb2tpZUtleSB8fCB0aGlzLm5vUGVyc2lzdCB8fCB0aGlzLm5vUGVyc2lzdFZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmlldy1jaHInXSA9IHRoaXMuY2hyO1xuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmlldy1zdGFydCddID0gdGhpcy52aWV3U3RhcnR8MDtcbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctZW5kJ10gPSB0aGlzLnZpZXdFbmR8MFxuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuc2hvd2luZy1hbHQtem9vbSddID0gJycgKyB0aGlzLmlzU25hcFpvb21pbmc7XG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zYXZlZC16b29tJ10gPSB0aGlzLnNhdmVkWm9vbTtcbiAgICBpZiAodGhpcy5jdXJyZW50U2VxTWF4KSB7XG5cdCAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuY3VycmVudC1zZXEtbGVuZ3RoJ10gPSB0aGlzLmN1cnJlbnRTZXFNYXg7XG4gICAgfVxufVxuXG5cbkJyb3dzZXIucHJvdG90eXBlLnN0b3JlVGllclN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jb29raWVLZXkgfHwgdGhpcy5ub1BlcnNpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50U291cmNlTGlzdCA9IFtdO1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdCkge1xuICAgICAgICB2YXIgdHQgPSB0aGlzLnRpZXJzW3RdO1xuICAgICAgICB2YXIgdHMgPSB0dC5kYXNTb3VyY2U7XG4gICAgICAgIGlmICghdHMubm9QZXJzaXN0KSB7XG4gICAgICAgICAgICBjdXJyZW50U291cmNlTGlzdC5wdXNoKHtzb3VyY2U6IHR0LmRhc1NvdXJjZSwgY29uZmlnOiB0dC5jb25maWcgfHwge319KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNvdXJjZXMnXSA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTb3VyY2VMaXN0KTtcblxuXG4gICAgdmFyIGNvdmVyZWRIdWJVUkxzID0ge307XG4gICAgdmFyIGN1cnJlbnRIdWJMaXN0ID0gW107XG4gICAgZm9yICh2YXIgaGkgPSAwOyBoaSA8IHRoaXMuaHViT2JqZWN0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgdmFyIHRkYiA9IHRoaXMuaHViT2JqZWN0c1toaV07XG4gICAgICAgIHZhciBoYyA9IHt1cmw6IHRkYi5odWIudXJsLCBnZW5vbWU6IHRkYi5nZW5vbWV9O1xuICAgICAgICBpZiAodGRiLmNyZWRlbnRpYWxzKVxuICAgICAgICAgICAgaGMuY3JlZGVudGlhbHMgPSB0ZGIuY3JlZGVudGlhbHM7XG4gICAgICAgIGlmICh0ZGIubWFwcGluZylcbiAgICAgICAgICAgIGhjLm1hcHBpbmcgPSB0ZGIubWFwcGluZztcbiAgICAgICAgY292ZXJlZEh1YlVSTHNbaGMudXJsXSA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRIdWJMaXN0LnB1c2goaGMpO1xuICAgIH1cblxuICAgIC8vIE5lZWRlZCB0byBoYW5kbGUgaHVicyB0aGF0IGZhaWxlZCB0byBjb25uZWN0LCBvciBodWJzIHRoYXQgaGF2ZW4ndFxuICAgIC8vIGNvbm5lY3RlZCB5ZXQgd2hlbiB3ZSdyZSBjYWxsZWQgc29vbiBhZnRlciBzdGFydHVwLlxuICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCB0aGlzLmh1YnMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgIHZhciBoYyA9IHRoaXMuaHVic1toaV07XG4gICAgICAgIGlmICh0eXBlb2YgaGMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgaGMgPSB7dXJsOiBoY307XG4gICAgICAgIGlmICghY292ZXJlZEh1YlVSTHNbaGMudXJsXSlcbiAgICAgICAgICAgIGN1cnJlbnRIdWJMaXN0LnB1c2goaGMpO1xuICAgIH1cblxuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuaHVicyddID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudEh1Ykxpc3QpO1xuXG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5yZXZlcnNlLXNjcm9sbGluZyddID0gdGhpcy5yZXZlcnNlU2Nyb2xsaW5nO1xuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcucmV2ZXJzZS1rZXktc2Nyb2xsaW5nJ10gPSB0aGlzLnJldmVyc2VLZXlTY3JvbGxpbmc7XG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zaW5nbGUtYmFzZS1oaWdobGlnaHQnXSA9IHRoaXMuc2luZ2xlQmFzZUhpZ2hsaWdodDtcbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnJ1bGVyLWxvY2F0aW9uJ10gPSB0aGlzLnJ1bGVyTG9jYXRpb247XG5cbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmV4cG9ydC1ydWxlciddID0gdGhpcy5leHBvcnRSdWxlcjtcbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmV4cG9ydC1oaWdobGlnaHRzJ10gPSB0aGlzLmV4cG9ydEhpZ2hsaWdodHM7XG4gICAgXG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy52ZXJzaW9uJ10gPSBWRVJTSU9OLkNPTkZJRztcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVzdG9yZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm5vUGVyc2lzdClcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIHZhciBzdG9yZWRDb25maWdWZXJzaW9uID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy52ZXJzaW9uJ107XG4gICAgaWYgKHN0b3JlZENvbmZpZ1ZlcnNpb24pIHtcbiAgICAgICAgc3RvcmVkQ29uZmlnVmVyc2lvbiA9IHN0b3JlZENvbmZpZ1ZlcnNpb258MDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZWRDb25maWdWZXJzaW9uID0gLTEwMDtcbiAgICB9XG4gICAgaWYgKFZFUlNJT04uQ09ORklHICE9IHN0b3JlZENvbmZpZ1ZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdG9yZWRDb25maWdIYXNoID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5jb25maWdIYXNoJ10gfHwgJyc7XG4gICAgdmFyIHBhZ2VDb25maWdIYXNoID0gaGV4X3NoYTEobWluaUpTT05pZnkoe1xuICAgICAgICBzb3VyY2VzOiB0aGlzLnNvdXJjZXMsXG4gICAgICAgIGh1YnM6IHRoaXMuaHVicyxcbiAgICAgICAgcnVsZXJMb2NhdGlvbjogdGhpcy5ydWxlckxvY2F0aW9uXG4gICAgfSkpO1xuICAgIGlmIChwYWdlQ29uZmlnSGFzaCAhPSBzdG9yZWRDb25maWdIYXNoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuY29uZmlnSGFzaCddID0gcGFnZUNvbmZpZ0hhc2g7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFNvdXJjZXNCeVVSSSA9IHt9O1xuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbc2ldO1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB1cmkgPSBzb3VyY2VEYXRhVVJJKHNvdXJjZSk7XG4gICAgICAgIHZhciB1bCA9IGRlZmF1bHRTb3VyY2VzQnlVUklbdXJpXTtcbiAgICAgICAgaWYgKCF1bClcbiAgICAgICAgICAgIGRlZmF1bHRTb3VyY2VzQnlVUklbdXJpXSA9IHVsID0gW107XG4gICAgICAgIHVsLnB1c2goc291cmNlKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5vUGVyc2lzdFZpZXcpIHtcbiAgICAgICAgdmFyIHFDaHIgPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctY2hyJ107XG4gICAgICAgIHZhciBxTWluID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy52aWV3LXN0YXJ0J118MDtcbiAgICAgICAgdmFyIHFNYXggPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctZW5kJ118MDtcbiAgICAgICAgaWYgKHFDaHIgJiYgcU1pbiAmJiBxTWF4KSB7XG4gICAgICAgIFx0dGhpcy5jaHIgPSBxQ2hyO1xuICAgICAgICBcdHRoaXMudmlld1N0YXJ0ID0gcU1pbjtcbiAgICAgICAgXHR0aGlzLnZpZXdFbmQgPSBxTWF4O1xuICAgICAgICBcdFxuICAgICAgICBcdHZhciBjc20gPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmN1cnJlbnQtc2VxLWxlbmd0aCddO1xuICAgICAgICBcdGlmIChjc20pIHtcbiAgICAgICAgXHQgICAgdGhpcy5jdXJyZW50U2VxTWF4ID0gY3NtfDA7XG4gICAgICAgIFx0fVxuXG4gICAgICAgICAgICB0aGlzLmlzU25hcFpvb21pbmcgPSAobG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zaG93aW5nLWFsdC16b29tJ10pID09ICd0cnVlJztcblxuICAgICAgICAgICAgdmFyIHN6ID0gcGFyc2VGbG9hdChsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNhdmVkLXpvb20nXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN6ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oc3opKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlZFpvb20gPSBzejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBycyA9IGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcucmV2ZXJzZS1zY3JvbGxpbmcnXTtcbiAgICB0aGlzLnJldmVyc2VTY3JvbGxpbmcgPSAocnMgJiYgcnMgPT0gJ3RydWUnKTtcbiAgICB2YXIgcmtzID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5yZXZlcnNlLWtleS1zY3JvbGxpbmcnXTtcbiAgICB0aGlzLnJldmVyc2VLZXlTY3JvbGxpbmcgPSAocmtzICYmIHJrcyA9PSAndHJ1ZScpO1xuICAgIHZhciBzYmggPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNpbmdsZS1iYXNlLWhpZ2hsaWdodCddO1xuICAgIHRoaXMuc2luZ2xlQmFzZUhpZ2hsaWdodCA9IChzYmggJiYgc2JoID09ICd0cnVlJyk7XG4gXG4gICAgdmFyIHJsID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5ydWxlci1sb2NhdGlvbiddO1xuICAgIGlmIChybClcbiAgICAgICAgdGhpcy5ydWxlckxvY2F0aW9uID0gcmw7XG5cbiAgICB2YXIgeCA9IGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuZXhwb3J0LXJ1bGVyJ107XG4gICAgaWYgKHgpXG4gICAgICAgIHRoaXMuZXhwb3J0UnVsZXIgPSAoeCA9PT0gJ3RydWUnKTtcbiAgICB2YXIgeCA9IGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuZXhwb3J0LWhpZ2hsaWdodHMnXTtcbiAgICBpZiAoeClcbiAgICAgICAgdGhpcy5leHBvcnRIaWdobGlnaHRzID0gKHggPT09ICd0cnVlJyk7XG5cbiAgICB2YXIgc291cmNlU3RyID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zb3VyY2VzJ107XG4gICAgaWYgKHNvdXJjZVN0cikge1xuXHQgICAgdmFyIHN0b3JlZFNvdXJjZXMgPSBKU09OLnBhcnNlKHNvdXJjZVN0cik7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnJlc3RvcmVkQ29uZmlncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc3RvcmVkU291cmNlcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbc2ldID0gc3RvcmVkU291cmNlc1tzaV0uc291cmNlO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlZENvbmZpZ3Nbc2ldID0gc3RvcmVkU291cmNlc1tzaV0uY29uZmlnO1xuICAgICAgICAgICAgdmFyIHVyaSA9IHNvdXJjZURhdGFVUkkoc291cmNlKTtcbiAgICAgICAgICAgIHZhciB1bCA9IGRlZmF1bHRTb3VyY2VzQnlVUklbdXJpXSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIG9zaSA9IDA7IG9zaSA8IHVsLmxlbmd0aDsgKytvc2kpIHsgICAgXG4gICAgICAgICAgICAgICAgdmFyIG9sZFNvdXJjZSA9IHVsW29zaV07XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNBcmVFcXVhbChzb3VyY2UsIG9sZFNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvbGRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRTb3VyY2UuaGFzT3duUHJvcGVydHkoaykgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihvbGRTb3VyY2Vba10pID09PSAnZnVuY3Rpb24nIHx8IG9sZFNvdXJjZVtrXSBpbnN0YW5jZW9mIEJsb2IpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVtrXSA9IG9sZFNvdXJjZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBodWJTdHIgPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmh1YnMnXTtcbiAgICBpZiAoaHViU3RyKSB7XG4gICAgICAgIHRoaXMuaHVicyA9IEpTT04ucGFyc2UoaHViU3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy50aWVycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgIHRoaXMucmVtb3ZlVGllcih7aW5kZXg6IGl9LCB0cnVlKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRlZmF1bHRTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5kZWZhdWx0U291cmNlc1tpXTtcbiAgICAgICAgaWYgKCFzLmRpc2FibGVkKSBcbiAgICAgICAgICAgIHRoaXMuYWRkVGllcih0aGlzLmRlZmF1bHRTb3VyY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZ2hsaWdodHMuc3BsaWNlKDAsIHRoaXMuaGlnaGxpZ2h0cy5sZW5ndGgpO1xuXG4gICAgdGhpcy5zZXRMb2NhdGlvbih0aGlzLmRlZmF1bHRDaHIsIHRoaXMuZGVmYXVsdFN0YXJ0LCB0aGlzLmRlZmF1bHRFbmQpO1xufVxuIiwiLypcclxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXHJcbiAqIGluIEZJUFMgMTgwLTFcclxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXHJcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcclxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXHJcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxyXG4gKi9cclxuXHJcbiBcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qXHJcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcclxuICogdGhlIHNlcnZlci1zaWRlLCBidXQgdGhlIGRlZmF1bHRzIHdvcmsgaW4gbW9zdCBjYXNlcy5cclxuICovXHJcbnZhciBoZXhjYXNlID0gMDsgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqL1xyXG52YXIgYjY0cGFkICA9IFwiXCI7IC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXHJcblxyXG4vKlxyXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcclxuICogVGhleSB0YWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgaGV4IG9yIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiBoZXhfc2hhMShzKSAgICB7IHJldHVybiByc3RyMmhleChyc3RyX3NoYTEoc3RyMnJzdHJfdXRmOChzKSkpOyB9XHJcbmZ1bmN0aW9uIGI2NF9zaGExKHMpICAgIHsgcmV0dXJuIHJzdHIyYjY0KHJzdHJfc2hhMShzdHIycnN0cl91dGY4KHMpKSk7IH1cclxuZnVuY3Rpb24gYW55X3NoYTEocywgZSkgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9zaGExKHN0cjJyc3RyX3V0ZjgocykpLCBlKTsgfVxyXG5mdW5jdGlvbiBoZXhfaG1hY19zaGExKGssIGQpXHJcbiAgeyByZXR1cm4gcnN0cjJoZXgocnN0cl9obWFjX3NoYTEoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSkpOyB9XHJcbmZ1bmN0aW9uIGI2NF9obWFjX3NoYTEoaywgZClcclxuICB7IHJldHVybiByc3RyMmI2NChyc3RyX2htYWNfc2hhMShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cclxuZnVuY3Rpb24gYW55X2htYWNfc2hhMShrLCBkLCBlKVxyXG4gIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfaG1hY19zaGExKHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpLCBlKTsgfVxyXG5cclxuLypcclxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGExX3ZtX3Rlc3QoKVxyXG57XHJcbiAgcmV0dXJuIGhleF9zaGExKFwiYWJjXCIpLnRvTG93ZXJDYXNlKCkgPT0gXCJhOTk5M2UzNjQ3MDY4MTZhYmEzZTI1NzE3ODUwYzI2YzljZDBkODlkXCI7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgU0hBMSBvZiBhIHJhdyBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIHJzdHJfc2hhMShzKVxyXG57XHJcbiAgcmV0dXJuIGJpbmIycnN0cihiaW5iX3NoYTEocnN0cjJiaW5iKHMpLCBzLmxlbmd0aCAqIDgpKTtcclxufVxyXG5cclxuLypcclxuICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXHJcbiAqL1xyXG5mdW5jdGlvbiByc3RyX2htYWNfc2hhMShrZXksIGRhdGEpXHJcbntcclxuICB2YXIgYmtleSA9IHJzdHIyYmluYihrZXkpO1xyXG4gIGlmKGJrZXkubGVuZ3RoID4gMTYpIGJrZXkgPSBiaW5iX3NoYTEoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xyXG5cclxuICB2YXIgaXBhZCA9IEFycmF5KDE2KSwgb3BhZCA9IEFycmF5KDE2KTtcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcclxuICB7XHJcbiAgICBpcGFkW2ldID0gYmtleVtpXSBeIDB4MzYzNjM2MzY7XHJcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzaCA9IGJpbmJfc2hhMShpcGFkLmNvbmNhdChyc3RyMmJpbmIoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIDgpO1xyXG4gIHJldHVybiBiaW5iMnJzdHIoYmluYl9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApKTtcclxufVxyXG5cclxuLypcclxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiByc3RyMmhleChpbnB1dClcclxue1xyXG4gIC8vIHRyeSB7IGhleGNhc2UgfSBjYXRjaChlKSB7IGhleGNhc2U9MDsgfVxyXG4gIHZhciBoZXhfdGFiID0gaGV4Y2FzZSA/IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiIDogXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgdmFyIHg7XHJcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxyXG4gIHtcclxuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgb3V0cHV0ICs9IGhleF90YWIuY2hhckF0KCh4ID4+PiA0KSAmIDB4MEYpXHJcbiAgICAgICAgICAgKyAgaGV4X3RhYi5jaGFyQXQoIHggICAgICAgICYgMHgwRik7XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgYmFzZS02NCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIHJzdHIyYjY0KGlucHV0KVxyXG57XHJcbiAgLy8gdHJ5IHsgYjY0cGFkIH0gY2F0Y2goZSkgeyBiNjRwYWQ9Jyc7IH1cclxuICB2YXIgdGFiID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpXHJcbiAge1xyXG4gICAgdmFyIHRyaXBsZXQgPSAoaW5wdXQuY2hhckNvZGVBdChpKSA8PCAxNilcclxuICAgICAgICAgICAgICAgIHwgKGkgKyAxIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKzEpIDw8IDggOiAwKVxyXG4gICAgICAgICAgICAgICAgfCAoaSArIDIgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMikgICAgICA6IDApO1xyXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcclxuICAgIHtcclxuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGlucHV0Lmxlbmd0aCAqIDgpIG91dHB1dCArPSBiNjRwYWQ7XHJcbiAgICAgIGVsc2Ugb3V0cHV0ICs9IHRhYi5jaGFyQXQoKHRyaXBsZXQgPj4+IDYqKDMtaikpICYgMHgzRik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFyYml0cmFyeSBzdHJpbmcgZW5jb2RpbmdcclxuICovXHJcbmZ1bmN0aW9uIHJzdHIyYW55KGlucHV0LCBlbmNvZGluZylcclxue1xyXG4gIHZhciBkaXZpc29yID0gZW5jb2RpbmcubGVuZ3RoO1xyXG4gIHZhciByZW1haW5kZXJzID0gQXJyYXkoKTtcclxuICB2YXIgaSwgcSwgeCwgcXVvdGllbnQ7XHJcblxyXG4gIC8qIENvbnZlcnQgdG8gYW4gYXJyYXkgb2YgMTYtYml0IGJpZy1lbmRpYW4gdmFsdWVzLCBmb3JtaW5nIHRoZSBkaXZpZGVuZCAqL1xyXG4gIHZhciBkaXZpZGVuZCA9IEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyAyKSk7XHJcbiAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXHJcbiAge1xyXG4gICAgZGl2aWRlbmRbaV0gPSAoaW5wdXQuY2hhckNvZGVBdChpICogMikgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIFJlcGVhdGVkbHkgcGVyZm9ybSBhIGxvbmcgZGl2aXNpb24uIFRoZSBiaW5hcnkgYXJyYXkgZm9ybXMgdGhlIGRpdmlkZW5kLFxyXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGVuY29kaW5nIGlzIHRoZSBkaXZpc29yLiBPbmNlIGNvbXB1dGVkLCB0aGUgcXVvdGllbnRcclxuICAgKiBmb3JtcyB0aGUgZGl2aWRlbmQgZm9yIHRoZSBuZXh0IHN0ZXAuIFdlIHN0b3Agd2hlbiB0aGUgZGl2aWRlbmQgaXMgemVyby5cclxuICAgKiBBbGwgcmVtYWluZGVycyBhcmUgc3RvcmVkIGZvciBsYXRlciB1c2UuXHJcbiAgICovXHJcbiAgd2hpbGUoZGl2aWRlbmQubGVuZ3RoID4gMClcclxuICB7XHJcbiAgICBxdW90aWVudCA9IEFycmF5KCk7XHJcbiAgICB4ID0gMDtcclxuICAgIGZvcihpID0gMDsgaSA8IGRpdmlkZW5kLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICB4ID0gKHggPDwgMTYpICsgZGl2aWRlbmRbaV07XHJcbiAgICAgIHEgPSBNYXRoLmZsb29yKHggLyBkaXZpc29yKTtcclxuICAgICAgeCAtPSBxICogZGl2aXNvcjtcclxuICAgICAgaWYocXVvdGllbnQubGVuZ3RoID4gMCB8fCBxID4gMClcclxuICAgICAgICBxdW90aWVudFtxdW90aWVudC5sZW5ndGhdID0gcTtcclxuICAgIH1cclxuICAgIHJlbWFpbmRlcnNbcmVtYWluZGVycy5sZW5ndGhdID0geDtcclxuICAgIGRpdmlkZW5kID0gcXVvdGllbnQ7XHJcbiAgfVxyXG5cclxuICAvKiBDb252ZXJ0IHRoZSByZW1haW5kZXJzIHRvIHRoZSBvdXRwdXQgc3RyaW5nICovXHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgZm9yKGkgPSByZW1haW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgb3V0cHV0ICs9IGVuY29kaW5nLmNoYXJBdChyZW1haW5kZXJzW2ldKTtcclxuXHJcbiAgLyogQXBwZW5kIGxlYWRpbmcgemVybyBlcXVpdmFsZW50cyAqL1xyXG4gIHZhciBmdWxsX2xlbmd0aCA9IE1hdGguY2VpbChpbnB1dC5sZW5ndGggKiA4IC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGgubG9nKGVuY29kaW5nLmxlbmd0aCkgLyBNYXRoLmxvZygyKSkpXHJcbiAgZm9yKGkgPSBvdXRwdXQubGVuZ3RoOyBpIDwgZnVsbF9sZW5ndGg7IGkrKylcclxuICAgIG91dHB1dCA9IGVuY29kaW5nWzBdICsgb3V0cHV0O1xyXG5cclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG4vKlxyXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTguXHJcbiAqIEZvciBlZmZpY2llbmN5LCB0aGlzIGFzc3VtZXMgdGhlIGlucHV0IGlzIHZhbGlkIHV0Zi0xNi5cclxuICovXHJcbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjgoaW5wdXQpXHJcbntcclxuICB2YXIgb3V0cHV0ID0gXCJcIjtcclxuICB2YXIgaSA9IC0xO1xyXG4gIHZhciB4LCB5O1xyXG5cclxuICB3aGlsZSgrK2kgPCBpbnB1dC5sZW5ndGgpXHJcbiAge1xyXG4gICAgLyogRGVjb2RlIHV0Zi0xNiBzdXJyb2dhdGUgcGFpcnMgKi9cclxuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgeSA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckNvZGVBdChpICsgMSkgOiAwO1xyXG4gICAgaWYoMHhEODAwIDw9IHggJiYgeCA8PSAweERCRkYgJiYgMHhEQzAwIDw9IHkgJiYgeSA8PSAweERGRkYpXHJcbiAgICB7XHJcbiAgICAgIHggPSAweDEwMDAwICsgKCh4ICYgMHgwM0ZGKSA8PCAxMCkgKyAoeSAmIDB4MDNGRik7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICAvKiBFbmNvZGUgb3V0cHV0IGFzIHV0Zi04ICovXHJcbiAgICBpZih4IDw9IDB4N0YpXHJcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xyXG4gICAgZWxzZSBpZih4IDw9IDB4N0ZGKVxyXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEMwIHwgKCh4ID4+PiA2ICkgJiAweDFGKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xyXG4gICAgZWxzZSBpZih4IDw9IDB4RkZGRilcclxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhFMCB8ICgoeCA+Pj4gMTIpICYgMHgwRiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XHJcbiAgICBlbHNlIGlmKHggPD0gMHgxRkZGRkYpXHJcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RjAgfCAoKHggPj4+IDE4KSAmIDB4MDcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiAxMikgJiAweDNGKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoIHggICAgICAgICAmIDB4M0YpKTtcclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5cclxuLypcclxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi0xNlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZsZShpbnB1dClcclxue1xyXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcclxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGKTtcclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHIycnN0cl91dGYxNmJlKGlucHV0KVxyXG57XHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxyXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYpO1xyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHNcclxuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByc3RyMmJpbmIoaW5wdXQpXHJcbntcclxuICB2YXIgb3V0cHV0ID0gQXJyYXkoaW5wdXQubGVuZ3RoID4+IDIpO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspXHJcbiAgICBvdXRwdXRbaV0gPSAwO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiA4OyBpICs9IDgpXHJcbiAgICBvdXRwdXRbaT4+NV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhGRikgPDwgKDI0IC0gaSAlIDMyKTtcclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG4vKlxyXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGJpbmIycnN0cihpbnB1dClcclxue1xyXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiAzMjsgaSArPSA4KVxyXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2k+PjVdID4+PiAoMjQgLSBpICUgMzIpKSAmIDB4RkYpO1xyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxyXG4gKi9cclxuZnVuY3Rpb24gYmluYl9zaGExKHgsIGxlbilcclxue1xyXG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXHJcbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XHJcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xyXG5cclxuICB2YXIgdyA9IEFycmF5KDgwKTtcclxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xyXG4gIHZhciBiID0gLTI3MTczMzg3OTtcclxuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xyXG4gIHZhciBkID0gIDI3MTczMzg3ODtcclxuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xyXG5cclxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXHJcbiAge1xyXG4gICAgdmFyIG9sZGEgPSBhO1xyXG4gICAgdmFyIG9sZGIgPSBiO1xyXG4gICAgdmFyIG9sZGMgPSBjO1xyXG4gICAgdmFyIG9sZGQgPSBkO1xyXG4gICAgdmFyIG9sZGUgPSBlO1xyXG5cclxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKVxyXG4gICAge1xyXG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcclxuICAgICAgZWxzZSB3W2pdID0gYml0X3JvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XHJcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQoYml0X3JvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTtcclxuICAgICAgZSA9IGQ7XHJcbiAgICAgIGQgPSBjO1xyXG4gICAgICBjID0gYml0X3JvbChiLCAzMCk7XHJcbiAgICAgIGIgPSBhO1xyXG4gICAgICBhID0gdDtcclxuICAgIH1cclxuXHJcbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XHJcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XHJcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XHJcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XHJcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkLCBlKTtcclxuXHJcbn1cclxuXHJcbi8qXHJcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XHJcbiAqIGl0ZXJhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxyXG57XHJcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XHJcbiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xyXG4gIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcclxuICByZXR1cm4gYiBeIGMgXiBkO1xyXG59XHJcblxyXG4vKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHNoYTFfa3QodClcclxue1xyXG4gIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XHJcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xyXG59XHJcblxyXG4vKlxyXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XHJcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxyXG57XHJcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcclxuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XHJcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cclxuICovXHJcbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXHJcbntcclxuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XHJcbn1cclxuXHJcbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGI2NF9zaGExOiBiNjRfc2hhMSxcclxuICAgIGhleF9zaGExOiBoZXhfc2hhMVxyXG4gIH1cclxufVxyXG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy9cbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyBzb3VyY2VhZGFwdGVycy5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgdGllciA9IHJlcXVpcmUoJy4vdGllcicpO1xuICAgIHZhciBEYXNUaWVyID0gdGllci5EYXNUaWVyO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBBd2FpdGVkID0gdXRpbHMuQXdhaXRlZDtcbiAgICB2YXIgYXJyYXlJbmRleE9mID0gdXRpbHMuYXJyYXlJbmRleE9mO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuICAgIHZhciByZXNvbHZlVXJsVG9QYWdlID0gdXRpbHMucmVzb2x2ZVVybFRvUGFnZTtcblxuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNTdHlsZXNoZWV0ID0gZGFzLkRBU1N0eWxlc2hlZXQ7XG4gICAgdmFyIERBU1N0eWxlID0gZGFzLkRBU1N0eWxlO1xuICAgIHZhciBEQVNTb3VyY2UgPSBkYXMuREFTU291cmNlO1xuICAgIHZhciBEQVNTZWdtZW50ID0gZGFzLkRBU1NlZ21lbnQ7XG4gICAgdmFyIERBU0ZlYXR1cmUgPSBkYXMuREFTRmVhdHVyZTtcbiAgICB2YXIgREFTU2VxdWVuY2UgPSBkYXMuREFTU2VxdWVuY2U7XG4gICAgdmFyIERBU0xpbmsgPSBkYXMuREFTTGluaztcblxuICAgIHZhciBiaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuICAgIHZhciBVUkxGZXRjaGFibGUgPSBiaW4uVVJMRmV0Y2hhYmxlO1xuICAgIHZhciBCbG9iRmV0Y2hhYmxlID0gYmluLkJsb2JGZXRjaGFibGU7XG5cbiAgICB2YXIgdHdvQml0ID0gcmVxdWlyZSgnLi90d29CaXQnKTtcbiAgICB2YXIgbWFrZVR3b0JpdCA9IHR3b0JpdC5tYWtlVHdvQml0O1xuXG4gICAgdmFyIGJiaSA9IHJlcXVpcmUoJy4vYmlnd2lnJyk7XG4gICAgdmFyIG1ha2VCd2cgPSBiYmkubWFrZUJ3ZztcblxuICAgIHZhciBiYW0gPSByZXF1aXJlKCcuL2JhbScpO1xuICAgIHZhciBtYWtlQmFtID0gYmFtLm1ha2VCYW07XG4gICAgdmFyIEJhbUZsYWdzID0gYmFtLkJhbUZsYWdzO1xuXG4gICAgdmFyIHNwYW5zID0gcmVxdWlyZSgnLi9zcGFucycpO1xuICAgIHZhciBSYW5nZSA9IHNwYW5zLlJhbmdlO1xuICAgIHZhciB1bmlvbiA9IHNwYW5zLnVuaW9uO1xuXG4gICAgdmFyIHBhcnNlQ2lnYXIgPSByZXF1aXJlKCcuL2NpZ2FyJykucGFyc2VDaWdhcjtcblxuICAgIHZhciBPdmVybGF5RmVhdHVyZVNvdXJjZSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpLk92ZXJsYXlGZWF0dXJlU291cmNlO1xuXG4gICAgdmFyIEpCcm93c2VTdG9yZSA9IHJlcXVpcmUoJy4vamJqc29uJykuSkJyb3dzZVN0b3JlO1xuXG4gICAgdmFyIENoYWluc2V0ID0gcmVxdWlyZSgnLi9jaGFpbnNldCcpLkNoYWluc2V0O1xuXG4gICAgdmFyIHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuICAgIHZhciBTdHlsZUZpbHRlclNldCA9IHN0eWxlLlN0eWxlRmlsdGVyU2V0O1xuXG4gICAgdmFyIEVuY29kZUZldGNoYWJsZSA9IHJlcXVpcmUoJy4vZW5jb2RlJykuRW5jb2RlRmV0Y2hhYmxlO1xufVxuXG52YXIgX19kYWxsaWFuY2Vfc291cmNlQWRhcHRlckZhY3RvcmllcyA9IHt9O1xuXG5mdW5jdGlvbiBkYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSh0eXBlLCBmYWN0b3J5KSB7XG4gICAgX19kYWxsaWFuY2Vfc291cmNlQWRhcHRlckZhY3Rvcmllc1t0eXBlXSA9IGZhY3Rvcnk7XG59XG5cblxudmFyIF9fZGFsbGlhbmNlX3BhcnNlckZhY3RvcmllcyA9IHt9O1xuXG5mdW5jdGlvbiBkYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5KHR5cGUsIGZhY3RvcnkpIHtcbiAgICBfX2RhbGxpYW5jZV9wYXJzZXJGYWN0b3JpZXNbdHlwZV0gPSBmYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBkYWxsaWFuY2VfbWFrZVBhcnNlcih0eXBlKSB7XG4gICAgaWYgKF9fZGFsbGlhbmNlX3BhcnNlckZhY3Rvcmllc1t0eXBlXSkge1xuICAgICAgICByZXR1cm4gX19kYWxsaWFuY2VfcGFyc2VyRmFjdG9yaWVzW3R5cGVdKHR5cGUpO1xuICAgIH1cbn1cblxuXG5EYXNUaWVyLnByb3RvdHlwZS5pbml0U291cmNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzVGllciA9IHRoaXM7XG5cbiAgICB2YXIgc291cmNlcyA9IHRoaXMuYnJvd3Nlci5jcmVhdGVTb3VyY2VzKHRoaXMuZGFzU291cmNlKTtcbiAgICB0aGlzLmZlYXR1cmVTb3VyY2UgPSBzb3VyY2VzLmZlYXR1cmVzIHx8IG5ldyBEdW1teUZlYXR1cmVTb3VyY2UoKTtcbiAgICB0aGlzLnNlcXVlbmNlU291cmNlID0gc291cmNlcy5zZXF1ZW5jZTtcblxuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5mZWF0dXJlU291cmNlLmFkZENoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZVNvdXJjZS5hZGRDaGFuZ2VMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXNUaWVyLmJyb3dzZXIucmVmcmVzaFRpZXIodGhpc1RpZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5Ccm93c2VyLnByb3RvdHlwZS5jcmVhdGVTb3VyY2VzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzb3VyY2VzID0gc2VsZi5zb3VyY2VDYWNoZS5nZXQoY29uZmlnKTtcbiAgICBpZiAoc291cmNlcylcbiAgICAgICAgcmV0dXJuIHNvdXJjZXM7XG5cbiAgICB2YXIgZnMsIHNzO1xuICAgIGlmIChjb25maWcudGllcl90eXBlID09PSBcIm11bHRpXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgZnM6IG51bGwsIHNzOiBudWxsIH07XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy50aWVyX3R5cGUgPT09IFwiZXh0ZXJuYWxcIikge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNvbmZpZ3VyaW5nIGV4dGVybmFsIHNvdXJjZVwiKTtcblxuICAgICAgICBjb25zb2xlLmxvZyh0eXBlb2YgY29uZmlnLmV4dGVybmFsX2ZldGNoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5leHRlcm5hbF9mZXRjaCAmJiB0eXBlb2YgY29uZmlnLmV4dGVybmFsX2ZldGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZzID0gbmV3IEZlYXR1cmVTb3VyY2VCYXNlKCk7XG4gICAgICAgICAgICBmcy5mZXRjaCA9IChhLGIsYyxkLGUsZixnKSA9PiBjb25maWcuZXh0ZXJuYWxfZmV0Y2goYSxiLGMsZCxlLGYsZykoKTtcbiAgICAgICAgICAgIHNzID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXh0ZXJuYWwgc291cmNlOlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGZzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibWlzY29uZmlndXJlZCBleHRlcm5hbCBmZWF0dXJlIHNvdXJjZVwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29uZmlnLnRpZXJfdHlwZSA9PSAnc2VxdWVuY2UnIHx8IGNvbmZpZy50d29CaXRVUkkgfHwgY29uZmlnLnR3b0JpdEJsb2IpIHtcbiAgICAgICAgaWYgKGNvbmZpZy50d29CaXRVUkkgfHwgY29uZmlnLnR3b0JpdEJsb2IpIHtcbiAgICAgICAgICAgIHNzID0gbmV3IFR3b0JpdFNlcXVlbmNlU291cmNlKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmVuc2VtYmxVUkkpIHtcbiAgICAgICAgICAgIHNzID0gbmV3IEVuc2VtYmxTZXF1ZW5jZVNvdXJjZShjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3MgPSBuZXcgREFTU2VxdWVuY2VTb3VyY2UoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29uZmlnLnRpZXJfdHlwZSAmJiBfX2RhbGxpYW5jZV9zb3VyY2VBZGFwdGVyRmFjdG9yaWVzW2NvbmZpZy50aWVyX3R5cGVdKSB7XG4gICAgICAgIHZhciBzYWYgPSBfX2RhbGxpYW5jZV9zb3VyY2VBZGFwdGVyRmFjdG9yaWVzW2NvbmZpZy50aWVyX3R5cGVdO1xuICAgICAgICB2YXIgbnM7XG4gICAgICAgIG5zID0gc2FmKGNvbmZpZyk7XG4gICAgICAgIGZzID0gbnMuZmVhdHVyZXM7XG4gICAgICAgIHNzID0gbnMuc2VxdWVuY2U7XG4gICAgfSBlbHNlIGlmIChjb25maWcuYndnVVJJIHx8IGNvbmZpZy5id2dCbG9iKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB0aGlzLmdldFdvcmtlcigpO1xuICAgICAgICBpZiAod29ya2VyKVxuICAgICAgICAgICAgZnMgPSBuZXcgUmVtb3RlQldHRmVhdHVyZVNvdXJjZShjb25maWcsIHdvcmtlciwgdGhpcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZzID0gbmV3IEJXR0ZlYXR1cmVTb3VyY2UoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5iYW1VUkkgfHwgY29uZmlnLmJhbUJsb2IpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHRoaXMuZ2V0V29ya2VyKCk7XG4gICAgICAgIGlmICh3b3JrZXIpXG4gICAgICAgICAgICBmcyA9IG5ldyBSZW1vdGVCQU1GZWF0dXJlU291cmNlKGNvbmZpZywgd29ya2VyLCB0aGlzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnMgPSBuZXcgQkFNRmVhdHVyZVNvdXJjZShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmpiVVJJKSB7XG4gICAgICAgIGZzID0gbmV3IEpCcm93c2VGZWF0dXJlU291cmNlKGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcudXJpIHx8IGNvbmZpZy5mZWF0dXJlc191cmkpIHtcbiAgICAgICAgZnMgPSBuZXcgREFTRmVhdHVyZVNvdXJjZShjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcub3ZlcmxheSkge1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBpZiAoZnMpXG4gICAgICAgICAgICBzb3VyY2VzLnB1c2gobmV3IENhY2hpbmdGZWF0dXJlU291cmNlKGZzKSk7XG5cbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IGNvbmZpZy5vdmVybGF5Lmxlbmd0aDsgKytvaSkge1xuICAgICAgICAgICAgdmFyIGNzID0gdGhpcy5jcmVhdGVTb3VyY2VzKGNvbmZpZy5vdmVybGF5W29pXSk7XG4gICAgICAgICAgICBpZiAoY3MgJiYgY3MuZmVhdHVyZXMpXG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKGNzLmZlYXR1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICBmcyA9IG5ldyBPdmVybGF5RmVhdHVyZVNvdXJjZShzb3VyY2VzLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuc2VxdWVuY2VBbGlhc2VzKSB7XG4gICAgICAgIGZzID0gbmV3IE1hcHBlZEZlYXR1cmVTb3VyY2UoZnMsIG5ldyBDaGFpbnNldCh7dHlwZTogJ2FsaWFzJywgc2VxdWVuY2VBbGlhc2VzOiBjb25maWcuc2VxdWVuY2VBbGlhc2VzfSkpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubWFwcGluZykge1xuICAgICAgICBmcyA9IG5ldyBNYXBwZWRGZWF0dXJlU291cmNlKGZzLCB0aGlzLmNoYWluc1tjb25maWcubWFwcGluZ10pO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubmFtZSAmJiBmcyAmJiAhZnMubmFtZSkge1xuICAgICAgICBmcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZnMgIT09IG51bGwgJiYgY29uZmlnLnRpZXJfdHlwZSAhPT0gXCJleHRlcm5hbFwiKSB7XG4gICAgICAgIGZzID0gbmV3IENhY2hpbmdGZWF0dXJlU291cmNlKGZzKTtcbiAgICB9XG5cbiAgICBpZiAoICh0eXBlb2YgZnMgIT09ICd1bmRlZmluZWQnICYmIGZzICE9PSAgbnVsbCkgfHwgKHR5cGVvZiBzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgc3MgIT0gbnVsbCkgKSB7XG4gICAgICAgIHNvdXJjZXMgPSB7XG4gICAgICAgICAgICBmZWF0dXJlczogZnMsXG4gICAgICAgICAgICBzZXF1ZW5jZTogc3NcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb3VyY2VDYWNoZS5wdXQoY29uZmlnLCBzb3VyY2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlcztcbn07XG5cbkRhc1RpZXIucHJvdG90eXBlLmZldGNoU3R5bGVzaGVldCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgdmFyIHNzU291cmNlO1xuICAgIC8vIFNvbWV3aGF0IHVnbHkgd29ya2Fyb3VuZCBmb3IgdGhlIHNwZWNpYWwgY2FzZSBvZiBEQVMgc291cmNlcy4uLlxuICAgIGlmICh0aGlzLmRhc1NvdXJjZS50aWVyX3R5cGUgPT09IFwibXVsdGktdHJhY2tcIikge1xuICAgICAgICBzc1NvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgfSBlbHNlXG4gICAgaWYgKHRoaXMuZGFzU291cmNlLnN0eWxlc2hlZXRfdXJpIHx8IChcbiAgICAgICAgIXRoaXMuZGFzU291cmNlLnRpZXJfdHlwZSAmJlxuICAgICAgICAhdGhpcy5kYXNTb3VyY2UuYndnVVJJICYmXG4gICAgICAgICF0aGlzLmRhc1NvdXJjZS5id2dCbG9iICYmXG4gICAgICAgICF0aGlzLmRhc1NvdXJjZS5iYW1VUkkgJiZcbiAgICAgICAgIXRoaXMuZGFzU291cmNlLmJhbUJsb2IgJiZcbiAgICAgICAgIXRoaXMuZGFzU291cmNlLnR3b0JpdFVSSSAmJlxuICAgICAgICAhdGhpcy5kYXNTb3VyY2UudHdvQml0QmxvYiAmJlxuICAgICAgICAhdGhpcy5kYXNTb3VyY2UuamJVUkkgJiZcbiAgICAgICAgIXRoaXMuZGFzU291cmNlLm92ZXJsYXkpKVxuICAgIHtcbiAgICAgICAgc3NTb3VyY2UgPSBuZXcgREFTRmVhdHVyZVNvdXJjZSh0aGlzLmRhc1NvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3NTb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhzc1NvdXJjZSk7XG4gICAgc3NTb3VyY2UuZ2V0U3R5bGVTaGVldChjYik7XG59O1xuXG52YXIgX19jZnNfaWRfc2VlZCA9IDA7XG5cbmZ1bmN0aW9uIENhY2hpbmdGZWF0dXJlU291cmNlKHNvdXJjZSkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmNmc2lkID0gJ2NmcycgKyAoKytfX2Nmc19pZF9zZWVkKTtcbiAgICBpZiAoc291cmNlLm5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuYWRkQ2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgc291cmNlLmFkZENoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpc0IuY2ZzaWQgPSAnY2ZzJyArICgrK19fY2ZzX2lkX3NlZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5hZGRSZWFkaW5lc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLmFkZFJlYWRpbmVzc0xpc3RlbmVyKVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuYWRkUmVhZGluZXNzTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGVsc2VcbiAgICAgICAgbGlzdGVuZXIobnVsbCk7XG59O1xuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUucmVtb3ZlUmVhZGluZXNzTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnNvdXJjZS5yZW1vdmVSZWFkaW5lc3NMaXN0ZW5lcilcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnJlbW92ZVJlYWRpbmVzc0xpc3RlbmVyKGxpc3RlbmVyKTtcbn07XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zb3VyY2Uuc2VhcmNoKVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2VhcmNoKHF1ZXJ5LCBjYWxsYmFjayk7XG59O1xuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZJUHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnNvdXJjZS5nZXREZWZhdWx0RklQcylcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldERlZmF1bHRGSVBzKGNhbGxiYWNrKTtcbn07XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLnNvdXJjZS5nZXRTdHlsZVNoZWV0KGNhbGxiYWNrKTtcbn07XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0U2NhbGVzKCk7XG59O1xuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuYWRkQWN0aXZpdHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICBpZiAodGhpcy5zb3VyY2UuYWRkQWN0aXZpdHlMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvdXJjZS5hZGRBY3Rpdml0eUxpc3RlbmVyKGwpO1xuICAgIH1cbn07XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIGlmICh0aGlzLnNvdXJjZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUFjdGl2aXR5TGlzdGVuZXIobCk7XG4gICAgfVxufTtcblxuQ2FjaGluZ0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmFkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIGlmICh0aGlzLnNvdXJjZS5hZGRDaGFuZ2VMaXN0ZW5lcilcbiAgICAgICAgdGhpcy5zb3VyY2UuYWRkQ2hhbmdlTGlzdGVuZXIobCk7XG59O1xuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKVxuICAgICAgICB0aGlzLnNvdXJjZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcihsKTtcbn07XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5maW5kTmV4dEZlYXR1cmUgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuc291cmNlLmZpbmROZXh0RmVhdHVyZShjaHIsIHBvcywgZGlyLCBjYWxsYmFjayk7XG59O1xuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUucXVhbnRGaW5kTmV4dEZlYXR1cmUgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCB0aHJlc2hvbGQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zb3VyY2UucXVhbnRGaW5kTmV4dEZlYXR1cmUoY2hyLCBwb3MsIGRpciwgdGhyZXNob2xkLCBjYWxsYmFjayk7XG59O1xuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuY2FwYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLmNhcGFiaWxpdGllcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY2FwYWJpbGl0aWVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2ssIHN0eWxlRmlsdGVycykge1xuICAgIGlmICghcG9vbCkge1xuICAgICAgICB0aHJvdyBFcnJvcignRmV0Y2ggcG9vbCBpcyBudWxsJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWNoZUtleSA9IHRoaXMuY2ZzaWQ7XG5cbiAgICB2YXIgYXdhaXRlZEZlYXR1cmVzID0gcG9vbC5hd2FpdGVkRmVhdHVyZXNbY2FjaGVLZXldO1xuICAgIGlmIChhd2FpdGVkRmVhdHVyZXMgJiYgYXdhaXRlZEZlYXR1cmVzLnN0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKGF3YWl0ZWRGZWF0dXJlcy5zdHlsZUZpbHRlcnMuZG9lc05vdENvbnRhaW4oc3R5bGVGaWx0ZXJzKSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZldGNoIGFscmVhZHkgc3RhcnRlZCB3aXRoIHdyb25nIHBhcmFtZXRlcnMsIHNraXBwaW5nIGNhY2hlLicpO1xuICAgICAgICAgICAgc2VsZi5zb3VyY2UuZmV0Y2goY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaywgc3R5bGVGaWx0ZXJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXdhaXRlZEZlYXR1cmVzKSB7XG4gICAgICAgIGlmIChhd2FpdGVkRmVhdHVyZXMuc3R5bGVGaWx0ZXJzKVxuICAgICAgICAgICAgYXdhaXRlZEZlYXR1cmVzLnN0eWxlRmlsdGVycy5hZGRBbGwoc3R5bGVGaWx0ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdGVkRmVhdHVyZXMgPSBuZXcgQXdhaXRlZCgpO1xuICAgICAgICB2YXIgdHlwZUxpc3QgPSBudWxsO1xuICAgICAgICBpZiAoc3R5bGVGaWx0ZXJzKSB7XG4gICAgICAgICAgICBhd2FpdGVkRmVhdHVyZXMuc3R5bGVGaWx0ZXJzID0gc3R5bGVGaWx0ZXJzO1xuICAgICAgICAgICAgdHlwZUxpc3QgPSBhd2FpdGVkRmVhdHVyZXMuc3R5bGVGaWx0ZXJzLnR5cGVMaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9vbC5hd2FpdGVkRmVhdHVyZXNbY2FjaGVLZXldID0gYXdhaXRlZEZlYXR1cmVzO1xuXG4gICAgICAgIHBvb2wucmVxdWVzdHNJc3N1ZWQudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGF3YWl0ZWRGZWF0dXJlcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYuc291cmNlLmZldGNoKFxuICAgICAgICAgICAgICAgIGNocixcbiAgICAgICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgICAgIHR5cGVMaXN0LFxuICAgICAgICAgICAgICAgIHBvb2wsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oc3RhdHVzLCBmZWF0dXJlcywgc2NhbGUsIGNvdmVyYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXdhaXRlZEZlYXR1cmVzLnJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0ZWRGZWF0dXJlcy5wcm92aWRlKHtzdGF0dXM6IHN0YXR1cywgZmVhdHVyZXM6IGZlYXR1cmVzLCBzY2FsZTogc2NhbGUsIGNvdmVyYWdlOiBjb3ZlcmFnZX0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXdhaXRlZEZlYXR1cmVzLnN0eWxlRmlsdGVycyk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXdhaXRlZEZlYXR1cmVzLmF3YWl0KGZ1bmN0aW9uKGFmKSB7XG4gICAgICAgIGNhbGxiYWNrKGFmLnN0YXR1cywgYWYuZmVhdHVyZXMsIGFmLnNjYWxlLCBhZi5jb3ZlcmFnZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBGZWF0dXJlU291cmNlQmFzZSgpIHtcbiAgICB0aGlzLmJ1c3kgPSAwO1xuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMucmVhZGluZXNzID0gbnVsbDtcbn1cblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLmFkZFJlYWRpbmVzc0xpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lcih0aGlzLnJlYWRpbmVzcyk7XG59O1xuXG5GZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUucmVtb3ZlUmVhZGluZXNzTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy5yZWFkaW5lc3NMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5yZWFkaW5lc3NMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufTtcblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLm5vdGlmeVJlYWRpbmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycy5sZW5ndGg7ICsrbGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVhZGluZXNzTGlzdGVuZXJzW2xpXSh0aGlzLnJlYWRpbmVzcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLmFkZEFjdGl2aXR5TGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG59O1xuXG5GZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUucmVtb3ZlQWN0aXZpdHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufTtcblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLm5vdGlmeUFjdGl2aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzW2xpXSh0aGlzLmJ1c3kpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY250KSB7XG4gICAgcmV0dXJuIGNudChudWxsLCBbXSwgMTAwMDAwMDAwMCk7XG59O1xuXG5GZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuICAgIHZhciBkZWZTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgIGRlZlN0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgZGVmU3R5bGUuQkdDT0xPUiA9ICdibHVlJztcbiAgICBkZWZTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgZGVmU3R5bGUpO1xuICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbn07XG5cblxuXG5mdW5jdGlvbiBEQVNGZWF0dXJlU291cmNlKGRhc1NvdXJjZSkge1xuICAgIHRoaXMuZGFzU291cmNlID0gbmV3IERBU1NvdXJjZShkYXNTb3VyY2UpO1xuICAgIHRoaXMuYnVzeSA9IDA7XG4gICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVycyA9IFtdO1xufVxuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5hZGRBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xufTtcblxuREFTRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUucmVtb3ZlQWN0aXZpdHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xufTtcblxuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5ub3RpZnlBY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVyc1tsaV0odGhpcy5idXN5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLmRhc1NvdXJjZS5zdHlsZXNoZWV0KGZ1bmN0aW9uKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgY2FsbGJhY2soc3R5bGVzaGVldCk7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFwiQ291bGRuJ3QgZmV0Y2ggREFTIHN0eWxlc2hlZXRcIik7XG4gICAgfSk7XG59O1xuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZXMgJiYgdHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFtdLCBzY2FsZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGFzU291cmNlLnVyaSAmJiAhdGhpcy5kYXNTb3VyY2UuZmVhdHVyZXNfdXJpKSB7XG4gICAgICAgIC8vIEZJWE1FIHNob3VsZCB0aGlzIGJlIG1ha2luZyBhbiBlcnJvciBjYWxsYmFjaz8/P1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGFzU291cmNlLmRhc1N0YXRpY0ZlYXR1cmVzICYmIHRoaXMuY2FjaGVkU3RhdGljRmVhdHVyZXMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRoaXMuY2FjaGVkU3RhdGljRmVhdHVyZXMsIHRoaXMuY2FjaGVkU3RhdGljU2NhbGUpO1xuICAgIH1cblxuICAgIHZhciB0cnlNYXhCaW5zID0gKHRoaXMuZGFzU291cmNlLm1heGJpbnMgIT09IGZhbHNlKTtcbiAgICB2YXIgZm9wcyA9IHtcbiAgICAgICAgdHlwZTogdHlwZXNcbiAgICB9O1xuICAgIGlmICh0cnlNYXhCaW5zKSB7XG4gICAgICAgIGZvcHMubWF4YmlucyA9IDEgKyAoKChtYXggLSBtaW4pIC8gc2NhbGUpIHwgMCk7XG4gICAgfVxuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcblxuICAgIHRoaXMuZGFzU291cmNlLmZlYXR1cmVzKFxuICAgICAgICBuZXcgREFTU2VnbWVudChjaHIsIG1pbiwgbWF4KSxcbiAgICAgICAgZm9wcyxcbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZXMsIHN0YXR1cykge1xuXG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICB2YXIgcmV0U2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgIGlmICghdHJ5TWF4Qmlucykge1xuICAgICAgICAgICAgICAgIHJldFNjYWxlID0gMC4xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0dXMgJiYgdGhpc0IuZGFzU291cmNlLmRhc1N0YXRpY0ZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IuY2FjaGVkU3RhdGljRmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgICAgICAgICB0aGlzQi5jYWNoZWRTdGF0aWNTY2FsZSA9IHJldFNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soc3RhdHVzLCBmZWF0dXJlcywgcmV0U2NhbGUpO1xuICAgICAgICB9XG4gICAgKTtcbn07XG5cbkRBU0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZGFzU291cmNlLmNhcGFiaWxpdGllcyAmJiBhcnJheUluZGV4T2YodGhpcy5kYXNTb3VyY2UuY2FwYWJpbGl0aWVzLCAnZGFzMTphZGphY2VudC1mZWF0dXJlJykgPj0gMCkge1xuICAgICAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kYXNBZGpMb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coJ0FscmVhZHkgbG9va2luZyBmb3IgYSBuZXh0IGZlYXR1cmUsIGJlIHBhdGllbnQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXNBZGpMb2NrID0gdHJ1ZTtcbiAgICAgICAgdmFyIGZvcHMgPSB7XG4gICAgICAgICAgICBhZGphY2VudDogY2hyICsgJzonICsgKHBvc3wwKSArICc6JyArIChkaXIgPiAwID8gJ0YnIDogJ0InKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdHlwZXMgPSB0aGlzVGllci5nZXREZXNpcmVkVHlwZXModGhpc1RpZXIuYnJvd3Nlci5zY2FsZSk7XG4gICAgICAgIGlmICh0eXBlcykge1xuICAgICAgICAgICAgZm9wcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNUaWVyLmRhc1NvdXJjZS5mZWF0dXJlcyhudWxsLCBmb3BzLCBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgIHRoaXNCLmRhc0FkakxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCAmJiByZXNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBEQVNTZXF1ZW5jZVNvdXJjZShkYXNTb3VyY2UpIHtcbiAgICB0aGlzLmRhc1NvdXJjZSA9IG5ldyBEQVNTb3VyY2UoZGFzU291cmNlKTtcbiAgICB0aGlzLmF3YWl0ZWRFbnRyeVBvaW50cyA9IG5ldyBBd2FpdGVkKCk7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuZGFzU291cmNlLmVudHJ5UG9pbnRzKFxuICAgICAgICBmdW5jdGlvbihlcCkge1xuICAgICAgICAgICAgdGhpc0IuYXdhaXRlZEVudHJ5UG9pbnRzLnByb3ZpZGUoZXApO1xuICAgICAgICB9KTtcbn1cblxuXG5EQVNTZXF1ZW5jZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBwb29sLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZGFzU291cmNlLnNlcXVlbmNlKFxuICAgICAgICBuZXcgREFTU2VnbWVudChjaHIsIG1pbiwgbWF4KSxcbiAgICAgICAgZnVuY3Rpb24oc2Vxcykge1xuICAgICAgICAgICAgaWYgKHNlcXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2Vxc1swXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhcIkRpZG4ndCBnZXQgc2VxdWVuY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufTtcblxuREFTU2VxdWVuY2VTb3VyY2UucHJvdG90eXBlLmdldFNlcUluZm8gPSBmdW5jdGlvbihjaHIsIGNudCkge1xuICAgIHRoaXMuYXdhaXRlZEVudHJ5UG9pbnRzLmF3YWl0KGZ1bmN0aW9uKGVwKSB7XG4gICAgICAgIGZvciAodmFyIGVwaSA9IDA7IGVwaSA8IGVwLmxlbmd0aDsgKytlcGkpIHtcbiAgICAgICAgICAgIGlmIChlcFtlcGldLm5hbWUgPT0gY2hyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNudCh7bGVuZ3RoOiBlcFtlcGldLmVuZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbnQoKTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIFR3b0JpdFNlcXVlbmNlU291cmNlKHNvdXJjZSkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy50d29CaXQgPSBuZXcgQXdhaXRlZCgpO1xuICAgIHZhciBkYXRhO1xuICAgIGlmIChzb3VyY2UudHdvQml0VVJJKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVVJMRmV0Y2hhYmxlKHNvdXJjZS50d29CaXRVUkksIHtjcmVkZW50aWFsczogc291cmNlLmNyZWRlbnRpYWxzLCByZXNvbHZlcjogc291cmNlLnJlc29sdmVyfSk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UudHdvQml0QmxvYikge1xuICAgICAgICBkYXRhID0gbmV3IEJsb2JGZXRjaGFibGUoc291cmNlLnR3b0JpdEJsb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiTm8gdHdvQml0VVJJIG9yIHR3b0JpdEJsb2IgcGFyYW1ldGVyXCIpO1xuICAgIH1cblxuICAgIG1ha2VUd29CaXQoZGF0YSwgZnVuY3Rpb24odGIsIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc0IudHdvQml0LnByb3ZpZGUodGIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblR3b0JpdFNlcXVlbmNlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudHdvQml0LmF3YWl0KGZ1bmN0aW9uKHRiKSB7XG4gICAgICAgICAgICB0Yi5mZXRjaChjaHIsIG1pbiwgbWF4LFxuICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oc2VxLCBlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IG5ldyBEQVNTZXF1ZW5jZShjaHIsIG1pbiwgbWF4LCAnRE5BJywgc2VxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNlcXVlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG59O1xuXG5Ud29CaXRTZXF1ZW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2VxSW5mbyA9IGZ1bmN0aW9uKGNociwgY250KSB7XG4gICAgdGhpcy50d29CaXQuYXdhaXQoZnVuY3Rpb24odGIpIHtcbiAgICAgICAgdmFyIHNlcSA9IHRiLmdldFNlcShjaHIpO1xuICAgICAgICBpZiAoc2VxKSB7XG4gICAgICAgICAgICB0Yi5nZXRTZXEoY2hyKS5sZW5ndGgoZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgIGNudCh7bGVuZ3RoOiBsfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNudCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBFbnNlbWJsU2VxdWVuY2VTb3VyY2Uoc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgLy8gaHR0cDovL2RhdGEuZ3JhbWVuZS5vcmcvZW5zZW1ibC9pbmZvL2Fzc2VtYmx5L3RyaXRpY3VtX2Flc3RpdnVtLzJCP2NvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbi9qc29uXG4gICAgLy8gaHR0cDovL2RhdGEuZ3JhbWVuZS5vcmcvZW5zZW1ibC9zZXF1ZW5jZS9yZWdpb24vdHJpdGljdW1fYWVzdGl2dW0vMkI6ODAwMS4uMTgwMDA6MT9jb250ZW50LXR5cGU9YXBwbGljYXRpb24vanNvblxufVxuXG5FbnNlbWJsU2VxdWVuY2VTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgcG9vbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdXJsID0gdGhpcy5zb3VyY2UuZW5zZW1ibFVSSSArICcvc2VxdWVuY2UvcmVnaW9uLycgKyB0aGlzLnNvdXJjZS5zcGVjaWVzICsgJy8nICtcbiAgICAgICAgICAgICAgY2hyICsgJzonICsgbWluICsgJy4uJyArIG1heCArICc6MT9jb250ZW50LXR5cGU9YXBwbGljYXRpb24vanNvbic7XG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgIHZhciBqcjtcbiAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID49IDMwMCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSAnRXJyb3IgY29kZSAnICsgcmVxLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBqciA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBqci5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqciA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBuZXcgREFTU2VxdWVuY2UoY2hyLCBtaW4sIG1heCwgJ0ROQScsIGpyLnNlcSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNlcXVlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICByZXEuc2VuZCgpO1xufTtcblxuRW5zZW1ibFNlcXVlbmNlU291cmNlLnByb3RvdHlwZS5nZXRTZXFJbmZvID0gZnVuY3Rpb24oY2hyLCBjbnQpIHtcbiAgdmFyIHVybCA9IHRoaXMuc291cmNlLmVuc2VtYmxVUkkgKyAnL2luZm8vYXNzZW1ibHkvJyArIHRoaXMuc291cmNlLnNwZWNpZXMgKyAnLycgKyBjaHIgKyAnP2NvbnRlbnQtdHlwZT1hcHBsaWNhdGlvbi9qc29uJztcbiAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgIGlmIChyZXEuc3RhdHVzID49IDMwMCkge1xuICAgICAgICAgICAgY250KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIganIgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgICBjbnQoanIpO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuICByZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgcmVxLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgcmVxLnNlbmQoKTtcbn07XG5cbkRBU0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbXTtcbn07XG5cbnZhciBid2dfcHJlZmxpZ2h0cyA9IHt9O1xuXG5mdW5jdGlvbiBCV0dGZWF0dXJlU291cmNlKGJ3Z1NvdXJjZSkge1xuICAgIEZlYXR1cmVTb3VyY2VCYXNlLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMucmVhZGluZXNzID0gJ0Nvbm5lY3RpbmcnO1xuICAgIHRoaXMuYndnU291cmNlID0gdGhpcy5vcHRzID0gYndnU291cmNlO1xuICAgIHRoaXNCLmJ3Z0hvbGRlciA9IG5ldyBBd2FpdGVkKCk7XG5cbiAgICBpZiAodGhpcy5vcHRzLnByZWZsaWdodCkge1xuICAgICAgICB2YXIgcGZzID0gYndnX3ByZWZsaWdodHNbdGhpcy5vcHRzLnByZWZsaWdodF07XG4gICAgICAgIGlmICghcGZzKSB7XG4gICAgICAgICAgICBwZnMgPSBuZXcgQXdhaXRlZCgpO1xuICAgICAgICAgICAgYndnX3ByZWZsaWdodHNbdGhpcy5vcHRzLnByZWZsaWdodF0gPSBwZnM7XG5cbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBmcy5wcm92aWRlKCdzdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZnMucHJvdmlkZSgnZmFpbHVyZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vcGVuKCdnZXQnLCB0aGlzLm9wdHMucHJlZmxpZ2h0ICsgJz8nICsgaGV4X3NoYTEoJ3NhbHQnICsgRGF0ZS5ub3coKSksIHRydWUpOyAgICAvLyBJbnN0ZWFkLCBlbnN1cmUgd2UgYWx3YXlzIHByZWZsaWdodCBhIHVuaXF1ZSBVUkkuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHBmcy5hd2FpdChmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgIHRoaXNCLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc0IuaW5pdCgpO1xuICAgIH1cbn1cblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZSk7XG5cbkJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHZhciBhcmc7XG5cbiAgICB2YXIgdXJpID0gdGhpcy5id2dTb3VyY2UudXJpIHx8IHRoaXMuYndnU291cmNlLmJ3Z1VSSTtcbiAgICBpZiAodXJpKSB7XG4gICAgICAgIGlmICh0aGlzLmJ3Z1NvdXJjZS50cmFuc3BvcnQgPT09ICdlbmNvZGUnKSB7XG4gICAgICAgICAgICBhcmcgPSBuZXcgRW5jb2RlRmV0Y2hhYmxlKHVyaSwge2NyZWRlbnRpYWxzOiB0aGlzLm9wdHMuY3JlZGVudGlhbHN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZyA9IG5ldyBVUkxGZXRjaGFibGUodXJpLCB7Y3JlZGVudGlhbHM6IHRoaXMub3B0cy5jcmVkZW50aWFscywgcmVzb2x2ZXI6IHRoaXMub3B0cy5yZXNvbHZlcn0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJnID0gbmV3IEJsb2JGZXRjaGFibGUodGhpcy5id2dTb3VyY2UuYndnQmxvYik7XG4gICAgfVxuXG4gICAgbWFrZUJ3ZyhhcmcsIGZ1bmN0aW9uKGJ3ZywgZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXNCLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgdGhpc0IucmVhZGluZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeVJlYWRpbmVzcygpO1xuICAgICAgICAgICAgdGhpc0IuYndnSG9sZGVyLnByb3ZpZGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzQi5id2dIb2xkZXIucHJvdmlkZShid2cpO1xuICAgICAgICAgICAgdGhpc0IucmVhZGluZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeVJlYWRpbmVzcygpO1xuICAgICAgICAgICAgaWYgKGJ3Zy50eXBlID09ICdiaWdiZWQnKSB7XG4gICAgICAgICAgICAgICAgYndnLmdldEV4dHJhSW5kaWNlcyhmdW5jdGlvbihlaSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5leHRyYUluZGljZXMgPSBlaTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuY2FwYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhcHMgPSB7bGVhcDogdHJ1ZX07XG4gICAgaWYgKHRoaXMuYndnSG9sZGVyLnJlcyAmJiB0aGlzLmJ3Z0hvbGRlci5yZXMudHlwZSA9PSAnYmlnd2lnJylcbiAgICAgICAgY2Fwcy5xdWFudExlYXAgPSB0cnVlO1xuICAgIGlmICh0aGlzLmV4dHJhSW5kaWNlcyAmJiB0aGlzLmV4dHJhSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhcHMuc2VhcmNoID0gW107XG4gICAgICAgIGZvciAodmFyIGVpaSA9IDA7IGVpaSA8IHRoaXMuZXh0cmFJbmRpY2VzLmxlbmd0aDsgKytlaWkpIHtcbiAgICAgICAgICAgIGNhcHMuc2VhcmNoLnB1c2godGhpcy5leHRyYUluZGljZXNbZWlpXS5maWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhcHM7XG59O1xuXG5CV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuYndnSG9sZGVyLmF3YWl0KGZ1bmN0aW9uKGJ3Zykge1xuICAgICAgICBpZiAodHlwZW9mIGJ3ZyA9PT0gJ3VuZGVmaW5lZCcgfHwgYndnID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpc0IuZXJyb3IgfHwgXCJDYW4ndCBhY2Nlc3MgYmluYXJ5IGZpbGVcIiwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgdmFyIHdhbnREZW5zaXR5ID0gIXR5cGVzIHx8IHR5cGVzLmxlbmd0aCA9PT0gMCB8fCBhcnJheUluZGV4T2YodHlwZXMsICdkZW5zaXR5JykgPj0gMDtcbiAgICAgICAgaWYgKHRoaXNCLm9wdHMuY2xpZW50QmluKSB7XG4gICAgICAgICAgICB3YW50RGVuc2l0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IHRoaXNCLm9wdHMuc2NhbGVGYWN0b3IgfHwgMS4wO1xuICAgICAgICBpZiAoYndnLnR5cGUgPT0gJ2JpZ3dpZycgfHwgd2FudERlbnNpdHkgfHwgKHR5cGVvZiB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IGJ3Zy56b29tTGV2ZWxzLmxlbmd0aDsgKyt6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ3Zy56b29tTGV2ZWxzW3pdLnJlZHVjdGlvbiA8PSAoc2NhbGUgKiBzY2FsZUZhY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbSA9IHo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHpvb20gPSB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoem9vbSA8IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYndnLmdldFVuem9vbWVkVmlldygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYndnLmdldFpvb21lZFZpZXcoem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gYndnLmdldFVuem9vbWVkVmlldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc0IuYnVzeSsrO1xuICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICBkYXRhLnJlYWRXaWdEYXRhKGNociwgbWluLCBtYXgsIGZ1bmN0aW9uKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICB2YXIgZnMgPSAxMDAwMDAwMDAwO1xuICAgICAgICAgICAgaWYgKGJ3Zy50eXBlID09PSAnYmlnd2lnJykge1xuICAgICAgICAgICAgICAgIHZhciBpcyA9IChtYXggLSBtaW4pIC8gZmVhdHVyZXMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoaXMgPCBmcykge1xuICAgICAgICAgICAgICAgICAgICBmcyA9IGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzQi5vcHRzLmxpbmspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gZmVhdHVyZXNbZmldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5saW5rcyA9IFtuZXcgREFTTGluaygnTGluaycsIHRoaXNCLm9wdHMubGluay5yZXBsYWNlKC9cXCRcXCQvLCBmLmxhYmVsKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmVhdHVyZXMsIGZzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5CV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5xdWFudEZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIHRocmVzaG9sZCwgY2FsbGJhY2spIHtcbiAgICAvLyB2YXIgYmVmb3JlUUZORiA9IERhdGUubm93KCl8MDtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXNCLmJ1c3krKztcbiAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgIHRoaXMuYndnSG9sZGVyLnJlcy50aHJlc2hvbGRTZWFyY2goY2hyLCBwb3MsIGRpciwgdGhyZXNob2xkLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICAgICAgLy8gdmFyIGFmdGVyUUZORiA9IERhdGUubm93KCl8MDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1FGTkYgdG9vayAnICsgKGFmdGVyUUZORiAtIGJlZm9yZVFGTkYpICsgJ21zJyk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiKTtcbiAgICB9KTtcbn07XG5cbkJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICB0aGlzLmJ3Z0hvbGRlci5yZXMuZ2V0VW56b29tZWRWaWV3KCkuZ2V0Rmlyc3RBZGphY2VudChjaHIsIHBvcywgZGlyLCBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgdGhpc0IuYnVzeS0tO1xuICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDAgJiYgcmVzWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNbMF0pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5CV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYndnID0gdGhpcy5id2dIb2xkZXIucmVzO1xuICAgIGlmIChid2cgLyogJiYgYndnLnR5cGUgPT0gJ2JpZ3dpZycgKi8pIHtcbiAgICAgICAgdmFyIHNjYWxlcyA9IFsxXTsgIC8vIENhbiB3ZSBiZSBzbWFydGVyIGFib3V0IGluZmVycmluZyBiYXNlbGluZSBzY2FsZT9cbiAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBid2cuem9vbUxldmVscy5sZW5ndGg7ICsreikge1xuICAgICAgICAgICAgc2NhbGVzLnB1c2goYndnLnpvb21MZXZlbHNbel0ucmVkdWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhbGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbkJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5leHRyYUluZGljZXMgfHwgdGhpcy5leHRyYUluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnTm8gaW5kaWNlcyBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmV4dHJhSW5kaWNlc1swXTtcbiAgICByZXR1cm4gaW5kZXgubG9va3VwKHF1ZXJ5LCBjYWxsYmFjayk7XG59O1xuXG5CV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXREZWZhdWx0RklQcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMub3B0cy5ub0V4dHJhRmVhdHVyZUluZm8pXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgdGhpcy5id2dIb2xkZXIuYXdhaXQoZnVuY3Rpb24oYndnKSB7XG4gICAgICAgIGlmICghYndnKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGJ3Zy5zY2hlbWEgJiYgYndnLmRlZmluZWRGaWVsZENvdW50IDwgYndnLnNjaGVtYS5maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZmlwID0gZnVuY3Rpb24oZmVhdHVyZSwgZmVhdHVyZUluZm8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgZmVhdHVyZUluZm8uaGl0Lmxlbmd0aDsgKytoaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUluZm8uaGl0W2hpXS5pc1N1cGVyR3JvdXApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gYndnLmRlZmluZWRGaWVsZENvdW50OyBmaSA8IGJ3Zy5zY2hlbWEuZmllbGRzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGJ3Zy5zY2hlbWEuZmllbGRzW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUluZm8uYWRkKGYuY29tbWVudCwgZmVhdHVyZVtmLm5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYWxsYmFjayhmaXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXMuYndnSG9sZGVyLmF3YWl0KGZ1bmN0aW9uKGJ3Zykge1xuICAgICAgICBpZiAoIWJ3Zykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdiYmkgZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICAgICAgaWYgKGJ3Zy50eXBlID09ICdiaWdiZWQnKSB7XG4gICAgICAgICAgICB2YXIgd2lnU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgICAgICAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSAnYmx1ZSc7XG4gICAgICAgICAgICB3aWdTdHlsZS5IRUlHSFQgPSA4O1xuICAgICAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5MQUJFTCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnYmlnYmVkJ30sIG51bGwsIHdpZ1N0eWxlKTtcbiAgICAgICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgICAgICAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSAncmVkJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNsYXRpb24nfSwgbnVsbCwgd2lnU3R5bGUpO1xuXG4gICAgICAgICAgICB2YXIgdHNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgdHNTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgdHNTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHRzU3R5bGUuQkdDT0xPUiA9ICd3aGl0ZSc7XG4gICAgICAgICAgICB0c1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICAgICAgdHNTdHlsZS5aSU5ERVggPSAxMDtcbiAgICAgICAgICAgIHRzU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB0c1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNjcmlwdCd9LCBudWxsLCB0c1N0eWxlKTtcblxuICAgICAgICAgICAgdmFyIGRlbnNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgZGVuc1N0eWxlLmdseXBoID0gJ0hJU1RPR1JBTSc7XG4gICAgICAgICAgICBkZW5zU3R5bGUuQ09MT1IxID0gJ3doaXRlJztcbiAgICAgICAgICAgIGRlbnNTdHlsZS5DT0xPUjIgPSAnYmxhY2snO1xuICAgICAgICAgICAgZGVuc1N0eWxlLkhFSUdIVD0zMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVuc2l0eSd9LCBudWxsLCBkZW5zU3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdISVNUT0dSQU0nO1xuICAgICAgICAgICAgd2lnU3R5bGUuQ09MT1IxID0gJ3doaXRlJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkNPTE9SMiA9ICdibGFjayc7XG4gICAgICAgICAgICB3aWdTdHlsZS5IRUlHSFQ9MzA7XG4gICAgICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ3Zy5kZWZpbmVkRmllbGRDb3VudCA9PSAxMiAmJiBid2cuZmllbGRDb3VudCA+PSAxNCkge1xuICAgICAgICAgICAgc3R5bGVzaGVldC5nZW5lSGludCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soc3R5bGVzaGVldCk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBSZW1vdGVCV0dGZWF0dXJlU291cmNlKGJ3Z1NvdXJjZSwgd29ya2VyLCBicm93c2VyKSB7XG4gICAgRmVhdHVyZVNvdXJjZUJhc2UuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy53b3JrZXIgPSB3b3JrZXI7XG4gICAgdGhpcy5yZWFkaW5lc3MgPSAnQ29ubmVjdGluZyc7XG4gICAgdGhpcy5id2dTb3VyY2UgPSB0aGlzLm9wdHMgPSBid2dTb3VyY2U7XG4gICAgdGhpcy5rZXlIb2xkZXIgPSBuZXcgQXdhaXRlZCgpO1xuXG4gICAgaWYgKGJ3Z1NvdXJjZS5yZXNvbHZlcikge1xuICAgICAgICB0aGlzLnJlc29sdmVyS2V5ID0gYnJvd3Nlci5yZWdpc3RlclJlc29sdmVyKGJ3Z1NvdXJjZS5yZXNvbHZlcik7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0KCk7XG59XG5cblJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUpO1xuXG5SZW1vdGVCV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgdXJpID0gdGhpcy51cmkgfHwgdGhpcy5id2dTb3VyY2UudXJpIHx8IHRoaXMuYndnU291cmNlLmJ3Z1VSSTtcbiAgICB2YXIgYmxvYiA9IHRoaXMuYndnU291cmNlLmJsb2IgfHwgdGhpcy5id2dTb3VyY2UuYndnQmxvYjtcblxuICAgIHZhciBjbnQgPSBmdW5jdGlvbihrZXksIGVycikge1xuICAgICAgICB0aGlzQi5yZWFkaW5lc3MgPSBudWxsO1xuICAgICAgICB0aGlzQi5ub3RpZnlSZWFkaW5lc3MoKTtcblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICB0aGlzQi53b3JrZXIucG9zdENvbW1hbmQoe2NvbW1hbmQ6ICdtZXRhJywgY29ubmVjdGlvbjoga2V5fSwgZnVuY3Rpb24obWV0YSwgZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iua2V5SG9sZGVyLnByb3ZpZGUobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IubWV0YSA9IG1ldGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLmtleUhvbGRlci5wcm92aWRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzQi5lcnJvciA9IGVycjtcbiAgICAgICAgICAgIHRoaXNCLmtleUhvbGRlci5wcm92aWRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmIChibG9iKSB7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnY29ubmVjdEJCSScsIGJsb2I6IGJsb2J9LCBjbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdjb25uZWN0QkJJJyxcbiAgICAgICAgICAgIHVyaTogcmVzb2x2ZVVybFRvUGFnZSh1cmkpLFxuICAgICAgICAgICAgcmVzb2x2ZXI6IHRoaXMucmVzb2x2ZXJLZXksXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHRoaXMuYndnU291cmNlLnRyYW5zcG9ydCxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmJ3Z1NvdXJjZS5jcmVkZW50aWFsc30sXG4gICAgICAgICAgY250KTtcbiAgICB9XG59O1xuXG5SZW1vdGVCV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5jYXBhYmlsaXRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FwcyA9IHtsZWFwOiB0cnVlfTtcblxuICAgIGlmICh0aGlzLm1ldGEgJiYgdGhpcy5tZXRhLnR5cGUgPT0gJ2JpZ3dpZycpXG4gICAgICAgIGNhcHMucXVhbnRMZWFwID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5tZXRhICYmIHRoaXMubWV0YS5leHRyYUluZGljZXMgJiYgdGhpcy5tZXRhLmV4dHJhSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhcHMuc2VhcmNoID0gW107XG4gICAgICAgIGZvciAodmFyIGVpaSA9IDA7IGVpaSA8IHRoaXMubWV0YS5leHRyYUluZGljZXMubGVuZ3RoOyArK2VpaSkge1xuICAgICAgICAgICAgY2Fwcy5zZWFyY2gucHVzaCh0aGlzLm1ldGEuZXh0cmFJbmRpY2VzW2VpaV0uZmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYXBzO1xufTtcblxuUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXNCLmJ1c3krKztcbiAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgdGhpcy5rZXlIb2xkZXIuYXdhaXQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXNCLmVycm9yIHx8IFwiQ2FuJ3QgYWNjZXNzIGJpbmFyeSBmaWxlXCIsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHpvb20gPSAtMTtcbiAgICAgICAgdmFyIHdhbnREZW5zaXR5ID0gIXR5cGVzIHx8IHR5cGVzLmxlbmd0aCA9PT0gMCB8fCBhcnJheUluZGV4T2YodHlwZXMsICdkZW5zaXR5JykgPj0gMDtcbiAgICAgICAgaWYgKHRoaXNCLm9wdHMuY2xpZW50QmluKSB7XG4gICAgICAgICAgICB3YW50RGVuc2l0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzQi5tZXRhLnR5cGUgPT0gJ2JpZ3dpZycgfHwgd2FudERlbnNpdHkgfHwgKHR5cGVvZiB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHogPSAxOyB6IDwgdGhpc0IubWV0YS56b29tTGV2ZWxzLmxlbmd0aDsgKyt6KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLm1ldGEuem9vbUxldmVsc1t6XSA8PSBzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICB6b29tID0geiAtIDE7IC8vIFNjYWxlcyByZXR1cm5lZCBpbiBtZXRhZGF0YSBzdGFydCBhdCAxLCB1bmxpa2UgXCJyZWFsXCIgem9vbSBsZXZlbHMuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHpvb20gPSB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpc0Iud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnZmV0Y2gnLCBjb25uZWN0aW9uOiBrZXksIGNocjogY2hyLCBtaW46IG1pbiwgbWF4OiBtYXgsIHpvb206IHpvb219LCBmdW5jdGlvbihmZWF0dXJlcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG5cbiAgICAgICAgICAgIHZhciBmcyA9IDEwMDAwMDAwMDA7XG4gICAgICAgICAgICBpZiAodGhpc0IubWV0YS50eXBlID09PSAnYmlnd2lnJykge1xuICAgICAgICAgICAgICAgIHZhciBpcyA9IChtYXggLSBtaW4pIC8gZmVhdHVyZXMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoaXMgPCBmcykge1xuICAgICAgICAgICAgICAgICAgICBmcyA9IGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzQi5vcHRzLmxpbmspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gZmVhdHVyZXNbZmldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZi5saW5rcyA9IFtuZXcgREFTTGluaygnTGluaycsIHRoaXNCLm9wdHMubGluay5yZXBsYWNlKC9cXCRcXCQvLCBmLmxhYmVsKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGZlYXR1cmVzLCBmcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuXG5SZW1vdGVCV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5xdWFudEZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIHRocmVzaG9sZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuYnVzeSsrO1xuICAgIHRoaXMubm90aWZ5QWN0aXZpdHkoKTtcbiAgICB0aGlzLndvcmtlci5wb3N0Q29tbWFuZCh7Y29tbWFuZDogJ3F1YW50TGVhcCcsIGNvbm5lY3Rpb246IHRoaXMua2V5SG9sZGVyLnJlcywgY2hyOiBjaHIsIHBvczogcG9zLCBkaXI6IGRpciwgdGhyZXNob2xkOiB0aHJlc2hvbGQsIHVuZGVyOiBmYWxzZX0sIGZ1bmN0aW9uKHJlc3VsdCwgZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCwgZXJyKTtcbiAgICAgICAgdGhpc0IuYnVzeS0tO1xuICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0LCBlcnIpO1xuICAgIH0pO1xufTtcblxuUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmluZE5leHRGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBwb3MsIGRpciwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuYnVzeSsrO1xuICAgIHRoaXMubm90aWZ5QWN0aXZpdHkoKTtcbiAgICB0aGlzLndvcmtlci5wb3N0Q29tbWFuZCh7Y29tbWFuZDogJ2xlYXAnLCBjb25uZWN0aW9uOiB0aGlzLmtleUhvbGRlci5yZXMsIGNocjogY2hyLCBwb3M6IHBvcywgZGlyOiBkaXJ9LCBmdW5jdGlvbihyZXN1bHQsIGVycikge1xuICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdFswXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtZXRhID0gdGhpcy5tZXRhO1xuICAgIGlmIChtZXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhLnpvb21MZXZlbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLm1ldGEuZXh0cmFJbmRpY2VzIHx8IHRoaXMubWV0YS5leHRyYUluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnTm8gaW5kaWNlcyBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuYnVzeSsrO1xuICAgIHRoaXMubm90aWZ5QWN0aXZpdHkoKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLm1ldGEuZXh0cmFJbmRpY2VzWzBdO1xuICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnc2VhcmNoJywgY29ubmVjdGlvbjogdGhpcy5rZXlIb2xkZXIucmVzLCBxdWVyeTogcXVlcnksIGluZGV4OiBpbmRleH0sIGZ1bmN0aW9uKHJlc3VsdCwgZXJyKSB7XG4gICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcblxuICAgICAgICBjYWxsYmFjayhyZXN1bHQsIGVycik7XG4gICAgfSk7XG59O1xuXG5SZW1vdGVCV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXREZWZhdWx0RklQcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMub3B0cy5ub0V4dHJhRmVhdHVyZUluZm8pXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmtleUhvbGRlci5hd2FpdChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGJ3ZyA9IHRoaXNCLm1ldGE7XG4gICAgICAgIGlmICghYndnKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGJ3Zy5zY2hlbWEgJiYgYndnLmRlZmluZWRGaWVsZENvdW50IDwgYndnLnNjaGVtYS5maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZmlwID0gZnVuY3Rpb24oZmVhdHVyZSwgZmVhdHVyZUluZm8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgZmVhdHVyZUluZm8uaGl0Lmxlbmd0aDsgKytoaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUluZm8uaGl0W2hpXS5pc1N1cGVyR3JvdXApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gYndnLmRlZmluZWRGaWVsZENvdW50OyBmaSA8IGJ3Zy5zY2hlbWEuZmllbGRzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGJ3Zy5zY2hlbWEuZmllbGRzW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUluZm8uYWRkKGYuY29tbWVudCwgZmVhdHVyZVtmLm5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYWxsYmFjayhmaXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXMua2V5SG9sZGVyLmF3YWl0KGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgYndnID0gdGhpc0IubWV0YTtcbiAgICAgICAgaWYgKCFid2cpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnYmJpIGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3R5bGVzaGVldCA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG4gICAgICAgIGlmIChid2cudHlwZSA9PSAnYmlnYmVkJykge1xuICAgICAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgICAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ2JsdWUnO1xuICAgICAgICAgICAgd2lnU3R5bGUuSEVJR0hUID0gODtcbiAgICAgICAgICAgIHdpZ1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgICAgICAgICAgd2lnU3R5bGUuTEFCRUwgPSB0cnVlO1xuICAgICAgICAgICAgd2lnU3R5bGUuWklOREVYID0gMjA7XG4gICAgICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2JpZ2JlZCd9LCBudWxsLCB3aWdTdHlsZSk7XG5cbiAgICAgICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgICAgICAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSAncmVkJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNsYXRpb24nfSwgbnVsbCwgd2lnU3R5bGUpO1xuXG4gICAgICAgICAgICB2YXIgdHNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgdHNTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgdHNTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHRzU3R5bGUuQkdDT0xPUiA9ICd3aGl0ZSc7XG4gICAgICAgICAgICB0c1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICAgICAgdHNTdHlsZS5aSU5ERVggPSAxMDtcbiAgICAgICAgICAgIHRzU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB0c1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNjcmlwdCd9LCBudWxsLCB0c1N0eWxlKTtcblxuICAgICAgICAgICAgdmFyIGRlbnNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgZGVuc1N0eWxlLmdseXBoID0gJ0hJU1RPR1JBTSc7XG4gICAgICAgICAgICBkZW5zU3R5bGUuQ09MT1IxID0gJ3doaXRlJztcbiAgICAgICAgICAgIGRlbnNTdHlsZS5DT0xPUjIgPSAnYmxhY2snO1xuICAgICAgICAgICAgZGVuc1N0eWxlLkhFSUdIVD0zMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVuc2l0eSd9LCBudWxsLCBkZW5zU3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdISVNUT0dSQU0nO1xuICAgICAgICAgICAgd2lnU3R5bGUuQ09MT1IxID0gJ3doaXRlJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkNPTE9SMiA9ICdibGFjayc7XG4gICAgICAgICAgICB3aWdTdHlsZS5IRUlHSFQ9MzA7XG4gICAgICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoYndnLmRlZmluZWRGaWVsZENvdW50ID09IDEyICYmIGJ3Zy5maWVsZENvdW50ID49IDE0KSB7XG4gICAgICAgICAgICBzdHlsZXNoZWV0LmdlbmVIaW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGJhbVJlY29yZFRvRmVhdHVyZShyLCBncm91cCkge1xuICAgIGlmIChyLmZsYWcgJiBCYW1GbGFncy5TRUdNRU5UX1VOTUFQUEVEKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgbGVuO1xuICAgIGlmIChyLnNlcSlcbiAgICAgICAgbGVuID0gci5zZXEubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgICAgbGVuID0gci5zZXFMZW5ndGg7XG5cbiAgICBpZiAoci5jaWdhcikge1xuICAgICAgICBsZW4gPSAwO1xuICAgICAgICB2YXIgb3BzID0gcGFyc2VDaWdhcihyLmNpZ2FyKTtcbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IG9wcy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgIHZhciBjbyA9IG9wc1tjaV07XG4gICAgICAgICAgICBpZiAoY28ub3AgPT0gJ00nIHx8IGNvLm9wID09ICdEJylcbiAgICAgICAgICAgICAgICBsZW4gKz0gY28uY250O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGYgPSBuZXcgREFTRmVhdHVyZSgpO1xuICAgIGYubWluID0gci5wb3MgKyAxO1xuICAgIGYubWF4ID0gci5wb3MgKyBsZW47XG4gICAgZi5zZWdtZW50ID0gci5zZWdtZW50O1xuICAgIGYudHlwZSA9ICdiYW0nO1xuICAgIGYuaWQgPSByLnJlYWROYW1lO1xuICAgIGYubm90ZXMgPSBbLyogJ1NlcXVlbmNlPScgKyByLnNlcSwgJ0NJR0FSPScgKyByLmNpZ2FyLCAqLyAnTVE9JyArIHIubXFdO1xuICAgIGYuY2lnYXIgPSByLmNpZ2FyO1xuICAgIGYuc2VxID0gci5zZXE7XG4gICAgZi5xdWFscyA9IHIucXVhbHM7XG4gICAgZi5vcmllbnRhdGlvbiA9IChyLmZsYWcgJiBCYW1GbGFncy5SRVZFUlNFX0NPTVBMRU1FTlQpID8gJy0nIDogJysnO1xuICAgIGYuYmFtUmVjb3JkID0gcjtcblxuICAgIGlmIChncm91cCAmJiAoci5mbGFnICYgQmFtRmxhZ3MuTVVMVElQTEVfU0VHTUVOVFMpKSB7XG4gICAgICAgIGYuZ3JvdXBzID0gW3tpZDogci5yZWFkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZWFkcGFpcid9XTtcbiAgICB9XG5cbiAgICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gQkFNRmVhdHVyZVNvdXJjZShiYW1Tb3VyY2UpIHtcbiAgICBGZWF0dXJlU291cmNlQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmJhbVNvdXJjZSA9IGJhbVNvdXJjZTtcbiAgICB0aGlzLm9wdHMgPSB7Y3JlZGVudGlhbHM6IGJhbVNvdXJjZS5jcmVkZW50aWFscywgcHJlZmxpZ2h0OiBiYW1Tb3VyY2UucHJlZmxpZ2h0LCBiYW1Hcm91cDogYmFtU291cmNlLmJhbUdyb3VwfTtcbiAgICB0aGlzLmJhbUhvbGRlciA9IG5ldyBBd2FpdGVkKCk7XG5cbiAgICBpZiAodGhpcy5vcHRzLnByZWZsaWdodCkge1xuICAgICAgICB2YXIgcGZzID0gYndnX3ByZWZsaWdodHNbdGhpcy5vcHRzLnByZWZsaWdodF07XG4gICAgICAgIGlmICghcGZzKSB7XG4gICAgICAgICAgICBwZnMgPSBuZXcgQXdhaXRlZCgpO1xuICAgICAgICAgICAgYndnX3ByZWZsaWdodHNbdGhpcy5vcHRzLnByZWZsaWdodF0gPSBwZnM7XG5cbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBmcy5wcm92aWRlKCdzdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZnMucHJvdmlkZSgnZmFpbHVyZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdjYWNoZS1jb250cm9sJywgJ25vLWNhY2hlJyk7ICAgIC8qIERvZXNuJ3Qgd29yaywgbm90IGFuIGFsbG93ZWQgcmVxdWVzdCBoZWFkZXIgaW4gQ09SUyAqL1xuICAgICAgICAgICAgcmVxLm9wZW4oJ2dldCcsIHRoaXMub3B0cy5wcmVmbGlnaHQgKyAnPycgKyBoZXhfc2hhMSgnc2FsdCcgKyBEYXRlLm5vdygpKSwgdHJ1ZSk7ICAgIC8vIEluc3RlYWQsIGVuc3VyZSB3ZSBhbHdheXMgcHJlZmxpZ2h0IGEgdW5pcXVlIFVSSS5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gJ3RydWUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBwZnMuYXdhaXQoZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgICAgICB0aGlzQi5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNCLmluaXQoKTtcbiAgICB9XG59XG5cbkJBTUZlYXR1cmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUpO1xuXG5CQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgYmFtRiwgYmFpRjtcbiAgICBpZiAodGhpcy5iYW1Tb3VyY2UuYmFtQmxvYikge1xuICAgICAgICBiYW1GID0gbmV3IEJsb2JGZXRjaGFibGUodGhpcy5iYW1Tb3VyY2UuYmFtQmxvYik7XG4gICAgICAgIGJhaUYgPSBuZXcgQmxvYkZldGNoYWJsZSh0aGlzLmJhbVNvdXJjZS5iYWlCbG9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBiYW1GID0gbmV3IFVSTEZldGNoYWJsZSh0aGlzLmJhbVNvdXJjZS5iYW1VUkksIHtjcmVkZW50aWFsczogdGhpcy5vcHRzLmNyZWRlbnRpYWxzLCByZXNvbHZlcjogdGhpcy5vcHRzLnJlc29sdmVyfSk7XG4gICAgICAgIGJhaUYgPSBuZXcgVVJMRmV0Y2hhYmxlKHRoaXMuYmFtU291cmNlLmJhaVVSSSB8fCAodGhpcy5iYW1Tb3VyY2UuYmFtVVJJICsgJy5iYWknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWRlbnRpYWxzOiB0aGlzLm9wdHMuY3JlZGVudGlhbHMsIHJlc29sdmVyOiB0aGlzLm9wdHMucmVzb2x2ZXJ9KTtcbiAgICB9XG4gICAgbWFrZUJhbShiYW1GLCBiYWlGLCBudWxsLCBmdW5jdGlvbihiYW0sIGVycikge1xuICAgICAgICB0aGlzQi5yZWFkaW5lc3MgPSBudWxsO1xuICAgICAgICB0aGlzQi5ub3RpZnlSZWFkaW5lc3MoKTtcblxuICAgICAgICBpZiAoYmFtKSB7XG4gICAgICAgICAgICB0aGlzQi5iYW1Ib2xkZXIucHJvdmlkZShiYW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc0IuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB0aGlzQi5iYW1Ib2xkZXIucHJvdmlkZShudWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpZ2h0ID0gdHlwZXMgJiYgKHR5cGVzLmxlbmd0aCA9PSAxKSAmJiAodHlwZXNbMF0gPT0gJ2RlbnNpdHknKTtcblxuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcblxuICAgIHRoaXMuYmFtSG9sZGVyLmF3YWl0KGZ1bmN0aW9uKGJhbSkge1xuICAgICAgICBpZiAoIWJhbSkge1xuICAgICAgICAgICAgdGhpc0IuYnVzeS0tO1xuICAgICAgICAgICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzQi5lcnJvciB8fCBcIkNvdWxkbid0IGZldGNoIEJBTVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhbS5mZXRjaChjaHIsIG1pbiwgbWF4LCBmdW5jdGlvbihiYW1SZWNvcmRzLCBlcnJvcikge1xuICAgICAgICAgICAgdGhpc0IuYnVzeS0tO1xuICAgICAgICAgICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByaSA9IDA7IHJpIDwgYmFtUmVjb3Jkcy5sZW5ndGg7ICsrcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBiYW1SZWNvcmRzW3JpXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGJhbVJlY29yZFRvRmVhdHVyZShyLCB0aGlzQi5vcHRzLmJhbUdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBmZWF0dXJlcywgMTAwMDAwMDAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtsaWdodDogbGlnaHR9KTtcbiAgICB9KTtcbn07XG5cbkJBTUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxMDAwMDAwMDAwO1xufTtcblxuQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYW1Ib2xkZXIuYXdhaXQoZnVuY3Rpb24oYmFtKSB7XG4gICAgICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICAgICAgdmFyIGRlbnNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICBkZW5zU3R5bGUuZ2x5cGggPSAnSElTVE9HUkFNJztcbiAgICAgICAgZGVuc1N0eWxlLkNPTE9SMSA9ICdibGFjayc7XG4gICAgICAgIGRlbnNTdHlsZS5DT0xPUjIgPSAncmVkJztcbiAgICAgICAgZGVuc1N0eWxlLkhFSUdIVD0zMDtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZW5zaXR5J30sICdsb3cnLCBkZW5zU3R5bGUpO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlbnNpdHknfSwgJ21lZGl1bScsIGRlbnNTdHlsZSk7XG5cbiAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ19fU0VRVUVOQ0UnO1xuICAgICAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgd2lnU3R5bGUuQkdDT0xPUiA9ICdibHVlJztcbiAgICAgICAgd2lnU3R5bGUuSEVJR0hUID0gODtcbiAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgIHdpZ1N0eWxlLkxBQkVMID0gZmFsc2U7XG4gICAgICAgIHdpZ1N0eWxlLlpJTkRFWCA9IDIwO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2JhbSd9LCAnaGlnaCcsIHdpZ1N0eWxlKTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soc3R5bGVzaGVldCk7XG4gICAgfSk7XG59O1xuXG5cbmZ1bmN0aW9uIFJlbW90ZUJBTUZlYXR1cmVTb3VyY2UoYmFtU291cmNlLCB3b3JrZXIpIHtcbiAgICBGZWF0dXJlU291cmNlQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmJhbVNvdXJjZSA9IGJhbVNvdXJjZTtcbiAgICB0aGlzLndvcmtlciA9IHdvcmtlcjtcbiAgICB0aGlzLm9wdHMgPSB7Y3JlZGVudGlhbHM6IGJhbVNvdXJjZS5jcmVkZW50aWFscywgcHJlZmxpZ2h0OiBiYW1Tb3VyY2UucHJlZmxpZ2h0LCBiYW1Hcm91cDogYmFtU291cmNlLmJhbUdyb3VwfTtcbiAgICB0aGlzLmtleUhvbGRlciA9IG5ldyBBd2FpdGVkKCk7XG5cbiAgICBpZiAoYmFtU291cmNlLnJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZXJLZXkgPSBicm93c2VyLnJlZ2lzdGVyUmVzb2x2ZXIoYmFtU291cmNlLnJlc29sdmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXQoKTtcbn1cblxuUmVtb3RlQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZSk7XG5cblJlbW90ZUJBTUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHsgICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgdXJpID0gdGhpcy5iYW1Tb3VyY2UudXJpIHx8IHRoaXMuYmFtU291cmNlLmJhbVVSSTtcbiAgICB2YXIgaW5kZXhVcmkgPSB0aGlzLmJhbVNvdXJjZS5pbmRleFVyaSB8fCB0aGlzLmJhbVNvdXJjZS5iYWlVUkkgfHwgdXJpICsgJy5iYWknO1xuXG4gICAgdmFyIGJsb2IgPSB0aGlzLmJhbVNvdXJjZS5iYW1CbG9iIHx8IHRoaXMuYmFtU291cmNlLmJsb2I7XG4gICAgdmFyIGluZGV4QmxvYiA9IHRoaXMuYmFtU291cmNlLmJhaUJsb2IgfHwgdGhpcy5iYW1Tb3VyY2UuaW5kZXhCbG9iO1xuXG4gICAgdmFyIGNudCA9IGZ1bmN0aW9uKHJlc3VsdCwgZXJyKSB7XG4gICAgICAgIHRoaXNCLnJlYWRpbmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXNCLm5vdGlmeVJlYWRpbmVzcygpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXNCLmtleUhvbGRlci5wcm92aWRlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzQi5lcnJvciA9IGVycjtcbiAgICAgICAgICAgIHRoaXNCLmtleUhvbGRlci5wcm92aWRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmIChibG9iKSB7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnY29ubmVjdEJBTScsIGJsb2I6IGJsb2IsIGluZGV4QmxvYjogaW5kZXhCbG9ifSwgY250KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0Q29tbWFuZCh7XG4gICAgICAgICAgICBjb21tYW5kOiAnY29ubmVjdEJBTScsXG4gICAgICAgICAgICB1cmk6IHJlc29sdmVVcmxUb1BhZ2UodXJpKSxcbiAgICAgICAgICAgIHJlc29sdmVyOiB0aGlzLnJlc29sdmVyS2V5LFxuICAgICAgICAgICAgaW5kZXhVcmk6IHJlc29sdmVVcmxUb1BhZ2UoaW5kZXhVcmkpLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuYmFtU291cmNlLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgaW5kZXhDaHVua3M6IHRoaXMuYmFtU291cmNlLmluZGV4Q2h1bmtzfSxcbiAgICAgICAgICBjbnQpO1xuICAgIH1cbn07XG5cblJlbW90ZUJBTUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaykge1xuICAgIHZhciBsaWdodCA9IHR5cGVzICYmICh0eXBlcy5sZW5ndGggPT0gMSkgJiYgKHR5cGVzWzBdID09ICdkZW5zaXR5Jyk7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXNCLmJ1c3krKztcbiAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgdGhpcy5rZXlIb2xkZXIuYXdhaXQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXNCLmVycm9yIHx8IFwiQ291bGRuJ3QgZmV0Y2ggQkFNXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc0Iud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnZmV0Y2gnLCBjb25uZWN0aW9uOiBrZXksIGNocjogY2hyLCBtaW46IG1pbiwgbWF4OiBtYXgsIG9wdHM6IHtsaWdodDogbGlnaHR9fSwgZnVuY3Rpb24oYmFtUmVjb3JkcywgZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZXRyaWV2ZWQgJyArIGJhbVJlY29yZHMubGVuZ3RoICsgJyB2aWEgd29ya2VyLicpO1xuXG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJpID0gMDsgcmkgPCBiYW1SZWNvcmRzLmxlbmd0aDsgKytyaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGJhbVJlY29yZHNbcmldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGJhbVJlY29yZFRvRmVhdHVyZShyLCB0aGlzQi5vcHRzLmJhbUdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBmZWF0dXJlcywgMTAwMDAwMDAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuUmVtb3RlQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NhbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDEwMDAwMDAwMDA7XG59O1xuXG5SZW1vdGVCQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLmtleUhvbGRlci5hd2FpdChmdW5jdGlvbihiYW0pIHtcbiAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuXG4gICAgICAgIHZhciBkZW5zU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgZGVuc1N0eWxlLmdseXBoID0gJ0hJU1RPR1JBTSc7XG4gICAgICAgIGRlbnNTdHlsZS5DT0xPUjEgPSAnYmxhY2snO1xuICAgICAgICBkZW5zU3R5bGUuQ09MT1IyID0gJ3JlZCc7XG4gICAgICAgIGRlbnNTdHlsZS5IRUlHSFQ9MzA7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVuc2l0eSd9LCAnbG93JywgZGVuc1N0eWxlKTtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZW5zaXR5J30sICdtZWRpdW0nLCBkZW5zU3R5bGUpO1xuXG4gICAgICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdfX1NFUVVFTkNFJztcbiAgICAgICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSAnYmx1ZSc7XG4gICAgICAgIHdpZ1N0eWxlLkhFSUdIVCA9IDg7XG4gICAgICAgIHdpZ1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgICAgICB3aWdTdHlsZS5MQUJFTCA9IGZhbHNlO1xuICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdiYW0nfSwgJ2hpZ2gnLCB3aWdTdHlsZSk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbiAgICB9KTtcbn07XG5cblxuZnVuY3Rpb24gTWFwcGVkRmVhdHVyZVNvdXJjZShzb3VyY2UsIG1hcHBpbmcpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLm1hcHBpbmcgPSBtYXBwaW5nO1xuXG4gICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuYnVzeSA9IDA7XG59XG5cbk1hcHBlZEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmFkZEFjdGl2aXR5TGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG59O1xuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBpZiAoaWR4ID49IDApXG4gICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMCk7XG59O1xuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5ub3RpZnlBY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVyc1tsaV0odGhpcy5idXN5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0U3R5bGVTaGVldChjYWxsYmFjayk7XG59O1xuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0U2NhbGVzKCk7XG59O1xuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXREZWZhdWx0RklQcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLmdldERlZmF1bHRGSVBzKVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0RGVmYXVsdEZJUHMoY2FsbGJhY2spO1xufTtcblxuTWFwcGVkRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuc2ltcGxpZnlTZWdtZW50cyA9IGZ1bmN0aW9uKHNlZ3MsIG1pbkdhcCkge1xuICAgIGlmIChzZWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNlZ3M7XG5cbiAgICBzZWdzLnNvcnQoZnVuY3Rpb24oczEsIHMyKSB7XG4gICAgICAgIHZhciBkID0gczEubmFtZSAtIHMyLm5hbWU7XG4gICAgICAgIGlmIChkKVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGQgPSBzMS5zdGFydCAtIHMyLnN0YXJ0O1xuICAgICAgICBpZiAoZClcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gczEuZW5kIC0gczIuZW5kOyAgIC8vIFNob3VsZCBuZXZlciBjb21lIHRvIHRoaXMuLi4/XG4gICAgfSk7XG5cbiAgICB2YXIgc3NlZ3MgPSBbXTtcbiAgICB2YXIgY3VycmVudFNlZyA9IHNlZ3NbMF07XG4gICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNlZ3MubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBucyA9IHNlZ3Nbc2ldO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5zLm5hbWUgKyAnICcgKyBucy5zdGFydCArICcgJyArIG5zLmVuZCk7XG4gICAgICAgIGlmIChucy5uYW1lICE9IGN1cnJlbnRTZWcubmFtZSB8fCBucy5zdGFydCA+IChjdXJyZW50U2VnLmVuZCArIG1pbkdhcCkpIHtcbiAgICAgICAgICAgIHNzZWdzLnB1c2goY3VycmVudFNlZyk7XG4gICAgICAgICAgICBjdXJyZW50U2VnID0gbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50U2VnID0gbmV3IERBU1NlZ21lbnQoY3VycmVudFNlZy5uYW1lLCBNYXRoLm1pbihjdXJyZW50U2VnLnN0YXJ0LCBucy5zdGFydCksIE1hdGgubWF4KGN1cnJlbnRTZWcuZW5kLCBucy5lbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzc2Vncy5wdXNoKGN1cnJlbnRTZWcpO1xuICAgIHJldHVybiBzc2Vncztcbn07XG5cbk1hcHBlZEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaywgc3R5bGVGaWx0ZXJzKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgZmV0Y2hMZW5ndGggPSBtYXggLSBtaW4gKyAxO1xuXG4gICAgdGhpc0IuYnVzeSsrO1xuICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG5cbiAgICB0aGlzLm1hcHBpbmcuc291cmNlQmxvY2tzRm9yUmFuZ2UoY2hyLCBtaW4sIG1heCwgZnVuY3Rpb24obXNlZykge1xuICAgICAgICBpZiAobXNlZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKFwiTm8gbWFwcGluZyBhdmFpbGFibGUgZm9yIHRoaXMgcmVnaW9uc1wiLCBbXSwgc2NhbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXNlZyA9IHRoaXNCLnNpbXBsaWZ5U2VnbWVudHMobXNlZywgTWF0aC5tYXgoMTAwLCAwLjA1ICogZmV0Y2hMZW5ndGgpKTtcblxuICAgICAgICAgICAgdmFyIG1hcHBlZEZlYXR1cmVzID0gW107XG4gICAgICAgICAgICB2YXIgbWFwcGVkTG9jID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IG1zZWcubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGZpbmFsU3RhdHVzO1xuXG4gICAgICAgICAgICBtc2VnLm1hcChmdW5jdGlvbihzZWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzQi5zb3VyY2UuZmV0Y2goc2VnLm5hbWUsIHNlZy5zdGFydCwgc2VnLmVuZCwgc2NhbGUsIHR5cGVzLCBwb29sLCBmdW5jdGlvbihzdGF0dXMsIGZlYXR1cmVzLCBmc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiAhZmluYWxTdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFN0YXR1cyA9IHN0YXR1cztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmZWF0dXJlcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc24gPSBmLnNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuLmluZGV4T2YoJ2NocicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuID0gc24uc3Vic3RyKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwaW5ncyA9IHRoaXNCLm1hcHBpbmcubWFwU2VnbWVudChzbiwgZi5taW4sIGYubWF4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYucGFydHMgJiYgZi5wYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkRmVhdHVyZXMucHVzaChmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG1pID0gMDsgbWkgPCBtYXBwaW5ncy5sZW5ndGg7ICsrbWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gbWFwcGluZ3NbbWldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1mID0gc2hhbGxvd0NvcHkoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZi5zZWdtZW50ID0gbS5zZWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWYubWluID0gbS5taW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZi5tYXggPSBtLm1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLnBhcnRpYWxNaW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWYucGFydGlhbE1pbiA9IG0ucGFydGlhbE1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLnBhcnRpYWxNYXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWYucGFydGlhbE1heCA9IG0ucGFydGlhbE1heDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0uZmxpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLm9yaWVudGF0aW9uID09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZi5vcmllbnRhdGlvbiA9ICcrJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYub3JpZW50YXRpb24gPT0gJysnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1mLm9yaWVudGF0aW9uID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZEZlYXR1cmVzLnB1c2gobWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG0xID0gdGhpc0IubWFwcGluZy5tYXBQb2ludChzZWcubmFtZSwgc2VnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0yID0gdGhpc0IubWFwcGluZy5tYXBQb2ludChzZWcubmFtZSwgc2VnLmVuZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG0xICYmIG0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VnRGVzdENvdmVyYWdlID0gbmV3IFJhbmdlKG0xLnBvcywgbTIucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwZWRMb2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkTG9jID0gdW5pb24obWFwcGVkTG9jLCBzZWdEZXN0Q292ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZExvYyA9IHNlZ0Rlc3RDb3ZlcmFnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC0tY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IuYnVzeS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZpbmFsU3RhdHVzLCBtYXBwZWRGZWF0dXJlcywgZnNjYWxlLCBtYXBwZWRMb2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc3R5bGVGaWx0ZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBEdW1teUZlYXR1cmVTb3VyY2UoKSB7XG59XG5cbkR1bW15RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NhbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5EdW1teUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjbnQpIHtcbiAgICByZXR1cm4gY250KG51bGwsIFtdLCAxMDAwMDAwMDAwKTtcbn07XG5cbkR1bW15RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuICAgIHZhciBkZWZTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgIGRlZlN0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgZGVmU3R5bGUuQkdDT0xPUiA9ICdibHVlJztcbiAgICBkZWZTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgZGVmU3R5bGUpO1xuICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbn07XG5cbmZ1bmN0aW9uIER1bW15U2VxdWVuY2VTb3VyY2UoKSB7XG59XG5cbkR1bW15U2VxdWVuY2VTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgcG9vbCwgY250KSB7XG4gICAgcmV0dXJuIGNudChudWxsLCBudWxsKTtcbn07XG5cbmZ1bmN0aW9uIEpCcm93c2VGZWF0dXJlU291cmNlKHNvdXJjZSkge1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgSkJyb3dzZVN0b3JlKHNvdXJjZS5qYlVSSSwgc291cmNlLmpiUXVlcnkpO1xufVxuXG5KQnJvd3NlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NhbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5KQnJvd3NlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuXG4gICAgdmFyIGNkc1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgY2RzU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICBjZHNTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICBjZHNTdHlsZS5CR0NPTE9SID0gJ3JlZCc7XG4gICAgY2RzU3R5bGUuSEVJR0hUID0gMTA7XG4gICAgY2RzU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgY2RzU3R5bGUuWklOREVYID0gMjA7XG4gICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICd0cmFuc2xhdGlvbid9LCBudWxsLCBjZHNTdHlsZSk7XG5cbiAgICB2YXIgdHNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgIHRzU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICB0c1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgIHRzU3R5bGUuQkdDT0xPUiA9ICd3aGl0ZSc7XG4gICAgdHNTdHlsZS5IRUlHSFQgPSAxMDtcbiAgICB0c1N0eWxlLlpJTkRFWCA9IDEwO1xuICAgIHRzU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgdHNTdHlsZS5MQUJFTCA9IHRydWU7XG4gICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICd0cmFuc2NyaXB0J30sIG51bGwsIHRzU3R5bGUpO1xuXG4gICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgd2lnU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ2dyZWVuJztcbiAgICB3aWdTdHlsZS5IRUlHSFQgPSA4O1xuICAgIHdpZ1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgIHdpZ1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHN0eWxlc2hlZXQpO1xufTtcblxuSkJyb3dzZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlcyAmJiB0eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgW10sIHNjYWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmb3BzID0ge307XG5cbiAgICB0aGlzLnN0b3JlLmZlYXR1cmVzKFxuICAgICAgICBuZXcgREFTU2VnbWVudChjaHIsIG1pbiwgbWF4KSxcbiAgICAgICAgZm9wcyxcbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZXMsIHN0YXR1cykge1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhdHVzLCBmZWF0dXJlcywgMTAwMDAwKTtcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG5Ccm93c2VyLnByb3RvdHlwZS5zb3VyY2VBZGFwdGVySXNDYXBhYmxlID0gZnVuY3Rpb24ocywgY2FwKSB7XG4gICAgaWYgKCFzLmNhcGFiaWxpdGllcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2UgcmV0dXJuIHMuY2FwYWJpbGl0aWVzKClbY2FwXTtcbn07XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgRmVhdHVyZVNvdXJjZUJhc2U6IEZlYXR1cmVTb3VyY2VCYXNlLFxuXG4gICAgICAgIFR3b0JpdFNlcXVlbmNlU291cmNlOiBUd29CaXRTZXF1ZW5jZVNvdXJjZSxcbiAgICAgICAgRW5zZW1ibFNlcXVlbmNlU291cmNlOiBFbnNlbWJsU2VxdWVuY2VTb3VyY2UsXG4gICAgICAgIERBU1NlcXVlbmNlU291cmNlOiBEQVNTZXF1ZW5jZVNvdXJjZSxcbiAgICAgICAgTWFwcGVkRmVhdHVyZVNvdXJjZTogTWFwcGVkRmVhdHVyZVNvdXJjZSxcbiAgICAgICAgQ2FjaGluZ0ZlYXR1cmVTb3VyY2U6IENhY2hpbmdGZWF0dXJlU291cmNlLFxuICAgICAgICBCV0dGZWF0dXJlU291cmNlOiBCV0dGZWF0dXJlU291cmNlLFxuICAgICAgICBSZW1vdGVCV0dGZWF0dXJlU291cmNlOiBSZW1vdGVCV0dGZWF0dXJlU291cmNlLFxuICAgICAgICBCQU1GZWF0dXJlU291cmNlOiBCQU1GZWF0dXJlU291cmNlLFxuICAgICAgICBSZW1vdGVCQU1GZWF0dXJlU291cmNlOiBSZW1vdGVCQU1GZWF0dXJlU291cmNlLFxuICAgICAgICBEdW1teUZlYXR1cmVTb3VyY2U6IER1bW15RmVhdHVyZVNvdXJjZSxcbiAgICAgICAgRHVtbXlTZXF1ZW5jZVNvdXJjZTogRHVtbXlTZXF1ZW5jZVNvdXJjZSxcbiAgICAgICAgREFTRmVhdHVyZVNvdXJjZTogREFTRmVhdHVyZVNvdXJjZSxcblxuICAgICAgICByZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5OiBkYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSxcbiAgICAgICAgcmVnaXN0ZXJQYXJzZXJGYWN0b3J5OiBkYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5LFxuICAgICAgICBtYWtlUGFyc2VyOiBkYWxsaWFuY2VfbWFrZVBhcnNlclxuICAgIH07XG5cbiAgICAvLyBTdGFuZGFyZCBzZXQgb2YgcGx1Z2lucy5cbiAgICByZXF1aXJlKCcuL2Vuc2VtYmxqc29uJyk7XG4gICAgcmVxdWlyZSgnLi90YWJpeC1zb3VyY2UnKTtcbiAgICByZXF1aXJlKCcuL21lbXN0b3JlJyk7XG4gICAgcmVxdWlyZSgnLi9iZWR3aWcnKTtcbiAgICByZXF1aXJlKCcuL3ZjZicpO1xuICAgIHJlcXVpcmUoJy4vcnF0bC1nZW5vdHlwZS1zb3VyY2UuZXM2Jyk7XG4gICAgcmVxdWlyZSgnLi9xdGwtc291cmNlLmVzNicpO1xuICAgIHJlcXVpcmUoJy4vdGVzdC1zb3VyY2UuZXM2Jyk7XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE1XG4vL1xuLy8gc291cmNlY29tcGFyZS5qc1xuLy9cblxuXG5mdW5jdGlvbiBzb3VyY2VEYXRhVVJJKGNvbmYpIHtcbiAgICBpZiAoY29uZi51cmkpIHtcbiAgICAgICAgcmV0dXJuIGNvbmYudXJpO1xuICAgIH0gZWxzZSBpZiAoY29uZi5ibG9iKSB7XG4gICAgICAgIHJldHVybiAnZmlsZTonICsgY29uZi5ibG9iLm5hbWU7XG4gICAgfSBlbHNlIGlmIChjb25mLmJ3Z0Jsb2IpIHtcbiAgICAgICAgcmV0dXJuICdmaWxlOicgKyBjb25mLmJ3Z0Jsb2IubmFtZTtcbiAgICB9IGVsc2UgaWYgKGNvbmYuYmFtQmxvYikge1xuICAgICAgICByZXR1cm4gJ2ZpbGU6JyArIGNvbmYuYmFtQmxvYi5uYW1lO1xuICAgIH0gZWxzZSBpZiAoY29uZi50d29CaXRCbG9iKSB7XG4gICAgICAgIHJldHVybiAnZmlsZTonICsgY29uZi50d29CaXRCbG9iLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmYuYndnVVJJIHx8IGNvbmYuYmFtVVJJIHx8IGNvbmYuamJVUkkgfHwgY29uZi50d29CaXRVUkkgfHwgJ2h0dHBzOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvbWFnaWMvbm9fdXJpJztcbn1cblxuZnVuY3Rpb24gc291cmNlU3R5bGVVUkkoY29uZikge1xuICAgIGlmIChjb25mLnN0eWxlc2hlZXRfdXJpKVxuICAgICAgICByZXR1cm4gY29uZi5zdHlsZXNoZWV0X3VyaTtcbiAgICBlbHNlIGlmIChjb25mLnRpZXJfdHlwZSA9PSAnc2VxdWVuY2UnIHx8IGNvbmYudHdvQml0VVJJIHx8IGNvbmYudHdvQml0QmxvYilcbiAgICAgICAgcmV0dXJuICdodHRwczovL3d3dy5iaW9kYWxsaWFuY2Uub3JnL21hZ2ljL3NlcXVlbmNlJ1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvdXJjZURhdGFVUkkoY29uZik7XG59XG5cbmZ1bmN0aW9uIHNvdXJjZXNBcmVFcXVhbE1vZHVsb1N0eWxlKGEsIGIpIHtcbiAgICBpZiAoc291cmNlRGF0YVVSSShhKSAhPSBzb3VyY2VEYXRhVVJJKGIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5tYXBwaW5nICE9IGIubWFwcGluZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGEudGllcl90eXBlICE9IGIudGllcl90eXBlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5vdmVybGF5KSB7XG4gICAgICAgIGlmICghYi5vdmVybGF5IHx8IGIub3ZlcmxheS5sZW5ndGggIT0gYS5vdmVybGF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IGEub3ZlcmxheS5sZW5ndGg7ICsrb2kpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlc0FyZUVxdWFsTW9kdWxvU3R5bGUoYS5vdmVybGF5W29pXSwgYi5vdmVybGF5W29pXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGIub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc291cmNlc0FyZUVxdWFsKGEsIGIpIHtcbiAgICBpZiAoc291cmNlRGF0YVVSSShhKSAhPSBzb3VyY2VEYXRhVVJJKGIpIHx8XG4gICAgICAgIHNvdXJjZVN0eWxlVVJJKGEpICE9IHNvdXJjZVN0eWxlVVJJKGIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5tYXBwaW5nICE9IGIubWFwcGluZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGEudGllcl90eXBlICE9IGIudGllcl90eXBlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5vdmVybGF5KSB7XG4gICAgICAgIGlmICghYi5vdmVybGF5IHx8IGIub3ZlcmxheS5sZW5ndGggIT0gYS5vdmVybGF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IGEub3ZlcmxheS5sZW5ndGg7ICsrb2kpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlc0FyZUVxdWFsKGEub3ZlcmxheVtvaV0sIGIub3ZlcmxheVtvaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChiLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc291cmNlc0FyZUVxdWFsOiBzb3VyY2VzQXJlRXF1YWwsXG4gICAgICAgIHNvdXJjZXNBcmVFcXVhbE1vZHVsb1N0eWxlOiBzb3VyY2VzQXJlRXF1YWxNb2R1bG9TdHlsZSxcbiAgICAgICAgc291cmNlRGF0YVVSSTogc291cmNlRGF0YVVSSSxcbiAgICAgICAgc291cmNlU3R5bGVVUkk6IHNvdXJjZVN0eWxlVVJJXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBzcGFucy5qczogSmF2YVNjcmlwdCBJbnRzZXQvTG9jYXRpb24gcG9ydC5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJhbmdlKG1pbiwgbWF4KVxue1xuICAgIGlmICh0eXBlb2YobWluKSAhPSAnbnVtYmVyJyB8fCB0eXBlb2YobWF4KSAhPSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgJ0JhZCByYW5nZSAnICsgbWluICsgJywnICsgbWF4O1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG59XG5cblJhbmdlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluO1xufVxuXG5SYW5nZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heDtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgcmV0dXJuIHBvcyA+PSB0aGlzLl9taW4gJiYgcG9zIDw9IHRoaXMuX21heDtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmlzQ29udGlndW91cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5SYW5nZS5wcm90b3R5cGUucmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFt0aGlzXTtcbn1cblxuUmFuZ2UucHJvdG90eXBlLl9wdXNoUmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgcmFuZ2VzLnB1c2godGhpcyk7XG59XG5cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnWycgKyB0aGlzLl9taW4gKyAnLScgKyB0aGlzLl9tYXggKyAnXSc7XG59XG5cbmZ1bmN0aW9uIF9Db21wb3VuZChyYW5nZXMpIHtcbiAgICAvLyBnaXZlbjogYSBzZXQgb2YgdW5zb3J0ZWQgcG9zc2libHkgb3ZlcmxhcHBpbmcgcmFuZ2VzXG4gICAgLy8gc29ydCB0aGUgaW5wdXQgcmFuZ2VzXG4gICAgdmFyIHNvcnRlZCA9IHJhbmdlcy5zb3J0KF9yYW5nZU9yZGVyKTtcbiAgICAvLyBtZXJnZSBvdmVybGFwcyBiZXR3ZWVuIGFkamFjZW50IHJhbmdlc1xuICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICB2YXIgY3VycmVudCA9IHNvcnRlZC5zaGlmdCgpO1xuICAgIHNvcnRlZC5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5fbWluIDw9IGN1cnJlbnQuX21heCkge1xuICAgICAgICAgICAgaWYgKHJhbmdlLl9tYXggPiBjdXJyZW50Ll9tYXgpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Ll9tYXggPSByYW5nZS5fbWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmFuZ2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICB0aGlzLl9yYW5nZXMgPSBtZXJnZWQ7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhbmdlc1swXS5taW4oKTtcbn1cblxuX0NvbXBvdW5kLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFuZ2VzW3RoaXMuX3Jhbmdlcy5sZW5ndGggLSAxXS5tYXgoKTtcbn1cblxuLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHJhbmdlIHRoYXQgaXMgbm90IGxlc3MgdGhhbiBwb3Ncbl9Db21wb3VuZC5wcm90b3R5cGUubG93ZXJfYm91bmQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBpZiBwb3MgaXMgb3V0IG9mIHJhbmdlXG4gICAgdmFyIHIgPSB0aGlzLnJhbmdlcygpO1xuICAgIGlmIChwb3MgPiB0aGlzLm1heCgpKSByZXR1cm4gci5sZW5ndGg7XG4gICAgaWYgKHBvcyA8IHRoaXMubWluKCkpIHJldHVybiAwO1xuICAgIC8vIGRvIGEgYmluYXJ5IHNlYXJjaFxuICAgIHZhciBhPTAsIGI9ci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKChhK2IpLzIpO1xuICAgICAgICBpZiAocG9zID4gclttXS5fbWF4KSB7XG4gICAgICAgICAgICBhID0gbSsxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA8IHJbbV0uX21pbikge1xuICAgICAgICAgICAgYiA9IG0tMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuXG5fQ29tcG91bmQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdmFyIGxiID0gdGhpcy5sb3dlcl9ib3VuZChwb3MpO1xuICAgIGlmIChsYiA8IHRoaXMuX3Jhbmdlcy5sZW5ndGggJiYgdGhpcy5fcmFuZ2VzW2xiXS5jb250YWlucyhwb3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUuaW5zZXJ0UmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgIHZhciBsYiA9IHRoaXMubG93ZXJfYm91bmQocmFuZ2UuX21pbik7XG4gICAgaWYgKGxiID09PSB0aGlzLl9yYW5nZXMubGVuZ3RoKSB7IC8vIHJhbmdlIGZvbGxvd3MgdGhpc1xuICAgICAgICB0aGlzLl9yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIHIgPSB0aGlzLnJhbmdlcygpO1xuICAgIGlmIChyYW5nZS5fbWF4IDwgcltsYl0uX21pbikgeyAvLyByYW5nZSBwcmVjZWVkcyBsYlxuICAgICAgICB0aGlzLl9yYW5nZXMuc3BsaWNlKGxiLDAscmFuZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmFuZ2Ugb3ZlcmxhcHMgbGIgKGF0IGxlYXN0KVxuICAgIGlmIChyW2xiXS5fbWluIDwgcmFuZ2UuX21pbikgcmFuZ2UuX21pbiA9IHJbbGJdLl9taW47XG4gICAgdmFyIHViID0gbGIrMTtcbiAgICB3aGlsZSAodWIgPCByLmxlbmd0aCAmJiByW3ViXS5fbWluIDw9IHJhbmdlLl9tYXgpIHtcbiAgICAgICAgdWIrKztcbiAgICB9XG4gICAgdWItLTtcbiAgICAvLyB1YiBpcyB0aGUgdXBwZXIgYm91bmQgb2YgdGhlIG5ldyByYW5nZVxuICAgIGlmIChyW3ViXS5fbWF4ID4gcmFuZ2UuX21heCkgcmFuZ2UuX21heCA9IHJbdWJdLl9tYXg7XG4gICAgXG4gICAgLy8gc3BsaWNlIHJhbmdlIGludG8gdGhpcy5fcmFuZ2VzXG4gICAgdGhpcy5fcmFuZ2VzLnNwbGljZShsYix1Yi1sYisxLHJhbmdlKTtcbiAgICByZXR1cm47XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUuaXNDb250aWd1b3VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhbmdlcy5sZW5ndGggPiAxO1xufVxuXG5fQ29tcG91bmQucHJvdG90eXBlLnJhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZXM7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUuX3B1c2hSYW5nZXMgPSBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICBmb3IgKHZhciByaSA9IDA7IHJpIDwgdGhpcy5fcmFuZ2VzLmxlbmd0aDsgKytyaSlcbiAgICAgICAgcmFuZ2VzLnB1c2godGhpcy5fcmFuZ2VzW3JpXSk7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgdGhpcy5fcmFuZ2VzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIGlmIChyPjApIHtcbiAgICAgICAgICAgIHMgPSBzICsgJywnO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzICsgdGhpcy5fcmFuZ2VzW3JdLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiB1bmlvbihzMCwgczEpIHtcbiAgICBpZiAoISAoczAgaW5zdGFuY2VvZiBfQ29tcG91bmQpKSB7XG4gICAgICAgIGlmICghIChzMCBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgIHMwID0gW3MwXTtcbiAgICAgICAgczAgPSBuZXcgX0NvbXBvdW5kKHMwKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHMxKVxuICAgICAgICBzMC5pbnNlcnRSYW5nZShzMSk7XG5cbiAgICByZXR1cm4gczA7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihzMCwgczEpIHtcbiAgICB2YXIgcjAgPSBzMC5yYW5nZXMoKTtcbiAgICB2YXIgcjEgPSBzMS5yYW5nZXMoKTtcbiAgICB2YXIgbDAgPSByMC5sZW5ndGgsIGwxID0gcjEubGVuZ3RoO1xuICAgIHZhciBpMCA9IDAsIGkxID0gMDtcbiAgICB2YXIgb3IgPSBbXTtcblxuICAgIHdoaWxlIChpMCA8IGwwICYmIGkxIDwgbDEpIHtcbiAgICAgICAgdmFyIHMwID0gcjBbaTBdLCBzMSA9IHIxW2kxXTtcbiAgICAgICAgdmFyIGxhcE1pbiA9IE1hdGgubWF4KHMwLm1pbigpLCBzMS5taW4oKSk7XG4gICAgICAgIHZhciBsYXBNYXggPSBNYXRoLm1pbihzMC5tYXgoKSwgczEubWF4KCkpO1xuICAgICAgICBpZiAobGFwTWF4ID49IGxhcE1pbikge1xuICAgICAgICAgICAgb3IucHVzaChuZXcgUmFuZ2UobGFwTWluLCBsYXBNYXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAubWF4KCkgPiBzMS5tYXgoKSkge1xuICAgICAgICAgICAgKytpMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsraTA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKG9yLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBGSVhNRVxuICAgIH0gZWxzZSBpZiAob3IubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9yWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbXBvdW5kKG9yKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvdmVyYWdlKHMpIHtcbiAgICB2YXIgdG90ID0gMDtcbiAgICB2YXIgcmwgPSBzLnJhbmdlcygpO1xuICAgIGZvciAodmFyIHJpID0gMDsgcmkgPCBybC5sZW5ndGg7ICsrcmkpIHtcbiAgICAgICAgdmFyIHIgPSBybFtyaV07XG4gICAgICAgIHRvdCArPSAoci5tYXgoKSAtIHIubWluKCkgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdDtcbn1cblxuXG5cbmZ1bmN0aW9uIHJhbmdlT3JkZXIoYSwgYilcbntcbiAgICBpZiAoYS5taW4oKSA8IGIubWluKCkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYS5taW4oKSA+IGIubWluKCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLm1heCgpIDwgYi5tYXgoKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChiLm1heCgpID4gYS5tYXgoKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9yYW5nZU9yZGVyKGEsIGIpXG57XG4gICAgaWYgKGEuX21pbiA8IGIuX21pbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhLl9taW4gPiBiLl9taW4pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLl9tYXggPCBiLl9tYXgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYi5fbWF4ID4gYS5fbWF4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBSYW5nZTogUmFuZ2UsXG4gICAgICAgIHVuaW9uOiB1bmlvbixcbiAgICAgICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgcmFuZ2VPdmVyOiByYW5nZU9yZGVyLFxuICAgICAgICBfcmFuZ2VPcmRlcjogX3JhbmdlT3JkZXJcbiAgICB9XG59IiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMTRcbi8vXG4vLyBzdHlsZS5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIFN0eWxlRmlsdGVyKHR5cGUsIG1ldGhvZCwgbGFiZWwpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbn1cblxuU3R5bGVGaWx0ZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09IG8udHlwZSAmJiB0aGlzLm1ldGhvZCA9PSBvLm1ldGhvZCAmJiB0aGlzLmxhYmVsID09IG8ubGFiZWw7XG59XG5cblN0eWxlRmlsdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmcyA9IFtdO1xuICAgIGlmICh0aGlzLnR5cGUpIFxuICAgICAgICBmcy5wdXNoKCd0eXBlPScgKyB0aGlzLnR5cGUpO1xuICAgIGlmICh0aGlzLm1ldGhvZClcbiAgICAgICAgZnMucHVzaCgnbWV0aG9kPScgKyB0aGlzLm1ldGhvZCk7XG4gICAgaWYgKHRoaXMubGFiZWwpXG4gICAgICAgIGZzLnB1c2goJ2xhYmVsPScgKyB0aGlzLmxhYmVsKTtcbiAgICByZXR1cm4gJ1N0eWxlRmlsdGVyPCcgKyBmcy5qb2luKCc7JykgKyAnPic7XG59XG5cbmZ1bmN0aW9uIFN0eWxlRmlsdGVyU2V0KGZpbHRlcnMpIHtcbiAgICB0aGlzLl9maWx0ZXJzID0ge307XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZpbHRlcnMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChmaWx0ZXJzW2ZpXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgZnMgPSBmaWx0ZXIudG9TdHJpbmcoKTtcbiAgICBpZiAoIXRoaXMuX2ZpbHRlcnNbZnNdKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnNbZnNdID0gZmlsdGVyO1xuICAgICAgICB0aGlzLl9saXN0ID0gbnVsbDtcbiAgICB9XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbihmaWx0ZXJTZXQpIHtcbiAgICB2YXIgbCA9IGZpbHRlclNldC5saXN0KCk7XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGwubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHRoaXMuYWRkKGxbZmldKTtcbiAgICB9XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS5kb2VzTm90Q29udGFpbiA9IGZ1bmN0aW9uKGZpbHRlclNldCkge1xuICAgIHZhciBsID0gZmlsdGVyU2V0Lmxpc3QoKTtcbiAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgbC5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJzW2ZpLnRvU3RyaW5nKCldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5TdHlsZUZpbHRlclNldC5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fbGlzdCkge1xuICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fZmlsdGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbHRlcnMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnB1c2godGhpcy5fZmlsdGVyc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xpc3Q7XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS50eXBlTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIHZhciBsaXN0ID0gdGhpcy5saXN0KCk7XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGxpc3QubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBsaXN0W2ZpXTtcbiAgICAgICAgdmFyIHR5cGUgPSBmaWx0ZXIudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT0gJ2RlZmF1bHQnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0eXBlcy5pbmRleE9mKHR5cGUpIDwgMClcbiAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBTdHlsZUZpbHRlcjogU3R5bGVGaWx0ZXIsXG4gICAgICAgIFN0eWxlRmlsdGVyU2V0OiBTdHlsZUZpbHRlclNldFxuICAgIH07XG59XG4iLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgcmVuZGVyVGllciwgZHJhd1RpZXIgfTtcblxuLyogVG8gYmUgdXNlZCBieSB0aWVycyB3aGljaCBhcmUgdG8gYmUgZHJhd24gaW4gYSBtdWx0aXRpZXJcbiAgIHVzaW5nIHRoZSBtdWx0aS1yZW5kZXJlci5cblxuICAgU3VidGllcnMgYXJlIGNvbmZpZ3VyZWQgYnkgYWRkaW5nIHRoZSBmb2xsb3dpbmcgdG8gYSB0aWVyJ3Mgc291cmNlIGNvbmZpZ3VyYXRpb246XG4gICAgICAgcmVuZGVyZXI6ICdzdWInLFxuICAgICAgIHN1Yjoge1xuICAgICAgICAgICBtdWx0aV9pZDogXCJtdWx0aV8xXCIsXG4gICAgICAgICAgIG9mZnNldDogMTMwLFxuICAgICAgICAgICB6OiAyLFxuICAgICAgIH1cbiAgIFRoaXMgd291bGQgZGVmaW5lIGEgc3VidGllciB0aGF0J3MgdG8gYmUgcmVuZGVyZWQgaW4gdGhlIG11bHRpLXRpZXIgd2l0aFxuICAgaWQgXCJtdWx0aV8xXCIsIHdpdGggdGhlIHRvcCBvZiB0aGUgc3VidGllciBhdCAxMzAgcGl4ZWxzIGFuZCBhdCB6LWluZGV4IDIuXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVGllcihzdGF0dXMsIHRpZXIpIHtcbiAgICBkcmF3VGllcih0aWVyKTtcbiAgICB0aWVyLnVwZGF0ZVN0YXR1cyhzdGF0dXMpO1xufVxuXG4vLyBkcmF3VGllciBpcyBjYWxsZWQgd2hlbiB0aGlzIHRpZXIncyBkYXRhIGhhcyBiZWVuIGZldGNoZWQsXG4vLyBzbyBieSByZWZyZXNoaW5nIHRoZSBtdWx0aVRpZXIgZnJvbSBoZXJlLCB3ZSBjYW4gYmUgc3VyZSB0aGF0XG4vLyB0aGVyZSdzIHNvbWV0aGluZyBuZXcgd29ydGggZHJhd2luZyBpbiBpdFxuZnVuY3Rpb24gZHJhd1RpZXIodGllcikge1xuICAgIGxldCBicm93c2VyID0gdGllci5icm93c2VyO1xuXG4gICAgbGV0IG11bHRpVGllciA9IGJyb3dzZXIudGllcnMuXG4gICAgICAgICAgICBmaWx0ZXIodCA9PiB0LmRhc1NvdXJjZS5yZW5kZXJlciA9PT0gJ211bHRpJyAmJlxuICAgICAgICAgICAgICAgICAgIHQuZGFzU291cmNlLm11bHRpLm11bHRpX2lkID09PSB0aWVyLmRhc1NvdXJjZS5zdWIubXVsdGlfaWQpO1xuXG4gICAgbXVsdGlUaWVyLmZvckVhY2godCA9PiBicm93c2VyLnJlZnJlc2hUaWVyKHQpKTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyBzdmctZXhwb3J0LmpzXG4vL1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi9jYnJvd3NlcicpO1xuICAgIHZhciBCcm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBtYWtlRWxlbWVudCA9IHV0aWxzLm1ha2VFbGVtZW50O1xuICAgIHZhciBtYWtlRWxlbWVudE5TID0gdXRpbHMubWFrZUVsZW1lbnROUztcblxuICAgIHZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbiAgICB2YXIgc3ZnU2VxVGllciA9IHJlcXVpcmUoJy4vc2VxdWVuY2UtZHJhdycpLnN2Z1NlcVRpZXI7XG5cbiAgICB2YXIgc3ZndSA9IHJlcXVpcmUoJy4vc3ZnLXV0aWxzJyk7XG4gICAgdmFyIE5TX1NWRyA9IHN2Z3UuTlNfU1ZHO1xuICAgIHZhciBOU19YTElOSyA9IHN2Z3UuTlNfWExJTks7XG4gICAgdmFyIFNWR1BhdGggPSBzdmd1LlNWR1BhdGg7XG5cbiAgICB2YXIgbmYgPSByZXF1aXJlKCcuL251bWZvcm1hdHMnKTtcbiAgICB2YXIgZm9ybWF0UXVhbnRMYWJlbCA9IG5mLmZvcm1hdFF1YW50TGFiZWw7XG4gICAgdmFyIGZvcm1hdExvbmdJbnQgPSBuZi5mb3JtYXRMb25nSW50O1xufVxuXG5cbkJyb3dzZXIucHJvdG90eXBlLm1ha2VTVkcgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIG1pblRpZXJIZWlnaHQgPSBvcHRzLm1pblRpZXJIZWlnaHQgfHwgMjA7XG4gICAgdmFyIHBhZGRpbmcgPSAzO1xuICAgIHZhciBmcHcgPSBvcHRzLndpZHRoIHx8IHRoaXMuZmVhdHVyZVBhbmVsV2lkdGg7XG5cbiAgICB2YXIgYmFja3VwRlBXID0gdGhpcy5mZWF0dXJlUGFuZWxXaWR0aDtcbiAgICB2YXIgYmFja3VwU2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggPSBmcHc7XG4gICAgdGhpcy5zY2FsZSA9IHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggLyAodGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQpO1xuXG4gICAgdmFyIGIgPSB0aGlzO1xuICAgIHZhciBzYXZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTlNfU1ZHLCAnc3ZnJywgbnVsbCk7XG5cbiAgICB2YXIgc2F2ZVJvb3QgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBudWxsLCB7XG4gICAgICAgIGZvbnRGYW1pbHk6ICdoZWx2ZXRpY2EnLFxuICAgICAgICBmb250U2l6ZTogJzhwdCdcbiAgICB9KTtcbiAgICBzYXZlRG9jLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzYXZlUm9vdCk7XG5cbiAgICB2YXIgbWFyZ2luID0gMjAwO1xuXG4gICAgaWYgKG9wdHMuYmFubmVyKSB7XG4gICAgICB2YXIgZGFsbGlhbmNlQW5jaG9yID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdhJyxcbiAgICAgICAgIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsICdHcmFwaGljcyBmcm9tIEJpb2RhbGxpYW5jZSAnICsgVkVSU0lPTiwge1xuICAgICAgICAgICAgIHg6IChiLmZlYXR1cmVQYW5lbFdpZHRoICsgbWFyZ2luKSAtIDEwMCxcbiAgICAgICAgICAgICB5OiAzNSxcbiAgICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgICBmb250U2l6ZTogJzEycHQnLFxuXHQgICAgIHRleHRBbmNob3I6ICdlbmQnLFxuXHQgICAgIGZpbGw6ICdibHVlJ1xuICAgICAgICAgfSkpO1xuICAgICAgZGFsbGlhbmNlQW5jaG9yLnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCBOU19YTElOSyk7XG4gICAgICBkYWxsaWFuY2VBbmNob3Iuc2V0QXR0cmlidXRlKCd4bGluazpocmVmJywgJ2h0dHA6Ly93d3cuYmlvZGFsbGlhbmNlLm9yZy8nKTtcblxuICAgICAgc2F2ZVJvb3QuYXBwZW5kQ2hpbGQoZGFsbGlhbmNlQW5jaG9yKTtcbiAgICB9XG4gIFxuICAgIGlmIChvcHRzLnJlZ2lvbikge1xuICAgICAgICBzYXZlUm9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIHRoaXMuY2hyICsgJzonICsgZm9ybWF0TG9uZ0ludCh0aGlzLnZpZXdTdGFydCkgKyAnLi4nICsgZm9ybWF0TG9uZ0ludCh0aGlzLnZpZXdFbmQpLCB7XG4gICAgICAgICAgICAgICAgeDogbWFyZ2luICsgMTAwLFxuICAgICAgICAgICAgICAgIHk6IDM1LFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJwdCcsXG4gICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0J1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNsaXBSZWN0ID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdyZWN0JywgbnVsbCwge1xuICAgIFx0eDogbWFyZ2luLFxuICAgIFx0eTogNTAsXG4gICAgXHR3aWR0aDogYi5mZWF0dXJlUGFuZWxXaWR0aCxcbiAgICBcdGhlaWdodDogMTAwMDAwXG4gICAgfSk7XG4gICAgdmFyIGNsaXAgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2NsaXBQYXRoJywgY2xpcFJlY3QsIHtpZDogJ2ZlYXR1cmVDbGlwJ30pO1xuICAgIHNhdmVSb290LmFwcGVuZENoaWxkKGNsaXApO1xuXG4gICAgdmFyIHBvcyA9IDcwO1xuICAgIHZhciB0aWVySG9sZGVyID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJywgbnVsbCwge30pO1xuXG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IGIudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgIHZhciB0aWVyID0gYi50aWVyc1t0aV07XG4gICAgICAgIHRpZXIuYmFja3VwU3VidGllcnMgPSB0aWVyLnN1YnRpZXJzO1xuICAgICAgICB0aWVyLmJhY2t1cE9yaWdpbkhheHggPSB0aWVyLm9yaWdpbkhheHg7XG4gICAgICAgIHRpZXIuYmFja3VwTGF5b3V0SGVpZ2h0ID0gdGllci5sYXlvdXRIZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBiLmdldFRpZXJSZW5kZXJlcih0aWVyKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyICYmIHJlbmRlcmVyLnByZXBhcmVTdWJ0aWVycykge1xuICAgICAgICAgICAgcmVuZGVyZXIucHJlcGFyZVN1YnRpZXJzKHRpZXIsIHRpZXIudmlld3BvcnQuZ2V0Q29udGV4dCgnMmQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGllclNWRyA9IG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnZycsIG51bGwsIHtjbGlwUGF0aDogJ3VybCgjZmVhdHVyZUNsaXApJywgY2xpcFJ1bGU6ICdub256ZXJvJ30pO1xuICAgIFx0dmFyIHRpZXJMYWJlbHMgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnKTtcbiAgICBcdHZhciB0aWVyVG9wUG9zID0gcG9zO1xuXG4gICAgXHR2YXIgdGllckJhY2tncm91bmQgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3JlY3QnLCBudWxsLCB7eDogMCwgeTogdGllclRvcFBvcywgd2lkdGg6ICcxMDAwMCcsIGhlaWdodDogNTAsIGZpbGw6IHRpZXIuYmFja2dyb3VuZH0pO1xuICAgIFx0dGllclNWRy5hcHBlbmRDaGlsZCh0aWVyQmFja2dyb3VuZCk7XG5cbiAgICBcdGlmICh0aWVyLnNlcXVlbmNlU291cmNlKSB7XG4gICAgXHQgICAgdmFyIHNlcVRyYWNrID0gc3ZnU2VxVGllcih0aWVyLCB0aWVyLmN1cnJlbnRTZXF1ZW5jZSk7XG4gICAgXHQgICAgXG4gICAgXHQgICAgdGllclNWRy5hcHBlbmRDaGlsZChtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBzZXFUcmFjaywge3RyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgKG1hcmdpbikgKyAnLCAnICsgcG9zICsgJyknfSkpO1xuICAgIFx0ICAgIHBvcyArPSA4MDtcbiAgICBcdH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRpZXIuc3VidGllcnMpIHtcbiAgICBcdFx0ICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgXHRcbiAgICBcdCAgICB2YXIgb2Zmc2V0ID0gKCh0aWVyLmdseXBoQ2FjaGVPcmlnaW4gLSBiLnZpZXdTdGFydCkgKiBiLnNjYWxlKTtcbiAgICAgICAgICAgIHZhciBoYXNRdWFudCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgc3RpID0gMDsgc3RpIDwgdGllci5zdWJ0aWVycy5sZW5ndGg7ICsrc3RpKSB7XG4gICAgICAgICAgICAgICAgcG9zICs9IHBhZGRpbmc7XG4gICAgICAgIFx0XHR2YXIgc3VidGllciA9IHRpZXIuc3VidGllcnNbc3RpXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIFx0XHR2YXIgZ2x5cGhFbGVtZW50cyA9IFtdO1xuICAgICAgICBcdFx0Zm9yICh2YXIgZ2kgPSAwOyBnaSA8IHN1YnRpZXIuZ2x5cGhzLmxlbmd0aDsgKytnaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBzdWJ0aWVyLmdseXBoc1tnaV07XG4gICAgICAgICAgICAgICAgICAgIGdseXBoRWxlbWVudHMucHVzaChnbHlwaC50b1NWRygpKTtcbiAgICAgICAgXHRcdH1cblxuICAgIFx0XHQgICAgdGllclNWRy5hcHBlbmRDaGlsZChtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBnbHlwaEVsZW1lbnRzLCB7dHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyAobWFyZ2luK29mZnNldCkgKyAnLCAnICsgcG9zICsgJyknfSkpO1xuXG4gICAgICAgIFx0XHRpZiAoc3VidGllci5xdWFudCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNRdWFudCA9IHRydWU7XG4gICAgICAgIFx0XHQgICAgdmFyIHEgPSBzdWJ0aWVyLnF1YW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHN1YnRpZXIuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1UaWNzID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPiA0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtVGljcyA9IDEgKyAoKGgvMjApIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpY1NwYWNpbmcgPSBoIC8gKG51bVRpY3MgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpY0ludGVydmFsID0gKHEubWF4IC0gcS5taW4pIC8gKG51bVRpY3MgLSAxKTtcblxuICAgICAgICBcdFx0ICAgIHZhciBwYXRoID0gbmV3IFNWR1BhdGgoKTtcbiAgICAgICAgXHRcdCAgICBwYXRoLm1vdmVUbyhtYXJnaW4gKyA1LCBwb3MpO1xuICAgICAgICBcdFx0ICAgIHBhdGgubGluZVRvKG1hcmdpbiwgcG9zKTtcbiAgICAgICAgXHRcdCAgICBwYXRoLmxpbmVUbyhtYXJnaW4sIHBvcyArIHN1YnRpZXIuaGVpZ2h0KTtcbiAgICAgICAgXHRcdCAgICBwYXRoLmxpbmVUbyhtYXJnaW4gKyA1LCBwb3MgKyBzdWJ0aWVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eSA9IHQqdGljU3BhY2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKG1hcmdpbiwgcG9zICsgdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5saW5lVG8obWFyZ2luKzMsIHBvcyArIHR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgIFx0XHQgICAgdGllckxhYmVscy5hcHBlbmRDaGlsZChtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3BhdGgnLCBudWxsLCB7ZDogcGF0aC50b1BhdGhEYXRhKCksIGZpbGw6ICdub25lJywgc3Ryb2tlOiAnYmxhY2snLCBzdHJva2VXaWR0aDogJzJweCd9KSk7XG4gICAgICAgIFx0XHQgICAgdGllckxhYmVscy5hcHBlbmRDaGlsZChtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3RleHQnLCBmb3JtYXRRdWFudExhYmVsKHEubWF4KSwge3g6IG1hcmdpbiAtIDMsIHk6IHBvcyArIDcsIHRleHRBbmNob3I6ICdlbmQnfSkpO1xuICAgICAgICBcdFx0ICAgIHRpZXJMYWJlbHMuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnROUyhOU19TVkcsICd0ZXh0JywgZm9ybWF0UXVhbnRMYWJlbChxLm1pbiksIHt4OiBtYXJnaW4gLSAzLCB5OiBwb3MgKyAgc3VidGllci5oZWlnaHQsIHRleHRBbmNob3I6ICdlbmQnfSkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IG51bVRpY3MtMTsgKyt0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWVyTGFiZWxzLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIGZvcm1hdFF1YW50TGFiZWwoKDEuMCpxLm1heCkgLSAodCp0aWNJbnRlcnZhbCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eDogbWFyZ2luIC0gMywgeTogcG9zICsgIHR5ICsgMywgdGV4dEFuY2hvcjogJ2VuZCd9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXHRcdH1cblxuICAgIFx0XHQgICAgcG9zICs9IHN1YnRpZXIuaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvcyAtIHRpZXJUb3BQb3MgPCBtaW5UaWVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcG9zID0gdGllclRvcFBvcyArIG1pblRpZXJIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgXHR9XG5cbiAgICAgICAgdmFyIGxhYmVsTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aWVyLmNvbmZpZy5uYW1lID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGxhYmVsTmFtZSA9IHRpZXIuY29uZmlnLm5hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxhYmVsTmFtZSA9IHRpZXIuZGFzU291cmNlLm5hbWU7XG4gICAgXHR0aWVyTGFiZWxzLmFwcGVuZENoaWxkKFxuICAgIFx0ICAgIG1ha2VFbGVtZW50TlMoXG4gICAgXHRcdE5TX1NWRywgJ3RleHQnLFxuICAgIFx0XHRsYWJlbE5hbWUsXG4gICAgXHRcdHt4OiBtYXJnaW4gLSAoaGFzUXVhbnQgPyAyMCA6IDEyKSwgeTogKHBvcyt0aWVyVG9wUG9zKzgpLzIsIGZvbnRTaXplOiAnMTBwdCcsIHRleHRBbmNob3I6ICdlbmQnfSkpO1xuXG4gICAgXHRcbiAgICBcdHRpZXJCYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgcG9zIC0gdGllclRvcFBvcyk7XG4gICAgXHR0aWVySG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnZycsIFt0aWVyU1ZHLCB0aWVyTGFiZWxzXSkpO1xuXG4gICAgICAgIHRpZXIuc3VidGllcnMgPSB0aWVyLmJhY2t1cFN1YnRpZXJzO1xuICAgICAgICB0aWVyLm9yaWdpbkhheHggPSB0aWVyLmJhY2t1cE9yaWdpbkhheHg7XG4gICAgICAgIHRpZXIubGF5b3V0SGVpZ2h0ID0gdGllci5iYWNrdXBMYXlvdXRIZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaGlnaGxpZ2h0cykge1xuICAgICAgICB2YXIgaGlnaGxpZ2h0cyA9IHRoaXMuaGlnaGxpZ2h0cyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaGkgPSAwOyBoaSA8IGhpZ2hsaWdodHMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgICAgICB2YXIgaCA9IGhpZ2hsaWdodHNbaGldO1xuICAgICAgICAgICAgaWYgKChoLmNociA9PSB0aGlzLmNociB8fCBoLmNociA9PSAoJ2NocicgKyB0aGlzLmNocikpICYmIGgubWluIDwgdGhpcy52aWV3RW5kICYmIGgubWF4ID4gdGhpcy52aWV3U3RhcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1pbiA9IChNYXRoLm1heChoLm1pbiwgdGhpcy52aWV3U3RhcnQpIC0gdGhpcy52aWV3U3RhcnQpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgICAgICB2YXIgdG1heCA9IChNYXRoLm1pbihoLm1heCwgdGhpcy52aWV3RW5kKSAtIHRoaXMudmlld1N0YXJ0KSAqIHRoaXMuc2NhbGU7XG5cbiAgICAgICAgICAgICAgICB0aWVySG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAncmVjdCcsIG51bGwsIHt4OiBtYXJnaW4gKyB0bWluLCB5OiA3MCwgd2lkdGg6ICh0bWF4LXRtaW4pLCBoZWlnaHQ6IHBvcy03MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICdub25lJywgZmlsbDogdGhpcy5kZWZhdWx0SGlnaGxpZ2h0RmlsbCwgZmlsbE9wYWNpdHk6IHRoaXMuZGVmYXVsdEhpZ2hsaWdodEFscGhhfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVyUG9zID0gLTE7IFxuICAgIGlmIChvcHRzLnJ1bGVyID09ICdjZW50ZXInKSB7XG4gICAgICAgIHJ1bGVyUG9zID0gbWFyZ2luICsgKCh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCkqdGhpcy5zY2FsZSkgLyAyO1xuICAgIH0gZWxzZSBpZiAob3B0cy5ydWxlciA9PSAnbGVmdCcpIHtcbiAgICAgICAgcnVsZXJQb3MgPSBtYXJnaW47XG4gICAgfSBlbHNlIGlmIChvcHRzLnJ1bGVyID09ICdyaWdodCcpIHtcbiAgICAgICAgcnVsZXJQb3MgPSBtYXJnaW4gKyAoKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KSp0aGlzLnNjYWxlKTtcbiAgICB9XG4gICAgaWYgKHJ1bGVyUG9zID49IDApIHtcbiAgICAgICAgdGllckhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2xpbmUnLCBudWxsLCB7eDE6IHJ1bGVyUG9zLCB5MTogNzAsIHgyOiBydWxlclBvcywgeTI6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnYmx1ZSd9KSk7XG4gICAgfVxuXG4gICAgc2F2ZVJvb3QuYXBwZW5kQ2hpbGQodGllckhvbGRlcik7XG4gICAgc2F2ZURvYy5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGIuZmVhdHVyZVBhbmVsV2lkdGggKyAyMCArIG1hcmdpbik7XG4gICAgc2F2ZURvYy5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBwb3MgKyA1MCk7XG5cbiAgICBcbiAgICB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoID0gYmFja3VwRlBXO1xuICAgIHRoaXMuc2NhbGUgPSBiYWNrdXBTY2FsZTtcblxuICAgIGxldCBzdmc7XG4gICAgaWYgKHR5cGVvZihYTUxTZXJpYWxpemVyKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3ZnID0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzYXZlRG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByb290ID0gc2F2ZURvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuICAgICAgICBzdmcgPSByb290Lm91dGVySFRNTDtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5vdXRwdXQgJiYgb3B0cy5vdXRwdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtzdmddLCB7dHlwZTogJ2ltYWdlL3N2Zyt4bWwnfSk7XG4gICAgfVxufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIHN2Zy11dGlscy5qc1xuLy9cblxudmFyIE5TX1NWRyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG52YXIgTlNfWExJTksgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbmZ1bmN0aW9uIFNWR1BhdGgoKSB7XG4gICAgdGhpcy5vcHMgPSBbXTtcbn1cblxuU1ZHUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3BzLnB1c2goJ00gJyArIHggKyAnICcgKyB5KTtcbn1cblxuU1ZHUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3BzLnB1c2goJ0wgJyArIHggKyAnICcgKyB5KTtcbn1cblxuU1ZHUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vcHMucHVzaCgnWicpO1xufVxuXG5TVkdQYXRoLnByb3RvdHlwZS50b1BhdGhEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3BzLmpvaW4oJyAnKTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBOU19TVkc6IE5TX1NWRyxcbiAgICAgICAgTlNfWExJTks6IE5TX1hMSU5LLFxuICAgICAgICBTVkdQYXRoOiBTVkdQYXRoXG4gICAgfVxufSIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyB0YWJpeC1zb3VyY2UuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgZGFsbGlhbmNlX3JlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnkgPSBzYS5yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5O1xuICAgIHZhciBkYWxsaWFuY2VfbWFrZVBhcnNlciA9IHNhLm1ha2VQYXJzZXI7XG4gICAgdmFyIEZlYXR1cmVTb3VyY2VCYXNlID0gc2EuRmVhdHVyZVNvdXJjZUJhc2U7XG5cbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgVVJMRmV0Y2hhYmxlID0gYmluLlVSTEZldGNoYWJsZTtcbiAgICB2YXIgQmxvYkZldGNoYWJsZSA9IGJpbi5CbG9iRmV0Y2hhYmxlO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBBd2FpdGVkID0gdXRpbHMuQXdhaXRlZDtcblxuICAgIHZhciBjb25uZWN0VGFiaXggPSByZXF1aXJlKCcuL3RhYml4JykuY29ubmVjdFRhYml4O1xufVxuXG5mdW5jdGlvbiBUYWJpeEZlYXR1cmVTb3VyY2Uoc291cmNlKSB7XG4gICAgRmVhdHVyZVNvdXJjZUJhc2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnJlYWRpbmVzcyA9ICdDb25uZWN0aW5nJztcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIHRoaXMudGFiaXhIb2xkZXIgPSBuZXcgQXdhaXRlZCgpO1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cblxuICAgIHZhciBwYXJzZXIgPSBkYWxsaWFuY2VfbWFrZVBhcnNlcihzb3VyY2UucGF5bG9hZCk7XG4gICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgdGhyb3cgJ1Vuc3Vwb3J0ZWQgdGFiaXggcGF5bG9hZCAnICsgc291cmNlLnBheWxvYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEsIGluZGV4O1xuICAgIGlmICh0aGlzLnNvdXJjZS5ibG9iKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYkZldGNoYWJsZSh0aGlzLnNvdXJjZS5ibG9iKTtcbiAgICAgICAgaW5kZXggPSBuZXcgQmxvYkZldGNoYWJsZSh0aGlzLnNvdXJjZS5pbmRleEJsb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVVJMRmV0Y2hhYmxlKHRoaXMuc291cmNlLnVyaSwge2NyZWRlbnRpYWxzOiB0aGlzLnNvdXJjZS5jcmVkZW50aWFscywgcmVzb2x2ZXI6IHRoaXMuc291cmNlLnJlc29sdmVyfSk7XG4gICAgICAgIGluZGV4ID0gbmV3IFVSTEZldGNoYWJsZSh0aGlzLnNvdXJjZS5pbmRleFVSSSB8fCAodGhpcy5zb3VyY2UudXJpICsgJy50YmknKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3JlZGVudGlhbHM6IHRoaXMuc291cmNlLmNyZWRlbnRpYWxzLCByZXNvbHZlcjogdGhpcy5zb3VyY2UucmVzb2x2ZXJ9KTtcbiAgICB9XG4gICAgY29ubmVjdFRhYml4KGRhdGEsIGluZGV4LCBmdW5jdGlvbih0YWJpeCwgZXJyKSB7XG4gICAgICAgIHRoaXNCLnRhYml4SG9sZGVyLnByb3ZpZGUodGFiaXgpO1xuICAgICAgICB0YWJpeC5mZXRjaEhlYWRlcihmdW5jdGlvbihsaW5lcywgZXJyKSB7XG4gICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHBhcnNlci5jcmVhdGVTZXNzaW9uKGZ1bmN0aW9uKCkgeyAvKiBOdWxsIHNpbmsgYmVjYXVzZSB3ZSBzaG91bGRuJ3QgZ2V0IHJlY29yZHMgKi8gfSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IGxpbmVzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnBhcnNlKGxpbmVzW2xpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24uZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNCLnJlYWRpbmVzcyA9IG51bGxcbiAgICAgICAgdGhpc0Iubm90aWZ5UmVhZGluZXNzKCk7XG4gICAgfSk7XG59XG5cblRhYml4RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZSk7XG5cblRhYml4RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICBcbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICBcbiAgICB0aGlzLnRhYml4SG9sZGVyLmF3YWl0KGZ1bmN0aW9uKHRhYml4KSB7XG4gICAgICAgIHRhYml4LmZldGNoKGNociwgbWluLCBtYXgsIGZ1bmN0aW9uKHJlY29yZHMsIGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzZXNzaW9uID0gdGhpc0IucGFyc2VyLmNyZWF0ZVNlc3Npb24oZnVuY3Rpb24oZikge2ZlYXR1cmVzLnB1c2goZil9KTtcbiAgICAgICAgICAgIGZvciAodmFyIHJpID0gMDsgcmkgPCByZWNvcmRzLmxlbmd0aDsgKytyaSkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gc2Vzc2lvbi5wYXJzZShyZWNvcmRzW3JpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXNzaW9uLmZsdXNoKCk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBmZWF0dXJlcywgMTAwMDAwMDAwMCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5cblRhYml4RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyICYmIHRoaXMucGFyc2VyLmdldFN0eWxlU2hlZXQpXG4gICAgICAgIHRoaXMucGFyc2VyLmdldFN0eWxlU2hlZXQoY2FsbGJhY2spXG59XG5cblRhYml4RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZJUHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBhcnNlciAmJiB0aGlzLnBhcnNlci5nZXREZWZhdWx0RklQcylcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RGVmYXVsdEZJUHMoY2FsbGJhY2spO1xufVxuXG5cbmRhbGxpYW5jZV9yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5KCd0YWJpeCcsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHJldHVybiB7ZmVhdHVyZXM6IG5ldyBUYWJpeEZlYXR1cmVTb3VyY2Uoc291cmNlKX07XG59KTtcbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTFcbi8vXG4vLyB0YWJpeC5qczogYmFzaWMgc3VwcG9ydCBmb3IgdGFiaXgtaW5kZXhlZCBmbGF0ZmlsZXNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgVEFCSVhfTUFHSUMgPSAweDAxNDk0MjU0O1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzcGFucyA9IHJlcXVpcmUoJy4vc3BhbnMnKTtcbiAgICB2YXIgUmFuZ2UgPSBzcGFucy5SYW5nZTtcbiAgICB2YXIgdW5pb24gPSBzcGFucy51bmlvbjtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gc3BhbnMuaW50ZXJzZWN0aW9uO1xuXG4gICAgdmFyIGJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG4gICAgdmFyIHJlYWRJbnQgPSBiaW4ucmVhZEludDtcbiAgICB2YXIgcmVhZFNob3J0ID0gYmluLnJlYWRTaG9ydDtcbiAgICB2YXIgcmVhZEJ5dGUgPSBiaW4ucmVhZEJ5dGU7XG4gICAgdmFyIHJlYWRJbnQ2NCA9IGJpbi5yZWFkSW50NjQ7XG4gICAgdmFyIHJlYWRGbG9hdCA9IGJpbi5yZWFkRmxvYXQ7XG5cbiAgICB2YXIgbGgzdXRpbHMgPSByZXF1aXJlKCcuL2xoM3V0aWxzJyk7XG4gICAgdmFyIHJlYWRWb2IgPSBsaDN1dGlscy5yZWFkVm9iO1xuICAgIHZhciB1bmJnemYgPSBsaDN1dGlscy51bmJnemY7XG4gICAgdmFyIHJlZzJiaW5zID0gbGgzdXRpbHMucmVnMmJpbnM7XG4gICAgdmFyIENodW5rID0gbGgzdXRpbHMuQ2h1bms7XG59XG5cbmZ1bmN0aW9uIFRhYml4RmlsZSgpIHtcbn1cblxuZnVuY3Rpb24gY29ubmVjdFRhYml4KGRhdGEsIHRiaSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGFiaXggPSBuZXcgVGFiaXhGaWxlKCk7XG4gICAgdGFiaXguZGF0YSA9IGRhdGE7XG4gICAgdGFiaXgudGJpID0gdGJpO1xuXG4gICAgdGFiaXgudGJpLmZldGNoKGZ1bmN0aW9uKGhlYWRlcikgeyAgIC8vIERvIHdlIHJlYWxseSBuZWVkIHRvIGZldGNoIHRoZSB3aG9sZSB0aGluZz8gOi0oXG4gICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJDb3VsZG4ndCBhY2Nlc3MgVGFiaXhcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5jaGVhZCA9IHVuYmd6ZihoZWFkZXIsIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmFyIHVuY2JhID0gbmV3IFVpbnQ4QXJyYXkodW5jaGVhZCk7XG4gICAgICAgIHZhciBtYWdpYyA9IHJlYWRJbnQodW5jYmEsIDApO1xuICAgICAgICBpZiAobWFnaWMgIT0gVEFCSVhfTUFHSUMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnTm90IGEgdGFiaXggaW5kZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBucmVmID0gcmVhZEludCh1bmNiYSwgNCk7XG4gICAgICAgIHRhYml4LmZvcm1hdCA9IHJlYWRJbnQodW5jYmEsIDgpO1xuICAgICAgICB0YWJpeC5jb2xTZXEgPSByZWFkSW50KHVuY2JhLCAxMik7XG4gICAgICAgIHRhYml4LmNvbFN0YXJ0ID0gcmVhZEludCh1bmNiYSwgMTYpO1xuICAgICAgICB0YWJpeC5jb2xFbmQgPSByZWFkSW50KHVuY2JhLCAyMCk7XG4gICAgICAgIHRhYml4Lm1ldGEgPSByZWFkSW50KHVuY2JhLCAyNCk7XG4gICAgICAgIHRhYml4LnNraXAgPSByZWFkSW50KHVuY2JhLCAyOCk7XG4gICAgICAgIHZhciBuYW1lTGVuZ3RoID0gcmVhZEludCh1bmNiYSwgMzIpO1xuXG4gICAgICAgIHRhYml4LmluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgcCA9IDM2O1xuICAgICAgICB0YWJpeC5jaHJUb0luZGV4ID0ge307XG4gICAgICAgIHRhYml4LmluZGV4VG9DaHIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBucmVmOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJydcblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSB1bmNiYVtwKytdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIG5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhYml4LmNoclRvSW5kZXhbbmFtZV0gPSBpO1xuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignY2hyJykgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRhYml4LmNoclRvSW5kZXhbbmFtZS5zdWJzdHJpbmcoMyldID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFiaXguY2hyVG9JbmRleFsnY2hyJyArIG5hbWVdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYml4LmluZGV4VG9DaHIucHVzaChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5CbG9ja0luZGV4ID0gMTAwMDAwMDAwMDtcbiAgICAgICAgZm9yICh2YXIgcmVmID0gMDsgcmVmIDwgbnJlZjsgKytyZWYpIHtcbiAgICAgICAgICAgIHZhciBibG9ja1N0YXJ0ID0gcDtcbiAgICAgICAgICAgIHZhciBuYmluID0gcmVhZEludCh1bmNiYSwgcCk7IHAgKz0gNDtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgbmJpbjsgKytiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbiA9IHJlYWRJbnQodW5jYmEsIHApO1xuICAgICAgICAgICAgICAgIHZhciBuY2huayA9IHJlYWRJbnQodW5jYmEsIHArNCk7XG4gICAgICAgICAgICAgICAgcCArPSA4ICsgKG5jaG5rICogMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5pbnR2ID0gcmVhZEludCh1bmNiYSwgcCk7IHAgKz0gNDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHEgPSBwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuaW50djsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSByZWFkVm9iKHVuY2JhLCBxKTsgcSArPSA4O1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaSA9IHYuYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lm9mZnNldCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBiaSArPSA2NTUzNjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYmkgPCBtaW5CbG9ja0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQmxvY2tJbmRleCA9IGJpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwICs9IChuaW50diAqIDgpO1xuXG5cbiAgICAgICAgICAgIHZhciB1YiA9IHVuY2JhO1xuICAgICAgICAgICAgaWYgKG5iaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGFiaXguaW5kaWNlc1tyZWZdID0gbmV3IFVpbnQ4QXJyYXkodW5jaGVhZCwgYmxvY2tTdGFydCwgcCAtIGJsb2NrU3RhcnQpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgdGFiaXguaGVhZGVyTWF4ID0gbWluQmxvY2tJbmRleDtcblxuICAgICAgICBjYWxsYmFjayh0YWJpeCk7XG4gICAgfSwge3RpbWVvdXQ6IDUwMDAwfSk7XG59XG5cbi8vIENvcHktcGFzdGUgZnJvbSBCYW1GaWxlXG5cblRhYml4RmlsZS5wcm90b3R5cGUuYmxvY2tzRm9yUmFuZ2UgPSBmdW5jdGlvbihyZWZJZCwgbWluLCBtYXgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGljZXNbcmVmSWRdO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBpbnRCaW5zTCA9IHJlZzJiaW5zKG1pbiwgbWF4KTtcbiAgICB2YXIgaW50QmlucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50Qmluc0wubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW50Qmluc1tpbnRCaW5zTFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgbGVhZkNodW5rcyA9IFtdLCBvdGhlckNodW5rcyA9IFtdO1xuXG4gICAgdmFyIG5iaW4gPSByZWFkSW50KGluZGV4LCAwKTtcbiAgICB2YXIgcCA9IDQ7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBuYmluOyArK2IpIHtcbiAgICAgICAgdmFyIGJpbiA9IHJlYWRJbnQoaW5kZXgsIHApO1xuICAgICAgICB2YXIgbmNobmsgPSByZWFkSW50KGluZGV4LCBwKzQpO1xuICAgICAgICBwICs9IDg7XG4gICAgICAgIGlmIChpbnRCaW5zW2Jpbl0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbmNobms7ICsrYykge1xuICAgICAgICAgICAgICAgIHZhciBjcyA9IHJlYWRWb2IoaW5kZXgsIHAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBjZSA9IHJlYWRWb2IoaW5kZXgsIHAgKyA4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAoYmluIDwgNDY4MSA/IG90aGVyQ2h1bmtzIDogbGVhZkNodW5rcykucHVzaChuZXcgQ2h1bmsoY3MsIGNlKSk7XG4gICAgICAgICAgICAgICAgcCArPSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gIChuY2huayAqIDE2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuaW50diA9IHJlYWRJbnQoaW5kZXgsIHApO1xuICAgIHZhciBsb3dlc3QgPSBudWxsO1xuICAgIHZhciBtaW5MaW4gPSBNYXRoLm1pbihtaW4+PjE0LCBuaW50diAtIDEpLCBtYXhMaW4gPSBNYXRoLm1pbihtYXg+PjE0LCBuaW50diAtIDEpO1xuICAgIGZvciAodmFyIGkgPSBtaW5MaW47IGkgPD0gbWF4TGluOyArK2kpIHtcbiAgICAgICAgdmFyIGxiID0gIHJlYWRWb2IoaW5kZXgsIHAgKyA0ICsgKGkgKiA4KSk7XG4gICAgICAgIGlmICghbGIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbG93ZXN0IHx8IGxiLmJsb2NrIDwgbG93ZXN0LmJsb2NrIHx8IGxiLm9mZnNldCA8IGxvd2VzdC5vZmZzZXQpIHtcbiAgICAgICAgICAgIGxvd2VzdCA9IGxiO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciBwcnVuZWRPdGhlckNodW5rcyA9IFtdO1xuICAgIGlmIChsb3dlc3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyQ2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2huayA9IG90aGVyQ2h1bmtzW2ldO1xuICAgICAgICAgICAgaWYgKGNobmsubWF4di5ibG9jayA+PSBsb3dlc3QuYmxvY2sgJiYgY2huay5tYXh2Lm9mZnNldCA+PSBsb3dlc3Qub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgcHJ1bmVkT3RoZXJDaHVua3MucHVzaChjaG5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gXG4gICAgb3RoZXJDaHVua3MgPSBwcnVuZWRPdGhlckNodW5rcztcblxuICAgIHZhciBpbnRDaHVua3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyQ2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGludENodW5rcy5wdXNoKG90aGVyQ2h1bmtzW2ldKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWFmQ2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGludENodW5rcy5wdXNoKGxlYWZDaHVua3NbaV0pO1xuICAgIH1cblxuICAgIGludENodW5rcy5zb3J0KGZ1bmN0aW9uKGMwLCBjMSkge1xuICAgICAgICB2YXIgZGlmID0gYzAubWludi5ibG9jayAtIGMxLm1pbnYuYmxvY2s7XG4gICAgICAgIGlmIChkaWYgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjMC5taW52Lm9mZnNldCAtIGMxLm1pbnYub2Zmc2V0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1lcmdlZENodW5rcyA9IFtdO1xuICAgIGlmIChpbnRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY3VyID0gaW50Q2h1bmtzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGludENodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5jID0gaW50Q2h1bmtzW2ldO1xuICAgICAgICAgICAgaWYgKG5jLm1pbnYuYmxvY2sgPT0gY3VyLm1heHYuYmxvY2sgLyogJiYgbmMubWludi5vZmZzZXQgPT0gY3VyLm1heHYub2Zmc2V0ICovKSB7IC8vIG5vIHBvaW50IHNwbGl0dGluZyBtaWQtYmxvY2tcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXcgQ2h1bmsoY3VyLm1pbnYsIG5jLm1heHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjdXIpO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGN1cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZENodW5rcztcbn1cblxuVGFiaXhGaWxlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHZhciBjaHJJZCA9IHRoaXMuY2hyVG9JbmRleFtjaHJdO1xuICAgIGlmIChjaHJJZCA9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhbXSk7XG5cbiAgICB2YXIgY2Fub25pY2FsQ2hyID0gdGhpcy5pbmRleFRvQ2hyW2NocklkXTtcblxuICAgIHZhciBjaHVua3M7XG4gICAgaWYgKGNocklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2h1bmtzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmtzID0gdGhpcy5ibG9ja3NGb3JSYW5nZShjaHJJZCwgbWluLCBtYXgpO1xuICAgICAgICBpZiAoIWNodW5rcykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ0Vycm9yIGluIGluZGV4IGZldGNoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkcyA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGRhdGE7XG5cbiAgICBmdW5jdGlvbiB0cmFtcCgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZWNvcmRzKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdmFyIGMgPSBjaHVua3NbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGZldGNoTWluID0gYy5taW52LmJsb2NrO1xuICAgICAgICAgICAgdmFyIGZldGNoTWF4ID0gYy5tYXh2LmJsb2NrICsgKDE8PDE2KTsgLy8gKnNpZ2gqXG4gICAgICAgICAgICB0aGlzQi5kYXRhLnNsaWNlKGZldGNoTWluLCBmZXRjaE1heCAtIGZldGNoTWluKS5mZXRjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuYmd6ZihyLCBjLm1heHYuYmxvY2sgLSBjLm1pbnYuYmxvY2sgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICB0aGlzQi5yZWFkUmVjb3JkcyhiYSwgY2h1bmtzW2luZGV4XS5taW52Lm9mZnNldCwgcmVjb3JkcywgbWluLCBtYXgsIGNhbm9uaWNhbENocik7XG4gICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdHJhbXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFtcCgpO1xufVxuXG5UYWJpeEZpbGUucHJvdG90eXBlLnJlYWRSZWNvcmRzID0gZnVuY3Rpb24oYmEsIG9mZnNldCwgc2luaywgbWluLCBtYXgsIGNocikge1xuICAgTElORV9MT09QOlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBsaW5lID0gJyc7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBiYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IGJhW29mZnNldCsrXTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAxMCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tzID0gbGluZS5zcGxpdCgnXFx0Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rc1t0aGlzLmNvbFNlcSAtIDFdID09IGNocikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm1pbiA9IHBhcnNlSW50KHRva3NbdGhpcy5jb2xTdGFydCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZtYXggPSBmbWluO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xFbmQgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm1heCA9IHBhcnNlSW50KHRva3NbdGhpcy5jb2xFbmQgLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdCAmIDB4MTAwMDApICsrZm1pbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZm1pbiA8PSBtYXggJiYgZm1heCA+PSBtaW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlIExJTkVfTE9PUDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG5UYWJpeEZpbGUucHJvdG90eXBlLmZldGNoSGVhZGVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGZldGNoUHRyID0gMCwgcHRyID0gMCwgbGluZT0nJztcbiAgICB2YXIgbGluZXMgPSBbXTtcblxuICAgIHNlbGYuZGF0YS5zbGljZSgwLCBzZWxmLmhlYWRlck1heCkuZmV0Y2goZnVuY3Rpb24oY2huaykge1xuICAgICAgICBpZiAoIWNobmspIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkZldGNoIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheSh1bmJnemYoY2huaywgY2huay5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIHZhciBwdHIgPSAwLCBsaW5lID0gJycsIGxpbmVzID0gW107XG4gICAgICAgIHdoaWxlIChwdHIgPCBiYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IGJhW3B0cisrXVxuICAgICAgICAgICAgaWYgKGNoID09IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuY2hhckNvZGVBdCgwKSA9PSBzZWxmLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhsaW5lcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGxpbmVzKTtcbiAgICB9KTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjb25uZWN0VGFiaXg6IGNvbm5lY3RUYWJpeCxcbiAgICAgICAgVEFCSVhfTUFHSUM6IFRBQklYX01BR0lDXG4gICAgfTtcbn1cbiIsIi8qIGpzaGludCBlc3ZlcnNpb246IDYgKi9cblxuLypcbiBTb3VyY2UgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB0byBwcm9kdWNlIGFueSB0eXBlIG9mIGZlYXR1cmUsXG4gdXNlZnVsIGZvciB0ZXN0aW5nIHJlbmRlcmVycy5cbiAqL1xuXG5pbXBvcnQgeyByZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5LFxuICAgICAgICAgRmVhdHVyZVNvdXJjZUJhc2VcbiAgICAgICB9IGZyb20gXCIuL3NvdXJjZWFkYXB0ZXJzLmpzXCI7XG5cbmltcG9ydCB7IERBU0ZlYXR1cmVcbiAgICAgICB9IGZyb20gXCIuL2Rhcy5qc1wiO1xuXG5pbXBvcnQgKiBhcyBSIGZyb20gXCJyYW1kYVwiO1xuXG5cbmNsYXNzIFRlc3RTb3VyY2UgZXh0ZW5kcyBGZWF0dXJlU291cmNlQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IFIuZGVmYXVsdFRvKFtdLCBzb3VyY2UuZmVhdHVyZXMpO1xuICAgIH1cblxuICAgIGdlbkZlYXR1cmUoY29uZikge1xuICAgICAgICBsZXQgZmVhdHVyZSA9IG5ldyBEQVNGZWF0dXJlKCk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmYpIHtcbiAgICAgICAgICAgIGZlYXR1cmVba2V5XSA9IGNvbmZba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZldGNoKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGZlYXR1cmVzID0gUi5mb3JFYWNoKHRoaXMuZ2VuRmVhdHVyZSwgdGhpcy5mZWF0dXJlcyk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmZWF0dXJlcywgMSk7XG4gICAgfVxufVxuXG5cbnJlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnkoJ3Rlc3Qtc291cmNlJywgc291cmNlID0+IHtcbiAgICByZXR1cm4geyBmZWF0dXJlczogbmV3IFRlc3RTb3VyY2Uoc291cmNlKSB9O1xufSk7XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gdGh1Yi5qczogc3VwcG9ydCBmb3IgdHJhY2staHViIHN0eWxlIHJlZ2lzdHJpZXNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgdGV4dFhIUiA9IHV0aWxzLnRleHRYSFI7XG4gICAgdmFyIHJlbGF0aXZlVVJMID0gdXRpbHMucmVsYXRpdmVVUkw7XG4gICAgdmFyIHNoYWxsb3dDb3B5ID0gdXRpbHMuc2hhbGxvd0NvcHk7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xuICAgIHZhciBEQVNTdHlsZSA9IGRhcy5EQVNTdHlsZTtcbn1cblxudmFyIFRIVUJfU1RBTlpBX1JFR0VYUCA9IC9cXG5cXHMqXFxuLztcbnZhciBUSFVCX1BBUlNFX1JFR0VYUCAgPSAvKFxcdyspICsoLispXFxuPy87XG52YXIgVEhVQl9TVUJHUk9VUF9SRUdFWFAgPSAvc3ViR3JvdXBbMS05XS87XG5cbnZhciBUSFVCX1BFTk5BTlRfUFJFRklYID0gJ2h0dHA6Ly9nZW5vbWUudWNzYy5lZHUvaW1hZ2VzLyc7XG5cbmZ1bmN0aW9uIFRyYWNrSHViKHVybCkge1xuICAgIHRoaXMuZ2Vub21lcyA9IHt9O1xuICAgIHRoaXMudXJsID0gdXJsO1xufVxuXG5mdW5jdGlvbiBUcmFja0h1YlRyYWNrKCkge1xufVxuXG5UcmFja0h1YlRyYWNrLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrKSB7XG4gICAgaWYgKHRoaXNba10pXG4gICAgICAgIHJldHVybiB0aGlzW2tdO1xuICAgIGVsc2UgaWYgKHRoaXMuX3BhcmVudCkgXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQuZ2V0KGspO1xufVxuXG5mdW5jdGlvbiBUcmFja0h1YkRCKGh1Yikge1xuICAgIHRoaXMuaHViID0gaHViO1xufVxuXG5UcmFja0h1YkRCLnByb3RvdHlwZS5nZXRUcmFja3MgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3RyYWNrcykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fdHJhY2tzKTtcbiAgICB9IFxuICAgIFxuICAgIHRleHRYSFIodGhpcy5hYnNVUkwsIGZ1bmN0aW9uKHRyYWNrRmlsZSwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB0cmFja0ZpbGUgPSB0cmFja0ZpbGUucmVwbGFjZSgvXFwjLiovZywgJycpO1xuICAgICAgICB0cmFja0ZpbGUgPSB0cmFja0ZpbGUucmVwbGFjZSgnXFxcXFxcbicsICcgJyk7XG5cbiAgICAgICAgdmFyIHRyYWNrcyA9IFtdO1xuICAgICAgICB2YXIgdHJhY2tzQnlJZCA9IHt9O1xuICAgICAgICB2YXIgc3RhbnphcyA9IHRyYWNrRmlsZS5zcGxpdChUSFVCX1NUQU5aQV9SRUdFWFApO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN0YW56YXMubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgICAgIHZhciB0b2tzID0gc3Rhbnphc1tzXS5yZXBsYWNlKC9cXCMuKi9nLCAnJykuc3BsaXQoVEhVQl9QQVJTRV9SRUdFWFApO1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gbmV3IFRyYWNrSHViVHJhY2soKTtcbiAgICAgICAgICAgIHRyYWNrLl9kYiA9IHRoaXNCO1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0b2tzLmxlbmd0aCAtIDI7IGwgKz0gMykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gdG9rc1tsKzFdLCB2ID0gdG9rc1tsKzJdO1xuICAgICAgICAgICAgICAgIGlmIChrLm1hdGNoKFRIVUJfU1VCR1JPVVBfUkVHRVhQKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLnN1Ymdyb3VwcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN1Ymdyb3VwcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2d0b2tzID0gdi5zcGxpdCgvXFxzLyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZ3RhZyA9IHNndG9rc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNncmVjb3JkID0ge25hbWU6IHNndG9rc1sxXSwgdGFnczogW10sIHRpdGxlczogW119O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzZ3RpID0gMjsgc2d0aSA8IHNndG9rcy5sZW5ndGg7ICsrc2d0aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdycCA9IHNndG9rc1tzZ3RpXS5zcGxpdCgvPS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2dyZWNvcmQudGFncy5wdXNoKGdycFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZ3JlY29yZC50aXRsZXMucHVzaChncnBbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN1Ymdyb3Vwc1tzZ3RhZ10gPSBzZ3JlY29yZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdzdWJHcm91cHMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZ3Rva3MgPSB2LnNwbGl0KC8oXFx3Kyk9KFxcdyspLyk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnNnbSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzZ3RpID0gMDsgc2d0aSA8IHNndG9rcy5sZW5ndGggLSAyOyBzZ3RpICs9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnNnbVtzZ3Rva3Nbc2d0aSsxXV0gPSBzZ3Rva3Nbc2d0aSArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tbdG9rc1tsKzFdXSA9IHRva3NbbCsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFjay50cmFjayAmJiAodHJhY2sudHlwZSB8fCB0cmFjay5jb250YWluZXIgfHwgdHJhY2sudmlldyB8fCB0cmFjay5iaWdEYXRhVXJsKSkge1xuICAgICAgICAgICAgICAgIHRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICAgICAgICAgICAgICB0cmFja3NCeUlkW3RyYWNrLnRyYWNrXSA9IHRyYWNrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2tpcHBpbmcgJywgdHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgdG9wbGV2ZWxzID0gW107XG4gICAgICAgIHZhciBjb21wb3NpdGVzID0gW107XG4gICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0cmFja3MubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbdGldO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHJhY2sucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHB0b2tzID0gdHJhY2sucGFyZW50LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRyYWNrc0J5SWRbcHRva3NbMF1dO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suX3BhcmVudCA9IHBhcmVudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0cmFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgZmluZCBwYXJlbnQgXCIgKyBwdG9rc1swXSArICcoJyArIHRyYWNrLnBhcmVudCArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2suY29tcG9zaXRlVHJhY2spIHtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVzLnB1c2godHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICB0b3BsZXZlbHMucHVzaCh0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY29tcG9zaXRlcy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgIHZhciBjb21wID0gY29tcG9zaXRlc1tjaV07XG4gICAgICAgICAgICBpZiAoIWNvbXAuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBwYXJlbnRPZlZpZXdzID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBraSA9IDA7IGtpIDwgY29tcC5jaGlsZHJlbi5sZW5ndGg7ICsra2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IGNvbXAuY2hpbGRyZW5ba2ldO1xuICAgICAgICAgICAgICAgIGlmIChrLnZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgay5zaG9ydExhYmVsID0gY29tcC5zaG9ydExhYmVsICsgXCI6IFwiICsgay5zaG9ydExhYmVsO1xuICAgICAgICAgICAgICAgICAgICB0b3BsZXZlbHMucHVzaChrKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2ZWaWV3cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJlbnRPZlZpZXdzKVxuICAgICAgICAgICAgICAgIHRvcGxldmVscy5wdXNoKGNvbXApO1xuICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgdGhpc0IuX3RyYWNrcyA9IHRvcGxldmVscztcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXNCLl90cmFja3MsIG51bGwpO1xuICAgIH0sIHtjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscywgc2FsdDogdHJ1ZX0pO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0VHJhY2tIdWIoaHViVVJMLCBjYWxsYmFjaywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIG9wdHMuc2FsdCA9IHRydWU7XG5cbiAgICB0ZXh0WEhSKGh1YlVSTCwgZnVuY3Rpb24oaHViRmlsZSwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva3MgPSBodWJGaWxlLnNwbGl0KFRIVUJfUEFSU0VfUkVHRVhQKTtcbiAgICAgICAgdmFyIGh1YiA9IG5ldyBUcmFja0h1YihodWJVUkwpO1xuICAgICAgICBpZiAob3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgaHViLmNyZWRlbnRpYWxzID0gb3B0cy5jcmVkZW50aWFscztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRva3MubGVuZ3RoIC0gMjsgbCArPSAzKSB7XG4gICAgICAgICAgICBodWJbdG9rc1tsKzFdXSA9IHRva3NbbCsyXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmIChodWIuZ2Vub21lc0ZpbGUpIHtcbiAgICAgICAgICAgIHZhciBnZW5VUkwgPSByZWxhdGl2ZVVSTChodWJVUkwsIGh1Yi5nZW5vbWVzRmlsZSk7XG4gICAgICAgICAgICB0ZXh0WEhSKGdlblVSTCwgZnVuY3Rpb24oZ2VuRmlsZSwgZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhbnphcyA9IGdlbkZpbGUuc3BsaXQoVEhVQl9TVEFOWkFfUkVHRVhQKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN0YW56YXMubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva3MgPSBzdGFuemFzW3NdLnNwbGl0KFRIVUJfUEFSU0VfUkVHRVhQKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdwcm9wcyA9IG5ldyBUcmFja0h1YkRCKGh1Yik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncHJvcHMuY3JlZGVudGlhbHMgPSBvcHRzLmNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0b2tzLmxlbmd0aCAtIDI7IGwgKz0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3Byb3BzW3Rva3NbbCsxXV0gPSB0b2tzW2wrMl07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3Byb3BzLnR3b0JpdFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdwcm9wcy50d29CaXRQYXRoID0gcmVsYXRpdmVVUkwoZ2VuVVJMLCBncHJvcHMudHdvQml0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3Byb3BzLmdlbm9tZSAmJiBncHJvcHMudHJhY2tEYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3Byb3BzLmFic1VSTCA9IHJlbGF0aXZlVVJMKGdlblVSTCwgZ3Byb3BzLnRyYWNrRGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHViLmdlbm9tZXNbZ3Byb3BzLmdlbm9tZV0gPSBncHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhodWIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdObyBnZW5vbWVzRmlsZScpO1xuICAgICAgICB9XG4gICAgfSwgb3B0cyk7XG59XG5cblxuVHJhY2tIdWJUcmFjay5wcm90b3R5cGUudG9EYWxsaWFuY2VTb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0ge1xuICAgICAgICBuYW1lOiB0aGlzLnNob3J0TGFiZWwsXG4gICAgICAgIGRlc2M6IHRoaXMubG9uZ0xhYmVsXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZGIubWFwcGluZykge1xuICAgICAgICBzb3VyY2UubWFwcGluZyA9IHRoaXMuX2RiLm1hcHBpbmc7XG4gICAgfVxuXG4gICAgdmFyIHBlbm5hbnRJY29uID0gdGhpcy5nZXQoJ3Blbm5hbnRJY29uJyk7XG4gICAgaWYgKHBlbm5hbnRJY29uKSB7XG4gICAgICAgIHZhciBwdG9rcyA9IHBlbm5hbnRJY29uLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHNvdXJjZS5wZW5uYW50ID0gVEhVQl9QRU5OQU5UX1BSRUZJWCArIHB0b2tzWzBdO1xuICAgIH1cblxuICAgIHZhciBzZWFyY2hUcml4ID0gdGhpcy5nZXQoJ3NlYXJjaFRyaXgnKTtcbiAgICBpZiAoc2VhcmNoVHJpeCkge1xuICAgICAgICBzb3VyY2UudHJpeFVSSSA9IHJlbGF0aXZlVVJMKHRoaXMuX2RiLmFic1VSTCwgc2VhcmNoVHJpeCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09ICdtdWx0aVdpZycpIHtcbiAgICAgICAgc291cmNlLm1lcmdlID0gJ2NvbmNhdCc7XG4gICAgICAgIHNvdXJjZS5vdmVybGF5ID0gW107XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gfHwgW107XG4gICAgICAgIHNvdXJjZS5zdHlsZSA9IFtdO1xuICAgICAgICBzb3VyY2Uubm9Eb3duc2FtcGxlID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBjaGlsZHJlbltjaV07XG4gICAgICAgICAgICB2YXIgY3MgPSBjaC50b0RhbGxpYW5jZVNvdXJjZSgpXG4gICAgICAgICAgICBzb3VyY2Uub3ZlcmxheS5wdXNoKGNzKTtcblxuICAgICAgICAgICAgaWYgKGNzLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IGNzLnN0eWxlLmxlbmd0aDsgKytzaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBjcy5zdHlsZVtzaV07XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm1ldGhvZCA9IGNoLnNob3J0TGFiZWw7ICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hZ2dyZWdhdGUgPT0gJ3RyYW5zcGFyZW50T3ZlcmxheScpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5zdHlsZS5BTFBIQSA9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnN0eWxlLnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlOyAgICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAocC5fcGFyZW50ICYmICFwLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBwID0gcC5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IHAudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0eXBlVG9rcyA9IHR5cGUuc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKHR5cGVUb2tzWzBdID09ICdiaWdCZWQnICYmIHRoaXMuYmlnRGF0YVVybCkge1xuICAgICAgICAgICAgdmFyIGJlZFRva2VucyA9IHR5cGVUb2tzWzFdfDBcbiAgICAgICAgICAgIHZhciBiZWRQbHVzID0gdHlwZVRva3NbMl0gPT0gJysnO1xuXG4gICAgICAgICAgICBzb3VyY2UuYndnVVJJID0gcmVsYXRpdmVVUkwodGhpcy5fZGIuYWJzVVJMLCB0aGlzLmJpZ0RhdGFVcmwpO1xuICAgICAgICAgICAgc291cmNlLnN0eWxlID0gdGhpcy5iaWdiZWRTdHlsZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kYi5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5jcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVkVG9rZW5zID49IDEyICYmIGJlZFBsdXMpXG4gICAgICAgICAgICAgICAgc291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlVG9rc1swXSA9PSAnYmlnV2lnJyAmJiB0aGlzLmJpZ0RhdGFVcmwpIHtcbiAgICAgICAgICAgIHNvdXJjZS5id2dVUkkgPSByZWxhdGl2ZVVSTCh0aGlzLl9kYi5hYnNVUkwsIHRoaXMuYmlnRGF0YVVybCk7XG4gICAgICAgICAgICBzb3VyY2Uuc3R5bGUgPSB0aGlzLmJpZ3dpZ1N0eWxlcygpO1xuICAgICAgICAgICAgc291cmNlLm5vRG93bnNhbXBsZSA9IHRydWU7ICAgICAvLyBGSVhNRSBzZWVtcyBsaWtlIGEgYmx1bnQgaW5zdHJ1bWVudC4uLlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy55TGluZU9uT2ZmICYmIHRoaXMueUxpbmVPbk9mZiA9PSAnb24nKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnF1YW50TGVhcFRocmVzaG9sZCA9IHRoaXMueUxpbmVNYXJrICE9PSB1bmRlZmluZWQgPyAoMS4wICogdGhpcy55TGluZU1hcmspIDogMC4wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZGIuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UuY3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVUb2tzWzBdID09ICdiYW0nICAmJiB0aGlzLmJpZ0RhdGFVcmwpIHtcbiAgICAgICAgICAgIHNvdXJjZS5iYW1VUkkgPSByZWxhdGl2ZVVSTCh0aGlzLl9kYi5hYnNVUkwsIHRoaXMuYmlnRGF0YVVybCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGIuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UuY3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlVG9rc1swXSA9PSAndmNmVGFiaXgnICYmIHRoaXMuYmlnRGF0YVVybCkge1xuICAgICAgICAgICAgc291cmNlLnVyaSA9IHJlbGF0aXZlVVJMKHRoaXMuX2RiLmFic1VSTCwgdGhpcy5iaWdEYXRhVXJsKTtcbiAgICAgICAgICAgIHNvdXJjZS50aWVyX3R5cGUgPSAndGFiaXgnO1xuICAgICAgICAgICAgc291cmNlLnBheWxvYWQgPSAndmNmJztcbiAgICAgICAgICAgIGlmICh0aGlzLl9kYi5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5jcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Vuc3VwcG9ydGVkICcgKyB0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5UcmFja0h1YlRyYWNrLnByb3RvdHlwZS5iaWd3aWdTdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocC5fcGFyZW50ICYmICFwLnR5cGUpIHtcbiAgICAgICAgICAgIHAgPSBwLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHAudHlwZTtcbiAgICB9XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHR5cGVUb2tzID0gdHlwZS5zcGxpdCgvXFxzKy8pO1xuXG4gICAgdmFyIG1pbiwgbWF4O1xuICAgIGlmICh0eXBlVG9rcy5sZW5ndGggPj0gMykge1xuICAgICAgICBtaW4gPSAxLjAgKiB0eXBlVG9rc1sxXTtcbiAgICAgICAgbWF4ID0gMS4wICogdHlwZVRva3NbMl07XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodDtcbiAgICBpZiAodGhpcy5tYXhIZWlnaHRQaXhlbHMpIHtcbiAgICAgICAgdmFyIG1ocFRva3MgPSB0aGlzLm1heEhlaWdodFBpeGVscy5zcGxpdCgvOi8pO1xuICAgICAgICBpZiAobWhwVG9rcy5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gbWhwVG9rc1sxXSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbWF4SGVpZ2h0UGl4ZWxzIHNob3VsZCBiZSBvZiB0aGUgZm9ybSBtYXg6ZGVmYXVsdDptaW4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgZ3R5cGUgPSAnYmFycyc7XG4gICAgaWYgKHRoaXMuZ3JhcGhUeXBlRGVmYXVsdCkge1xuICAgICAgICBndHlwZSA9IHRoaXMuZ3JhcGhUeXBlRGVmYXVsdDtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNvbG9yID0gJ2JsYWNrJztcbiAgICB2YXIgYWx0Q29sb3IgPSBudWxsO1xuICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gJ3JnYignICsgdGhpcy5jb2xvciArICcpJztcbiAgICB9XG4gICAgaWYgKHRoaXMuYWx0Q29sb3IpIHtcbiAgICAgICAgYWx0Q29sb3IgPSAncmdiKCcgKyB0aGlzLmFsdENvbG9yICsgJyknO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc3R5bGVzaGVldCA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG4gICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgaWYgKGd0eXBlID09ICdwb2ludHMnKSB7XG4gICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ1BPSU5UJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdISVNUT0dSQU0nO1xuICAgIH1cblxuICAgIGlmIChhbHRDb2xvcikge1xuICAgICAgICB3aWdTdHlsZS5DT0xPUjEgPSBjb2xvcjtcbiAgICAgICAgd2lnU3R5bGUuQ09MT1IyID0gYWx0Q29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2lnU3R5bGUuQkdDT0xPUiA9IGNvbG9yO1xuICAgIH1cbiAgICB3aWdTdHlsZS5IRUlHSFQgPSBoZWlnaHQgfHwgMzA7XG4gICAgaWYgKG1pbiB8fCBtYXgpIHtcbiAgICAgICAgd2lnU3R5bGUuTUlOID0gbWluO1xuICAgICAgICB3aWdTdHlsZS5NQVggPSBtYXg7XG4gICAgfVxuICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVmYXVsdCd9LCBudWxsLCB3aWdTdHlsZSk7XG4gICAgcmV0dXJuIHN0eWxlc2hlZXQuc3R5bGVzO1xufVxuXG5UcmFja0h1YlRyYWNrLnByb3RvdHlwZS5iaWdiZWRTdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbVJnYiA9ICgnJyt0aGlzLmdldCgnaXRlbVJnYicpKS50b0xvd2VyQ2FzZSgpID09ICdvbic7XG4gICAgdmFyIHZpc2liaWxpdHkgPSB0aGlzLmdldCgndmlzaWJpbGl0eScpIHx8ICdmdWxsJztcbiAgICB2YXIgY29sb3IgPSB0aGlzLmdldCgnY29sb3InKTtcbiAgICBpZiAoY29sb3IpXG4gICAgICAgIGNvbG9yID0gJ3JnYignICsgY29sb3IgKyAnKSc7XG4gICAgZWxzZSBcbiAgICAgICAgY29sb3IgPSAnYmx1ZSc7XG4gICAgXG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgIHdpZ1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgd2lnU3R5bGUuQkdDT0xPUiA9IGNvbG9yO1xuICAgIHdpZ1N0eWxlLkhFSUdIVCA9ICh2aXNpYmlsaXR5ID09ICdmdWxsJyB8fCB2aXNpYmlsaXR5ID09ICdwYWNrJykgPyAxMiA6IDg7XG4gICAgd2lnU3R5bGUuQlVNUCA9ICh2aXNpYmlsaXR5ID09ICdmdWxsJyB8fCB2aXNpYmlsaXR5ID09ICdwYWNrJyk7XG4gICAgd2lnU3R5bGUuTEFCRUwgPSAodmlzaWJpbGl0eSA9PSAnZnVsbCcgfHwgdmlzaWJpbGl0eSA9PSAncGFjaycpO1xuICAgIHdpZ1N0eWxlLlpJTkRFWCA9IDIwO1xuICAgIGlmIChpdGVtUmdiKVxuICAgICAgICB3aWdTdHlsZS5CR0lURU0gPSB0cnVlO1xuXG4gICAgdmFyIGNicyA9IHRoaXMuZ2V0KCdjb2xvckJ5U3RyYW5kJyk7XG4gICAgaWYgKGNicykge1xuICAgICAgICB2YXIgY2JzVG9rcyA9IGNicy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBcbiAgICAgICAgdmFyIHBsdXMgPSBzaGFsbG93Q29weSh3aWdTdHlsZSk7XG4gICAgICAgIHBsdXMuQkdDT0xPUiA9ICdyZ2IoJyArIGNic1Rva3NbMF0gKyAnKSc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnYmlnYmVkJywgb3JpZW50YXRpb246ICcrJ30sIG51bGwsIHBsdXMpO1xuXG4gICAgICAgIHZhciBtaW51cyA9IHNoYWxsb3dDb3B5KHdpZ1N0eWxlKTtcbiAgICAgICAgbWludXMuQkdDT0xPUiA9ICdyZ2IoJyArIGNic1Rva3NbMV0gKyAnKSc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnYmlnYmVkJywgb3JpZW50YXRpb246ICctJ30sIG51bGwsIG1pbnVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2JpZ2JlZCd9LCBudWxsLCB3aWdTdHlsZSk7XG4gICAgfSAgIFxuICAgIFxuICAgIHZhciB0bFN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgdGxTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgIHRsU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgaWYgKGl0ZW1SZ2IpXG4gICAgICAgIHRsU3R5bGUuQkdJVEVNID0gdHJ1ZTtcbiAgICB0bFN0eWxlLkJHQ09MT1IgPSAncmVkJ1xuICAgIHRsU3R5bGUuSEVJR0hUID0gMTA7XG4gICAgdGxTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICB0bFN0eWxlLlpJTkRFWCA9IDIwO1xuICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNsYXRpb24nfSwgbnVsbCwgdGxTdHlsZSk7XG4gICAgXG4gICAgdmFyIHRzU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICB0c1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgdHNTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICB0c1N0eWxlLkJHQ09MT1IgPSAnd2hpdGUnO1xuICAgIHRzU3R5bGUuSEVJR0hUID0gMTA7XG4gICAgdHNTdHlsZS5aSU5ERVggPSAxMDtcbiAgICB0c1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgIHRzU3R5bGUuTEFCRUwgPSB0cnVlO1xuICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNjcmlwdCd9LCBudWxsLCB0c1N0eWxlKTtcblxuICAgIHJldHVybiBzdHlsZXNoZWV0LnN0eWxlcztcbn1cblxuZnVuY3Rpb24gVEhVQl9DT01QQVJFKGcsIGgpIHtcbiAgICBpZiAoZy5wcmlvcml0eSAmJiBoLnByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAoMS4wICogZy5wcmlvcml0eSkgLSAoMS4wICogaC5wcmlvcml0eSlcbiAgICB9IGVsc2UgaWYgKGcucHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChoLnByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZy5zaG9ydExhYmVsLmxvY2FsZUNvbXBhcmUoaC5zaG9ydExhYmVsKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY29ubmVjdFRyYWNrSHViOiBjb25uZWN0VHJhY2tIdWIsXG4gICAgICAgIFRIVUJfQ09NUEFSRTogVEhVQl9DT01QQVJFXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyB0aWVyLWFjdGlvbnMuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi9jYnJvd3NlcicpO1xuICAgIHZhciBCcm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tZXJnZVNlbGVjdGVkVGllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIHZhciBzdHlsZXMgPSBbXTtcblxuICAgIGZvciAodmFyIHN0aSA9IDA7IHN0aSA8IHRoaXMuc2VsZWN0ZWRUaWVycy5sZW5ndGg7ICsrc3RpKSB7XG4gICAgICAgIHZhciB0aWVyID0gdGhpcy50aWVyc1t0aGlzLnNlbGVjdGVkVGllcnNbc3RpXV07XG5cdCAgICBzb3VyY2VzLnB1c2goc2hhbGxvd0NvcHkodGllci5kYXNTb3VyY2UpKTtcbiAgICAgICAgdmFyIHNzID0gdGllci5zdHlsZXNoZWV0LnN0eWxlcztcbiAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICAgICAgdmFyIHNoID0gc3Nbc2ldO1xuICAgICAgICAgICAgdmFyIG5zaCA9IHNoYWxsb3dDb3B5KHNoKTtcbiAgICAgICAgICAgIG5zaC5tZXRob2QgPSB0aWVyLmRhc1NvdXJjZS5uYW1lLnJlcGxhY2UoL1soKSsqP10vZywgJ1xcXFwkJicpO1xuICAgICAgICAgICAgbnNoLl9tZXRob2RSRSA9IG51bGw7XG4gICAgICAgICAgICBuc2guc3R5bGUgPSBzaGFsbG93Q29weShzaC5zdHlsZSk7XG4gICAgICAgICAgICBpZiAobnNoLnN0eWxlLlpJTkRFWCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG5zaC5zdHlsZS5aSU5ERVggPSBzdGk7XG5cbiAgICAgICAgICAgIGlmICh0aWVyLmZvcmNlTWluKSB7XG4gICAgICAgICAgICAgICAgbnNoLnN0eWxlLk1JTiA9IHRpZXIuZm9yY2VNaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGllci5mb3JjZU1heCkge1xuICAgICAgICAgICAgICAgIG5zaC5zdHlsZS5NQVggPSB0aWVyLmZvcmNlTWF4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZXMucHVzaChuc2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMuYWRkVGllcihcblx0e25hbWU6ICdNZXJnZWQnLFxuXHQgbWVyZ2U6ICdjb25jYXQnLFxuXHQgb3ZlcmxheTogc291cmNlcyxcblx0IG5vRG93bnNhbXBsZTogdHJ1ZSxcbiAgICAgc3R5bGU6IHN0eWxlc30pO1xuXG4gICAgdGhpcy5zZXRTZWxlY3RlZFRpZXIodGhpcy50aWVycy5sZW5ndGggLSAxKTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyB0aWVyLWVkaXQuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi9jYnJvd3NlcicpO1xuICAgIHZhciBCcm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBtYWtlRWxlbWVudCA9IHV0aWxzLm1ha2VFbGVtZW50O1xuXG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIGlzRGFzQm9vbGVhblRydWUgPSBkYXMuaXNEYXNCb29sZWFuVHJ1ZTtcbiAgICB2YXIgaXNEYXNCb29sZWFuTm90RmFsc2UgPSBkYXMuaXNEYXNCb29sZWFuTm90RmFsc2U7XG4gICAgdmFyIGNvcHlTdHlsZXNoZWV0ID0gZGFzLmNvcHlTdHlsZXNoZWV0O1xuXG4gICAgdmFyIGNvbG9yID0gcmVxdWlyZSgnLi9jb2xvcicpO1xuICAgIHZhciBkYXNDb2xvdXJGb3JOYW1lID0gY29sb3IuZGFzQ29sb3VyRm9yTmFtZTtcblxuICAgIHZhciBzb3VyY2VEYXRhVVJJID0gcmVxdWlyZSgnLi9zb3VyY2Vjb21wYXJlJykuc291cmNlRGF0YVVSSTtcbn1cblxudmFyIF9fZGFsbGlhbmNlX3NtYWxsR2x5cGhzID0ge1xuICAgIERPVDogdHJ1ZSwgXG4gICAgRVg6IHRydWUsIFxuICAgIFNUQVI6IHRydWUsIFxuICAgIFNRVUFSRTogdHJ1ZSwgXG4gICAgQ1JPU1M6IHRydWUsIFxuICAgIFRSSUFOR0xFOiB0cnVlLCBcbiAgICBQTElNU09MTDogdHJ1ZVxufTtcblxuQnJvd3Nlci5wcm90b3R5cGUub3BlblRpZXJQYW5lbCA9IGZ1bmN0aW9uKHRpZXIpIHtcbiAgICB2YXIgYiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy51aU1vZGUgPT09ICd0aWVyJyAmJiB0aGlzLm1hbmlwdWxhdGluZ1RpZXIgPT09IHRpZXIpIHtcbiAgICAgICAgdGhpcy5oaWRlVG9vbFBhbmVsKCk7XG4gICAgICAgIHRoaXMuc2V0VWlNb2RlKCdub25lJyk7XG4gICAgfSBlbHNlIGlmICghdGllcikge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNldFN0eWxlQ29sb3JzID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZS5CR0dSQUQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAobnVtQ29sb3JzID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuZ2x5cGggPT0gJ0xJTkVQTE9UJyB8fCBfX2RhbGxpYW5jZV9zbWFsbEdseXBoc1tzdHlsZS5nbHlwaF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuRkdDT0xPUiA9IHRpZXJDb2xvckZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLkJHQ09MT1IgPSB0aWVyQ29sb3JGaWVsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3R5bGUuQ09MT1IxID0gc3R5bGUuQ09MT1IyID0gc3R5bGUuQ09MT1IzID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuQ09MT1IxID0gdGllckNvbG9yRmllbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgc3R5bGUuQ09MT1IyID0gdGllckNvbG9yRmllbGQyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChudW1Db2xvcnMgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLkNPTE9SMyA9IHRpZXJDb2xvckZpZWxkMy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5DT0xPUjMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlLl9ncmFkaWVudCA9IG51bGw7XG4gICAgICAgICAgICBzdHlsZS5fcGx1c0NvbG9yID0gdGllclBsdXNDb2xvckZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgc3R5bGUuX21pbnVzQ29sb3IgPSB0aWVyTWludXNDb2xvckZpZWxkLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG11dGF0ZVN0eWxlc2hlZXQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgICAgICB2YXIgbnNzID0gY29weVN0eWxlc2hlZXQodGllci5zdHlsZXNoZWV0KTtcbiAgICAgICAgICAgIHZhciBzc1NjYWxlID0gdGllci5icm93c2VyLnpvb21Gb3JDdXJyZW50U2NhbGUoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuc3Muc3R5bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoID0gbnNzLnN0eWxlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2guem9vbSAmJiBzaC56b29tICE9IHNzU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmlzaXRvcihzaC5zdHlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhbmdlQ29sb3IgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdGllci5tZXJnZVN0eWxlc2hlZXQobXV0YXRlU3R5bGVzaGVldChzZXRTdHlsZUNvbG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLm1hbmlwdWxhdGluZ1RpZXIgPSB0aWVyO1xuXG4gICAgICAgIHZhciB0aWVyRm9ybSA9IG1ha2VFbGVtZW50KCdkaXYnLCBudWxsLCB7Y2xhc3NOYW1lOiAndGllci1lZGl0J30pO1xuXG4gICAgICAgIHZhciBhYm91dEJhbm5lciA9IG1ha2VFbGVtZW50KCdkaXYnLCBcIkFib3V0ICdcIiArICh0aWVyLmNvbmZpZy5OYW1lIHx8IHRpZXIuZGFzU291cmNlLm5hbWUpICsgXCInXCIsIG51bGwsXG4gICAgICAgICAgICAgICAge2JhY2tncm91bmQ6ICdncmF5JywgcGFkZGluZ0JvdHRvbTogJzVweCcsIG1hcmdpbkJvdHRvbTogJzVweCcsIHRleHRBbGlnbjogJ2NlbnRlcid9KTtcbiAgICAgICAgdGllckZvcm0uYXBwZW5kQ2hpbGQoYWJvdXRCYW5uZXIpO1xuXG4gICAgICAgIHZhciBhYm91dCA9IG1ha2VFbGVtZW50KCdkaXYnLCBcbiAgICAgICAgICAgIFttYWtlRWxlbWVudCgncCcsIHRpZXIuZGFzU291cmNlLmRlc2MpXVxuICAgICAgICApO1xuICAgICAgICB2YXIgYWJvdXROb3RlcyA9IFtdO1xuICAgICAgICB2YXIgc2R1cmkgPSBzb3VyY2VEYXRhVVJJKHRpZXIuZGFzU291cmNlKTtcbiAgICAgICAgaWYgKHNkdXJpICYmXG4gICAgICAgICAgICAoc2R1cmkuaW5kZXhPZignaHR0cDovLycpID09IDAgfHxcbiAgICAgICAgICAgICBzZHVyaS5pbmRleE9mKCdodHRwczovLycpID09IDAgfHxcbiAgICAgICAgICAgICBzZHVyaS5pbmRleE9mKCcvLycpID09IDApICYmXG4gICAgICAgICAgICBzZHVyaSAhPT0gJ2h0dHBzOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvbWFnaWMvbm9fdXJpJylcbiAgICAgICAge1xuICAgICAgICAgICAgYWJvdXROb3Rlcy5wdXNoKG1ha2VFbGVtZW50KCdsaScsIG1ha2VFbGVtZW50KCdhJywgJyhEb3dubG9hZCBkYXRhKScsIHtocmVmOiBzZHVyaX0pKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGllci5kYXNTb3VyY2UubWFwcGluZykge1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuY2hhaW5zW3RpZXIuZGFzU291cmNlLm1hcHBpbmddLmNvb3JkcztcbiAgICAgICAgICAgIGFib3V0Tm90ZXMucHVzaChtYWtlRWxlbWVudCgnbGknLCAgJ01hcHBlZCBmcm9tICcgKyBjb29yZHMuYXV0aCArIGNvb3Jkcy52ZXJzaW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWJvdXROb3Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhYm91dC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgndWwnLCBhYm91dE5vdGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRpZXJGb3JtLmFwcGVuZENoaWxkKGFib3V0KTtcblxuICAgICAgICB2YXIgc2VtYW50aWNCYW5uZXIgPSBtYWtlRWxlbWVudCgnc3BhbicsICcgKHN0eWxlcyBmb3IgY3VycmVudCB6b29tIGxldmVsKScsIG51bGwsIHtkaXNwbGF5OiAnbm9uZSd9KTtcbiAgICAgICAgdmFyIGVkaXRCYW5uZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgWydFZGl0Jywgc2VtYW50aWNCYW5uZXJdLCBudWxsLFxuICAgICAgICAgICAgICB7YmFja2dyb3VuZDogJ2dyYXknLCBwYWRkaW5nQm90dG9tOiAnNXB4JywgbWFyZ2luQm90dG9tOiAnNXB4JywgdGV4dEFsaWduOiAnY2VudGVyJ30pO1xuICAgICAgICB0aWVyRm9ybS5hcHBlbmRDaGlsZChlZGl0QmFubmVyKTtcblxuICAgICAgICB2YXIgdGllck5hbWVGaWVsZCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCd9KTtcbiAgICAgICAgdmFyIHRpZXJQaW5uZWRUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94JywgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZVBpbm5pbmd9KTtcblxuICAgICAgICB2YXIgZ2x5cGhGaWVsZCA9IG1ha2VFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgZ2x5cGhGaWVsZC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnb3B0aW9uJywgJ0hpc3RvZ3JhbScsIHt2YWx1ZTogJ0hJU1RPR1JBTSd9KSk7XG4gICAgICAgIGdseXBoRmllbGQuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsICdMaW5lIFBsb3QnLCB7dmFsdWU6ICdMSU5FUExPVCd9KSk7XG4gICAgICAgIGdseXBoRmllbGQuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsICdSaWJib24nLCB7dmFsdWU6ICdHUkFESUVOVCd9KSk7XG4gICAgICAgIGdseXBoRmllbGQuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsICdTY2F0dGVyJywge3ZhbHVlOiAnU0NBVFRFUid9KSk7XG5cbiAgICAgICAgdmFyIHRpZXJDb2xvckZpZWxkID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcjZGQwMGRkJ30pO1xuICAgICAgICB2YXIgdGllckNvbG9yRmllbGQyID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcjZGQwMGRkJ30pO1xuICAgICAgICB2YXIgdGllckNvbG9yRmllbGQzID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcjZGQwMGRkJ30pO1xuXG4gICAgICAgIHZhciB0aWVyUGx1c0NvbG9yRmllbGQgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ3RleHQnLCB2YWx1ZTogJyNmZmEwN2EnfSk7XG4gICAgICAgIHZhciB0aWVyTWludXNDb2xvckZpZWxkID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcjODdjZWZhJ30pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aWVyQ29sb3JGaWVsZC50eXBlID0gdGllckNvbG9yRmllbGQyLnR5cGUgPSB0aWVyQ29sb3JGaWVsZDMudHlwZSA9ICdjb2xvcic7XG4gICAgICAgICAgICB0aWVyUGx1c0NvbG9yRmllbGQudHlwZSA9IHRpZXJNaW51c0NvbG9yRmllbGQudHlwZSA9ICdjb2xvcic7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElFIHRocm93cyBpZiBhdHRlbXB0IHRvIHNldCB0eXBlIHRvICdjb2xvcicuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGllckNvbG9yRmllbGRzID0gW3RpZXJDb2xvckZpZWxkLCB0aWVyQ29sb3JGaWVsZDIsIHRpZXJDb2xvckZpZWxkM107XG4gICAgICAgIHZhciBjb2xvckxpc3RQbHVzID0gbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtcGx1cy1jaXJjbGUnfSk7XG4gICAgICAgIHZhciBjb2xvckxpc3RNaW51cyA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLW1pbnVzLWNpcmNsZSd9KTtcbiAgICAgICAgdmFyIG51bUNvbG9ycyA9IDE7XG4gICAgICAgIHZhciBjb2xvckxpc3RFbGVtZW50ID0gbWFrZUVsZW1lbnQoJ3RkJywgdGllckNvbG9yRmllbGRzKTtcbiAgICAgICAgdmFyIHNldE51bUNvbG9ycyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIG51bUNvbG9ycyA9IG47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgXG4gICAgICAgICAgICAgICAgdGllckNvbG9yRmllbGRzW2ldLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPCB0aWVyQ29sb3JGaWVsZHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGllckNvbG9yRmllbGRzW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3JMaXN0UGx1cy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBpZiAobnVtQ29sb3JzIDwgMykge1xuICAgICAgICAgICAgICAgIHNldE51bUNvbG9ycyhudW1Db2xvcnMgKyAxKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDb2xvcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBjb2xvckxpc3RNaW51cy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICAgICAgICAgIHNldE51bUNvbG9ycyhudW1Db2xvcnMgLSAxKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDb2xvcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIHZhciB0aWVyTWluRmllbGQgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ3RleHQnLCB2YWx1ZTogJzAuMCd9KTtcbiAgICAgICAgdmFyIHRpZXJNYXhGaWVsZCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnMTAuMCd9KTtcbiAgICAgICAgdmFyIHRpZXJNaW5Ub2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94J30pO1xuICAgICAgICB2YXIgdGllck1heFRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnfSk7XG5cbiAgICAgICAgdmFyIHF1YW50TGVhcFRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiB0aWVyLnF1YW50TGVhcFRocmVzaG9sZCAhPT0gdW5kZWZpbmVkfSk7XG4gICAgICAgIHZhciBxdWFudExlYXBUaHJlc2hGaWVsZCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiB0aWVyLnF1YW50TGVhcFRocmVzaG9sZCwgZGlzYWJsZWQ6ICFxdWFudExlYXBUb2dnbGUuY2hlY2tlZH0pO1xuXG4gICAgICAgIHZhciB0aWVySGVpZ2h0RmllbGQgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ3RleHQnLCB2YWx1ZTogJzUwJ30pO1xuXG4gICAgICAgIHZhciBidW1wVG9nZ2xlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdjaGVja2JveCd9KTtcbiAgICAgICAgdmFyIGJ1bXBMaW1pdCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCd9KTtcbiAgICAgICAgdmFyIGxhYmVsVG9nZ2xlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdjaGVja2JveCd9KTtcblxuICAgICAgICB2YXIgbWFpblN0eWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHRpZXIuc3R5bGVzaGVldC5zdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHMgPSBtYWluU3R5bGUgPSB0aWVyLnN0eWxlc2hlZXQuc3R5bGVzWzBdLnN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGllci5jb25maWcubmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGllck5hbWVGaWVsZC52YWx1ZSA9IHRpZXIuY29uZmlnLm5hbWU7XG4gICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIHRpZXJOYW1lRmllbGQudmFsdWUgPSB0aWVyLmRhc1NvdXJjZS5uYW1lO1xuXG4gICAgICAgICAgICB0aWVyUGlubmVkVG9nZ2xlLmNoZWNrZWQgPSB0aWVyLnBpbm5lZDtcblxuICAgICAgICAgICAgaWYgKHRpZXIuZm9yY2VIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aWVySGVpZ2h0RmllbGQudmFsdWUgPSAnJyArIHRpZXIuZm9yY2VIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1haW5TdHlsZSAmJiBtYWluU3R5bGUuSEVJR0hUKSB7XG4gICAgICAgICAgICAgICAgdGllckhlaWdodEZpZWxkLnZhbHVlID0gJycgKyBtYWluU3R5bGUuSEVJR0hUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpZXIucXVhbnRMZWFwVGhyZXNob2xkID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcXVhbnRMZWFwVG9nZ2xlLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHF1YW50TGVhcFRocmVzaEZpZWxkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQocXVhbnRMZWFwVGhyZXNoRmllbGQudmFsdWUpICE9IHRpZXIucXVhbnRMZWFwVGhyZXNob2xkKVxuICAgICAgICAgICAgICAgICAgICBxdWFudExlYXBUaHJlc2hGaWVsZC52YWx1ZSA9IHRpZXIucXVhbnRMZWFwVGhyZXNob2xkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWFudExlYXBUb2dnbGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHF1YW50TGVhcFRocmVzaEZpZWxkLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aWVyLnN1YnRpZXJNYXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBidW1wTGltaXQudmFsdWUgPSAnJyArIHRpZXIuc3VidGllck1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVtcExpbWl0LnZhbHVlID0gJycgKyAodGllci5kYXNTb3VyY2Uuc3VidGllck1heCB8fCB0aWVyLmJyb3dzZXIuZGVmYXVsdFN1YnRpZXJNYXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGllci5zdHlsZXNoZWV0LnN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBpc1F1YW50aXRhdGl2ZT1mYWxzZSwgaXNTaW1wbGVRdWFudGl0YXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgc3NTY2FsZSA9IHRpZXIuYnJvd3Nlci56b29tRm9yQ3VycmVudFNjYWxlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZVN0eWxlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHRpZXIuc3R5bGVzaGVldC5zdHlsZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaCA9IHRpZXIuc3R5bGVzaGVldC5zdHlsZXNbc2ldOyAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaC56b29tICYmIHNoLnpvb20gIT0gc3NTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKythY3RpdmVTdHlsZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3MgPSB0aWVyLnN0eWxlc2hlZXQuc3R5bGVzW3NpXS5zdHlsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBtYWluU3R5bGUgPSBzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNzLmdseXBoID09ICdMSU5FUExPVCcgfHwgc3MuZ2x5cGggPT0gJ0hJU1RPR1JBTScgfHwgc3MuZ2x5cGggPT0gJ0dSQURJRU5UJyB8fCBpc0Rhc0Jvb2xlYW5UcnVlKHNzLlNDQVRURVIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVhbnRpdGF0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBtYWluU3R5bGUgPSBzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUXVhbnRpdGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbWFudGljQmFubmVyLnN0eWxlLmRpc3BsYXkgPSAoYWN0aXZlU3R5bGVDb3VudCA9PSB0aWVyLnN0eWxlc2hlZXQuc3R5bGVzLmxlbmd0aCkgPyAnbm9uZScgOiAnaW5saW5lJztcblxuICAgICAgICAgICAgICAgIGlzU2ltcGxlUXVhbnRpdGF0aXZlID0gaXNRdWFudGl0YXRpdmUgJiYgYWN0aXZlU3R5bGVDb3VudCA9PSAxO1xuICAgICAgICAgICAgICAgIHZhciBpc0dyYWRpZW50ID0gcy5DT0xPUjIgfHwgcy5CR0dSQUQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNRdWFudGl0YXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluUm93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgbWF4Um93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgYnVtcFJvdy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFJvdy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblJvdy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBtYXhSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgYnVtcFJvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgICAgIGJ1bXBUb2dnbGUuY2hlY2tlZCA9IGlzRGFzQm9vbGVhblRydWUobWFpblN0eWxlLkJVTVApO1xuICAgICAgICAgICAgICAgICAgICBidW1wTGltaXQuZGlzYWJsZWQgPSAhaXNEYXNCb29sZWFuVHJ1ZShtYWluU3R5bGUuQlVNUCk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsUm93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxUb2dnbGUuY2hlY2tlZCA9IGlzRGFzQm9vbGVhblRydWUobWFpblN0eWxlLkxBQkVMKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaW1wbGVRdWFudGl0YXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVSb3cuc3R5bGUuZGlzcGxheSA9ICd0YWJsZS1yb3cnO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclJvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBudW1Db2xvcnMgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChzLkNPTE9SMSkge1xuICAgICAgICAgICAgICAgICAgICB0aWVyQ29sb3JGaWVsZC52YWx1ZSA9IGRhc0NvbG91ckZvck5hbWUocy5DT0xPUjEpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLkNPTE9SMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGllckNvbG9yRmllbGQyLnZhbHVlID0gZGFzQ29sb3VyRm9yTmFtZShzLkNPTE9SMikudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLkNPTE9SMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZXJDb2xvckZpZWxkMy52YWx1ZSA9IGRhc0NvbG91ckZvck5hbWUocy5DT0xPUjMpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtQ29sb3JzID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtQ29sb3JzID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmdseXBoID09ICdMSU5FUExPVCcgfHwgcy5nbHlwaCA9PSAnRE9UJyAmJiBzLkZHQ09MT1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpZXJDb2xvckZpZWxkLnZhbHVlID0gZGFzQ29sb3VyRm9yTmFtZShzLkZHQ09MT1IpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocy5CR0NPTE9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWVyQ29sb3JGaWVsZC52YWx1ZSA9IGRhc0NvbG91ckZvck5hbWUocy5CR0NPTE9SKS50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBzZXROdW1Db2xvcnMobnVtQ29sb3JzKTtcblxuICAgICAgICAgICAgICAgIGlmIChzLl9wbHVzQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIHRpZXJQbHVzQ29sb3JGaWVsZC52YWx1ZSA9IGRhc0NvbG91ckZvck5hbWUocy5fcGx1c0NvbG9yKS50b0hleFN0cmluZygpIHx8IHMuX3BsdXNDb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAocy5fbWludXNDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgdGllck1pbnVzQ29sb3JGaWVsZC52YWx1ZSA9IGRhc0NvbG91ckZvck5hbWUocy5fbWludXNDb2xvcikudG9IZXhTdHJpbmcoKSB8fCBzLl9taW51c0NvbG9yO1xuICAgICAgICAgICAgICAgIGlmIChpc0Rhc0Jvb2xlYW5UcnVlKHMuU0NBVFRFUikpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhGaWVsZC52YWx1ZSA9ICdTQ0FUVEVSJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEZpZWxkLnZhbHVlID0gcy5nbHlwaDtcbiAgICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgICAgdmFyIHNldE1pblZhbHVlLCBzZXRNYXhWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocy5NSU4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQocy5NSU4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWluVmFsdWUgPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRpZXIuZm9yY2VNaW5EeW5hbWljICYmIChzLk1JTiAhPT0gdW5kZWZpbmVkIHx8IHRpZXIuZm9yY2VNaW4gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllck1pblRvZ2dsZS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGllck1pbkZpZWxkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGllck1pblRvZ2dsZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNaW5GaWVsZC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHMuTUFYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KHMuTUFYKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF4VmFsdWUgPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRpZXIuZm9yY2VNYXhEeW5hbWljICYmIChzLk1BWCAhPT0gdW5kZWZpbmVkIHx8IHRpZXIuZm9yY2VNYXggIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllck1heFRvZ2dsZS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGllck1heEZpZWxkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGllck1heFRvZ2dsZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNYXhGaWVsZC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRpZXIuZm9yY2VNaW4gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE1pblZhbHVlID0gdGllci5mb3JjZU1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpZXIuZm9yY2VNYXggIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE1heFZhbHVlID0gdGllci5mb3JjZU1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzZXRNaW5WYWx1ZSkgPT0gJ251bWJlcicgJiYgc2V0TWluVmFsdWUgIT0gcGFyc2VGbG9hdCh0aWVyTWluRmllbGQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNaW5GaWVsZC52YWx1ZSA9IHNldE1pblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHNldE1heFZhbHVlKSA9PSAnbnVtYmVyJyAmJiBzZXRNYXhWYWx1ZSAhPSBwYXJzZUZsb2F0KHRpZXJNYXhGaWVsZC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllck1heEZpZWxkLnZhbHVlID0gc2V0TWF4VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNlcVN0eWxlID0gZ2V0U2VxU3R5bGUodGllci5zdHlsZXNoZWV0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VxU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxTWlzbWF0Y2hSb3cuc3R5bGUuZGlzcGxheSA9ICd0YWJsZS1yb3cnO1xuICAgICAgICAgICAgICAgICAgICBzZXFNaXNtYXRjaFRvZ2dsZS5jaGVja2VkID0gKHNlcVN0eWxlLl9fU0VRQ09MT1IgPT09ICdtaXNtYXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICBzZXFJbnNlcnRSb3cuc3R5bGUuZGlzcGxheSA9ICd0YWJsZS1yb3cnO1xuICAgICAgICAgICAgICAgICAgICBzZXFJbnNlcnRUb2dnbGUuY2hlY2tlZCA9ICBpc0Rhc0Jvb2xlYW5UcnVlKHNlcVN0eWxlLl9fSU5TRVJUSU9OUyk7XG4gICAgICAgICAgICAgICAgICAgIHNlcUlnbm9yZVF1YWxzUm93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgc2VxSWdub3JlUXVhbHNUb2dnbGUuY2hlY2tlZCA9IChzZXFTdHlsZS5fX2Rpc2FibGVRdWFscyA9PT0gdW5kZWZpbmVkIHx8IHNlcVN0eWxlLl9fZGlzYWJsZVF1YWxzID09PSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNlcVN0eWxlLl9fZGlzYWJsZVF1YWxzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXFNaXNtYXRjaFJvdy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBzZXFJbnNlcnRSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgc2VxSWdub3JlUXVhbHNSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VxU3R5bGUgJiYgc2VxTWlzbWF0Y2hUb2dnbGUuY2hlY2tlZCAmJiAhaXNTaW1wbGVRdWFudGl0YXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1c1N0cmFuZENvbG9yUm93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgbWludXNTdHJhbmRDb2xvclJvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1c1N0cmFuZENvbG9yUm93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIG1pbnVzU3RyYW5kQ29sb3JSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1F1YW50aXRhdGl2ZSAmJiB0aWVyLmJyb3dzZXIuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdxdWFudExlYXAnKSlcbiAgICAgICAgICAgICAgICBxdWFudExlYXBSb3cuc3R5bGUuZGlzcGxheSA9ICd0YWJsZS1yb3cnO1xuICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICBxdWFudExlYXBSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXFNaXNtYXRjaFRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnfSk7XG4gICAgICAgIHZhciBzZXFNaXNtYXRjaFJvdyA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0hpZ2hsaWdodCBtaXNtYXRjaGVzICYgc3RyYW5kcycpLFxuICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIHNlcU1pc21hdGNoVG9nZ2xlKV0pO1xuICAgICAgICBzZXFNaXNtYXRjaFRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIG5zcyA9IGNvcHlTdHlsZXNoZWV0KHRpZXIuc3R5bGVzaGVldCk7XG4gICAgICAgICAgICB2YXIgc2VxU3R5bGUgPSBnZXRTZXFTdHlsZShuc3MpO1xuICAgICAgICAgICAgc2VxU3R5bGUuX19TRVFDT0xPUiA9IHNlcU1pc21hdGNoVG9nZ2xlLmNoZWNrZWQgPyAnbWlzbWF0Y2gnIDogJ2Jhc2UnO1xuICAgICAgICAgICAgdGllci5tZXJnZVN0eWxlc2hlZXQobnNzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNlcUluc2VydFRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnfSk7XG4gICAgICAgIHZhciBzZXFJbnNlcnRSb3cgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdTaG93IGluc2VydGlvbnMnKSxcbiAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBzZXFJbnNlcnRUb2dnbGUpXSk7XG4gICAgICAgIHNlcUluc2VydFRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIG5zcyA9IGNvcHlTdHlsZXNoZWV0KHRpZXIuc3R5bGVzaGVldCk7XG4gICAgICAgICAgICB2YXIgc2VxU3R5bGUgPSBnZXRTZXFTdHlsZShuc3MpO1xuICAgICAgICAgICAgc2VxU3R5bGUuX19JTlNFUlRJT05TID0gc2VxSW5zZXJ0VG9nZ2xlLmNoZWNrZWQgPyAneWVzJyA6ICdubyc7XG4gICAgICAgICAgICB0aWVyLm1lcmdlU3R5bGVzaGVldChuc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VxSWdub3JlUXVhbHNUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94J30pO1xuICAgICAgICB2YXIgc2VxSWdub3JlUXVhbHNSb3cgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdSZWZsZWN0IGJhc2UgcXVhbGl0eSBhcyBiYXNlIGNvbG9yIHRyYW5zcGFyZW5jeScpLFxuICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIHNlcUlnbm9yZVF1YWxzVG9nZ2xlKV0pO1xuICAgICAgICBzZXFJZ25vcmVRdWFsc1RvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIG5zcyA9IGNvcHlTdHlsZXNoZWV0KHRpZXIuc3R5bGVzaGVldCk7XG4gICAgICAgICAgICB2YXIgc2VxU3R5bGUgPSBnZXRTZXFTdHlsZShuc3MpO1xuICAgICAgICAgICAgc2VxU3R5bGUuX19kaXNhYmxlUXVhbHMgPSAhc2VxSWdub3JlUXVhbHNUb2dnbGUuY2hlY2tlZDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHNlcVN0eWxlLl9fZGlzYWJsZVF1YWxzKTtcbiAgICAgICAgICAgIHRpZXIubWVyZ2VTdHlsZXNoZWV0KG5zcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdHlsZVJvdyA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdTdHlsZScpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBnbHlwaEZpZWxkKV0pO1xuICAgICAgICB2YXIgY29sb3JSb3cgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgICAgIFttYWtlRWxlbWVudCgndGgnLCBbJ0NvbG91cihzKScsIGNvbG9yTGlzdFBsdXMsIGNvbG9yTGlzdE1pbnVzXSksXG4gICAgICAgICAgICAgICAgIGNvbG9yTGlzdEVsZW1lbnRdKTtcbiAgICAgICAgdmFyIHBsdXNTdHJhbmRDb2xvclJvdyA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdQbHVzIFN0cmFuZCBDb2xvcicpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCB0aWVyUGx1c0NvbG9yRmllbGQpXSk7XG4gICAgICAgIHZhciBtaW51c1N0cmFuZENvbG9yUm93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ01pbnVzIFN0cmFuZCBDb2xvcicpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCB0aWVyTWludXNDb2xvckZpZWxkKV0pO1xuICAgICAgICB2YXIgbWluUm93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ01pbiB2YWx1ZScpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBbdGllck1pblRvZ2dsZSwgJyAnLCB0aWVyTWluRmllbGRdKV0pO1xuICAgICAgICB2YXIgbWF4Um93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ01heCB2YWx1ZScpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBbdGllck1heFRvZ2dsZSwgJyAnLCB0aWVyTWF4RmllbGRdKV0pO1xuICAgICAgICB2YXIgcXVhbnRMZWFwUm93ID0gXG4gICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ1RocmVzaG9sZCBsZWFwOicpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBbcXVhbnRMZWFwVG9nZ2xlLCAnICcsIHF1YW50TGVhcFRocmVzaEZpZWxkXSldKTtcbiAgICAgICAgdmFyIGJ1bXBSb3cgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgICAgIFttYWtlRWxlbWVudCgndGgnLCAnQnVtcCBvdmVybGFwcycpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBbYnVtcFRvZ2dsZSwgJyBsaW1pdDogJywgYnVtcExpbWl0XSldKTtcbiAgICAgICAgdmFyIGxhYmVsUm93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0xhYmVsIGZlYXR1cmVzJyksXG4gICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIGxhYmVsVG9nZ2xlKV0pO1xuXG5cbiAgICAgICAgdmFyIHRpZXJUYWJsZSA9IG1ha2VFbGVtZW50KCd0YWJsZScsXG4gICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ05hbWUnLCB7fSwge3dpZHRoOiAnMTUwcHgnLCB0ZXh0QWxpZ246ICdyaWdodCd9KSxcbiAgICAgICAgICAgICAgICAgdGllck5hbWVGaWVsZF0pLFxuXG4gICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ1BpbiB0byB0b3AnKSxcbiAgICAgICAgICAgICAgICAgdGllclBpbm5lZFRvZ2dsZV0pLFxuXG4gICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0hlaWdodCcpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCB0aWVySGVpZ2h0RmllbGQpXSksXG5cbiAgICAgICAgICAgIHN0eWxlUm93LFxuICAgICAgICAgICAgY29sb3JSb3csXG4gICAgICAgICAgICBwbHVzU3RyYW5kQ29sb3JSb3csXG4gICAgICAgICAgICBtaW51c1N0cmFuZENvbG9yUm93LFxuICAgICAgICAgICAgbWluUm93LFxuICAgICAgICAgICAgbWF4Um93LFxuICAgICAgICAgICAgcXVhbnRMZWFwUm93LFxuICAgICAgICAgICAgYnVtcFJvdyxcbiAgICAgICAgICAgIGxhYmVsUm93LFxuICAgICAgICAgICAgc2VxTWlzbWF0Y2hSb3csXG4gICAgICAgICAgICBzZXFJbnNlcnRSb3csXG4gICAgICAgICAgICBzZXFJZ25vcmVRdWFsc1Jvd1xuICAgICAgICAgICAgIF0pO1xuXG5cbiAgICAgICAgcmVmcmVzaCgpO1xuXG4gICAgICAgIHRpZXJGb3JtLmFwcGVuZENoaWxkKHRpZXJUYWJsZSk7XG5cbiAgICAgICAgdmFyIHJlc2V0QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2J1dHRvbicsICdSZXNldCB0cmFjaycsIHtjbGFzc05hbWU6ICdidG4nfSwge21hcmdpbkxlZnQ6ICdhdXRvJywgbWFyZ2luUmlnaHQ6ICdhdXRvJywgZGlzcGxheTogJ2Jsb2NrJ30pO1xuICAgICAgICByZXNldEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB0aWVyLnNldENvbmZpZyh7fSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgdGllckZvcm0uYXBwZW5kQ2hpbGQocmVzZXRCdXR0b24pO1xuXG4gICAgICAgIHRpZXJOYW1lRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyh7bmFtZTogdGllck5hbWVGaWVsZC52YWx1ZX0pO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgdGllclBpbm5lZFRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyh7cGlubmVkOiB0aWVyUGlubmVkVG9nZ2xlLmNoZWNrZWR9KTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCB0aWVyQ29sb3JGaWVsZHMubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgICAgICB0aWVyQ29sb3JGaWVsZHNbY2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUNvbG9yLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aWVyUGx1c0NvbG9yRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlQ29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGllck1pbnVzQ29sb3JGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VDb2xvciwgZmFsc2UpO1xuXG4gICAgICAgIGdseXBoRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBuc3MgPSBtdXRhdGVTdHlsZXNoZWV0KGZ1bmN0aW9uKHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoRmllbGQudmFsdWUgPT09ICdTQ0FUVEVSJykge1xuICAgICAgICAgICAgICAgICAgICB0cy5TQ0FUVEVSID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdHMuZ2x5cGggPSAnRE9UJztcbiAgICAgICAgICAgICAgICAgICAgdHMuU0laRSA9ICczJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cy5nbHlwaCA9IGdseXBoRmllbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRzLlNDQVRURVIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFN0eWxlQ29sb3JzKHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGllci5tZXJnZVN0eWxlc2hlZXQobnNzKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIHRpZXJNaW5Ub2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBjb25mID0ge2ZvcmNlTWluRHluYW1pYzogIXRpZXJNaW5Ub2dnbGUuY2hlY2tlZH07XG4gICAgICAgICAgICB0aWVyTWluRmllbGQuZGlzYWJsZWQgPSAhdGllck1pblRvZ2dsZS5jaGVja2VkO1xuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KHRpZXJNaW5GaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGllck1pblRvZ2dsZS5jaGVja2VkICYmIHR5cGVvZih4KSA9PSAnbnVtYmVyJyAmJiAhaXNOYU4oeCkpXG4gICAgICAgICAgICAgICAgY29uZi5mb3JjZU1pbiA9IHBhcnNlRmxvYXQoeCk7XG4gICAgICAgICAgICB0aWVyLm1lcmdlQ29uZmlnKGNvbmYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGllck1pbkZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdCh0aWVyTWluRmllbGQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZih4KSA9PSAnbnVtYmVyJyAmJiAhaXNOYU4oeCkpXG4gICAgICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyh7Zm9yY2VNaW46IHh9KTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIHRpZXJNYXhUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBjb25mID0ge2ZvcmNlTWF4RHluYW1pYzogIXRpZXJNYXhUb2dnbGUuY2hlY2tlZH07XG4gICAgICAgICAgICB0aWVyTWF4RmllbGQuZGlzYWJsZWQgPSAhdGllck1heFRvZ2dsZS5jaGVja2VkO1xuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KHRpZXJNYXhGaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGllck1heFRvZ2dsZS5jaGVja2VkICYmIHR5cGVvZih4KSA9PSAnbnVtYmVyJyAmJiAhaXNOYU4oeCkpXG4gICAgICAgICAgICAgICAgY29uZi5mb3JjZU1heCA9IHBhcnNlRmxvYXQoeCk7XG4gICAgICAgICAgICB0aWVyLm1lcmdlQ29uZmlnKGNvbmYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGllck1heEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdCh0aWVyTWF4RmllbGQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZih4KSA9PSAnbnVtYmVyJyAmJiAhaXNOYU4oeCkpXG4gICAgICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyh7Zm9yY2VNYXg6IHh9KTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIHRpZXJIZWlnaHRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQodGllckhlaWdodEZpZWxkLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoeCkgPT0gJ251bWJlcicgJiYgIWlzTmFOKHgpKVxuICAgICAgICAgICAgICAgIHRpZXIubWVyZ2VDb25maWcoe2hlaWdodDogTWF0aC5taW4oNTAwLCB4fDApfSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB2YXIgdXBkYXRlUXVhbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHF1YW50TGVhcFRocmVzaEZpZWxkLmRpc2FibGVkID0gIXF1YW50TGVhcFRvZ2dsZS5jaGVja2VkO1xuICAgICAgICAgICAgaWYgKHF1YW50TGVhcFRvZ2dsZS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KHF1YW50TGVhcFRocmVzaEZpZWxkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHgpID09ICdudW1iZXInICYmICFpc05hTih4KSkge1xuICAgICAgICAgICAgICAgICAgICB0aWVyLm1lcmdlQ29uZmlnKHtxdWFudExlYXBUaHJlc2hvbGQ6IHBhcnNlRmxvYXQocXVhbnRMZWFwVGhyZXNoRmllbGQudmFsdWUpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aWVyLm1lcmdlQ29uZmlnKHtxdWFudExlYXBUaHJlc2hvbGQ6IG51bGx9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWFudExlYXBUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHVwZGF0ZVF1YW50KCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgcXVhbnRMZWFwVGhyZXNoRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdXBkYXRlUXVhbnQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGxhYmVsVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgbnNzID0gbXV0YXRlU3R5bGVzaGVldChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLkxBQkVMID0gbGFiZWxUb2dnbGUuY2hlY2tlZCA/ICd5ZXMnIDogJ25vJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGllci5tZXJnZVN0eWxlc2hlZXQobnNzKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBidW1wVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgbnNzID0gbXV0YXRlU3R5bGVzaGVldChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLkJVTVAgPSBidW1wVG9nZ2xlLmNoZWNrZWQgPyAneWVzJyA6ICdubyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpZXIubWVyZ2VTdHlsZXNoZWV0KG5zcyk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgYnVtcExpbWl0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQoYnVtcExpbWl0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoeCkgPT0gJ251bWJlcicgJiYgeCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aWVyLm1lcmdlQ29uZmlnKHtzdWJ0aWVyTWF4OiB4fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcblxuXG4gICAgICAgIHRoaXMuc2hvd1Rvb2xQYW5lbCh0aWVyRm9ybSk7XG4gICAgICAgIHRoaXMuc2V0VWlNb2RlKCd0aWVyJyk7XG5cbiAgICAgICAgdGllci5hZGRUaWVyTGlzdGVuZXIocmVmcmVzaCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTY2FsZSA9IHRpZXIuYnJvd3Nlci5zY2FsZTtcbiAgICAgICAgdGllci5icm93c2VyLmFkZFZpZXdMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aWVyLmJyb3dzZXIuc2NhbGUgIT0gY3VycmVudFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNjYWxlID0gdGllci5icm93c2VyLnNjYWxlO1xuICAgICAgICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXFTdHlsZShzdHlsZXNoZWV0KSB7XG4gICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHN0eWxlc2hlZXQuc3R5bGVzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgc3MgPSBzdHlsZXNoZWV0LnN0eWxlc1tzaV0uc3R5bGU7XG4gICAgICAgIGlmIChzcy5nbHlwaCA9PT0gJ19fU0VRVUVOQ0UnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyB0aWVyLmpzOiAodHJ5KSB0byBlbmNhcHN1bGF0ZSB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhIGJyb3dzZXIgdGllci5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbiAgICB2YXIgcmVtb3ZlQ2hpbGRyZW4gPSB1dGlscy5yZW1vdmVDaGlsZHJlbjtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcbiAgICB2YXIgcHVzaG5ldyA9IHV0aWxzLnB1c2huZXc7XG4gICAgdmFyIG1pbmlKU09OaWZ5ID0gdXRpbHMubWluaUpTT05pZnk7XG4gICAgdmFyIGFycmF5SW5kZXhPZiA9IHV0aWxzLmFycmF5SW5kZXhPZjtcblxuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNTdHlsZXNoZWV0ID0gZGFzLkRBU1N0eWxlc2hlZXQ7XG4gICAgdmFyIERBU1N0eWxlID0gZGFzLkRBU1N0eWxlO1xuXG4gICAgdmFyIHNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKTtcbiAgICB2YXIgYjY0X3NoYTEgPSBzaGExLmI2NF9zaGExO1xuXG4gICAgdmFyIHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuICAgIHZhciBTdHlsZUZpbHRlciA9IHN0eWxlLlN0eWxlRmlsdGVyO1xuICAgIHZhciBTdHlsZUZpbHRlclNldCA9IHN0eWxlLlN0eWxlRmlsdGVyU2V0O1xuXG4gICAgdmFyIHNjID0gcmVxdWlyZSgnLi9zb3VyY2Vjb21wYXJlJyk7XG4gICAgdmFyIHNvdXJjZURhdGFVUkkgPSBzYy5zb3VyY2VEYXRhVVJJO1xuXG4gICAgdmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG5cbiAgICB2YXIgc29ydEZlYXR1cmVzID0gcmVxdWlyZSgnLi9mZWF0dXJlcycpLnNvcnRGZWF0dXJlcztcbn1cblxudmFyIF9fdGllcl9pZFNlZWQgPSAwO1xuXG5mdW5jdGlvbiBEYXNUaWVyKGJyb3dzZXIsIHNvdXJjZSwgY29uZmlnLCBiYWNrZ3JvdW5kKVxue1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuaWQgPSAndGllcicgKyAoKytfX3RpZXJfaWRTZWVkKTtcbiAgICB0aGlzLmJyb3dzZXIgPSBicm93c2VyO1xuICAgIHRoaXMuZGFzU291cmNlID0gc2hhbGxvd0NvcHkoc291cmNlKTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXG4gICAgdGhpcy52aWV3cG9ydCA9IG1ha2VFbGVtZW50KCdjYW52YXMnLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3dpZHRoOiAnJyArICgodGhpcy5icm93c2VyLmZlYXR1cmVQYW5lbFdpZHRofDApICsgMjAwMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjMwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICd2aWV3cG9ydF8xMl81J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtwb3NpdGlvbjogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwcHgnLCBib3JkZXI6ICcwcHgnfSk7XG4gICAgdGhpcy52aWV3cG9ydEhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnLCB0aGlzLnZpZXdwb3J0LCB7Y2xhc3NOYW1lOiAndmlld3BvcnQtaG9sZGVyXzEyXzUnfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMHB4JywgbWFyZ2luOiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJzBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnLTEwMDBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6ICcyMDBweCd9KTtcbiAgICB0aGlzLm92ZXJsYXkgPSBtYWtlRWxlbWVudCgnY2FudmFzJywgbnVsbCxcbiAgICAgICAgIHt3aWR0aDogKyAoKHRoaXMuYnJvd3Nlci5mZWF0dXJlUGFuZWxXaWR0aHwwKSksIFxuICAgICAgICAgIGhlaWdodDogXCIzMFwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ3ZpZXdwb3J0LW92ZXJsYXknfSk7XG5cbiAgICB0aGlzLm5vdGlmaWVyID0gbWFrZUVsZW1lbnQoJ2RpdicsICcnLCB7Y2xhc3NOYW1lOiAnbm90aWZpZXInfSk7XG4gICAgdGhpcy5ub3RpZmllckhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnLCB0aGlzLm5vdGlmaWVyLCB7Y2xhc3NOYW1lOiAnbm90aWZpZXItaG9sZGVyJ30pO1xuICAgIHRoaXMucXVhbnRPdmVybGF5ID0gbWFrZUVsZW1lbnQoXG4gICAgICAgICdjYW52YXMnLCBudWxsLCBcbiAgICAgICAge3dpZHRoOiAnNTAnLCBoZWlnaHQ6IFwiNTZcIixcbiAgICAgICAgIGNsYXNzTmFtZTogJ3F1YW50LW92ZXJsYXknfSk7XG5cbiAgICB0aGlzLnJlbW92ZUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXRpbWVzJ30pO1xuICAgIHRoaXMuYnVtcEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXBsdXMtY2lyY2xlJ30pO1xuICAgIHRoaXMubG9hZGVyQnV0dG9uID0gYnJvd3Nlci5tYWtlTG9hZGVyKDE2KTtcbiAgICB0aGlzLmxvYWRlckJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuaW5mb0VsZW1lbnQgPSBtYWtlRWxlbWVudCgnZGl2JywgdGhpcy5kYXNTb3VyY2UuZGVzYywge2NsYXNzTmFtZTogJ3RyYWNrLWxhYmVsLWluZm8nfSk7XG4gICAgdGhpcy5uYW1lQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2RpdicsIFtdLCB7Y2xhc3NOYW1lOiAndGllci10YWInfSk7XG4gICAgdGhpcy5uYW1lQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMucmVtb3ZlQnV0dG9uKTtcbiAgICBpZiAoc291cmNlLnBlbm5hbnQpIHtcbiAgICAgICAgdGhpcy5uYW1lQnV0dG9uLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdpbWcnLCBudWxsLCB7c3JjOiBzb3VyY2UucGVubmFudCwgd2lkdGg6ICcxNicsIGhlaWdodDogJzE2J30pKVxuICAgIH0gZWxzZSBpZiAoc291cmNlLm1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHZlcnNpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5icm93c2VyLmNoYWluc1tzb3VyY2UubWFwcGluZ10pXG4gICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5icm93c2VyLmNoYWluc1tzb3VyY2UubWFwcGluZ10uY29vcmRzLnZlcnNpb247XG4gICAgICAgIGlmICh2ZXJzaW9uKVxuICAgICAgICAgICAgdGhpcy5uYW1lQnV0dG9uLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdzcGFuJywgJycgKyB2ZXJzaW9uLCBudWxsLCB7Zm9udFNpemU6ICc4cHQnLCBiYWNrZ3JvdW5kOiAnYmxhY2snLCBjb2xvcjogJ3doaXRlJywgcGFkZGluZ0xlZnQ6ICczcHgnLCBwYWRkaW5nUmlnaHQ6ICczcHgnLCBwYWRkaW5nVG9wOiAnMXB4JywgcGFkZGluZ0JvdHRvbTogJzFweCcsIG1hcmdpbkxlZnQ6ICcycHgnLCBib3JkZXJSYWRpdXM6ICcxMHB4J30pKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lRWxlbWVudCA9IG1ha2VFbGVtZW50KCdzcGFuJywgc291cmNlLm5hbWUpO1xuICAgIHRoaXMubmFtZUJ1dHRvbi5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnc3BhbicsIFt0aGlzLm5hbWVFbGVtZW50LCB0aGlzLmluZm9FbGVtZW50XSwge2NsYXNzTmFtZTogJ3RyYWNrLW5hbWUtaG9sZGVyJ30pKTtcbiAgICB0aGlzLm5hbWVCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5idW1wQnV0dG9uKTtcbiAgICB0aGlzLm5hbWVCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5sb2FkZXJCdXR0b24pO1xuXG4gICAgdGhpcy5sYWJlbCA9IG1ha2VFbGVtZW50KCdzcGFuJyxcbiAgICAgICBbdGhpcy5uYW1lQnV0dG9uXSxcbiAgICAgICB7Y2xhc3NOYW1lOiAnYnRuLWdyb3VwIHRyYWNrLWxhYmVsJ30pO1xuXG4gICAgdmFyIGNsYXNzZXMgPSAndGllcicgKyAoc291cmNlLmNsYXNzTmFtZSA/ICcgJyArIHNvdXJjZS5jbGFzc05hbWUgOiAnJyk7XG4gICAgdGhpcy5yb3cgPSBtYWtlRWxlbWVudCgnZGl2JywgW3RoaXMudmlld3BvcnRIb2xkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3ZlcmxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFudE92ZXJsYXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6IGNsYXNzZXN9KTtcblxuICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgICB0aGlzLnJvdy5zdHlsZS5iYWNrZ3JvdW5kID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGlmICghYnJvd3Nlci5ub0RlZmF1bHRMYWJlbHMpXG4gICAgICAgIHRoaXMucm93LmFwcGVuZENoaWxkKHRoaXMubGFiZWwpO1xuICAgIHRoaXMucm93LmFwcGVuZENoaWxkKHRoaXMubm90aWZpZXJIb2xkZXIpO1xuICAgIFxuICAgIHRoaXMubGF5b3V0SGVpZ2h0ID0gMjU7XG4gICAgdGhpcy5idW1wZWQgPSB0cnVlO1xuICAgIHRoaXMuc3R5bGVJZFNlZWQgPSAwO1xuICAgIGlmIChzb3VyY2UucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMucXVhbnRMZWFwVGhyZXNob2xkID0gc291cmNlLnF1YW50TGVhcFRocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpIHtcbiAgICAgICAgdGhpcy5idW1wZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXRXYXNEb25lID0gZmFsc2U7XG5cbiAgICBpZiAoc291cmNlLmZlYXR1cmVJbmZvUGx1Z2luKSB7XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZUluZm9QbHVnaW4oc291cmNlLmZlYXR1cmVJbmZvUGx1Z2luKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRTb3VyY2VzKCk7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5mZWF0dXJlU291cmNlLmdldERlZmF1bHRGSVBzICYmICFzb3VyY2Uubm9Tb3VyY2VGZWF0dXJlSW5mbykge1xuICAgICAgICB0aGlzLmZlYXR1cmVTb3VyY2UuZ2V0RGVmYXVsdEZJUHMoZnVuY3Rpb24oZmlwKSB7XG4gICAgICAgICAgICBpZiAoZmlwKVxuICAgICAgICAgICAgICAgIHRoaXNCLmFkZEZlYXR1cmVJbmZvUGx1Z2luKGZpcCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5mZWF0dXJlU291cmNlLmFkZFJlYWRpbmVzc0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVhZGluZXNzTGlzdGVuZXIgPSBmdW5jdGlvbihyZWFkeSkge1xuICAgICAgICAgICAgdGhpc0Iubm90aWZ5KHJlYWR5LCAtMSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmVhdHVyZVNvdXJjZS5hZGRSZWFkaW5lc3NMaXN0ZW5lcih0aGlzLnJlYWRpbmVzc0xpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlU291cmNlICYmIHRoaXMuZmVhdHVyZVNvdXJjZS5hZGRBY3Rpdml0eUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGJ1c3kpIHtcbiAgICAgICAgICAgIGlmIChidXN5ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXNCLmxvYWRlckJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNCLmxvYWRlckJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc0IuYnJvd3Nlci5waW5nQWN0aXZpdHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mZWF0dXJlU291cmNlLmFkZEFjdGl2aXR5TGlzdGVuZXIodGhpcy5hY3Rpdml0eUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuZmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmZpcnN0UmVuZGVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHRoaXMuX3Jlc29sdmVGaXJzdFJlbmRlclByb21pc2UgPSByZXNvbHZlKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UucmVtb3ZlUmVhZGluZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlU291cmNlLnJlbW92ZVJlYWRpbmVzc0xpc3RlbmVyKHRoaXMucmVhZGluZXNzTGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlU291cmNlLnJlbW92ZUFjdGl2aXR5TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlU291cmNlLnJlbW92ZUFjdGl2aXR5TGlzdGVuZXIodGhpcy5hY3Rpdml0eUxpc3RlbmVyKTtcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnNldEJhY2tncm91bmQgPSBmdW5jdGlvbihiKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYjtcbiAgICB0aGlzLnZpZXdwb3J0SG9sZGVyLnN0eWxlLmJhY2tncm91bmQgPSBiO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5hZGRGZWF0dXJlSW5mb1BsdWdpbiA9IGZ1bmN0aW9uKHApIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZUluZm9QbHVnaW5zKSBcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5mb1BsdWdpbnMgPSBbXTtcbiAgICB0aGlzLmZlYXR1cmVJbmZvUGx1Z2lucy5wdXNoKHApO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpZXIgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIFxuICAgICAgICBpZiAodGllci5kYXNTb3VyY2Uuc3R5bGUpIHtcbiAgICAgICAgICAgIHRpZXIuc2V0U3R5bGVzaGVldCh7c3R5bGVzOiB0aWVyLmRhc1NvdXJjZS5zdHlsZX0pO1xuICAgICAgICAgICAgcmVzb2x2ZSh0aWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpZXIuc3RhdHVzID0gJ0ZldGNoaW5nIHN0eWxlc2hlZXQnO1xuICAgICAgICAgICAgdGllci5mZXRjaFN0eWxlc2hlZXQoZnVuY3Rpb24oc3MsIGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgIXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXIuZXJyb3IgPSAnTm8gc3R5bGVzaGVldCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcyA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWZTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgICAgICAgICBkZWZTdHlsZS5CR0NPTE9SID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICBkZWZTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICAgICAgc3MucHVzaFN0eWxlKHt0eXBlOiAnZGVmYXVsdCd9LCBudWxsLCBkZWZTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRpZXIuc2V0U3R5bGVzaGVldChzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGllci5zZXRTdHlsZXNoZWV0KHNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNzLmdlbmVIaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWVyLmRhc1NvdXJjZS5jb2xsYXBzZVN1cGVyR3JvdXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpZXIuYnVtcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWVyLnVwZGF0ZUxhYmVsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGllci5fdXBkYXRlRnJvbUNvbmZpZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRpZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuc2V0U3R5bGVzaGVldCA9IGZ1bmN0aW9uKHNzKSB7XG4gICAgdGhpcy5iYXNlU3R5bGVzaGVldCA9IHNoYWxsb3dDb3B5KHNzKTtcbiAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgdGhpcy5iYXNlU3R5bGVzaGVldC5zdHlsZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzaCA9IHRoaXMuYmFzZVN0eWxlc2hlZXQuc3R5bGVzW3NpXSA9IHNoYWxsb3dDb3B5KHRoaXMuYmFzZVN0eWxlc2hlZXQuc3R5bGVzW3NpXSk7XG4gICAgICAgIHNoLl9tZXRob2RSRSA9IHNoLl9sYWJlbFJFID0gc2guX3R5cGVSRSA9IG51bGw7XG4gICAgICAgIHNoLnN0eWxlID0gc2hhbGxvd0NvcHkoc2guc3R5bGUpO1xuICAgICAgICBzaC5zdHlsZS5pZCA9ICdzdHlsZScgKyAoKyt0aGlzLnN0eWxlSWRTZWVkKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlU3R5bGVzaGVldFZhbGlkaXR5ID0gYjY0X3NoYTEobWluaUpTT05pZnkodGhpcy5iYXNlU3R5bGVzaGVldCkpO1xuICAgIHRoaXMuX3VwZGF0ZUZyb21Db25maWcoKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZVNvdXJjZTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZ2V0RGVzaXJlZFR5cGVzID0gZnVuY3Rpb24oc2NhbGUpIHtcbiAgICB2YXIgc2ZzID0gdGhpcy5nZXRBY3RpdmVTdHlsZUZpbHRlcnMoc2NhbGUpO1xuICAgIGlmIChzZnMpXG4gICAgICAgIHJldHVybiBzZnMudHlwZUxpc3QoKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZ2V0QWN0aXZlU3R5bGVGaWx0ZXJzID0gZnVuY3Rpb24oc2NhbGUpIHtcbiAgICB2YXIgc3NTY2FsZSA9IHRoaXMuYnJvd3Nlci56b29tRm9yQ3VycmVudFNjYWxlKCk7XG5cbiAgICBpZiAodGhpcy5zdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBzdHlsZXMgPSBuZXcgU3R5bGVGaWx0ZXJTZXQoKTtcbiAgICAgICAgdmFyIHNzID0gdGhpcy5zdHlsZXNoZWV0LnN0eWxlcztcbiAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICAgICAgdmFyIHNoID0gc3Nbc2ldO1xuICAgICAgICAgICAgaWYgKCFzaC56b29tIHx8IHNoLnpvb20gPT0gc3NTY2FsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5hZGQobmV3IFN0eWxlRmlsdGVyKHNoLnR5cGUsIHNoLm1ldGhvZCwgc2gubGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbn1cblxuRGFzVGllci5wcm90b3R5cGUubmVlZHNTZXF1ZW5jZSA9IGZ1bmN0aW9uKHNjYWxlICkge1xuICAgIGlmICh0aGlzLnNlcXVlbmNlU291cmNlICYmIHNjYWxlIDwgNSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCh0aGlzLmRhc1NvdXJjZS5iYW1VUkkgfHwgdGhpcy5kYXNTb3VyY2UuYmFtQmxvYiB8fCB0aGlzLmRhc1NvdXJjZS5id2dVUkkgfHwgdGhpcy5kYXNTb3VyY2UuYndnQmxvYilcbiAgICAgICAgICAgICAgICAgJiYgc2NhbGUgPCAyMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnNldEZlYXR1cmVzID0gZnVuY3Rpb24oY2hyLCBjb3ZlcmFnZSwgc2NhbGUsIGZlYXR1cmVzLCBzZXF1ZW5jZSkge1xuICAgIHRoaXMuY3VycmVudEZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBzZXF1ZW5jZTsgICAgXG4gICAgdGhpcy5rbm93bkNociA9IGNocjtcbiAgICB0aGlzLmtub3duQ292ZXJhZ2UgPSBjb3ZlcmFnZTtcbiAgICBcblxuICAgIC8vIG9ubHkgbm90aWZ5IGZlYXR1cmVzIGxvYWRlZCwgaWYgdGhleSBhcmUgdmFsaWRcbiAgICBpZiAoZmVhdHVyZXMpIHtcbiAgICAgICAgc29ydEZlYXR1cmVzKHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGlmeUZlYXR1cmVzTG9hZGVkKCk7XG4gICAgfVxufVxuXG5cbkRhc1RpZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZyhcIlVzZSBicm93c2VyLmdldFRpZXJSZW5kZXJlcih0aWVyKS5kcmF3VGllcih0aWVyKVwiKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZmluZE5leHRGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBwb3MsIGRpciwgZmVkZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYnJvd3Nlci52aWV3RW5kIC0gdGhpcy5icm93c2VyLnZpZXdTdGFydCArIDE7XG4gICAgICAgIHBvcyA9IChwb3MgKyAgKCh3aWR0aCAqIGRpcikgLyAyKSl8MFxuICAgICAgICB0aGlzLmZlYXR1cmVTb3VyY2UucXVhbnRGaW5kTmV4dEZlYXR1cmUoY2hyLCBwb3MsIGRpciwgdGhpcy5xdWFudExlYXBUaHJlc2hvbGQsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5rbm93bkNvdmVyYWdlICYmIHBvcyA+PSB0aGlzLmtub3duQ292ZXJhZ2UubWluKCkgJiYgcG9zIDw9IHRoaXMua25vd25Db3ZlcmFnZS5tYXgoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlc3RGZWF0dXJlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgdGhpcy5jdXJyZW50RmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5jdXJyZW50RmVhdHVyZXNbZmldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWYubWluIHx8ICFmLm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGYucGFyZW50cyAmJiBmLnBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWRnZSA9PSAxICYmIGYubWF4ID49IHBvcyAmJiBmLm1pbiA8IHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVzdEZlYXR1cmUgfHwgZi5taW4gPiBiZXN0RmVhdHVyZS5taW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGYubWluID09IGJlc3RGZWF0dXJlLm1pbiAmJiBmLm1heCA8IGJlc3RGZWF0dXJlLm1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZlYXR1cmUgPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZi5tYXggPCBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3RGZWF0dXJlIHx8IGYubWF4ID4gYmVzdEZlYXR1cmUubWF4IHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZi5tYXggPT0gYmVzdEZlYXR1cmUubWF4ICYmIGYubWluIDwgYmVzdEZlYXR1cmUubWluKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZi5taW4gPT0gYmVzdEZlYXR1cmUubW1pbiAmJiBiZXN0RmVhdHVyZS5tYXggPj0gcG9zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0RmVhdHVyZSA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWRnZSA9PSAxICYmIGYubWluIDw9IHBvcyAmJiBmLm1heCA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVzdEZlYXR1cmUgfHwgZi5tYXggPCBiZXN0RmVhdHVyZS5tYXggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGYubWF4ID09IGJlc3RGZWF0dXJlLm1heCAmJiBmLm1pbiA+IGJlc3RGZWF0dXJlLm1pbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZlYXR1cmUgPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZi5taW4gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3RGZWF0dXJlIHx8IGYubWluIDwgYmVzdEZlYXR1cmUubWluIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmLm1pbiA9PSBiZXN0RmVhdHVyZS5taW4gJiYgZi5tYXggPiBiZXN0RmVhdHVyZS5tYXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmLm1heCA9PSBiZXN0RmVhdHVyZS5tYXggJiYgYmVzdEZlYXR1cmUubWluIDw9IHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZlYXR1cmUgPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdEZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGJlc3RGZWF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5icm93c2VyLmtub3duU3BhY2UubWluO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuYnJvd3Nlci5rbm93blNwYWNlLm1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyeVNvdXJjZUZORihjaHIsIHBvcywgZGlyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS50cnlTb3VyY2VGTkYgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZlYXR1cmVTb3VyY2UuZmluZE5leHRGZWF0dXJlKGNociwgcG9zLCBkaXIsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKVxuICAgICAgICAgICAgY2FsbGJhY2soZmVhdHVyZSk7XG5cbiAgICAgICAgdmFyIHNzID0gc2VsZi5icm93c2VyLmdldFNlcXVlbmNlU291cmNlKCk7XG4gICAgICAgIGlmICghc3MpIC8vIFdlJ3JlIHByb2JhYmx5IGluIHRyb3VibGUsIGJ1dCByZXR1cm4gYW55d2F5LlxuICAgICAgICAgICAgY2FsbGJhY2soZmVhdHVyZSlcblxuICAgICAgICBzcy5nZXRTZXFJbmZvKGZlYXR1cmUuc2VnbWVudCwgZnVuY3Rpb24oc2kpIHtcbiAgICAgICAgICAgIGlmIChzaSlcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxmLnRyeVNvdXJjZUZORihmZWF0dXJlLnNlZ21lbnQsIGRpciA+IDAgPyAxMDAwMDAwMDAwMCA6IDAsIGRpciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuXG5EYXNUaWVyLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5idW1wQnV0dG9uLmNsYXNzTmFtZSA9IHRoaXMuYnVtcGVkID8gJ2ZhIGZhLW1pbnVzLWNpcmNsZScgOiAnZmEgZmEtcGx1cy1jaXJjbGUnO1xuICAgaWYgKHRoaXMuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpIHtcbiAgICAgICAgdGhpcy5idW1wQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1bXBCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3VycmVudEhlaWdodCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGF5b3V0SGVpZ2h0LCB0aGlzLmxhYmVsLmNsaWVudEhlaWdodCArIDIpLCB0aGlzLmJyb3dzZXIubWluVGllckhlaWdodCk7XG4gICAgdGhpcy5yb3cuc3R5bGUuaGVpZ2h0ID0gJycgKyB0aGlzLmN1cnJlbnRIZWlnaHQgKyAncHgnO1xuICAgIHRoaXMuYnJvd3Nlci51cGRhdGVIZWlnaHQoKTtcbiB9XG5cblxuRGFzVGllci5wcm90b3R5cGUuZHJhd092ZXJsYXkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXM7XG4gICAgdmFyIGIgPSB0aGlzLmJyb3dzZXI7XG4gICAgdmFyIHJldGluYSA9IGIucmV0aW5hICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMTtcbiAgICBcbiAgICB0Lm92ZXJsYXkuaGVpZ2h0ID0gdC52aWV3cG9ydC5oZWlnaHQ7XG4gICAgdC5vdmVybGF5LndpZHRoID0gcmV0aW5hID8gYi5mZWF0dXJlUGFuZWxXaWR0aCAqIDIgOiBiLmZlYXR1cmVQYW5lbFdpZHRoO1xuXG4gICAgdmFyIGcgPSB0Lm92ZXJsYXkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAocmV0aW5hKSB7XG4gICAgICAgIGcuc2NhbGUoMiwgMik7XG4gICAgfVxuICAgIFxuICAgIHZhciBvcmlnaW4gPSBiLnZpZXdTdGFydDtcbiAgICB2YXIgdmlzU3RhcnQgPSBiLnZpZXdTdGFydDtcbiAgICB2YXIgdmlzRW5kID0gYi52aWV3RW5kO1xuXG4gICAgaWYgKHRoaXMub3ZlcmxheUxhYmVsQ2FudmFzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAoKHRoaXMuZ2x5cGhDYWNoZU9yaWdpbiAtIHRoaXMuYnJvd3Nlci52aWV3U3RhcnQpKnRoaXMuYnJvd3Nlci5zY2FsZSk7XG4gICAgICAgIGcuc2F2ZSgpO1xuICAgICAgICBnLnRyYW5zbGF0ZShvZmZzZXQsIDApO1xuICAgICAgICB2YXIgZHJhd1N0YXJ0ID0gLW9mZnNldCArIDI7XG4gICAgICAgIGlmICh0aGlzLmRhc1NvdXJjZS50aWVyR3JvdXApXG4gICAgICAgICAgICBkcmF3U3RhcnQgKz0gMTU7XG4gICAgICAgIHRoaXMub3ZlcmxheUxhYmVsQ2FudmFzLmRyYXcoZywgZHJhd1N0YXJ0LCBiLmZlYXR1cmVQYW5lbFdpZHRoLW9mZnNldCk7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCBiLmhpZ2hsaWdodHMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgIHZhciBoID0gYi5oaWdobGlnaHRzW2hpXTtcbiAgICAgICAgaWYgKCgoaC5jaHIgPT09IGIuY2hyKSB8fCAoaC5jaHIgPT09ICgnY2hyJyArIGIuY2hyKSkpICYmIGgubWluIDwgdmlzRW5kICYmIGgubWF4ID4gdmlzU3RhcnQpIHtcbiAgICAgICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBiLmRlZmF1bHRIaWdobGlnaHRBbHBoYTtcbiAgICAgICAgICAgIGcuZmlsbFN0eWxlID0gYi5kZWZhdWx0SGlnaGxpZ2h0RmlsbDtcbiAgICAgICAgICAgIGcuZmlsbFJlY3QoKGgubWluIC0gb3JpZ2luKSAqIGIuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgIChoLm1heCAtIGgubWluKSAqIGIuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgIHQub3ZlcmxheS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfSBcblxuICAgIC8vIHQub29yaWdpbiA9IGIudmlld1N0YXJ0O1xuICAgIHQub3ZlcmxheS5zdHlsZS53aWR0aCA9IGIuZmVhdHVyZVBhbmVsV2lkdGg7XG4gICAgdC5vdmVybGF5LnN0eWxlLmhlaWdodCA9IHQudmlld3BvcnQuc3R5bGUuaGVpZ2h0O1xuICAgIHQub3ZlcmxheS5zdHlsZS5sZWZ0ID0gJzBweCc7XG59XG5cblxuRGFzVGllci5wcm90b3R5cGUudXBkYXRlU3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuX25vdGlmaWVyVG9TdGF0dXMoKTtcbiAgICAgICAgdmFyIHNkID0gc291cmNlRGF0YVVSSSh0aGlzLmRhc1NvdXJjZSk7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonICYmIHNvdXJjZURhdGFVUkkodGhpcy5kYXNTb3VyY2UpLmluZGV4T2YoJ2h0dHA6JykgPT0gMCAmJiAhdGhpcy5jaGVja2VkSFRUUCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkSFRUUCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJyb3dzZXIuY2FuRmV0Y2hQbGFpbkhUVFAoKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi53YXJuSFRUUCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3RpZmllclRvU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuX25vdGlmaWVyVG9TdGF0dXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuRGFzVGllci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24obWVzc2FnZSwgdGltZW91dCkge1xuICAgIGlmICh0eXBlb2YodGltZW91dCkgIT09ICdudW1iZXInKVxuICAgICAgICB0aW1lb3V0ID0gMjAwMDtcblxuICAgIGlmICh0aGlzLm5vdGlmaWVyRmFkZVRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm90aWZpZXJGYWRlVGltZW91dCk7XG4gICAgICAgIHRoaXMubm90aWZpZXJGYWRlVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fbm90aWZpZXJPbihtZXNzYWdlKTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5ub3RpZmllckZhZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzQi5fbm90aWZpZXJUb1N0YXR1cygpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub3RpZmllclRvU3RhdHVzKCk7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5fbm90aWZpZXJPbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHdhcm5IVFRQKSB7XG4gICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy5ub3RpZmllcik7XG4gICAgaWYgKHdhcm5IVFRQKSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBtYWtlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCdhJywgJ1tIVFRQIFdhcm5pbmddICcsIHtocmVmOiB0aGlzLmJyb3dzZXIuaHR0cFdhcm5pbmdVUkwsIHRhcmdldDogXCJfYmxhbmtcIn0pLFxuICAgICAgICAgICAgICAgICBtZXNzYWdlXVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmaWVyLnN0eWxlLm9wYWNpdHkgPSAwLjg7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLl9ub3RpZmllck9mZiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm90aWZpZXIuc3R5bGUub3BhY2l0eSA9IDA7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLl9ub3RpZmllclRvU3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuX25vdGlmaWVyT24odGhpcy5zdGF0dXMsIHRoaXMud2FybkhUVFApXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbm90aWZpZXJPZmYoKTtcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnNldENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuX3VwZGF0ZUZyb21Db25maWcoKTtcbiAgICB0aGlzLm5vdGlmeVRpZXJMaXN0ZW5lcnMoKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUubWVyZ2VTdHlsZXNoZWV0ID0gZnVuY3Rpb24obmV3U3R5bGUpIHtcbiAgICB0aGlzLm1lcmdlQ29uZmlnKHtcbiAgICAgICAgc3R5bGVzaGVldDogbmV3U3R5bGUsIFxuICAgICAgICBzdHlsZXNoZWV0VmFsaWRpdHk6IHRoaXMuYmFzZVN0eWxlc2hlZXRWYWxpZGl0eVxuICAgIH0pO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5tZXJnZUNvbmZpZyA9IGZ1bmN0aW9uKG5ld0NvbmZpZykge1xuICAgIGZvciAodmFyIGsgaW4gbmV3Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnW2tdID0gbmV3Q29uZmlnW2tdO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVGcm9tQ29uZmlnKCk7XG4gICAgdGhpcy5ub3RpZnlUaWVyTGlzdGVuZXJzKCk7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLl91cGRhdGVGcm9tQ29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgIHZhciBuZWVkc1Jlb3JkZXIgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcubmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRoaXMubmFtZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5uYW1lRWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuZGFzU291cmNlLm5hbWU7XG5cbiAgICB2YXIgd2FudGVkSGVpZ2h0ID0gdGhpcy5jb25maWcuaGVpZ2h0IHx8IHRoaXMuZGFzU291cmNlLmZvcmNlSGVpZ2h0O1xuICAgIGlmICh3YW50ZWRIZWlnaHQgIT0gdGhpcy5mb3JjZUhlaWdodCkge1xuICAgICAgICB0aGlzLmZvcmNlSGVpZ2h0ID0gd2FudGVkSGVpZ2h0O1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZvcmNlTWluRHluYW1pYyAhPSB0aGlzLmNvbmZpZy5mb3JjZU1pbkR5bmFtaWMpIHtcbiAgICAgICAgdGhpcy5mb3JjZU1pbkR5bmFtaWMgPSB0aGlzLmNvbmZpZy5mb3JjZU1pbkR5bmFtaWM7XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGZvcmNlTWluID0gdGhpcy5jb25maWcuZm9yY2VNaW4gIT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcuZm9yY2VNaW4gOiB0aGlzLmRhc1NvdXJjZS5mb3JjZU1pbjtcbiAgICBpZiAodGhpcy5mb3JjZU1pbiAhPSBmb3JjZU1pbikge1xuICAgICAgICB0aGlzLmZvcmNlTWluID0gZm9yY2VNaW47XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZm9yY2VNYXhEeW5hbWljICE9IHRoaXMuY29uZmlnLmZvcmNlTWF4RHluYW1pYykge1xuICAgICAgICB0aGlzLmZvcmNlTWF4RHluYW1pYyA9IHRoaXMuY29uZmlnLmZvcmNlTWF4RHluYW1pYztcbiAgICAgICAgbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGZvcmNlTWF4ID0gdGhpcy5jb25maWcuZm9yY2VNYXggIT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcuZm9yY2VNYXggOiB0aGlzLmRhc1NvdXJjZS5mb3JjZU1heDtcbiAgICBpZiAodGhpcy5mb3JjZU1heCAhPSBmb3JjZU1heCkge1xuICAgICAgICB0aGlzLmZvcmNlTWF4ID0gZm9yY2VNYXg7XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHF1YW50TGVhcFRocmVzaG9sZCA9IG51bGw7XG4gICAgaWYgKHRoaXMuY29uZmlnLnF1YW50TGVhcFRocmVzaG9sZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBxdWFudExlYXBUaHJlc2hvbGQgPSB0aGlzLmNvbmZpZy5xdWFudExlYXBUaHJlc2hvbGQ7XG4gICAgZWxzZSBpZiAodGhpcy5kYXNTb3VyY2UucXVhbnRMZWFwVGhyZXNob2xkICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHF1YW50TGVhcFRocmVzaG9sZCA9IHRoaXMuZGFzU291cmNlLnF1YW50TGVhcFRocmVzaG9sZDtcbiAgICBpZiAocXVhbnRMZWFwVGhyZXNob2xkICE9IHRoaXMucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMucXVhbnRMZWFwVGhyZXNob2xkID0gcXVhbnRMZWFwVGhyZXNob2xkO1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBQb3NzaWJsZSBGSVhNRSAtLSBhcmUgdGhlcmUgY2FzZXMgd2hlcmUgc3R5bGUgSURzIG5lZWQgdG8gYmUgcmVhc3NpZ25lZD9cbiAgICB2YXIgc3R5bGVzaGVldCA9IG51bGw7XG4gICAgaWYgKHRoaXMuY29uZmlnLnN0eWxlc2hlZXRWYWxpZGl0eSA9PSB0aGlzLmJhc2VTdHlsZXNoZWV0VmFsaWRpdHkpXG4gICAgICAgIHN0eWxlc2hlZXQgPSB0aGlzLmNvbmZpZy5zdHlsZXNoZWV0O1xuICAgIHN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0IHx8IHRoaXMuYmFzZVN0eWxlc2hlZXQ7XG4gICAgaWYgKHRoaXMuc3R5bGVzaGVldCAhPT0gc3R5bGVzaGVldCkge1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0O1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB3YW50ZWRQaW5uZWQgPSB0aGlzLmNvbmZpZy5waW5uZWQgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLnBpbm5lZCA6IHRoaXMuZGFzU291cmNlLnBpbm5lZDtcbiAgICBpZiAod2FudGVkUGlubmVkICE9PSB0aGlzLnBpbm5lZCkge1xuICAgICAgICB0aGlzLnBpbm5lZCA9IHdhbnRlZFBpbm5lZDtcbiAgICAgICAgbmVlZHNSZW9yZGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgd2FudGVkU3VidGllck1heCA9ICh0eXBlb2YodGhpcy5jb25maWcuc3VidGllck1heCA9PT0gJ251bWJlcicpID8gXG4gICAgICAgIHRoaXMuY29uZmlnLnN1YnRpZXJNYXggOiB0aGlzLmRhc1NvdXJjZS5zdWJ0aWVyTWF4IHx8IHRoaXMuYnJvd3Nlci5kZWZhdWx0U3VidGllck1heCk7XG4gICAgaWYgKHdhbnRlZFN1YnRpZXJNYXggIT0gdGhpcy5zdWJ0aWVyTWF4KSB7XG4gICAgICAgIHRoaXMuc3VidGllck1heCA9IHdhbnRlZFN1YnRpZXJNYXg7XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHdhbnRlZEJ1bXBlZDtcbiAgICBpZiAodGhpcy5jb25maWcuYnVtcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FudGVkQnVtcGVkID0gdGhpcy5jb25maWcuYnVtcGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXNTb3VyY2UuYnVtcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FudGVkQnVtcGVkID0gdGhpcy5kYXNTb3VyY2UuYnVtcGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbnRlZEJ1bXBlZCA9IHRoaXMuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGlmICh3YW50ZWRCdW1wZWQgIT09IHRoaXMuYnVtcGVkKSB7XG4gICAgICAgIHRoaXMuYnVtcGVkID0gd2FudGVkQnVtcGVkO1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVmcmVzaClcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZHJhdygpO1xuXG4gICAgaWYgKG5lZWRzUmVvcmRlcilcbiAgICAgICAgdGhpcy5icm93c2VyLnJlb3JkZXJUaWVycygpO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5zY2hlZHVsZVJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50RmVhdHVyZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICB2YXIgdGllciA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMucmVkcmF3VGltZW91dCkge1xuICAgICAgICB0aGlzLnJlZHJhd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc29ydEZlYXR1cmVzKHRpZXIpOyAgIC8vIFNvbWUgcmVuZGVyIGFjdGlvbnMgbXV0YXRlIHRoZSByZXN1bHRzIG9mIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPT4gbmVlZCB0byByZS1ydW4gYmVmb3JlIHJlZnJlc2hpbmcuXG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aWVyLmJyb3dzZXIuZ2V0VGllclJlbmRlcmVyKHRpZXIpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZHJhd1RpZXIodGllcik7XG4gICAgICAgICAgICB0aWVyLnJlZHJhd1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxufVxuRGFzVGllci5wcm90b3R5cGUuY2xlYXJUaWVyTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMubGlzdGVuZXJzID0gW107XG59XG5cblxuRGFzVGllci5wcm90b3R5cGUuYWRkVGllckxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobCk7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnJlbW92ZVRpZXJMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMubGlzdGVuZXJzLCBsKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5ub3RpZnlUaWVyTGlzdGVuZXJzID0gZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbGldKGNoYW5nZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnJvd3Nlci5ub3RpZnlUaWVyKCk7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLmNsZWFyRmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mZWF0dXJlc0xvYWRlZExpc3RlbmVycyA9IFtdO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5hZGRGZWF0dXJlc0xvYWRlZExpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHRoaXMuZmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZXNMb2FkZWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMuZmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLmZlYXR1cmVzTG9hZGVkTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuRGFzVGllci5wcm90b3R5cGUubm90aWZ5RmVhdHVyZXNMb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGhpcy5mZWF0dXJlc0xvYWRlZExpc3RlbmVycy5sZW5ndGg7ICsrbGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnNbbGldLmNhbGwodGhpcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS53YXNSZW5kZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Jlc29sdmVGaXJzdFJlbmRlclByb21pc2UoKTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBEYXNUaWVyOiBEYXNUaWVyXG4gICAgfTtcblxuICAgIC8vIEltcG9ydGVkIGZvciBzaWRlIGVmZmVjdHNcbiAgICB2YXIgZmQgPSByZXF1aXJlKCcuL2ZlYXR1cmUtZHJhdycpO1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIHRyYWNrLWFkZGVyLmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciBzYyA9IHJlcXVpcmUoJy4vc291cmNlY29tcGFyZScpO1xuICAgIHZhciBzb3VyY2VzQXJlRXF1YWwgPSBzYy5zb3VyY2VzQXJlRXF1YWw7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIG1ha2VFbGVtZW50ID0gdXRpbHMubWFrZUVsZW1lbnQ7XG4gICAgdmFyIHJlbW92ZUNoaWxkcmVuID0gdXRpbHMucmVtb3ZlQ2hpbGRyZW47XG4gICAgdmFyIE9ic2VydmVkID0gdXRpbHMuT2JzZXJ2ZWQ7XG5cbiAgICB2YXIgdGh1YiA9IHJlcXVpcmUoJy4vdGh1YicpO1xuICAgIHZhciBUSFVCX0NPTVBBUkUgPSB0aHViLlRIVUJfQ09NUEFSRTtcbiAgICB2YXIgY29ubmVjdFRyYWNrSHViID0gdGh1Yi5jb25uZWN0VHJhY2tIdWI7XG5cbiAgICB2YXIgZG9tdWkgPSByZXF1aXJlKCcuL2RvbXVpJyk7XG4gICAgdmFyIG1ha2VUcmVlVGFibGVTZWN0aW9uID0gZG9tdWkubWFrZVRyZWVUYWJsZVNlY3Rpb247XG5cbiAgICB2YXIgcHJvYmVSZXNvdXJjZSA9IHJlcXVpcmUoJy4vcHJvYmUnKS5wcm9iZVJlc291cmNlO1xuXG5cbiAgICAvLyBNb3N0IG9mIHRoaXMgY291bGQgZGlzYXBwZWFyIGlmIHdlIGxlYXZlIGFsbCBwcm9iaW5nIHRvIHRoZSBwcm9iZSBtb2R1bGUuLi5cbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgVVJMRmV0Y2hhYmxlID0gYmluLlVSTEZldGNoYWJsZTtcbiAgICB2YXIgQmxvYkZldGNoYWJsZSA9IGJpbi5CbG9iRmV0Y2hhYmxlO1xuICAgIHZhciByZWFkSW50ID0gYmluLnJlYWRJbnQ7XG5cbiAgICB2YXIgbGgzdXRpbHMgPSByZXF1aXJlKCcuL2xoM3V0aWxzJyk7XG4gICAgdmFyIHVuYmd6ZiA9IGxoM3V0aWxzLnVuYmd6ZjtcblxuICAgIHZhciBiYW0gPSByZXF1aXJlKCcuL2JhbScpO1xuICAgIHZhciBCQU1fTUFHSUMgPSBiYW0uQkFNX01BR0lDO1xuICAgIHZhciBCQUlfTUFHSUMgPSBiYW0uQkFJX01BR0lDO1xuXG4gICAgdmFyIHRiaSA9IHJlcXVpcmUoJy4vdGFiaXgnKTtcbiAgICB2YXIgVEFCSVhfTUFHSUMgPSB0YmkuVEFCSVhfTUFHSUM7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU291cmNlID0gZGFzLkRBU1NvdXJjZTtcbiAgICB2YXIgREFTU2VnbWVudCA9IGRhcy5EQVNTZWdtZW50O1xuICAgIHZhciBEQVNSZWdpc3RyeSA9IGRhcy5EQVNSZWdpc3RyeTtcbiAgICB2YXIgY29vcmRzTWF0Y2ggPSBkYXMuY29vcmRzTWF0Y2g7XG5cbiAgICB2YXIgRW5jb2RlRmV0Y2hhYmxlID0gcmVxdWlyZSgnLi9lbmNvZGUnKS5FbmNvZGVGZXRjaGFibGU7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmN1cnJlbnRseUFjdGl2ZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICBpZiAoc291cmNlc0FyZUVxdWFsKHRoaXMudGllcnNbdGldLmRhc1NvdXJjZSwgc291cmNlKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpZXJzW3RpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYWtlQnV0dG9uID0gZnVuY3Rpb24obmFtZSwgdG9vbHRpcCkge1xuICAgIHZhciByZWdCdXR0b24gPSBtYWtlRWxlbWVudCgnYScsIG5hbWUsIHtocmVmOiAnIyd9KTtcbiAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICB0aGlzLm1ha2VUb29sdGlwKHJlZ0J1dHRvbiwgdG9vbHRpcCk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlRWxlbWVudCgnbGknLCByZWdCdXR0b24pO1xufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgd2hpY2gpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZE1vZGVCdXR0b25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiID0gYWRkTW9kZUJ1dHRvbnNbaV07XG4gICAgICAgIGlmIChiID09PSB3aGljaCkge1xuICAgICAgICAgICAgYi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNob3dUcmFja0FkZGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAodGhpcy51aU1vZGUgPT09ICdhZGQnKSB7XG4gICAgICAgIHRoaXMuaGlkZVRvb2xQYW5lbCgpO1xuICAgICAgICB0aGlzLnNldFVpTW9kZSgnbm9uZScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHZhciBwb3B1cCA9IG1ha2VFbGVtZW50KCdkaXYnLCBudWxsLCB7Y2xhc3NOYW1lOiAnZGFsbGlhbmNlJ30gLCB7d2lkdGg6ICcxMDAlJywgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIGJveFNpemluZzogJ2JvcmRlci1ib3gnLCBNb3pCb3hTaXppbmc6ICdib3JkZXItYm94JywgdmVydGljYWxBbGlnbjogJ3RvcCcsIHBhZGRpbmdSaWdodDogJzE1cHgnfSk7XG5cbiAgICB2YXIgYWRkTW9kZUJ1dHRvbnMgPSBbXTtcbiAgICB2YXIgbWFrZVN0YWIsIG1ha2VTdGFiT2JzZXJ2ZXI7XG5cblxuICAgIGlmICghdGhpcy5ub1JlZ2lzdHJ5VGFicykge1xuICAgICAgICB2YXIgcmVnQnV0dG9uID0gdGhpcy5tYWtlQnV0dG9uKCdSZWdpc3RyeScsICdCcm93c2UgY29tcGF0aWJsZSBkYXRhc291cmNlcyBmcm9tIHRoZSBEQVMgcmVnaXN0cnknKTtcbiAgICAgICAgYWRkTW9kZUJ1dHRvbnMucHVzaChyZWdCdXR0b24pO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgbSBpbiB0aGlzLm1hcHBhYmxlU291cmNlcykge1xuICAgICAgICAgICAgdmFyIG1mICA9IGZ1bmN0aW9uKG1tKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcEJ1dHRvbiA9IHRoaXNCLm1ha2VCdXR0b24odGhpc0IuY2hhaW5zW21tXS5zcmNUYWcsICdCcm93c2UgZGF0YXNvdXJjZXMgbWFwcGVkIGZyb20gJyArIHRoaXNCLmNoYWluc1ttbV0uc3JjVGFnKTtcbiAgICAgICAgICAgICAgICBhZGRNb2RlQnV0dG9ucy5wdXNoKG1hcEJ1dHRvbik7XG4gICAgICAgICAgICAgICAgbWFwQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBtYXBCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICBtYWtlU3RhYih0aGlzQi5tYXBwYWJsZVNvdXJjZXNbbW1dLCBtbSk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfTsgbWYobSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBlZERlZmF1bHRzID0ge307XG4gICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHRoaXMuZGVmYXVsdFNvdXJjZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5kZWZhdWx0U291cmNlc1tzaV07XG4gICAgICAgIHZhciBnID0gcy5ncm91cCB8fCAnRGVmYXVsdHMnO1xuICAgICAgICBpZiAoZ3JvdXBlZERlZmF1bHRzW2ddKSB7XG4gICAgICAgICAgICBncm91cGVkRGVmYXVsdHNbZ10ucHVzaChzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwZWREZWZhdWx0c1tnXSA9IFtzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcblxuICAgIHZhciBtYWtlSHViQnV0dG9uID0gZnVuY3Rpb24odGRiKSB7XG4gICAgICAgIHZhciBodWIgPSB0ZGIuaHViO1xuICAgICAgICB2YXIgaHViTWVudUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWxpc3QtYWx0J30sIHtjdXJzb3I6ICdjb250ZXh0LW1lbnUnfSk7XG4gICAgICAgIHZhciBsYWJlbCA9IGh1Yi5hbHRMYWJlbCB8fCBodWIuc2hvcnRMYWJlbCB8fCAnVW5rbm93bic7XG4gICAgICAgIGlmICh0ZGIubWFwcGluZylcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwgKyAnICgnICsgdGRiLmdlbm9tZSArICcpJztcbiAgICAgICAgdmFyIGhiQ29udGVudCA9IG1ha2VFbGVtZW50KCdzcGFuJywgW2xhYmVsLCAnICcsIGh1Yk1lbnVCdXR0b25dKTtcbiAgICAgICAgdmFyIGh1YkJ1dHRvbiA9IHRoaXNCLm1ha2VCdXR0b24oaGJDb250ZW50LCBodWIubG9uZ0xhYmVsKTtcbiAgICAgICAgaHViQnV0dG9uLmh1YiA9IHRkYjtcbiAgICAgICAgYWRkTW9kZUJ1dHRvbnMucHVzaChodWJCdXR0b24pO1xuICAgICAgICBcbiAgICAgICAgaHViQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYWN0aXZhdGVCdXR0b24oYWRkTW9kZUJ1dHRvbnMsIGh1YkJ1dHRvbik7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSB0aGlzQi5tYWtlTG9hZGVyKDI0KTtcbiAgICAgICAgICAgIGxvYWRlci5zdHlsZS5tYXJnaW5MZWZ0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLm1hcmdpblJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLm1hcmdpblRvcCA9ICcxMDBweCc7XG4gICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdkaXYnLCBsb2FkZXIsIG51bGwsIHt0ZXh0QWxpZ246ICdjZW50ZXInfSkpO1xuXG4gICAgICAgICAgICByZWZyZXNoQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGNhbkJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICB0ZGIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBtYWtlSHViU3RhYih0cmFja3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBodWJNZW51QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmVtb3ZlSHViSXRlbSA9IG1ha2VFbGVtZW50KCdsaScsIG1ha2VFbGVtZW50KCdhJywgJ1JlbW92ZSBodWInKSk7XG4gICAgICAgICAgICB2YXIgYWxsT25JdGVtID0gbWFrZUVsZW1lbnQoJ2xpJywgIG1ha2VFbGVtZW50KCdhJywgJ0VuYWJsZSBhbGwnKSk7XG4gICAgICAgICAgICB2YXIgYWxsT2ZmSXRlbSA9IG1ha2VFbGVtZW50KCdsaScsICBtYWtlRWxlbWVudCgnYScsICdEaXNhYmxlIGFsbCcpKTtcbiAgICAgICAgICAgIHZhciBodWJNZW51ID0gbWFrZUVsZW1lbnQoJ3VsJywgW3JlbW92ZUh1Ykl0ZW0sIGFsbE9uSXRlbSwgYWxsT2ZmSXRlbV0sIHtjbGFzc05hbWU6ICdkcm9wZG93bi1tZW51J30sIHtkaXNwbGF5OiAnYmxvY2snfSk7XG5cbiAgICAgICAgICAgIHZhciBteCA9ICBldi5jbGllbnRYLCBteSA9IGV2LmNsaWVudFk7XG4gICAgICAgICAgICBteCArPSAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgbXkgKz0gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG5cbiAgICAgICAgICAgIGh1Yk1lbnUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgaHViTWVudS5zdHlsZS50b3AgPSAnJyArIChteSsxMCkgKyAncHgnO1xuICAgICAgICAgICAgaHViTWVudS5zdHlsZS5sZWZ0ID0gJycgKyAobXgtMzApICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXNCLmhQb3B1cEhvbGRlci5hcHBlbmRDaGlsZChodWJNZW51KTtcblxuICAgICAgICAgICAgdmFyIGNsaWNrQ2F0Y2hlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NjJyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrQ2F0Y2hlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpc0IuaFBvcHVwSG9sZGVyLnJlbW92ZUNoaWxkKGh1Yk1lbnUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0NhdGNoZXIsIHRydWUpO1xuXG4gICAgICAgICAgICByZW1vdmVIdWJJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpc0IuaHViT2JqZWN0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNCLmh1Yk9iamVjdHNbaGldLmFic1VSTCA9PSB0ZGIuYWJzVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5odWJPYmplY3RzLnNwbGljZShoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpc0IuaHVicy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhjID0gdGhpc0IuaHVic1toaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgaGMgPSB7dXJsOiBoY307XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYy51cmwgPT0gdGRiLmh1Yi51cmwgJiYgIWhjLmdlbm9tZSB8fCBoYy5nZW5vbWUgPT0gdGRiLmdlbm9tZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IuaHVicy5zcGxpY2UoaGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeVRpZXIoKTtcblxuICAgICAgICAgICAgICAgIG1vZGVCdXR0b25Ib2xkZXIucmVtb3ZlQ2hpbGQoaHViQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgYWRkSHViQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cblxuICAgICAgICAgICAgYWxsT25JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB0ZGIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0cmFja3MubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHMgPSB0cmFja3NbdGldLnRvRGFsbGlhbmNlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNCLmN1cnJlbnRseUFjdGl2ZShkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBhbGxPZmZJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB0ZGIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0cmFja3MubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHMgPSB0cmFja3NbdGldLnRvRGFsbGlhbmNlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0IuY3VycmVudGx5QWN0aXZlKGRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnJlbW92ZVRpZXIoZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gaHViQnV0dG9uO1xuICAgIH1cblxuICAgIHZhciBmaXJzdERlZkJ1dHRvbiA9IG51bGw7XG4gICAgdmFyIGZpcnN0RGVmU291cmNlcyA9IG51bGw7XG4gICAgZm9yICh2YXIgZyBpbiBncm91cGVkRGVmYXVsdHMpIHtcbiAgICAgICAgKGZ1bmN0aW9uKGcsIGRzKSB7XG4gICAgICAgICAgICB2YXIgZGVmQnV0dG9uID0gdGhpc0IubWFrZUJ1dHRvbihnLCAnQnJvd3NlIHRoZSBkZWZhdWx0IHNldCBvZiBkYXRhIGZvciB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgICAgIGRlZkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGVCdXR0b24oYWRkTW9kZUJ1dHRvbnMsIGRlZkJ1dHRvbik7XG4gICAgICAgICAgICAgICAgbWFrZVN0YWIobmV3IE9ic2VydmVkKGRzKSk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICBhZGRNb2RlQnV0dG9ucy5wdXNoKGRlZkJ1dHRvbik7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3REZWZCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBmaXJzdERlZkJ1dHRvbiA9IGRlZkJ1dHRvbjtcbiAgICAgICAgICAgICAgICBmaXJzdERlZlNvdXJjZXMgPSBkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoZywgZ3JvdXBlZERlZmF1bHRzW2ddKTtcbiAgICB9ICAgXG4gICAgdmFyIGN1c3RCdXR0b24gPSB0aGlzLm1ha2VCdXR0b24oJ0RBUycsICdBZGQgYXJiaXRyYXJ5IERBUyBkYXRhJyk7XG4gICAgYWRkTW9kZUJ1dHRvbnMucHVzaChjdXN0QnV0dG9uKTtcbiAgICB2YXIgYmluQnV0dG9uID0gdGhpcy5tYWtlQnV0dG9uKCdCaW5hcnknLCAnQWRkIGRhdGEgaW4gYmlnd2lnIG9yIGJpZ2JlZCBmb3JtYXQnKTtcbiAgICBhZGRNb2RlQnV0dG9ucy5wdXNoKGJpbkJ1dHRvbik7XG5cblxuICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCB0aGlzLmh1Yk9iamVjdHMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgIHZhciBodWIgPSB0aGlzLmh1Yk9iamVjdHNbaGldO1xuICAgICAgICBtYWtlSHViQnV0dG9uKGh1Yik7XG4gICAgfVxuXG4gICAgdmFyIGFkZEh1YkJ1dHRvbiA9IHRoaXMubWFrZUJ1dHRvbignKycsICdDb25uZWN0IHRvIGEgbmV3IHRyYWNrLWh1YicpO1xuICAgIGFkZE1vZGVCdXR0b25zLnB1c2goYWRkSHViQnV0dG9uKTtcblxuXG4gICAgdmFyIG1vZGVCdXR0b25Ib2xkZXIgPSBtYWtlRWxlbWVudCgndWwnLCBhZGRNb2RlQnV0dG9ucywge2NsYXNzTmFtZTogJ25hdiBuYXYtdGFicyd9LCB7bWFyZ2luQm90dG9tOiAnMHB4J30pO1xuICAgIHBvcHVwLmFwcGVuZENoaWxkKG1vZGVCdXR0b25Ib2xkZXIpO1xuICAgIFxuICAgIHZhciBjdXN0VVJMLCBjdXN0TmFtZSwgY3VzdENTLCBjdXN0UXVhbnQsIGN1c3RGaWxlLCBjdXN0VXNlciwgY3VzdFBhc3M7XG4gICAgdmFyIGN1c3RvbU1vZGUgPSBmYWxzZTtcbiAgICB2YXIgZGF0YVRvRmluYWxpemUgPSBudWxsO1xuXG4gICAgdmFyIGFzZm9ybSA9IG1ha2VFbGVtZW50KCdmb3JtJywgbnVsbCwge30sIHtkaXNwbGF5OiAnaW5saW5lLWJsb2NrJywgd2lkdGg6ICcxMDAlJ30pO1xuICAgIGFzZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb0FkZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHRydWUpOyBcbiAgICB2YXIgc3RhYkhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnKTtcbiAgICBzdGFiSG9sZGVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBzdGFiSG9sZGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgLy8gc3RhYkhvbGRlci5zdHlsZS5oZWlnaHQgPSAnNTAwcHgnO1xuICAgIGFzZm9ybS5hcHBlbmRDaGlsZChzdGFiSG9sZGVyKTtcblxuICAgIHZhciBfX21hcHBpbmc7XG4gICAgdmFyIF9fc291cmNlSG9sZGVyO1xuXG5cbiAgICBtYWtlU3RhYiA9IGZ1bmN0aW9uKG1zb3VyY2VzLCBtYXBwaW5nKSB7XG4gICAgICAgIHJlZnJlc2hCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYWRkQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNhbkJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBpZiAoX19zb3VyY2VIb2xkZXIpIHtcbiAgICAgICAgICAgIF9fc291cmNlSG9sZGVyLnJlbW92ZUxpc3RlbmVyKG1ha2VTdGFiT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIF9fbWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgIF9fc291cmNlSG9sZGVyID0gbXNvdXJjZXM7XG4gICAgICAgIF9fc291cmNlSG9sZGVyLmFkZExpc3RlbmVyQW5kRmlyZShtYWtlU3RhYk9ic2VydmVyKTtcbiAgICB9XG5cbiAgICBtYWtlU3RhYk9ic2VydmVyID0gZnVuY3Rpb24obXNvdXJjZXMpIHtcbiAgICAgICAgY3VzdG9tTW9kZSA9IGZhbHNlO1xuICAgICAgICB2YXIgYnV0dG9ucyA9IFtdO1xuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgaWYgKCFtc291cmNlcykge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdEYWxsaWFuY2Ugd2FzIHVuYWJsZSB0byByZXRyaWV2ZSBkYXRhIHNvdXJjZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBEQVMgcmVnaXN0cnksIHBsZWFzZSB0cnkgYWdhaW4gbGF0ZXInKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzdGFiQm9keSA9IG1ha2VFbGVtZW50KCd0Ym9keScsIG51bGwsIHtjbGFzc05hbWU6ICd0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZCd9LCB7d2lkdGg6ICcxMDAlJ30pO1xuICAgICAgICB2YXIgc3RhYiA9IG1ha2VFbGVtZW50KCd0YWJsZScsIHN0YWJCb2R5LCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSwge3dpZHRoOiAnMTAwJScsIHRhYmxlTGF5b3V0OiAnZml4ZWQnfSk7IFxuICAgICAgICB2YXIgaWR4ID0gMDtcblxuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2gobXNvdXJjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzb3VyY2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEubmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKS5sb2NhbGVDb21wYXJlKGIubmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgICAgICB2YXIgciA9IG1ha2VFbGVtZW50KCd0cicpO1xuXG4gICAgICAgICAgICB2YXIgYmQgPSBtYWtlRWxlbWVudCgndGQnLCBudWxsLCB7fSwge3dpZHRoOiAnMzBweCd9KTtcbiAgICAgICAgICAgIGJkLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UucHJvcHMgfHwgc291cmNlLnByb3BzLmNvcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG1ha2VFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGIudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgICAgICAgICAgYi5kYWxsaWFuY2Vfc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGlmIChfX21hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5kYWxsaWFuY2VfbWFwcGluZyA9IF9fbWFwcGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYi5jaGVja2VkID0gdGhpc0IuY3VycmVudGx5QWN0aXZlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgYmQuYXBwZW5kQ2hpbGQoYik7XG4gICAgICAgICAgICAgICAgYnV0dG9ucy5wdXNoKGIpO1xuICAgICAgICAgICAgICAgIGIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGV2LnRhcmdldC5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnJlbW92ZVRpZXIoZXYudGFyZ2V0LmRhbGxpYW5jZV9zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJkLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCchJykpO1xuICAgICAgICAgICAgICAgIHRoaXNCLm1ha2VUb29sdGlwKGJkLCBtYWtlRWxlbWVudCgnc3BhbicsIFtcIlRoaXMgZGF0YSBzb3VyY2UgaXNuJ3QgYWNjZXNzaWJsZSBiZWNhdXNlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBcIiwgbWFrZUVsZW1lbnQoJ2EnLCBcIkNPUlNcIiwge2hyZWY6ICdodHRwOi8vd3d3LnczLm9yZy9UUi9jb3JzLyd9KSwgXCIuXCJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLmFwcGVuZENoaWxkKGJkKTtcbiAgICAgICAgICAgIHZhciBsZCA9IG1ha2VFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgbGQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc291cmNlLm5hbWUpKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuZGVzYyAmJiBzb3VyY2UuZGVzYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IubWFrZVRvb2x0aXAobGQsIHNvdXJjZS5kZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIuYXBwZW5kQ2hpbGQobGQpO1xuICAgICAgICAgICAgc3RhYkJvZHkuYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgICArK2lkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXRDaGVja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGJpID0gMDsgYmkgPCBidXR0b25zLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gYnV0dG9uc1tiaV07XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzQi5jdXJyZW50bHlBY3RpdmUoYi5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICBiLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRDaGVja3MoKTtcbiAgICAgICAgdGhpc0IuYWRkVGllckxpc3RlbmVyKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgIHNldENoZWNrcygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKHN0YWIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlSHViU3RhYih0cmFja3MpIHtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgY2FuQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgY3VzdG9tTW9kZSA9IGZhbHNlO1xuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgXG4gICAgICAgIHZhciB0dGFiID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHt9LCB7d2lkdGg6ICcxMDAlJ30pO1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHRyYWNrc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNvdXJjZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zaG9ydExhYmVsLnRvTG93ZXJDYXNlKCkudHJpbSgpLmxvY2FsZUNvbXBhcmUoYi5zaG9ydExhYmVsLnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICB2YXIgdG9wcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHNvdXJjZXMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSBzb3VyY2VzW3RpXTtcbiAgICAgICAgICAgIGlmICh0cmFjay5jaGlsZHJlbiAmJiB0cmFjay5jaGlsZHJlbi5sZW5ndGggPiAwICYmIHRyYWNrLmNvbnRhaW5lciAhPSAnbXVsdGlXaWcnKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2godHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BzLnB1c2godHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzaG9ydExhYmVsOiAnT3RoZXJzJyxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogLTEwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogdG9wc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXBzLnNvcnQoVEhVQl9DT01QQVJFKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBidXR0b25zID0gW107XG4gICAgICAgIGZvciAodmFyIGdpID0gMDsgZ2kgPCBncm91cHMubGVuZ3RoOyArK2dpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbZ2ldO1xuICAgICAgICAgICAgdmFyIGRnID0gZ3JvdXA7XG4gICAgICAgICAgICBpZiAoIWRnLmRpbWVuc2lvbnMgJiYgZGcuX3BhcmVudCAmJiBkZy5fcGFyZW50LmRpbWVuc2lvbnMpXG4gICAgICAgICAgICAgICAgZGcgPSBkZy5fcGFyZW50O1xuXG4gICAgICAgICAgICB2YXIgZHByb3BzID0ge31cbiAgICAgICAgICAgIGlmIChkZy5kaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR0b2tzID0gZGcuZGltZW5zaW9ucy5zcGxpdCgvKFxcdyspPShcXHcrKS8pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR0aSA9IDA7IGR0aSA8IGR0b2tzLmxlbmd0aCAtIDI7IGR0aSArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRwcm9wc1tkdG9rc1tkdGkgKyAxXV0gPSBkdG9rc1tkdGkgKyAyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkcHJvcHMuZGltWCAmJiBkcHJvcHMuZGltWSkge1xuICAgICAgICAgICAgICAgIHZhciBkaW1YID0gZHByb3BzLmRpbVgsIGRpbVkgPSBkcHJvcHMuZGltWTtcbiAgICAgICAgICAgICAgICB2YXIgc2dYID0gZGcuc3ViZ3JvdXBzW2RpbVhdO1xuICAgICAgICAgICAgICAgIHZhciBzZ1kgPSBkZy5zdWJncm91cHNbZGltWV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHRya3MgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuW2NpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZYID0gY2hpbGQuc2dtW2RpbVhdLCB2WSA9IGNoaWxkLnNnbVtkaW1ZXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmtzW3ZYXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRya3NbdlhdID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRya3NbdlhdW3ZZXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBtYXRyaXggPSBtYWtlRWxlbWVudCgndGFibGUnLCBudWxsLCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSwge3RhYmxlTGF5b3V0OiAnZml4ZWQnfSk7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gbWFrZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgndGgnLCBudWxsLCB7fSwge3dpZHRoOiAnMTUwcHgnLCBoZWlnaHQ6ICcxMDBweCd9KSk7ICAgLy8gYmxhbmsgY29ybmVyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNnWC50aXRsZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IG1ha2VFbGVtZW50KCd0aCcsIG1ha2VFbGVtZW50KCdkaXYnLCBzZ1gudGl0bGVzW3NpXSwge30sIHt0cmFuc2Zvcm06ICdyb3RhdGUoLTYwZGVnKScsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICcwJSAxMDAlJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmtpdFRyYW5zZm9ybTogJ3JvdGF0ZSgtNjBkZWcpIHRyYW5zbGF0ZSgyMHB4LDEwcHgpJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmtpdFRyYW5zZm9ybU9yaWdpbjogJzAlIDEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0J30pLCB7fSwge3dpZHRoOiAnMzVweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdib3R0b20nfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRyaXguYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbWJvZHkgPSBtYWtlRWxlbWVudCgndGJvZHknLCBudWxsLCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5aSA9IDA7IHlpIDwgc2dZLnRpdGxlcy5sZW5ndGg7ICsreWkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZZID0gc2dZLnRhZ3NbeWldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gbWFrZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgndGgnLCBzZ1kudGl0bGVzW3lpXSksIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhpID0gMDsgeGkgPCBzZ1gudGl0bGVzLmxlbmd0aDsgKyt4aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZYID0gc2dYLnRhZ3NbeGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBtYWtlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmtzW3ZYXSAmJiB0cmtzW3ZYXVt2WV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmtzW3ZYXVt2WV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRzID0gdHJhY2sudG9EYWxsaWFuY2VTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG1ha2VFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZCA9IG1ha2VFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJkLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gbWFrZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmRhbGxpYW5jZV9zb3VyY2UgPSBkcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19tYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZGFsbGlhbmNlX21hcHBpbmcgPSBfX21hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaChiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGV2LnRhcmdldC5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnJlbW92ZVRpZXIoZXYudGFyZ2V0LmRhbGxpYW5jZV9zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgbWJvZHkuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0cml4LmFwcGVuZENoaWxkKG1ib2R5KTtcbiAgICAgICAgICAgICAgICB0dGFiLmFwcGVuZENoaWxkKG1ha2VUcmVlVGFibGVTZWN0aW9uKGdyb3VwLnNob3J0TGFiZWwsIG1hdHJpeCwgZ2k9PTApKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGFiQm9keSA9IG1ha2VFbGVtZW50KCd0Ym9keScsIG51bGwsIHtjbGFzc05hbWU6ICd0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZCd9KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhYiA9IG1ha2VFbGVtZW50KCd0YWJsZScsIHN0YWJCb2R5LCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSwge3dpZHRoOiAnMTAwJScsIHRhYmxlTGF5b3V0OiAnZml4ZWQnfSk7IFxuICAgICAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZ3JvdXAuY2hpbGRyZW4uc29ydChUSFVCX0NPTVBBUkUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gZ3JvdXAuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcyA9IHRyYWNrLnRvRGFsbGlhbmNlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG1ha2VFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmQgPSBtYWtlRWxlbWVudCgndGQnLCBudWxsLCB7fSwge3dpZHRoOiAnMzBweCd9KTtcbiAgICAgICAgICAgICAgICAgICAgYmQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG1ha2VFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICBiLnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgICAgICAgICBiLmRhbGxpYW5jZV9zb3VyY2UgPSBkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fbWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5kYWxsaWFuY2VfbWFwcGluZyA9IF9fbWFwcGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goYik7XG4gICAgICAgICAgICAgICAgICAgIGJkLmFwcGVuZENoaWxkKGIpO1xuICAgICAgICAgICAgICAgICAgICBiLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGV2LnRhcmdldC5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IucmVtb3ZlVGllcihldi50YXJnZXQuZGFsbGlhbmNlX3NvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHIuYXBwZW5kQ2hpbGQoYmQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGQgPSBtYWtlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgbGQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodHJhY2suc2hvcnRMYWJlbCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2subG9uZ0xhYmVsICYmIHRyYWNrLmxvbmdMYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5tYWtlVG9vbHRpcChsZCwgdHJhY2subG9uZ0xhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByLmFwcGVuZENoaWxkKGxkKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYkJvZHkuYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgICAgICAgICAgICsraWR4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoID4gMSB8fCBncm91cC5zaG9ydExhYmVsICE9PSAnT3RoZXJzJykge1xuICAgICAgICAgICAgICAgICAgICB0dGFiLmFwcGVuZENoaWxkKG1ha2VUcmVlVGFibGVTZWN0aW9uKGdyb3VwLnNob3J0TGFiZWwsIHN0YWIsIGdpPT0wKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHRhYi5hcHBlbmRDaGlsZChzdGFiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0Q2hlY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYnV0dG9ucy5sZW5ndGg7ICsrYmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGJ1dHRvbnNbYmldO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpc0IuY3VycmVudGx5QWN0aXZlKGIuZGFsbGlhbmNlX3NvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYi5kaXNhYmxlZCA9IHQuc2VxdWVuY2VTb3VyY2UgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2hlY2tzKCk7XG4gICAgICAgIHRoaXNCLmFkZFRpZXJMaXN0ZW5lcihmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICBzZXRDaGVja3MoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKHR0YWIpO1xuICAgIH1cblxuICAgIGlmIChyZWdCdXR0b24pIHtcbiAgICAgICAgcmVnQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYWN0aXZhdGVCdXR0b24oYWRkTW9kZUJ1dHRvbnMsIHJlZ0J1dHRvbik7XG4gICAgICAgICAgICBtYWtlU3RhYih0aGlzQi5hdmFpbGFibGVTb3VyY2VzKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiBcbiAgICBiaW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc3dpdGNoVG9CaW5Nb2RlKCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGFkZEh1YkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCk7XG4gICAgfSwgZmFsc2UpO1xuXG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hUb0Jpbk1vZGUoKSB7XG4gICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBiaW5CdXR0b24pO1xuICAgICAgICBjdXN0b21Nb2RlID0gJ2Jpbic7XG5cbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgdmFyIHBhZ2VIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge30sIHtwYWRkaW5nTGVmdDogJzEwcHgnLCBwYWRkaW5nUmlnaHQ6ICcxMHB4J30pO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMycsICdBZGQgY3VzdG9tIFVSTC1iYXNlZCBkYXRhJykpO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgWydZb3UgY2FuIGFkZCBpbmRleGVkIGJpbmFyeSBkYXRhIGhvc3RlZCBvbiBhbiB3ZWIgc2VydmVyIHRoYXQgc3VwcG9ydHMgQ09SUyAoJywgbWFrZUVsZW1lbnQoJ2EnLCAnZnVsbCBkZXRhaWxzJywge2hyZWY6ICdodHRwOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvYmluLmh0bWwnfSksICcpLiAgQ3VycmVudGx5IHN1cHBvcnRlZCBmb3JtYXRzIGFyZSBiaWd3aWcsIGJpZ2JlZCwgYW5kIGluZGV4ZWQgQkFNLiddKSk7XG5cbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnYnInKSk7XG4gICAgICAgIHBhZ2VIb2xkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1VSTDogJykpO1xuICAgICAgICBjdXN0VVJMID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgJycsIHtzaXplOiA4MCwgdmFsdWU6ICdodHRwOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvZGF0YXNldHMvZW5zR2VuZS5iYid9LCB7d2lkdGg6ICcxMDAlJ30pO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKGN1c3RVUkwpO1xuICAgICAgICBcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnYnInKSk7XG4gICAgICAgIHBhZ2VIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2InLCAnLSBvciAtJykpO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdicicpKTtcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnRmlsZTogJykpO1xuICAgICAgICBjdXN0RmlsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnZmlsZScsIG11bHRpcGxlOiAnbXVsdGlwbGUnfSk7XG4gICAgICAgIHBhZ2VIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdEZpbGUpO1xuICAgICAgICBcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdDbGlja2luZyB0aGUgXCJBZGRcIiBidXR0b24gYmVsb3cgd2lsbCBpbml0aWF0ZSBhIHNlcmllcyBvZiB0ZXN0IHF1ZXJpZXMuJykpO1xuXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQocGFnZUhvbGRlcik7XG4gICAgICAgIGN1c3RVUkwuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCkge1xuICAgICAgICBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgYWRkSHViQnV0dG9uKTtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBjdXN0b21Nb2RlID0gJ2h1Yi1jb25uZWN0JztcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG5cbiAgICAgICAgdmFyIHBhZ2VIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge30sIHtwYWRkaW5nTGVmdDogJzEwcHgnLCBwYWRkaW5nUmlnaHQ6ICcxMHB4J30pO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMycsICdDb25uZWN0IHRvIGEgdHJhY2sgaHViLicpKTtcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFsnRW50ZXIgdGhlIHRvcC1sZXZlbCBVUkwgKHVzdWFsbHkgcG9pbnRzIHRvIGEgZmlsZSBjYWxsZWQgXCJodWIudHh0XCIpIG9mIGEgVUNTQy1zdHlsZSB0cmFjayBodWInXSkpO1xuICAgICAgICBcbiAgICAgICAgY3VzdFVSTCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7c2l6ZTogMTIwLCB2YWx1ZTogJ2h0dHA6Ly93d3cuYmlvZGFsbGlhbmNlLm9yZy9kYXRhc2V0cy90ZXN0aHViL2h1Yi50eHQnfSwge3dpZHRoOiAnMTAwJSd9KTtcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChjdXN0VVJMKTtcbiAgICAgICAgXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQocGFnZUhvbGRlcik7XG4gICAgICAgIFxuICAgICAgICBjdXN0VVJMLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgY3VzdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzd2l0Y2hUb0N1c3RvbU1vZGUoKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hUb0N1c3RvbU1vZGUoKSB7XG4gICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBjdXN0QnV0dG9uKTtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBjdXN0b21Nb2RlID0gJ2Rhcyc7XG5cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG5cbiAgICAgICAgdmFyIGN1c3RvbUZvcm0gPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge30sICB7cGFkZGluZ0xlZnQ6ICcxMHB4JywgcGFkZGluZ1JpZ2h0OiAnMTBweCd9KTtcbiAgICAgICAgY3VzdG9tRm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDMnLCAnQWRkIGN1c3RvbSBEQVMgZGF0YScpKTtcbiAgICAgICAgY3VzdG9tRm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdUaGlzIGludGVyZmFjZSBpcyBpbnRlbmRlZCBmb3IgYWRkaW5nIGN1c3RvbSBvciBsYWItc3BlY2lmaWMgZGF0YS4gIFB1YmxpYyBkYXRhIGNhbiBiZSBhZGRlZCBtb3JlIGVhc2lseSB2aWEgdGhlIHJlZ2lzdHJ5IGludGVyZmFjZS4nKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIGN1c3RvbUZvcm0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1VSTDogJykpO1xuICAgICAgICBjdXN0b21Gb3JtLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdicicpKTtcbiAgICAgICAgY3VzdFVSTCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7c2l6ZTogODAsIHZhbHVlOiAnaHR0cDovL3d3dy5kZXJraG9sbS5uZXQ6ODA4MC9kYXMvbWVkaXBzZXFfcmVhZHMvJ30sIHt3aWR0aDogJzEwMCUnfSk7XG4gICAgICAgIGN1c3RvbUZvcm0uYXBwZW5kQ2hpbGQoY3VzdFVSTCk7XG5cbiAgICAgICAgY3VzdG9tRm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdDbGlja2luZyB0aGUgXCJBZGRcIiBidXR0b24gYmVsb3cgd2lsbCBpbml0aWF0ZSBhIHNlcmllcyBvZiB0ZXN0IHF1ZXJpZXMuICBJZiB0aGUgc291cmNlIGlzIHBhc3N3b3JkLXByb3RlY3RlZCwgeW91IG1heSBiZSBwcm9tcHRlZCB0byBlbnRlciBjcmVkZW50aWFscy4nKSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdG9tRm9ybSk7XG5cbiAgICAgICAgY3VzdFVSTC5mb2N1cygpO1xuICAgIH1cblxuXG5cbiAgICB2YXIgYWRkQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2J1dHRvbicsICdBZGQnLCB7Y2xhc3NOYW1lOiAnYnRuIGJ0bi1wcmltYXJ5J30pO1xuICAgIGFkZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkb0FkZCgpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIGZ1bmN0aW9uIGRvQWRkKCkge1xuICAgICAgICBpZiAoY3VzdG9tTW9kZSkge1xuICAgICAgICAgICAgaWYgKGN1c3RvbU1vZGUgPT09ICdkYXMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cmkgPSBjdXN0VVJMLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIS9eLis6XFwvXFwvLy5leGVjKGN1cmkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cmkgPSAnaHR0cDovLycgKyBjdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmRzID0gbmV3IERBU1NvdXJjZSh7bmFtZTogJ3RlbXBvcmFyeScsIHVyaTogY3VyaX0pO1xuICAgICAgICAgICAgICAgIHRyeUFkZERBUyhuZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAnYmluJykge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTGlzdCA9IGN1c3RGaWxlLmZpbGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVMaXN0ICYmIGZpbGVMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5QWRkTXVsdGlwbGUoZmlsZUxpc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJpID0gY3VzdFVSTC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghL14uKzpcXC9cXC8vLmV4ZWMoY3VyaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cmkgPSAnaHR0cDovLycgKyBjdXJpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB7dXJpOiBjdXJpfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxjdXJpID0gY3VyaS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGN1cmkuaW5kZXhPZihcImh0dHBzOi8vd3d3LmVuY29kZXByb2plY3Qub3JnL1wiKSA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsY3VyaS5pbmRleE9mKFwiQEBkb3dubG9hZFwiKSA+PSAwKSBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLnRyYW5zcG9ydCA9ICdlbmNvZGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeUFkZEJpbihzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tTW9kZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgICAgICAgICAgIHN3aXRjaFRvQ3VzdG9tTW9kZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAncmVzZXQtYmluJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaFRvQmluTW9kZSgpOyBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tTW9kZSA9PT0gJ3Jlc2V0LWh1YicpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbU1vZGUgPT09ICdwcm9tcHQtYmFpJykge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTGlzdCA9IGN1c3RGaWxlLmZpbGVzO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTGlzdCAmJiBmaWxlTGlzdC5sZW5ndGggPiAwICYmIGZpbGVMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLmJhaUJsb2IgPSBmaWxlTGlzdFswXTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVCQU0oZGF0YVRvRmluYWxpemUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21wdEZvckJBSShkYXRhVG9GaW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAncHJvbXB0LXRiaScpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUxpc3QgPSBjdXN0RmlsZS5maWxlcztcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUxpc3QgJiYgZmlsZUxpc3QubGVuZ3RoID4gMCAmJiBmaWxlTGlzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVG9GaW5hbGl6ZS5pbmRleEJsb2IgPSBmaWxlTGlzdFswXTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVUYWJpeFZDRihkYXRhVG9GaW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0Rm9yVGFiaXgoZGF0YVRvRmluYWxpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tTW9kZSA9PT0gJ2ZpbmFsaXplJyB8fCBjdXN0b21Nb2RlID09PSAnZmluYWxpemUtYmluJykge1xuICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLm5hbWUgPSBjdXN0TmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGN1c3RDUy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobSAhPSAnX19kZWZhdWx0X18nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLm1hcHBpbmcgPSBtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLm1hcHBpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXN0UXVhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRvRmluYWxpemUubWF4YmlucyA9IGN1c3RRdWFudC5jaGVja2VkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXN0VXNlci52YWx1ZS5sZW5ndGggPiAxICYmIGN1c3RQYXNzLnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRvRmluYWxpemUueFVzZXIgPSBjdXN0VXNlci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRvRmluYWxpemUueFBhc3MgPSBjdXN0UGFzcy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGRhdGFUb0ZpbmFsaXplKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Nb2RlID09ICdmaW5hbGl6ZS1iaW4nKVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUb0Jpbk1vZGUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvQ3VzdG9tTW9kZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAnaHViLWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cmkgPSBjdXN0VVJMLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIS9eLis6XFwvXFwvLy5leGVjKGN1cmkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cmkgPSAnaHR0cDovLycgKyBjdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnlBZGRIdWIoY3VyaSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbU1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtaSA9IDA7IG1pIDwgbXVsdGlwbGVTZXQubGVuZ3RoOyArK21pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbXVsdGlwbGVTZXRbbWldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5oaWRkZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT0gJ2JhbScgJiYgIXMuaW5kZXhCbG9iICYmICFzLmluZGV4VXJpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnRpZXJfdHlwZSA9PSAndGFiaXgnICYmICFzLmluZGV4QmxvYiAmJiAhcy5pbmRleFVyaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZHMgPSBtYWtlU291cmNlQ29uZmlnKHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZHMubm9QZXJzaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmFkZFRpZXIobmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaFRvQmluTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc0IucmVtb3ZlQWxsUG9wdXBzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJ5QWRkSHViKGN1cmksIG9wdHMsIHJldHJ5KSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpc0IuaHViT2JqZWN0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgIHZhciBoID0gdGhpc0IuaHViT2JqZWN0c1toaV07XG4gICAgICAgICAgICBpZiAoaC5odWIudXJsID09IGN1cmkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYWRkTW9kZUJ1dHRvbnMubGVuZ3RoOyArK2JpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRNb2RlQnV0dG9uc1tiaV0uaHViID09IGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBhZGRNb2RlQnV0dG9uc1tiaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGguZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFrZUh1YlN0YWIodHJhY2tzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29ubmVjdFRyYWNrSHViKGN1cmksIGZ1bmN0aW9uKGh1YiwgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5QWRkSHViKGN1cmksIHtjcmVkZW50aWFsczogdHJ1ZX0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMicsICdFcnJvciBjb25uZWN0aW5nIHRvIHRyYWNrIGh1YicpKVxuICAgICAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3AnLCBlcnIpKTtcbiAgICAgICAgICAgICAgICBjdXN0b21Nb2RlID0gJ3Jlc2V0LWh1Yic7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVzdEh1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGJlc3RIdWJCdXR0b24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGdlbm9tZSBpbiBodWIuZ2Vub21lcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBva2F5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbm9tZSA9PSB0aGlzQi5jb29yZFN5c3RlbS51Y3NjTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2theSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbWlkIGluIHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpc0IuY2hhaW5zW21pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbm9tZSA9PSBtLmNvb3Jkcy51Y3NjTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBva2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9rYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYyA9IHt1cmw6IGN1cmksIGdlbm9tZTogZ2Vub21lfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhjLmNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGMubWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHViLmdlbm9tZXNbZ2Vub21lXS5tYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmh1YnMucHVzaChoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5odWJPYmplY3RzLnB1c2goaHViLmdlbm9tZXNbZ2Vub21lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodWJCdXR0b24gPSBtYWtlSHViQnV0dG9uKGh1Yi5nZW5vbWVzW2dlbm9tZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZUJ1dHRvbkhvbGRlci5hcHBlbmRDaGlsZChodWJCdXR0b24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcHBpbmcgfHwgIWJlc3RIdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0SHViID0gaHViLmdlbm9tZXNbZ2Vub21lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0SHViQnV0dG9uID0gaHViQnV0dG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJlc3RIdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllcigpO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgYmVzdEh1YkJ1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RIdWIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlSHViU3RhYih0cmFja3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDInLCAnTm8gZGF0YSBmb3IgdGhpcyBnZW5vbWUnKSlcbiAgICAgICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdUaGlzIFVSTCBhcHBlYXJzIHRvIGJlIGEgdmFsaWQgdHJhY2staHViLCBidXQgaXQgZG9lc25cXCd0IGNvbnRhaW4gYW55IGRhdGEgZm9yIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGlzIGJyb3dzZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3AnLCAnY29vcmRTeXN0ZW0udWNzY05hbWUgPSAnICsgdGhpc0IuY29vcmRTeXN0ZW0udWNzY05hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tTW9kZSA9ICdyZXNldC1odWInO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgdHJ5QWRkREFTID0gZnVuY3Rpb24obmRzLCByZXRyeSkge1xuICAgICAgICB2YXIga25vd25TcGFjZSA9IHRoaXNCLmtub3duU3BhY2U7XG4gICAgICAgIGlmICgha25vd25TcGFjZSkge1xuICAgICAgICAgICAgYWxlcnQoXCJDYW4ndCBjb25maXJtIHRyYWNrLWFkZGl0aW9uIHRvIGFuIHVuaW5pdCBicm93c2VyLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHNtID0gTWF0aC5tYXgoa25vd25TcGFjZS5taW4sIChrbm93blNwYWNlLm1pbiArIGtub3duU3BhY2UubWF4IC0gMTAwKSAvIDIpfDA7XG4gICAgICAgIHZhciB0ZXN0U2VnbWVudCA9IG5ldyBEQVNTZWdtZW50KGtub3duU3BhY2UuY2hyLCB0c20sIE1hdGgubWluKHRzbSArIDk5LCBrbm93blNwYWNlLm1heCkpO1xuICAgICAgICBuZHMuZmVhdHVyZXModGVzdFNlZ21lbnQsIHt9LCBmdW5jdGlvbihmZWF0dXJlcywgc3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICBuZHMuY3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cnlBZGREQVMobmRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDInLCAnQ3VzdG9tIGRhdGEgbm90IGZvdW5kJykpO1xuICAgICAgICAgICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgJ0RBUyB1cmk6ICcgKyBuZHMudXJpICsgJyBpcyBub3QgYW5zd2VyaW5nIGZlYXR1cmVzIHJlcXVlc3RzJykpO1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21Nb2RlID0gJ3Jlc2V0JztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVFeHRyYWN0UGF0dGVybiA9IG5ldyBSZWdFeHAoJy8oW14vXSspLz8kJyk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbmFtZUV4dHJhY3RQYXR0ZXJuLmV4ZWMobmRzLnVyaSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5kcy5uYW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5QWRkREFTeFNvdXJjZXMobmRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyeUFkZERBU3hTb3VyY2VzKG5kcywgcmV0cnkpIHtcbiAgICAgICAgdmFyIHVyaSA9IG5kcy51cmk7XG4gICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gLyguKylcXC9bXlxcL10rXFwvPy8uZXhlYyh1cmkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdXJpID0gbWF0Y2hbMV0gKyAnL3NvdXJjZXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNxZmFpbCgpIHtcbiAgICAgICAgICAgIGlmICghcmV0cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5QWRkREFTeFNvdXJjZXMobmRzLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZERhc0NvbXBsZXRpb25QYWdlKG5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3IERBU1JlZ2lzdHJ5KHVyaSwge2NyZWRlbnRpYWxzOiBuZHMuY3JlZGVudGlhbHN9KS5zb3VyY2VzKFxuICAgICAgICAgICAgZnVuY3Rpb24oc291cmNlcykge1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlcyB8fCBzb3VyY2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcWZhaWwoKTtcbiAgICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgICAgdmFyIGZzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmcyA9IHNvdXJjZXNbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlc1tpXS51cmkgPT09IG5kcy51cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHNvdXJjZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzRGV0ZXJtaW5lZCA9IGZhbHNlLCBxdWFudERldGVybWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmRzLm5hbWUgPSBmcy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBuZHMuZGVzYyA9IGZzLmRlc2M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcy5tYXhiaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZHMubWF4YmlucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZHMubWF4YmlucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcy5jYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5kcy5jYXBhYmlsaXRpZXMgPSBmcy5jYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcXVhbnREZXRlcm1pbmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmNvb3JkcyAmJiBmcy5jb29yZHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBmcy5jb29yZHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRzTWF0Y2goY29vcmRzLCB0aGlzQi5jb29yZFN5c3RlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpc0IuY2hhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzQi5jaGFpbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3Jkc01hdGNoKGNvb3JkcywgdGhpc0IuY2hhaW5zW2tdLmNvb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5kcy5tYXBwaW5nID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRGFzQ29tcGxldGlvblBhZ2UobmRzLCBjb29yZHNEZXRlcm1pbmVkLCBxdWFudERldGVybWluZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcWZhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbWFrZVNvdXJjZUNvbmZpZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIG5kcyA9IHtuYW1lOiBzLm5hbWV9O1xuICAgICAgICBpZiAocy5jcmVkZW50aWFscylcbiAgICAgICAgICAgIG5kcy5jcmVkZW50aWFscyA9IHMuY3JlZGVudGlhbHM7XG4gICAgICAgIFxuICAgICAgICBpZiAocy5tYXBwaW5nICYmIHMubWFwcGluZyAhPSAnX19kZWZhdWx0X18nKVxuICAgICAgICAgICAgbmRzLm1hcHBpbmcgPSBzLm1hcHBpbmc7XG5cbiAgICAgICAgaWYgKHMudHJhbnNwb3J0KVxuICAgICAgICAgICAgbmRzLnRyYW5zcG9ydCA9IHMudHJhbnNwb3J0O1xuXG4gICAgICAgIGlmIChzLnRpZXJfdHlwZSA9PSAnYndnJykge1xuICAgICAgICAgICAgaWYgKHMuYmxvYilcbiAgICAgICAgICAgICAgICBuZHMuYndnQmxvYiA9IHMuYmxvYjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHMudXJpKVxuICAgICAgICAgICAgICAgIG5kcy5id2dVUkkgPSBzLnVyaTtcbiAgICAgICAgICAgIHJldHVybiBuZHM7XG4gICAgICAgIH0gZWxzZSBpZiAocy50aWVyX3R5cGUgPT0gJ2JhbScpIHtcbiAgICAgICAgICAgIGlmIChzLmJsb2IpIHtcbiAgICAgICAgICAgICAgICBuZHMuYmFtQmxvYiA9IHMuYmxvYjtcbiAgICAgICAgICAgICAgICBuZHMuYmFpQmxvYiA9IHMuaW5kZXhCbG9iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZHMuYmFtVVJJID0gcy51cmk7XG4gICAgICAgICAgICAgICAgbmRzLmJhaVVSSSA9IHMuaW5kZXhVcmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmRzO1xuICAgICAgICB9IGVsc2UgaWYgKHMudGllcl90eXBlID09ICd0YWJpeCcpIHtcbiAgICAgICAgICAgIG5kcy50aWVyX3R5cGUgPSAndGFiaXgnO1xuICAgICAgICAgICAgbmRzLnBheWxvYWQgPSBzLnBheWxvYWQ7XG4gICAgICAgICAgICBpZiAocy5ibG9iKSB7XG4gICAgICAgICAgICAgICAgbmRzLmJsb2IgPSBzLmJsb2I7XG4gICAgICAgICAgICAgICAgbmRzLmluZGV4QmxvYiA9IHMuaW5kZXhCbG9iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZHMudXJpID0gcy51cmk7XG4gICAgICAgICAgICAgICAgbmRzLmluZGV4VXJpID0gcy5pbmRleFVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZHM7XG4gICAgICAgIH0gZWxzZSBpZiAocy50aWVyX3R5cGUgPT0gJ21lbXN0b3JlJykge1xuICAgICAgICAgICAgbmRzLnRpZXJfdHlwZSA9ICdtZW1zdG9yZSc7XG4gICAgICAgICAgICBuZHMucGF5bG9hZCA9IHMucGF5bG9hZDtcbiAgICAgICAgICAgIGlmIChzLmJsb2IpXG4gICAgICAgICAgICAgICAgbmRzLmJsb2IgPSBzLmJsb2I7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbmRzLnVyaSA9IHMudXJpO1xuICAgICAgICAgICAgcmV0dXJuIG5kcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cnlBZGRCaW4gPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcHJvYmVSZXNvdXJjZShzb3VyY2UsIGZ1bmN0aW9uKHNvdXJjZSwgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG4gICAgICAgICAgICAgICAgdmFyIHRhYkVycm9yID0gbWFrZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHRhYkVycm9yLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMicsIFwiQ291bGRuJ3QgYWNjZXNzIGN1c3RvbSBkYXRhXCIpKTtcbiAgICAgICAgICAgICAgICB0YWJFcnJvci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICcnICsgZXJyKSk7XG4gICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZCh0YWJFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiBzb3VyY2UudXJpLmluZGV4T2YoJ2h0dHA6JykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5jYW5GZXRjaFBsYWluSFRUUCgpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJFcnJvci5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCdwJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCdzdHJvbmcnLCAnSFRUUCB3YXJuaW5nOiAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAneW91IG1heSBub3QgYmUgYWJsZSB0byBhY2Nlc3MgSFRUUCByZXNvdXJjZXMgZnJvbSBhbiBpbnN0YW5jZSBvZiBCaW9kYWxsaWFuY2Ugd2hpY2ggeW91IGFyZSBhY2Nlc3NpbmcgdmlhIEhUVFBTLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ2EnLCAnW01vcmUgaW5mb10nLCB7aHJlZjogdGhpc0IuaHR0cFdhcm5pbmdVUkwsIHRhcmdldDogXCJfYmxhbmtcIn0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VzdG9tTW9kZSA9ICdyZXNldC1iaW4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmRzID0gbWFrZVNvdXJjZUNvbmZpZyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UudGllcl90eXBlID09ICdiYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZUJBTShuZHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnRpZXJfdHlwZSA9PSAndGFiaXgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVRhYml4VkNGKG5kcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZERhc0NvbXBsZXRpb25QYWdlKG5kcywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb21wdEZvckJBSShuZHMpIHtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKHN0YWJIb2xkZXIpO1xuICAgICAgICBjdXN0b21Nb2RlID0gJ3Byb21wdC1iYWknXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ1NlbGVjdCBhbiBpbmRleCBmaWxlJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgJ0RhbGxpYW5jZSByZXF1aXJlcyBhIEJBTSBpbmRleCAoLmJhaSkgZmlsZSB3aGVuIGRpc3BsYXlpbmcgQkFNIGRhdGEuICBUaGVzZSBub3JtYWxseSBhY2NvbXBhbnkgQkFNIGZpbGVzLiAgRm9yIHNlY3VyaXR5IHJlYXNvbnMsIHdlYiBhcHBsaWNhdGlvbnMgbGlrZSBEYWxsaWFuY2UgY2FuIG9ubHkgYWNjZXNzIGxvY2FsIGZpbGVzIHdoaWNoIHlvdSBoYXZlIGV4cGxpY2l0eSBzZWxlY3RlZC4gIFBsZWFzZSB1c2UgdGhlIGZpbGUgY2hvb3NlciBiZWxvdyB0byBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIEJBSSBmaWxlJykpO1xuXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0luZGV4IGZpbGU6ICcpKTtcbiAgICAgICAgY3VzdEZpbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2ZpbGUnfSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdEZpbGUpO1xuICAgICAgICBkYXRhVG9GaW5hbGl6ZSA9IG5kcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9tcHRGb3JUYWJpeChuZHMpIHtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKHN0YWJIb2xkZXIpO1xuICAgICAgICBjdXN0b21Nb2RlID0gJ3Byb21wdC10YmknXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ1NlbGVjdCBhbiBpbmRleCBmaWxlJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgJ0RhbGxpYW5jZSByZXF1aXJlcyBhIFRhYml4IGluZGV4ICgudGJpKSBmaWxlIHdoZW4gZGlzcGxheWluZyBWQ0YgZGF0YS4gIEZvciBzZWN1cml0eSByZWFzb25zLCB3ZWIgYXBwbGljYXRpb25zIGxpa2UgRGFsbGlhbmNlIGNhbiBvbmx5IGFjY2VzcyBsb2NhbCBmaWxlcyB3aGljaCB5b3UgaGF2ZSBleHBsaWNpdHkgc2VsZWN0ZWQuICBQbGVhc2UgdXNlIHRoZSBmaWxlIGNob29zZXIgYmVsb3cgdG8gc2VsZWN0IHRoZSBhcHByb3ByaWF0ZSBCQUkgZmlsZScpKTtcblxuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdJbmRleCBmaWxlOiAnKSk7XG4gICAgICAgIGN1c3RGaWxlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdmaWxlJ30pO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGN1c3RGaWxlKTtcbiAgICAgICAgZGF0YVRvRmluYWxpemUgPSBuZHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVCQU0obmRzKSB7XG4gICAgICAgIHZhciBpbmRleEY7XG4gICAgICAgIGlmIChuZHMuYmFpQmxvYikgXG4gICAgICAgICAgICBpbmRleEYgPSBuZXcgQmxvYkZldGNoYWJsZShuZHMuYmFpQmxvYik7XG4gICAgICAgIGVsc2UgaWYgKG5kcy50cmFuc3BvcnQgPT0gJ2VuY29kZScpXG4gICAgICAgICAgICBpbmRleEYgPSBuZXcgRW5jb2RlRmV0Y2hhYmxlKG5kcy5iYW1VUkkgKyAnLmJhaScpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpbmRleEYgPSBuZXcgVVJMRmV0Y2hhYmxlKG5kcy5iYW1VUkkgKyAnLmJhaScsIHtjcmVkZW50aWFsczogbmRzLmNyZWRlbnRpYWxzfSk7XG5cbiAgICAgICAgaW5kZXhGLnNsaWNlKDAsIDI1NikuZmV0Y2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHZhciBoYXNCQUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hZ2ljMiA9IHJlYWRJbnQoYmEsIDApO1xuICAgICAgICAgICAgICAgICAgICBoYXNCQUkgPSAobWFnaWMyID09IEJBSV9NQUdJQyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNCQUkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZERhc0NvbXBsZXRpb25QYWdlKG5kcywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluRm9ybWF0RXJyb3JQYWdlKCdZb3UgaGF2ZSBzZWxlY3RlZCBhIHZhbGlkIEJBTSBmaWxlLCBidXQgYSBjb3JyZXNwb25kaW5nIGluZGV4ICguYmFpKSBmaWxlIHdhcyBub3QgZm91bmQuICBQbGVhc2UgaW5kZXggeW91ciBCQU0gKHNhbXRvb2xzIGluZGV4KSBhbmQgcGxhY2UgdGhlIEJBSSBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVUYWJpeFZDRihuZHMpIHtcbiAgICAgICAgdmFyIGluZGV4RjtcbiAgICAgICAgaWYgKG5kcy5pbmRleEJsb2IpIHtcbiAgICAgICAgICAgIGluZGV4RiA9IG5ldyBCbG9iRmV0Y2hhYmxlKG5kcy5pbmRleEJsb2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhGID0gbmV3IFVSTEZldGNoYWJsZShuZHMudXJpICsgJy50YmknKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleEYuc2xpY2UoMCwgMTw8MTYpLmZldGNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHZhciBoYXNUYWJpeCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFbMF0gPT0gMzEgfHwgYmFbMV0gPT0gMTM5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmMgPSB1bmJnemYocik7XG4gICAgICAgICAgICAgICAgICAgIGJhID0gbmV3IFVpbnQ4QXJyYXkodW5jKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0yID0gcmVhZEludChiYSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1RhYml4ID0gKG0yID09IFRBQklYX01BR0lDKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVGFiaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRGFzQ29tcGxldGlvblBhZ2UobmRzLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluRm9ybWF0RXJyb3JQYWdlKCdZb3UgaGF2ZSBzZWxlY3RlZCBhIHZhbGlkIFZDRiBmaWxlLCBidXQgYSBjb3JyZXNwb25kaW5nIGluZGV4ICgudGJpKSBmaWxlIHdhcyBub3QgZm91bmQuICBQbGVhc2UgaW5kZXggeW91ciBWQ0YgKFwidGFiaXggLXAgdmNmIC1mIG15ZmlsZS52Y2YuZ3pcIikgYW5kIHBsYWNlIHRoZSAudGJpIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbkZvcm1hdEVycm9yUGFnZShtZXNzYWdlKSB7XG4gICAgICAgIHJlZnJlc2hCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYWRkQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgY2FuQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0N1c3RvbSBkYXRhIGZvcm1hdCBub3QgcmVjb2duaXplZCc7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ0Vycm9yIGFkZGluZyBjdXN0b20gZGF0YScpKTtcbiAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIG1lc3NhZ2UpKTtcbiAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdDdXJyZW50bHkgc3VwcG9ydGVkIGZvcm1hdHMgYXJlIGJpZ0JlZCwgYmlnV2lnLCBhbmQgQkFNLicpKTtcbiAgICAgICAgY3VzdG9tTW9kZSA9ICdyZXNldC1iaW4nO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgICAgICAgICAgICAgICAgICAgXG4gICAgdmFyIGFkZERhc0NvbXBsZXRpb25QYWdlID0gZnVuY3Rpb24obmRzLCBjb29yZHNEZXRlcm1pbmVkLCBxdWFudERldGVybWluZWQsIHF1YW50SXJyZWxldmFudCkge1xuICAgICAgICByZWZyZXNoQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGFkZEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGNhbkJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG5cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ0FkZCBjdXN0b20gZGF0YTogc3RlcCAyJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdMYWJlbDogJykpO1xuICAgICAgICBjdXN0TmFtZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7dmFsdWU6IG5kcy5uYW1lfSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdE5hbWUpO1xuXG5cbiAgICAgICAgLy8gc3RhYkhvbGRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVXNlcjogJykpO1xuICAgICAgICBjdXN0VXNlciA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnKTtcbiAgICAgICAgLy8gc3RhYkhvbGRlci5hcHBlbmRDaGlsZChjdXN0VXNlcik7XG4gICAgICAgIC8vc3RhYkhvbGRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnUGFzczogJykpO1xuICAgICAgICBjdXN0UGFzcyA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnKTtcbiAgICAgICAgLy8gc3RhYkhvbGRlci5hcHBlbmRDaGlsZChjdXN0UGFzcyk7XG4gICAgICAgIFxuXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdicicpKTtcbiAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDQnLCAnQ29vcmRpbmF0ZSBzeXN0ZW06ICcpKTtcbiAgICAgICAgY3VzdENTID0gbWFrZUVsZW1lbnQoJ3NlbGVjdCcsIG51bGwpO1xuICAgICAgICBjdXN0Q1MuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsIHRoaXNCLm5hbWVGb3JDb29yZFN5c3RlbSh0aGlzQi5jb29yZFN5c3RlbSksIHt2YWx1ZTogJ19fZGVmYXVsdF9fJ30pKTtcbiAgICAgICAgaWYgKHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgZm9yICh2YXIgY3NrIGluIHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgICAgIHZhciBjcyA9IHRoaXNCLmNoYWluc1tjc2tdLmNvb3JkcztcbiAgICAgICAgICAgICAgICBjdXN0Q1MuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsIHRoaXNCLm5hbWVGb3JDb29yZFN5c3RlbShjcyksIHt2YWx1ZTogY3NrfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1c3RDUy52YWx1ZSA9IG5kcy5tYXBwaW5nIHx8ICdfX2RlZmF1bHRfXyc7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdENTKTtcblxuICAgICAgICBpZiAoY29vcmRzRGV0ZXJtaW5lZCkge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFwiKEJhc2VkIG9uIHNlcnZlciByZXNwb25zZSwgcHJvYmFibHkgZG9lc24ndCBuZWVkIGNoYW5naW5nLilcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFttYWtlRWxlbWVudCgnYicsICdXYXJuaW5nOiAnKSwgXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZhbHVlIGZyb20gc2VydmVyIHJlc3BvbnNlcy4gIFBsZWFzZSBjaGVjayBjYXJlZnVsbHkuXCJdKSk7XG4gICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgXCJJZiB5b3UgZG9uJ3Qgc2VlIHRoZSBtYXBwaW5nIHlvdSdyZSBsb29raW5nIGZvciwgcGxlYXNlIGNvbnRhY3QgdGhvbWFzQGJpb2RhbGxpYW5jZS5vcmdcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFxdWFudElycmVsZXZhbnQpIHtcbiAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1F1YW50aXRhdGl2ZTogJykpO1xuICAgICAgICAgICAgY3VzdFF1YW50ID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdjaGVja2JveCcsIGNoZWNrZWQ6IHRydWV9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmRzLm1heGJpbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY3VzdFF1YW50LmNoZWNrZWQgPSBuZHMubWF4YmlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdFF1YW50KTtcbiAgICAgICAgICAgIGlmIChxdWFudERldGVybWluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgXCIoQmFzZWQgb24gc2VydmVyIHJlc3BvbnNlLCBwcm9iYWJseSBkb2Vzbid0IG5lZWQgY2hhbmdpbmcuKVwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3AnLCBbbWFrZUVsZW1lbnQoJ2InLCBcIldhcm5pbmc6IFwiKSwgXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgdmFsdWUuICBJZiBpbiBkb3VidCwgbGVhdmUgY2hlY2tlZC5cIl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZHMuYndnQmxvYikge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFttYWtlRWxlbWVudCgnYicsICdXYXJuaW5nOiAnKSwgJ2RhdGEgYWRkZWQgZnJvbSBsb2NhbCBmaWxlLiAgRHVlIHRvIHRoZSBicm93c2VyIHNlY3VyaXR5IG1vZGVsLCB0aGUgdHJhY2sgd2lsbCBkaXNhcHBlYXIgaWYgeW91IHJlbG9hZCBEYWxsaWFuY2UuJ10pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1c3ROYW1lLmZvY3VzKCk7XG5cbiAgICAgICAgaWYgKGN1c3RvbU1vZGUgPT09ICdiaW4nIHx8IGN1c3RvbU1vZGUgPT09ICdwcm9tcHQtYmFpJyB8fCBjdXN0b21Nb2RlID09PSAncHJvbXB0LXRiaScpXG4gICAgICAgICAgICBjdXN0b21Nb2RlID0gJ2ZpbmFsaXplLWJpbic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN1c3RvbU1vZGUgPSAnZmluYWxpemUnO1xuICAgICAgICBkYXRhVG9GaW5hbGl6ZSA9IG5kcztcbiAgICB9XG5cbiAgICB2YXIgbXVsdGlwbGVTZXQgPSBudWxsO1xuICAgIHZhciB0cnlBZGRNdWx0aXBsZSA9IGZ1bmN0aW9uKGZpbGVMaXN0KSB7XG4gICAgICAgIHZhciBuZXdTb3VyY2VzID0gbXVsdGlwbGVTZXQgPSBbXTtcbiAgICAgICAgY3VzdG9tTW9kZSA9ICdtdWx0aXBsZSc7XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmaWxlTGlzdC5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmlsZUxpc3RbZmldO1xuICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICBuZXdTb3VyY2VzLnB1c2goe2Jsb2I6IGZ9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBuZXdTb3VyY2VzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgcHJvYmVNdWx0aXBsZShuZXdTb3VyY2VzW2ZpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTXVsdGlwbGVTdGF0dXMoKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvYmVNdWx0aXBsZSA9IGZ1bmN0aW9uKG5zKSB7XG4gICAgICAgIHByb2JlUmVzb3VyY2UobnMsIGZ1bmN0aW9uKHNvdXJjZSwgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdXNlZEluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBiYW1zID0ge30sIHRhYml4ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBtdWx0aXBsZVNldC5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG11bHRpcGxlU2V0W3NpXTtcbiAgICAgICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT0gJ2JhbScgJiYgIXMuaW5kZXhCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhbXNbcy5ibG9iLm5hbWVdID0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMudGllcl90eXBlID09ICd0YWJpeCcgJiYgIXMuaW5kZXhCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYml4ZXNbcy5ibG9iLm5hbWVdID0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBtdWx0aXBsZVNldC5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG11bHRpcGxlU2V0W3NpXTtcbiAgICAgICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT09ICdiYWknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYWlQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnKC4rKVxcXFwuYmFpJCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBiYWlQYXR0ZXJuLmV4ZWMocy5ibG9iLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgYmFtc1ttYXRjaFsxXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbXNbbWF0Y2hbMV1dLmluZGV4QmxvYiA9IHMuYmxvYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRJbmRpY2VzLnB1c2goc2kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzLnRpZXJfdHlwZSA9PT0gJ3RhYml4LWluZGV4Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGJpUGF0dGVybiA9IG5ldyBSZWdFeHAoJyguKylcXFxcLnRiaSQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdGJpUGF0dGVybi5leGVjKHMuYmxvYi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIHRhYml4ZXNbbWF0Y2hbMV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJpeGVzW21hdGNoWzFdXS5pbmRleEJsb2IgPSBzLmJsb2I7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkSW5kaWNlcy5wdXNoKHNpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgYmkgPSB1c2VkSW5kaWNlcy5sZW5ndGggLSAxOyBiaSA+PSAwOyAtLWJpKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGVTZXQuc3BsaWNlKHVzZWRJbmRpY2VzW2JpXSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZU11bHRpcGxlU3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVNdWx0aXBsZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgdmFyIG5lZWRzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgdmFyIG11bHRUYWJsZSA9IG1ha2VFbGVtZW50KCd0YWJsZScsIG11bHRpcGxlU2V0XG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzKSB7cmV0dXJuICFzLmhpZGRlbn0pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gbWFrZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3RkJywgcy5uYW1lIHx8IHMuYmxvYi5uYW1lKSk7XG4gICAgICAgICAgICB2YXIgdHlwZUNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAocy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHR5cGVDb250ZW50ID0gbWFrZUVsZW1lbnQoJ3NwYW4nLCAnRXJyb3InLCBudWxsLCB7Y29sb3I6ICdyZWQnfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMudGllcl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdHlwZUNvbnRlbnQgPSBzLnBheWxvYWQgfHwgcy50aWVyX3R5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVDb250ZW50ID0gdGhpc0IubWFrZUxvYWRlcigxNik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjY3M7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSAndW5rbm93bic7XG4gICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT0gJ2J3ZycgfHwgcy50aWVyX3R5cGUgPT0gJ21lbXN0b3JlJykge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gJ29rYXknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzLnRpZXJfdHlwZSA9PSAnYmFtJykge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gcy5pbmRleEJsb2IgPyAnb2theScgOiAnbmVlZHMtaW5kZXgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzLnRpZXJfdHlwZSA9PSAndGFiaXgnKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzLmluZGV4QmxvYiA/ICdva2F5JyA6ICduZWVkcy1pbmRleCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PSAnb2theScpIHtcbiAgICAgICAgICAgICAgICBjY3MgPSBtYWtlRWxlbWVudCgnc2VsZWN0JywgbnVsbCwgbnVsbCwge3dpZHRoOiAnMTUwcHgnfSk7XG4gICAgICAgICAgICAgICAgY2NzLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCB0aGlzQi5uYW1lRm9yQ29vcmRTeXN0ZW0odGhpc0IuY29vcmRTeXN0ZW0pLCB7dmFsdWU6ICdfX2RlZmF1bHRfXyd9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjc2sgaW4gdGhpc0IuY2hhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3MgPSB0aGlzQi5jaGFpbnNbY3NrXS5jb29yZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjY3MuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsIHRoaXNCLm5hbWVGb3JDb29yZFN5c3RlbShjcyksIHt2YWx1ZTogY3NrfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNjcy52YWx1ZSA9IHMubWFwcGluZyB8fCAnX19kZWZhdWx0X18nO1xuXG4gICAgICAgICAgICAgICAgY2NzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHMubWFwcGluZyA9IGNjcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocyk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSAnbmVlZHMtaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgY2NzID0gbWFrZUVsZW1lbnQoJ3NwYW4nLCAnTmVlZHMgaW5kZXgnLCB7fSwge2NvbG9yOiAncmVkJ30pO1xuICAgICAgICAgICAgICAgIG5lZWRzSW5kZXggPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFrZUVsZW1lbnQoJ3RyJywgW21ha2VFbGVtZW50KCd0ZCcsIHMubmFtZSB8fCBzLmJsb2IubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIHR5cGVDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgY2NzKV0pO1xuXG4gICAgICAgIH0pLCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobXVsdFRhYmxlKTtcblxuICAgICAgICBpZiAobmVlZHNJbmRleCkge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdTb21lIG9mIHRoZXNlIGZpbGVzIGFyZSBtaXNzaW5nIHJlcXVpcmVkIGluZGV4ICguYmFpIG9yIC50YmkpIGZpbGVzLiAgRm9yIHNlY3VyaXR5IHJlYXNvbnMsIHdlYiBhcHBsaWNhdGlvbnMgbGlrZSBEYWxsaWFuY2UgY2FuIG9ubHkgYWNjZXNzIGxvY2FsIGZpbGVzIHdoaWNoIHlvdSBoYXZlIGV4cGxpY2l0eSBzZWxlY3RlZC4gIFBsZWFzZSB1c2UgdGhlIGZpbGUgY2hvb3NlciBiZWxvdyB0byBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIGluZGV4IGZpbGUnKSk7XG4gICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdJbmRleCBmaWxlKHMpOiAnKSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhGaWxlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdmaWxlJywgbXVsdGlwbGU6ICdtdWx0aXBsZSd9KTtcbiAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoaW5kZXhGaWxlKTtcbiAgICAgICAgICAgIGluZGV4RmlsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaWxlc2V0IGNoYW5nZWQnKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUxpc3QgPSBpbmRleEZpbGUuZmlsZXMgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZpbGVMaXN0Lmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZpbGVMaXN0W2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBucyA9IHtibG9iOiBmLCBoaWRkZW46IHRydWV9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVTZXQucHVzaChucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9iZU11bHRpcGxlKG5zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYW5CdXR0b24gPSBtYWtlRWxlbWVudCgnYnV0dG9uJywgJ0NhbmNlbCcsIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgY2FuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChjdXN0b21Nb2RlID09PSAnZmluYWxpemUtYmluJylcbiAgICAgICAgICAgIHN3aXRjaFRvQmluTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzd2l0Y2hUb0N1c3RvbU1vZGUoKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgcmVmcmVzaEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdidXR0b24nLCAnUmVmcmVzaCcsIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgcmVmcmVzaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzQi5xdWVyeVJlZ2lzdHJ5KF9fbWFwcGluZyk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHRoaXMubWFrZVRvb2x0aXAocmVmcmVzaEJ1dHRvbiwgJ0NsaWNrIHRvIHJlLWZldGNoIGRhdGEgZnJvbSB0aGUgREFTIHJlZ2lzdHJ5Jyk7XG5cbiAgICB2YXIgYnV0dG9uSG9sZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIFthZGRCdXR0b24sICcgJywgY2FuQnV0dG9uLCAnICcsIHJlZnJlc2hCdXR0b25dKTtcbiAgICBidXR0b25Ib2xkZXIuc3R5bGUubWFyZ2luID0gJzEwcHgnO1xuICAgIGFzZm9ybS5hcHBlbmRDaGlsZChidXR0b25Ib2xkZXIpO1xuXG4gICAgcG9wdXAuYXBwZW5kQ2hpbGQoYXNmb3JtKTtcbiAgICBtYWtlU3RhYih0aGlzQi5hdmFpbGFibGVTb3VyY2VzKTtcblxuICAgIHRoaXMuc2hvd1Rvb2xQYW5lbChwb3B1cCk7XG4gICAgdGhpcy5zZXRVaU1vZGUoJ2FkZCcpO1xuXG4gICAgaWYgKGZpcnN0RGVmQnV0dG9uKSB7XG4gICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBmaXJzdERlZkJ1dHRvbik7XG4gICAgICAgIG1ha2VTdGFiKG5ldyBPYnNlcnZlZChmaXJzdERlZlNvdXJjZXMpKTtcbiAgICB9XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gdHJpeC5qczogVUNTQy1zdHlsZSBmcmVlIHRleHQgaW5kaWNlc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGNvbm5lY3RUcml4KGl4LCBpeHgsIGNhbGxiYWNrKSB7XG4gICAgaXh4LmZldGNoQXNUZXh0KGZ1bmN0aW9uKGl4eERhdGEpIHtcbiAgICAgICAgaWYgKCFpeHhEYXRhKSBcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkNvdWxkbid0IGZldGNoIGluZGV4LWluZGV4XCIpO1xuXG4gICAgICAgIHZhciB0b2tzID0gaXh4RGF0YS5zcGxpdCgvKC4rKShbMC05QS1GXXsxMH0pXFxuLyk7XG5cbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdGkgPSAxOyB0aSA8IHRva3MubGVuZ3RoOyB0aSArPSAzKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2godG9rc1t0aV0pO1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlSW50KHRva3NbdGkrMV0sIDE2KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IFRyaXhJbmRleChrZXlzLCBvZmZzZXRzLCBpeCkpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBUcml4SW5kZXgoa2V5cywgb2Zmc2V0cywgaXgpIHtcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgdGhpcy5peCA9IGl4O1xufVxuXG5Ucml4SW5kZXgucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIHZhciBpeHNsaWNlO1xuXG4gICAgdmFyIHF0YWcgPSAocXVlcnkgKyAnICAgICAnKS5zdWJzdHJpbmcoMCw1KS50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChxdGFnLmxvY2FsZUNvbXBhcmUodGhpcy5rZXlzW2ldKSA8IDApIHtcbiAgICAgICAgICAgIGl4c2xpY2UgPSB0aGlzLml4LnNsaWNlKHRoaXMub2Zmc2V0c1tpIC0gMV0sIHRoaXMub2Zmc2V0c1tpXSAtIHRoaXMub2Zmc2V0c1tpIC0gMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWl4c2xpY2UpIHtcbiAgICAgICAgaXhzbGljZSA9IHRoaXMuaXguc2xpY2UodGhpcy5vZmZzZXRzW3RoaXMub2Zmc2V0cy5sZW5ndGggLSAxXSk7XG4gICAgfVxuXG4gICAgaXhzbGljZS5mZXRjaEFzVGV4dChmdW5jdGlvbihpc3QpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gaXN0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IGxpbmVzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICAgICAgaWYgKGxpbmVzW2xpXS5pbmRleE9mKHF1ZXJ5LnRvTG93ZXJDYXNlKCkgKyAnICcpID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobGluZXNbbGldLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9KTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjb25uZWN0VHJpeDogY29ubmVjdFRyaXhcbiAgICB9O1xufSIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyB0d29CaXQuanM6IHBhY2tlZC1iaW5hcnkgcmVmZXJlbmNlIHNlcXVlbmNlc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG4gICAgdmFyIHJlYWRJbnQgPSBiaW4ucmVhZEludDtcbiAgICB2YXIgcmVhZEludEJFID0gYmluLnJlYWRJbnRCRTtcblxuICAgIHZhciBzcGFucyA9IHJlcXVpcmUoJy4vc3BhbnMnKTtcbiAgICB2YXIgUmFuZ2UgPSBzcGFucy5SYW5nZTtcbiAgICB2YXIgdW5pb24gPSBzcGFucy51bmlvbjtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gc3BhbnMuaW50ZXJzZWN0aW9uO1xufVxuXG52YXIgVFdPQklUX01BR0lDID0gMHgxYTQxMjc0MztcbnZhciBUV09CSVRfTUFHSUNfQkUgPSAweDQzMjc0MTFhO1xudmFyIEhFQURFUl9CTE9DS19TSVpFID0gMTI1MDA7XG5cbmZ1bmN0aW9uIFR3b0JpdEZpbGUoKSB7XG59XG5cbmZ1bmN0aW9uIG1ha2VUd29CaXQoZmV0Y2hhYmxlLCBjbnQpIHtcbiAgICB2YXIgdGIgPSBuZXcgVHdvQml0RmlsZSgpO1xuICAgIHRiLmRhdGEgPSBmZXRjaGFibGU7XG4gICAgdmFyIGhlYWRlckJsb2NrU2l6ZSA9IEhFQURFUl9CTE9DS19TSVpFO1xuICAgIHZhciBoZWFkZXJCbG9ja3NGZXRjaGVkPTA7XG4gICAgXG4gICAgdGIuZGF0YS5zbGljZSgwLCBoZWFkZXJCbG9ja1NpemUpLmZldGNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICByZXR1cm4gY250KG51bGwsIFwiQ291bGRuJ3QgYWNjZXNzIGRhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkocik7XG4gICAgICAgIHZhciBtYWdpYyA9IHJlYWRJbnQoYmEsIDApO1xuICAgICAgICBpZiAobWFnaWMgPT0gVFdPQklUX01BR0lDKSB7XG4gICAgICAgICAgICB0Yi5yZWFkSW50ID0gcmVhZEludDtcbiAgICAgICAgfSBlbHNlIGlmIChtYWdpYyA9PSBUV09CSVRfTUFHSUNfQkUpIHtcbiAgICAgICAgICAgIHRiLnJlYWRJbnQgPSByZWFkSW50QkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY250KG51bGwsIFwiTm90IGEgLjJiaXQgZmlsZSwgbWFnaWM9MHhcIiArIG1hZ2ljLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVyc2lvbiA9IHRiLnJlYWRJbnQoYmEsIDQpO1xuICAgICAgICBpZiAodmVyc2lvbiAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY250KG51bGwsICdVbnN1cHBvcnRlZCB2ZXJzaW9uICcgKyB2ZXJzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRiLnNlcUNvdW50ID0gdGIucmVhZEludChiYSwgOCk7XG4gICAgICAgIHRiLnNlcURpY3QgPSB7fTtcblxuICAgICAgICB2YXIgcCA9IDE2LCBpPTA7XG4gICAgICAgIHZhciBvID0gMDsgIC8vIE9mZnNldCBvZiB0aGUgY3VycmVudCBibG9jayBpZiB3ZSBuZWVkIHRvIGZldGNoIG11bHRpcGxlIGhlYWRlciBibG9ja3MuXG5cbiAgICAgICAgdmFyIHBhcnNlU2VxSW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0Yi5zZXFDb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBucyA9IGJhW3BdO1xuICAgICAgICAgICAgICAgIGlmIChwICsgbnMgKyA2ID49IGJhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJCbG9ja3NGZXRjaGVkICs9IGhlYWRlckJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyQmxvY2tTaXplID0gTWF0aC5tYXgoSEVBREVSX0JMT0NLX1NJWkUsTWF0aC5mbG9vcihoZWFkZXJCbG9ja3NGZXRjaGVkKnRiLnNlcUNvdW50L2kpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRiLmRhdGEuc2xpY2UobyArIHAsIGhlYWRlckJsb2NrU2l6ZSkuZmV0Y2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gKz0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmEgPSBuZXcgVWludDhBcnJheShyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU2VxSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IG5zOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGIucmVhZEludChiYSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGIuc2VxRGljdFtuYW1lXSA9IG5ldyBUd29CaXRTZXEodGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY250KHRiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlU2VxSW5mbygpO1xuICAgICAgICBcbiAgICB9KTtcbn1cblxuVHdvQml0RmlsZS5wcm90b3R5cGUuZ2V0U2VxID0gZnVuY3Rpb24oY2hyKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuc2VxRGljdFtjaHJdO1xuICAgIGlmICghc2VxKSB7XG4gICAgICAgIHNlcSA9IHRoaXMuc2VxRGljdFsnY2hyJyArIGNocl07XG4gICAgfVxuICAgIHJldHVybiBzZXE7XG59XG5cblR3b0JpdEZpbGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgY250KSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuZ2V0U2VxKGNocik7XG4gICAgaWYgKCFzZXEpIHtcbiAgICAgICAgcmV0dXJuIGNudChudWxsLCBcIkNvdWxkbid0IGZpbmQgXCIgKyBjaHIpO1xuICAgIH0gZWxzZSBpZiAobWF4IDw9IG1pbikge1xuICAgICAgICByZXR1cm4gY250KCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXEuZmV0Y2gobWluLCBtYXgsIGNudCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBUd29CaXRTZXEodGJmLCBvZmZzZXQpIHtcbiAgICB0aGlzLnRiZiA9IHRiZjtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbn1cblxuVHdvQml0U2VxLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oY250KSB7XG4gICAgaWYgKHRoaXMuc2VxT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBjbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXNCLnRiZi5kYXRhLnNsaWNlKHRoaXNCLm9mZnNldCwgOCkuZmV0Y2goZnVuY3Rpb24ocjEpIHtcbiAgICAgICAgaWYgKCFyMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNudCgnRmV0Y2ggZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkocjEpO1xuICAgICAgICB0aGlzQi5fbGVuZ3RoID0gdGhpc0IudGJmLnJlYWRJbnQoYmEsIDApO1xuICAgICAgICB0aGlzQi5uQmxvY2tDbnQgPSB0aGlzQi50YmYucmVhZEludChiYSwgNCk7XG4gICAgICAgIHRoaXNCLnRiZi5kYXRhLnNsaWNlKHRoaXNCLm9mZnNldCArIDgsIHRoaXNCLm5CbG9ja0NudCo4ICsgNCkuZmV0Y2goZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICAgIGlmICghcjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY250KCdGZXRjaCBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KHIyKTtcbiAgICAgICAgICAgIHZhciBuYnMgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCB0aGlzQi5uQmxvY2tDbnQ7ICsrYikge1xuICAgICAgICAgICAgICAgIHZhciBuYk1pbiA9IHRoaXNCLnRiZi5yZWFkSW50KGJhLCBiICogNCk7XG4gICAgICAgICAgICAgICAgdmFyIG5iTGVuID0gdGhpc0IudGJmLnJlYWRJbnQoYmEsIChiICsgdGhpc0IubkJsb2NrQ250KSAqIDQpO1xuICAgICAgICAgICAgICAgIHZhciBuYiA9IG5ldyBSYW5nZShuYk1pbiwgbmJNaW4gKyBuYkxlbiAtIDEpO1xuICAgICAgICAgICAgICAgIGlmICghbmJzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5icyA9IG5iO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5icyA9IHVuaW9uKG5icywgbmIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNCLm5CbG9ja3MgPSBuYnM7XG4gICAgICAgICAgICB0aGlzQi5tQmxvY2tDbnQgPSB0aGlzQi50YmYucmVhZEludChiYSwgdGhpc0IubkJsb2NrQ250KjgpO1xuICAgICAgICAgICAgdGhpc0Iuc2VxTGVuZ3RoID0gKCh0aGlzQi5fbGVuZ3RoICsgMykvNCl8MDtcbiAgICAgICAgICAgIHRoaXNCLnNlcU9mZnNldCA9IHRoaXNCLm9mZnNldCArIDE2ICsgKCh0aGlzQi5uQmxvY2tDbnQgKyB0aGlzQi5tQmxvY2tDbnQpICogOCk7XG4gICAgICAgICAgICByZXR1cm4gY250KCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG52YXIgVFdPQklUX1RBQkxFID0gWydUJywgJ0MnLCAnQScsICdHJ107XG5cblR3b0JpdFNlcS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihtaW4sIG1heCwgY250KSB7XG4gICAgLS1taW47IC0tbWF4OyAgICAgICAvLyBTd2l0Y2ggdG8gemVyby1iYXNlZC5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuaW5pdChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjbnQobnVsbCwgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZldGNoTWluID0gbWluID4+IDI7XG4gICAgICAgIHZhciBmZXRjaE1heCA9IG1heCArIDMgPj4gMjtcbiAgICAgICAgaWYgKGZldGNoTWluIDwgMCB8fCBmZXRjaE1heCA+IHRoaXNCLnNlcUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNudCgnQ29vcmRpbmF0ZXMgb3V0IG9mIGJvdW5kczogJyArIG1pbiArICc6JyArIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzQi50YmYuZGF0YS5zbGljZSh0aGlzQi5zZXFPZmZzZXQgKyBmZXRjaE1pbiwgZmV0Y2hNYXggLSBmZXRjaE1pbikuc2FsdGVkKCkuZmV0Y2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbnQoJ1NlcUZldGNoIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlcURhdGEgPSBuZXcgVWludDhBcnJheShyKTtcblxuICAgICAgICAgICAgdmFyIG5TcGFucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXNCLm5CbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ciA9IGludGVyc2VjdGlvbihuZXcgUmFuZ2UobWluLCBtYXgpLCB0aGlzQi5uQmxvY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50cikge1xuICAgICAgICAgICAgICAgICAgICBuU3BhbnMgPSBpbnRyLnJhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNlcXN0ciA9ICcnO1xuICAgICAgICAgICAgdmFyIHB0ciA9IG1pbjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbGxTZXEoZnNtKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ciA8PSBmc20pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJiID0gKHB0ciA+PiAyKSAtIGZldGNoTWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmkgPSBwdHIgJiAweDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBidiA9IHNlcURhdGFbYmJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAoYnYgPj4gNikgJiAweDM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IChidiA+PiA0KSAmIDB4MztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuaSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gKGJ2ID4+IDIpICYgMHgzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IChidikgJiAweDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vxc3RyICs9IFRXT0JJVF9UQUJMRVtuXTtcbiAgICAgICAgICAgICAgICAgICAgKytwdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IG5TcGFucy5sZW5ndGg7ICsrYikge1xuICAgICAgICAgICAgICAgIHZhciBuYiA9IG5TcGFuc1tiXTtcbiAgICAgICAgICAgICAgICBpZiAocHRyID4gbmIubWluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ04gbWlzbWF0Y2guLi4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHRyIDwgbmIubWluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFNlcShuYi5taW4oKSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAocHRyIDw9IG5iLm1heCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcXN0ciArPSAnTic7XG4gICAgICAgICAgICAgICAgICAgICsrcHRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwdHIgPD0gbWF4KSB7XG4gICAgICAgICAgICAgICAgZmlsbFNlcShtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNudChzZXFzdHIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuVHdvQml0U2VxLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbihjbnQpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuaW5pdChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjbnQobnVsbCwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNudCh0aGlzQi5fbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIG1ha2VUd29CaXQ6IG1ha2VUd29CaXRcbiAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIHV0aWxzLmpzOiBvZGRzLCBzb2RzLCBhbmQgZW5kcy5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzaGExID0gcmVxdWlyZSgnLi9zaGExJyk7XG4gICAgdmFyIGI2NF9zaGExID0gc2hhMS5iNjRfc2hhMTtcbn1cblxudmFyIE5VTV9SRUdFWFAgPSBuZXcgUmVnRXhwKCdbMC05XSsnKTtcblxuZnVuY3Rpb24gc3RyaW5nVG9OdW1iZXJzQXJyYXkoc3RyKSB7XG4gICAgdmFyIG51bXMgPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgbTtcbiAgICB3aGlsZSAobSA9IE5VTV9SRUdFWFAuZXhlYyhzdHIpKSB7XG4gICAgICAgIG51bXMucHVzaChtWzBdKTtcbiAgICAgICAgc3RyPXN0ci5zdWJzdHJpbmcobS5pbmRleCArIChtWzBdLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtcztcbn1cblxudmFyIFNUUklDVF9OVU1fUkVHRVhQID0gbmV3IFJlZ0V4cCgnXlswLTldKyQnKTtcblxuZnVuY3Rpb24gc3RyaW5nVG9JbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnLCcsICdnJyksICcnKTtcbiAgICBpZiAoIVNUUklDVF9OVU1fUkVHRVhQLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnwwO1xufVxuXG5mdW5jdGlvbiBwdXNobmV3KGEsIHYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPT0gdikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGEucHVzaCh2KTtcbn1cblxuZnVuY3Rpb24gcHVzaG8ob2JqLCBrLCB2KSB7XG4gICAgaWYgKG9ialtrXSkge1xuICAgICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba10gPSBbdl07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwdXNobmV3byhvYmosIGssIHYpIHtcbiAgICB2YXIgYSA9IG9ialtrXTtcbiAgICBpZiAoYSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHsgICAgLy8gaW5kZXhPZiByZXF1aXJlcyBKUzE2IDotKC5cbiAgICAgICAgICAgIGlmIChhW2ldID09IHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrXSA9IFt2XTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gcGljayhhLCBiLCBjLCBkKVxue1xuICAgIGlmIChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSBlbHNlIGlmIChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHVzaG5ldyhsLCBvKVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobFtpXSA9PSBvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbC5wdXNoKG8pO1xufVxuXG5cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mKGEsIHgpIHtcbiAgICBpZiAoIWEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA9PT0geCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBhcnJheVJlbW92ZShhLCB4KSB7XG4gICAgdmFyIGkgPSBhcnJheUluZGV4T2YoYSwgeCk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9cbi8vIERPTSB1dGlsaXRpZXNcbi8vXG5cblxuZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnLCBjaGlsZHJlbiwgYXR0cmlicywgc3R5bGVzKVxue1xuICAgIHZhciBlbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghIChjaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChhdHRyaWJzKSB7XG4gICAgICAgIGZvciAodmFyIGwgaW4gYXR0cmlicykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVbbF0gPSBhdHRyaWJzW2xdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciBzZXR0aW5nICcgKyBsKTtcbiAgICAgICAgICAgICAgICB0aHJvdyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgIGZvciAodmFyIGwgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICBlbGUuc3R5bGVbbF0gPSBzdHlsZXNbbF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZTtcbn1cblxuZnVuY3Rpb24gbWFrZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZywgY2hpbGRyZW4sIGF0dHJpYnMpXG57XG4gICAgdmFyIGVsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghIChjaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2V0QXR0cnMoZWxlLCBhdHRyaWJzKTtcbiAgICByZXR1cm4gZWxlO1xufVxuXG52YXIgYXR0cl9uYW1lX2NhY2hlID0ge307XG5cbmZ1bmN0aW9uIHNldEF0dHIobm9kZSwga2V5LCB2YWx1ZSlcbntcbiAgICB2YXIgYXR0ciA9IGF0dHJfbmFtZV9jYWNoZVtrZXldO1xuICAgIGlmICghYXR0cikge1xuICAgICAgICB2YXIgX2F0dHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBrZXkubGVuZ3RoOyArK2MpIHtcbiAgICAgICAgICAgIHZhciBjYyA9IGtleS5zdWJzdHJpbmcoYywgYysxKTtcbiAgICAgICAgICAgIHZhciBsY2MgPSBjYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGxjYyAhPSBjYykge1xuICAgICAgICAgICAgICAgIF9hdHRyID0gX2F0dHIgKyAnLScgKyBsY2M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9hdHRyID0gX2F0dHIgKyBjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyX25hbWVfY2FjaGVba2V5XSA9IF9hdHRyO1xuICAgICAgICBhdHRyID0gX2F0dHI7XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cnMobm9kZSwgYXR0cmlicylcbntcbiAgICBpZiAoYXR0cmlicykge1xuICAgICAgICBmb3IgKHZhciBsIGluIGF0dHJpYnMpIHtcbiAgICAgICAgICAgIHNldEF0dHIobm9kZSwgbCwgYXR0cmlic1tsXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKVxue1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbn1cblxuXG5cbi8vXG4vLyBXQVJOSU5HOiBub3QgZm9yIGdlbmVyYWwgdXNlIVxuLy9cblxuZnVuY3Rpb24gbWluaUpTT05pZnkobywgZXhjKSB7XG4gICAgaWYgKHR5cGVvZiBvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgfSBlbHNlIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIG8gKyBcIidcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgbztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gXCJcIiArIG87XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzID0gKHMgPT0gbnVsbCA/ICcnIDogKHMgKyAnLCAnKSkgKyBtaW5pSlNPTmlmeShvW2ldLCBleGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIChzP3M6JycpICsgJ10nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhjID0gZXhjIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y1trXSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGsgIT0gdW5kZWZpbmVkICYmIHR5cGVvZihvW2tdKSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSAocyA9PSBudWxsID8gJycgOiAocyArICcsICcpKSArIGsgKyAnOiAnICsgbWluaUpTT05pZnkob1trXSwgZXhjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgKHM/czonJykgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBvKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KG8pIHtcbiAgICB2YXIgbiA9IHt9O1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgICBuW2tdID0gb1trXTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIE9ic2VydmVkKHgpIHtcbiAgICB0aGlzLnZhbHVlID0geDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG5PYnNlcnZlZC5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChmKTtcbn1cblxuT2JzZXJ2ZWQucHJvdG90eXBlLmFkZExpc3RlbmVyQW5kRmlyZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGYpO1xuICAgIGYodGhpcy52YWx1ZSk7XG59XG5cbk9ic2VydmVkLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGYpIHtcbiAgICBhcnJheVJlbW92ZSh0aGlzLmxpc3RlbmVycywgZik7XG59XG5cbk9ic2VydmVkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuT2JzZXJ2ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB0aGlzLnZhbHVlID0geDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2ldKHgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gQXdhaXRlZCgpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG5cbkF3YWl0ZWQucHJvdG90eXBlLnByb3ZpZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHRoaXMucmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgXCJSZXNvdXJjZSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkLlwiO1xuICAgIH1cblxuICAgIHRoaXMucmVzID0geDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVtpXSh4KTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZSA9IG51bGw7ICAgLy8gYXZvaWQgbGVha2luZyBjbG9zdXJlcy5cbn1cblxuQXdhaXRlZC5wcm90b3R5cGUuYXdhaXQgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYgKHRoaXMucmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZih0aGlzLnJlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZik7XG4gICAgfVxufVxuXG52YXIgX19kYWxsaWFuY2Vfc2FsdFNlZWQgPSAwO1xuXG5mdW5jdGlvbiBzYWx0VVJMKHVybCkge1xuICAgIHJldHVybiB1cmwgKyAnP3NhbHQ9JyArIGI2NF9zaGExKCcnICsgRGF0ZS5ub3coKSArICcsJyArICgrK19fZGFsbGlhbmNlX3NhbHRTZWVkKSk7XG59XG5cbmZ1bmN0aW9uIHRleHRYSFIodXJsLCBjYWxsYmFjaywgb3B0cykge1xuICAgIGlmIChvcHRzICYmIG9wdHMuc2FsdCkgXG4gICAgICAgIHVybCA9IHNhbHRVUkwodXJsKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGltaW5nIG91dCAnICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnVGltZW91dCcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0cy50aW1lb3V0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgXHQgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIFx0ICAgICAgICBpZiAocmVxLnN0YXR1cyA8IDIwMCB8fCByZXEuc3RhdHVzID49IDMwMCkge1xuICAgIFx0XHQgICAgY2FsbGJhY2sobnVsbCwgJ0Vycm9yIGNvZGUgJyArIHJlcS5zdGF0dXMpO1xuICAgIFx0ICAgICAgICB9IGVsc2Uge1xuICAgIFx0XHQgICAgY2FsbGJhY2socmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgXHQgICAgICAgIH1cbiAgICBcdCAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcblxuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgJ0V4Y2VwdGlvbiAnICsgZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVVSTChiYXNlLCByZWwpIHtcbiAgICAvLyBGSVhNRSBxdWl0ZSBuYWl2ZSAtLSBnb29kIGVub3VnaCBmb3IgdHJhY2todWJzP1xuXG4gICAgaWYgKHJlbC5pbmRleE9mKCdodHRwOicpID09IDAgfHwgcmVsLmluZGV4T2YoJ2h0dHBzOicpID09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlbDtcbiAgICB9XG5cbiAgICB2YXIgbGkgPSBiYXNlLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgaWYgKGxpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGJhc2Uuc3Vic3RyKDAsIGxpICsgMSkgKyByZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbDtcbiAgICB9XG59XG5cbnZhciBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OID0ge1xuICAgICdUVFQnOiAnRicsXG4gICAgJ1RUQyc6ICdGJyxcbiAgICAnVFRBJzogJ0wnLFxuICAgICdUVEcnOiAnTCcsXG4gICAgJ0NUVCc6ICdMJyxcbiAgICAnQ1RDJzogJ0wnLFxuICAgICdDVEEnOiAnTCcsXG4gICAgJ0NURyc6ICdMJyxcbiAgICAnQVRUJzogJ0knLFxuICAgICdBVEMnOiAnSScsXG4gICAgJ0FUQSc6ICdJJyxcbiAgICAnQVRHJzogJ00nLFxuICAgICdHVFQnOiAnVicsXG4gICAgJ0dUQyc6ICdWJyxcbiAgICAnR1RBJzogJ1YnLFxuICAgICdHVEcnOiAnVicsXG4gICAgJ1RDVCc6ICdTJyxcbiAgICAnVENDJzogJ1MnLFxuICAgICdUQ0EnOiAnUycsXG4gICAgJ1RDRyc6ICdTJyxcbiAgICAnQ0NUJzogJ1AnLFxuICAgICdDQ0MnOiAnUCcsXG4gICAgJ0NDQSc6ICdQJyxcbiAgICAnQ0NHJzogJ1AnLFxuICAgICdBQ1QnOiAnVCcsXG4gICAgJ0FDQyc6ICdUJyxcbiAgICAnQUNBJzogJ1QnLFxuICAgICdBQ0cnOiAnVCcsXG4gICAgJ0dDVCc6ICdBJyxcbiAgICAnR0NDJzogJ0EnLFxuICAgICdHQ0EnOiAnQScsXG4gICAgJ0dDRyc6ICdBJyxcbiAgICAnVEFUJzogJ1knLFxuICAgICdUQUMnOiAnWScsXG4gICAgJ1RBQSc6ICcqJywgIC8vIHN0b3BcbiAgICAnVEFHJzogJyonLCAgLy8gc3RvcFxuICAgICdDQVQnOiAnSCcsXG4gICAgJ0NBQyc6ICdIJyxcbiAgICAnQ0FBJzogJ1EnLFxuICAgICdDQUcnOiAnUScsXG4gICAgJ0FBVCc6ICdOJyxcbiAgICAnQUFDJzogJ04nLFxuICAgICdBQUEnOiAnSycsXG4gICAgJ0FBRyc6ICdLJyxcbiAgICAnR0FUJzogJ0QnLFxuICAgICdHQUMnOiAnRCcsXG4gICAgJ0dBQSc6ICdFJyxcbiAgICAnR0FHJzogJ0UnLFxuICAgICdUR1QnOiAnQycsXG4gICAgJ1RHQyc6ICdDJyxcbiAgICAnVEdBJzogJyonLCAgLy8gc3RvcFxuICAgICdUR0cnOiAnVycsXG4gICAgJ0NHVCc6ICdSJyxcbiAgICAnQ0dDJzogJ1InLFxuICAgICdDR0EnOiAnUicsXG4gICAgJ0NHRyc6ICdSJyxcbiAgICAnQUdUJzogJ1MnLFxuICAgICdBR0MnOiAnUycsXG4gICAgJ0FHQSc6ICdSJyxcbiAgICAnQUdHJzogJ1InLFxuICAgICdHR1QnOiAnRycsXG4gICAgJ0dHQyc6ICdHJyxcbiAgICAnR0dBJzogJ0cnLFxuICAgICdHR0cnOiAnRydcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVVybFRvUGFnZShyZWwpIHtcbiAgICByZXR1cm4gbWFrZUVsZW1lbnQoJ2EnLCBudWxsLCB7aHJlZjogcmVsfSkuaHJlZjtcbn1cblxuLy9cbi8vIE1pc3NpbmcgQVBJc1xuLy8gXG5cbmlmICghKCd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlKSkge1xuICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICB9O1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHRleHRYSFI6IHRleHRYSFIsXG4gICAgICAgIHJlbGF0aXZlVVJMOiByZWxhdGl2ZVVSTCxcbiAgICAgICAgcmVzb2x2ZVVybFRvUGFnZTogcmVzb2x2ZVVybFRvUGFnZSxcbiAgICAgICAgc2hhbGxvd0NvcHk6IHNoYWxsb3dDb3B5LFxuICAgICAgICBwdXNobzogcHVzaG8sXG4gICAgICAgIHB1c2huZXc6IHB1c2huZXcsXG4gICAgICAgIHB1c2huZXdvOiBwdXNobmV3byxcbiAgICAgICAgYXJyYXlJbmRleE9mOiBhcnJheUluZGV4T2YsXG4gICAgICAgIHBpY2s6IHBpY2ssXG5cbiAgICAgICAgbWFrZUVsZW1lbnQ6IG1ha2VFbGVtZW50LFxuICAgICAgICBtYWtlRWxlbWVudE5TOiBtYWtlRWxlbWVudE5TLFxuICAgICAgICByZW1vdmVDaGlsZHJlbjogcmVtb3ZlQ2hpbGRyZW4sXG5cbiAgICAgICAgbWluaUpTT05pZnk6IG1pbmlKU09OaWZ5LFxuXG4gICAgICAgIE9ic2VydmVkOiBPYnNlcnZlZCxcbiAgICAgICAgQXdhaXRlZDogQXdhaXRlZCxcblxuICAgICAgICBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OOiBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OXG4gICAgfVxufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIHZjZi5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHNhID0gcmVxdWlyZSgnLi9zb3VyY2VhZGFwdGVycycpO1xuICAgIHZhciBkYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5ID0gc2EucmVnaXN0ZXJQYXJzZXJGYWN0b3J5O1xuXG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU1N0eWxlc2hlZXQgPSBkYXMuREFTU3R5bGVzaGVldDtcbiAgICB2YXIgREFTU3R5bGUgPSBkYXMuREFTU3R5bGU7XG4gICAgdmFyIERBU0ZlYXR1cmUgPSBkYXMuREFTRmVhdHVyZTtcbiAgICB2YXIgREFTR3JvdXAgPSBkYXMuREFTR3JvdXA7XG59XG5cbmZ1bmN0aW9uIFZDRlBhcnNlcigpIHtcbiAgICB0aGlzLmluZm8gPSBbXTtcbn1cblxudmFyIFZDRl9JTkZPX1JFID0gLyhbXjs9XSspKD0oW147XSspKT87Py87XG52YXIgVkNGX0lORk9fSEVBREVSID0gLyMjSU5GTz08KFtePl0rKT4vO1xudmFyIFZDRl9JTkZPX0hFQURFUl9UT0sgPSAvKFteLD1dKyk9KFteLF0rfFwiW15cIl0rXCIpLD8vXG5cblZDRlBhcnNlci5wcm90b3R5cGUuY3JlYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uKHNpbmspIHtcbiAgICByZXR1cm4gbmV3IFZDRlBhcnNlU2Vzc2lvbih0aGlzLCBzaW5rKTtcbn1cblxuZnVuY3Rpb24gVkNGUGFyc2VTZXNzaW9uKHBhcnNlciwgc2luaykge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMuc2luayAgPSBzaW5rO1xufVxuXG5WQ0ZQYXJzZVNlc3Npb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24obGluZSkge1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGxpbmVbMF0gPT0gJyMnKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDEgJiYgbGluZVsxXSA9PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBtID0gVkNGX0lORk9fSEVBREVSLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tzID0gbVsxXS5zcGxpdChWQ0ZfSU5GT19IRUFERVJfVE9LKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBudWxsLCBkZXNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdG9rcy5sZW5ndGggLSAxOyB0aSArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0b2tzW3RpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva3NbdGkgKyAyXS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ0lEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0gJ0Rlc2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VyLmluZm8ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogZGVzY31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdG9rcyA9IGxpbmUuc3BsaXQoJ1xcdCcpO1xuICAgIHZhciBmID0gbmV3IERBU0ZlYXR1cmUoKTtcbiAgICBmLnNlZ21lbnQgPSB0b2tzWzBdO1xuICAgIGYuaWQgPSB0b2tzWzJdXG4gICAgZi5yZWZBbGxlbGUgPSB0b2tzWzNdO1xuICAgIGYuYWx0QWxsZWxlcyA9IHRva3NbNF0uc3BsaXQoJywnKTtcbiAgICBmLm1pbiA9IHBhcnNlSW50KHRva3NbMV0pO1xuICAgIGYubWF4ID0gZi5taW4gKyBmLnJlZkFsbGVsZS5sZW5ndGggLSAxO1xuXG4gICAgdmFyIGluZm9Ub2tzID0gdG9rc1s3XS5zcGxpdChWQ0ZfSU5GT19SRSk7XG4gICAgZi5pbmZvID0ge307XG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IGluZm9Ub2tzLmxlbmd0aDsgdGkgKz0gNCkge1xuICAgICAgICBmLmluZm9baW5mb1Rva3NbdGkgKyAxXV0gPSBpbmZvVG9rc1t0aSArIDNdO1xuICAgIH1cblxuXG4gICAgdmFyIGFsdCA9IGYuYWx0QWxsZWxlc1swXTtcbiAgICB2YXIgcmVmID0gZi5yZWZBbGxlbGU7XG4gICAgaWYgKGFsdC5sZW5ndGggPiByZWYubGVuZ3RoKSB7XG4gICAgICAgIGYudHlwZSA9IFwiaW5zZXJ0aW9uXCI7XG4gICAgICAgIGlmIChhbHQuaW5kZXhPZihyZWYpID09IDApIHtcbiAgICAgICAgICAgIGYuaW5zZXJ0aW9uID0gYWx0LnN1YnN0cihyZWYubGVuZ3RoKTtcbiAgICAgICAgICAgIGYubWluICs9IHJlZi5sZW5ndGg7XG4gICAgICAgICAgICBmLm1heCA9IGYubWluIC0gMTsgLy8gRWZmZWN0aXZlbHkgXCJiZXR3ZWVuXCIgYmFzZXMuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmLmluc2VydGlvbiA9IGFsdDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0Lmxlbmd0aCA8IHJlZi5sZW5ndGgpIHtcbiAgICAgICAgZi50eXBlID0gXCJkZWxldGlvblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGYudHlwZSA9ICdzdWJzdGl0dXRpb24nO1xuICAgIH1cblxuICAgIHRoaXMuc2luayhmKTtcbn1cblxuVkNGUGFyc2VTZXNzaW9uLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge307XG5cblZDRlBhcnNlci5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuXG4gICAge1xuICAgICAgICB2YXIgdmFyU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdmFyU3R5bGUuZ2x5cGggPSAnX19JTlNFUlRJT04nO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdyZ2IoNTAsODAsMjU1KSc7XG4gICAgICAgIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLlNUUk9LRUNPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdpbnNlcnRpb24nfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdQTElNU09MTCc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JnYigyNTUsIDYwLCA2MCknO1xuICAgICAgICB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5TVFJPS0VDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVsZXRpb24nfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdQTElNU09MTCc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JnYig1MCw4MCwyNTUpJztcbiAgICAgICAgdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuU1RST0tFQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbn1cblxuVkNGUGFyc2VyLnByb3RvdHlwZS5nZXREZWZhdWx0RklQcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmaXAgPSBmdW5jdGlvbihmZWF0dXJlLCBmZWF0dXJlSW5mbykge1xuICAgICAgICBmZWF0dXJlSW5mby5hZGQoXCJSZWYuIGFsbGVsZVwiLCBmZWF0dXJlLnJlZkFsbGVsZSk7XG4gICAgICAgIGZlYXR1cmVJbmZvLmFkZChcIkFsdC4gYWxsZWxlc1wiLCBmZWF0dXJlLmFsdEFsbGVsZXMuam9pbignLCcpKTtcblxuICAgICAgICBpZiAoZmVhdHVyZS5pbmZvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2VsZi5pbmZvLmxlbmd0aDsgKytpaSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gc2VsZi5pbmZvW2lpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gZmVhdHVyZS5pbmZvW2luZm8uaWRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5mby5hZGQoaW5mby5kZXNjLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2soZmlwKTtcbn1cblxuZGFsbGlhbmNlX3JlZ2lzdGVyUGFyc2VyRmFjdG9yeSgndmNmJywgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBWQ0ZQYXJzZXIoKX0pO1xuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIHZlcnNpb24uanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgVkVSU0lPTiA9IHtcbiAgICBDT05GSUc6IDUsXG4gICAgTUFKT1I6ICAwLFxuICAgIE1JTk9SOiAgMTMsXG4gICAgTUlDUk86ICA3LFxuICAgIEJSQU5DSDogJ2Rldidcbn07XG5cblZFUlNJT04udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdnMgPSAnJyArIHRoaXMuTUFKT1IgKyAnLicgKyB0aGlzLk1JTk9SICsgJy4nICsgdGhpcy5NSUNSTztcbiAgICBpZiAodGhpcy5QQVRDSCkge1xuICAgICAgICB2cyA9IHZzICsgdGhpcy5QQVRDSDtcbiAgICB9XG4gICAgaWYgKHRoaXMuQlJBTkNIICYmIHRoaXMuQlJBTkNIICE9ICcnKSB7XG4gICAgICAgIHZzID0gdnMgKyAnLScgKyB0aGlzLkJSQU5DSDtcbiAgICB9XG4gICAgcmV0dXJuIHZzO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWRVJTSU9OO1xufVxuIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuXG4vLyByZW5kZXJlciB0aGF0IHdyYXBzIGEgcHVyZXNjcmlwdCByZW5kZXJlciB0byBhZGQgcnVsZXJzLCBxdWFudCBzdHVmZiwgZXRjLlxuXG5pbXBvcnQgKiBhcyBEZWZhdWx0UmVuZGVyZXIgZnJvbSBcIi4vZGVmYXVsdC1yZW5kZXJlci5lczZcIjtcblxuZXhwb3J0IHsgd3JhcFJlbmRlcmVyIH07XG5cblxuZnVuY3Rpb24gd3JhcFJlbmRlcmVyKGdseXBoaWZ5RmVhdHVyZXMsIGNhbnZhc0hlaWdodCkge1xuXG4gICAgY29uc3QgcHJlcGFyZVN1YnRpZXJzID0gdGllciA9PiB7XG5cbiAgICAgICAgY29uc3QgdmlldyA9IHsgdmlld1N0YXJ0OiB0aWVyLmJyb3dzZXIudmlld1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogdGllci5icm93c2VyLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hyOiB0aWVyLmtub3duQ2hyXG4gICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZlYXR1cmVzID0gdGllci5jdXJyZW50RmVhdHVyZXM7XG5cbiAgICAgICAgdGllci5wYWRkaW5nID0gMztcbiAgICAgICAgdGllci5zdWJ0aWVycyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBnbHlwaGlmeUZlYXR1cmVzKHZpZXcpKGZlYXR1cmVzKTtcblxuICAgICAgICAvLyBJZiBhbGwgdGhlIHJlc3VsdHMgYXJlIGEgc3RyaW5nLCB3ZSB3YW50IHRvIHNob3cgaXQgb24gc2NyZWVuIC0gc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGllci51cGRhdGVTdGF0dXMocmVzdWx0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2Ugd2FudCB0byBwcmludCB0aGUgZXJyb3JzIHRvIGNvbnNvbGUsIHdoaWxlIHRlbGxpbmcgdGhlIHVzZXIgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICAgICAgICBsZXQgc3RhdHVzID0gXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdHMuZ2x5cGhzLmZvckVhY2gociA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiRXJyb3Igd2hlbiBwYXJzaW5nIGZlYXR1cmVzIC0gc2VlIGJyb3dzZXIgY29uc29sZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHRpZXIudXBkYXRlU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpZXIuc3VidGllcnNbMF0gPVxuICAgICAgICAgICAgICAgIHsgZ2x5cGhzOiByZXN1bHRzLmdseXBocy5maWx0ZXIociA9PiB0eXBlb2YgciAhPT0gXCJzdHJpbmdcIiksXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0cy5xdWFudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cy5xdWFudCk7XG4gICAgICAgICAgICB0aWVyLnN1YnRpZXJzWzBdLnF1YW50ID0gcmVzdWx0cy5xdWFudDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGllci5nbHlwaENhY2hlT3JpZ2luID0gdGllci5icm93c2VyLnZpZXdTdGFydDtcbiAgICB9O1xuXG4gICAgY29uc3QgZHJhd1RpZXIgPSB0aWVyID0+IHtcblxuICAgICAgICAvLyBpZiB0aGUgc291cmNlIGhhcyBhIHN1YiBjb25maWcsIHRoaXMgdHJhY2sgaXMgdHJlYXRlZCBhcyBhIHN1YnRyYWNrXG4gICAgICAgIGlmICh0eXBlb2YgdGllci5kYXNTb3VyY2Uuc3ViID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBsZXQgYnJvd3NlciA9IHRpZXIuYnJvd3NlcjtcblxuICAgICAgICAgICAgbGV0IG11bHRpVGllciA9IGJyb3dzZXIudGllcnMuXG4gICAgICAgICAgICAgICAgZmlsdGVyKHQgPT4gdC5kYXNTb3VyY2UucmVuZGVyZXIgPT09ICdtdWx0aScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgdC5kYXNTb3VyY2UubXVsdGkubXVsdGlfaWQgPT09IHRpZXIuZGFzU291cmNlLnN1Yi5tdWx0aV9pZCk7XG5cbiAgICAgICAgICAgIG11bHRpVGllci5mb3JFYWNoKHQgPT4gYnJvd3Nlci5yZWZyZXNoVGllcih0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVwYXJlU3VidGllcnModGllcik7XG5cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRpZXIudmlld3BvcnQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgY29uc3QgcmV0aW5hID0gdGllci5icm93c2VyLnJldGluYSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG5cbiAgICAgICAgICAgIERlZmF1bHRSZW5kZXJlci5wcmVwYXJlVmlld3BvcnQodGllciwgY3R4LCByZXRpbmEpO1xuICAgICAgICAgICAgRGVmYXVsdFJlbmRlcmVyLnBhaW50KHRpZXIsIGN0eCk7XG5cbiAgICAgICAgICAgIHRpZXIuZHJhd092ZXJsYXkoKTtcbiAgICAgICAgICAgIHRpZXIucGFpbnRRdWFudCgpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mKHRpZXIuZGFzU291cmNlLmRyYXdDYWxsYmFjaykgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRpZXIuZGFzU291cmNlLmRyYXdDYWxsYmFjayhjdHgsIHRpZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aWVyLm9yaWdpbkhheHggPSAwO1xuICAgICAgICAgICAgdGllci5icm93c2VyLmFycmFuZ2VUaWVycygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbmRlclRpZXIgPSAoc3RhdHVzLCB0aWVyKSA9PiB7XG4gICAgICAgIGRyYXdUaWVyKHRpZXIpO1xuICAgICAgICB0aWVyLnVwZGF0ZVN0YXR1cyhzdGF0dXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4geyBwcmVwYXJlU3VidGllcnM6IHByZXBhcmVTdWJ0aWVycyxcbiAgICAgICAgICAgICBkcmF3VGllcjogZHJhd1RpZXIsXG4gICAgICAgICAgICAgcmVuZGVyVGllcjogcmVuZGVyVGllclxuICAgICAgICAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIHpvb21zbGlkZXIuanM6IGN1c3RvbSBzbGlkZXIgY29tcG9uZW50XG4vL1xuXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gbWFrZVpvb21TbGlkZXIob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIFxuICAgIHZhciBtaW5Qb3MgPSAwLCBtYXhQb3MgPSBvcHRzLndpZHRoIHx8IDIwMDtcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gMjAwO1xuICAgIHZhciBwb3MgPSA1MCwgcG9zMiA9IDEwMDtcbiAgICB2YXIgbGFiZWxzID0gW107XG4gICAgdmFyIHRyYWNrID0gbWFrZUVsZW1lbnQoJ2hyJywgbnVsbCwge2NsYXNzTmFtZTogJ3NsaWRlci10cmFjayd9LCB7d2lkdGg6ICcnICsgKG1heFBvc3wwKSArICdweCd9KTtcbiAgICB2YXIgdGh1bWIgPSBtYWtlRWxlbWVudCgnaHInLCBudWxsLCB7Y2xhc3NOYW1lOiAnc2xpZGVyLXRodW1iIGFjdGl2ZSd9KTtcbiAgICB2YXIgdGh1bWIyID0gbWFrZUVsZW1lbnQoJ2hyJywgbnVsbCwge2NsYXNzTmFtZTogJ3NsaWRlci10aHVtYid9KTtcbiAgICB2YXIgc2xpZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIFt0cmFjaywgdGh1bWIsIHRodW1iMl0sIHtjbGFzc05hbWU6ICdzbGlkZXInfSwgIHt3aWR0aDogJycgKyAoKG1heFBvc3wwKSArIDEwKSArICdweCd9KTtcblxuICAgIHNsaWRlci5yZW1vdmVMYWJlbHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IGxhYmVscy5sZW5ndGg7ICsrbGkpIHtcbiAgICAgICAgICAgIHNsaWRlci5yZW1vdmVDaGlsZChsYWJlbHNbbGldKTtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbHMgPSBbXTtcbiAgICB9XG5cbiAgICBzbGlkZXIuYWRkTGFiZWwgPSBmdW5jdGlvbih2YWwsIHR4dCkge1xuICAgICAgICB2YXIgcG9zID0gKG1pblBvcyArICgodmFsIC0gbWluKSAqIChtYXhQb3MgLSBtaW5Qb3MpKS8obWF4LW1pbikpfDA7XG4gICAgICAgIHZhciBsYWJlbCA9IG1ha2VFbGVtZW50KCdkaXYnLCB0eHQsIHtjbGFzc05hbWU6ICdzbGlkZXItbGFiZWwnfSwge1xuICAgICAgICAgICAgbGVmdDogJycgKyAoKG1pblBvcyArICgodmFsIC0gbWluKSAqIChtYXhQb3MgLSBtaW5Qb3MpKS8obWF4LW1pbikpfDApICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgICAgc2xpZGVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgIH1cblxuICAgIHZhciBvbkNoYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgb25DaGFuZ2UuaW5pdEV2ZW50KCdjaGFuZ2UnLCB0cnVlLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBzZXRQb3MobnApIHtcbiAgICAgICAgbnAgPSBNYXRoLm1pbihucCwgbWF4UG9zKTtcbiAgICAgICAgbnAgPSBNYXRoLm1heChucCwgbWluUG9zKTtcbiAgICAgICAgcG9zID0gbnA7XG4gICAgICAgIHRodW1iLnN0eWxlLmxlZnQgPSAnJyArIHBvcyArICdweCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UG9zMihucCkge1xuICAgICAgICBucCA9IE1hdGgubWluKG5wLCBtYXhQb3MpO1xuICAgICAgICBucCA9IE1hdGgubWF4KG5wLCBtaW5Qb3MpO1xuICAgICAgICBwb3MyID0gbnA7XG4gICAgICAgIHRodW1iMi5zdHlsZS5sZWZ0ID0gJycgKyBwb3MyICsgJ3B4JztcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2xpZGVyLCAndmFsdWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSAge3JldHVybiBtaW4gKyAoKChwb3MtbWluUG9zKSAqIChtYXgtbWluKSkgLyAobWF4UG9zIC0gbWluUG9zKSk7fSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIG5wID0gbWluUG9zICsgKCh2LW1pbikgKiAobWF4UG9zLW1pblBvcykpLyhtYXgtbWluKTtcbiAgICAgICAgICBzZXRQb3MobnApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2xpZGVyLCAndmFsdWUyJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgIHtyZXR1cm4gbWluICsgKCgocG9zMi1taW5Qb3MpICogKG1heC1taW4pKSAvIChtYXhQb3MgLSBtaW5Qb3MpKTt9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgbnAgPSBtaW5Qb3MgKyAoKHYtbWluKSAqIChtYXhQb3MtbWluUG9zKSkvKG1heC1taW4pO1xuICAgICAgICAgIHNldFBvczIobnApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2xpZGVyLCAnYWN0aXZlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aHVtYi5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpID8gMSA6IDJ9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIGlmICh4ID09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHVtYi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB0aHVtYjIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRodW1iMi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB0aHVtYi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNsaWRlciwgJ21pbicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7cmV0dXJuIG1pbn0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHttaW4gPSB2fVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNsaWRlciwgJ21heCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7cmV0dXJuIG1heH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHttYXggPSB2fVxuICAgIH0pO1xuXG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgd2hpY2g7XG5cbiAgICB2YXIgdGh1bWJNb3VzZURvd24gPSBmdW5jdGlvbihldikge1xuICAgICAgICB3aGljaCA9IHRoaXMgPT0gdGh1bWIgPyAxIDogMjtcbiAgICAgICAgaWYgKHdoaWNoICE9IHNsaWRlci5hY3RpdmUpIHtcbiAgICAgICAgICAgIHNsaWRlci5hY3RpdmUgPSB3aGljaDtcbiAgICAgICAgICAgIHNsaWRlci5kaXNwYXRjaEV2ZW50KG9uQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRodW1iRHJhZ0hhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aHVtYkRyYWdFbmRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIG9mZnNldCA9IGV2LmNsaWVudFggLSAod2hpY2ggPT0gMSA/IHBvcyA6IHBvczIpO1xuICAgIH07XG5cbiAgICB0aHVtYi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aHVtYk1vdXNlRG93biwgZmFsc2UpO1xuICAgIHRodW1iMi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aHVtYk1vdXNlRG93biwgZmFsc2UpO1xuXG4gICAgdmFyIHRodW1iRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAod2hpY2ggPT0gMSlcbiAgICAgICAgICAgIHNldFBvcyhldi5jbGllbnRYIC0gb2Zmc2V0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2V0UG9zMihldi5jbGllbnRYIC0gb2Zmc2V0KTtcbiAgICAgICAgc2xpZGVyLmRpc3BhdGNoRXZlbnQob25DaGFuZ2UpO1xuICAgIH07XG5cbiAgICB2YXIgdGh1bWJEcmFnRW5kSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aHVtYkRyYWdIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGh1bWJEcmFnRW5kSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGlkZXI7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2Vab29tU2xpZGVyO1xufVxuIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4wLjJcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5ID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm47XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuXSA9IGNhbGxiYWNrO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKz0gMjtcbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID09PSAyKSB7XG4gICAgICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcChhc2FwRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gYXNhcEZuO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgfHwge307XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB2ZXJ0eFxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV07XG5cbiAgICAgICAgY2FsbGJhY2soYXJnKTtcblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCgpIHt9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQgPSAxO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAgPSAyO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKHByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSkge1xuICAgICAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhlbiA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4obWF5YmVUaGVuYWJsZSk7XG5cbiAgICAgICAgaWYgKHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQ7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIGxlbmd0aCA9IHN1YnNjcmliZXJzLmxlbmd0aDtcblxuICAgICAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICB2YWx1ZSwgZXJyb3IsIHN1Y2NlZWRlZCwgZmFpbGVkO1xuXG4gICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFsdWUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICBlbnVtZXJhdG9yLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmIChlbnVtZXJhdG9yLl92YWxpZGF0ZUlucHV0KGlucHV0KSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICAgICAgZW51bWVyYXRvci5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgZW51bWVyYXRvci5faW5pdCgpO1xuXG4gICAgICAgIGlmIChlbnVtZXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IubGVuZ3RoID0gZW51bWVyYXRvci5sZW5ndGggfHwgMDtcbiAgICAgICAgICBlbnVtZXJhdG9yLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAoZW51bWVyYXRvci5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChlbnVtZXJhdG9yLnByb21pc2UsIGVudW1lcmF0b3IuX3ZhbGlkYXRpb25FcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlSW5wdXQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShpbnB1dCk7XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcjtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIHZhciBsZW5ndGggID0gZW51bWVyYXRvci5sZW5ndGg7XG4gICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcbiAgICAgIHZhciBpbnB1dCAgID0gZW51bWVyYXRvci5faW5wdXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW51bWVyYXRvci5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuICAgICAgdmFyIGMgPSBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoZW50cnkpKSB7XG4gICAgICAgIGlmIChlbnRyeS5jb25zdHJ1Y3RvciA9PT0gYyAmJiBlbnRyeS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgICBlbnRyeS5fb25lcnJvciA9IG51bGw7XG4gICAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bWVyYXRvci5fd2lsbFNldHRsZUF0KGMucmVzb2x2ZShlbnRyeSksIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmctLTtcbiAgICAgICAgZW51bWVyYXRvci5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24oc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZy0tO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnVtZXJhdG9yLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGwoZW50cmllcykge1xuICAgICAgcmV0dXJuIG5ldyBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGw7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZShlbnRyaWVzKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmICghbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxtZW50KHZhbHVlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlamVjdGlvbihyZWFzb24pIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSksIHVuZGVmaW5lZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmUob2JqZWN0KSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdChyZWFzb24pIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIgPSAwO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZTtcbiAgICAvKipcbiAgICAgIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgICAgIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gICAgICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgICAgIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBUZXJtaW5vbG9neVxuICAgICAgLS0tLS0tLS0tLS1cblxuICAgICAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgICAgIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICAgICAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgICAgIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgICAgIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gICAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgICAgIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICAgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICAgICAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICAgICAgQmFzaWMgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgYGBganNcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gb24gZmFpbHVyZVxuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgICAgIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICAgICAgYGBganNcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gICAgICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICAgICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAY2xhc3MgUHJvbWlzZVxuICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICAgIHRoaXMuX2lkID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIrKztcbiAgICAgIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICAgIGlmICghbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UpKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0QXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9hc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXA7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEICYmICFvbkZ1bGZpbGxtZW50IHx8IHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAmJiAhb25SZWplY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyZW50Ll9yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW3N0YXRlIC0gMV07XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHN0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jaHJvbm91c1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIGNhdGNoXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsKCkge1xuICAgICAgdmFyIGxvY2FsO1xuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgICBpZiAoUCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsLlByb21pc2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdDtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGw7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZSA9IHtcbiAgICAgICdQcm9taXNlJzogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQsXG4gICAgICAncG9seWZpbGwnOiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHRcbiAgICB9O1xuXG4gICAgLyogZ2xvYmFsIGRlZmluZTp0cnVlIG1vZHVsZTp0cnVlIHdpbmRvdzogdHJ1ZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1snRVM2UHJvbWlzZSddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQoKTtcbn0pLmNhbGwodGhpcyk7XG5cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIEphdmFzY3JpcHQgWkxpYlxuLy8gQnkgVGhvbWFzIERvd24gMjAxMC0yMDExXG4vL1xuLy8gQmFzZWQgdmVyeSBoZWF2aWx5IG9uIHBvcnRpb25zIG9mIGp6bGliIChieSB5bW5rQGpjcmFmdC5jb20pLCB3aG8gaW5cbi8vIHR1cm4gY3JlZGl0cyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyIGZvciB0aGUgb3JpZ2luYWwgemxpYiBjb2RlLlxuLy9cbi8vIGluZmxhdGUuanM6IFpMaWIgaW5mbGF0ZSBjb2RlXG4vL1xuXG4vL1xuLy8gU2hhcmVkIGNvbnN0YW50c1xuLy9cblxudmFyIE1BWF9XQklUUz0xNTsgLy8gMzJLIExaNzcgd2luZG93XG52YXIgREVGX1dCSVRTPU1BWF9XQklUUztcbnZhciBNQVhfTUVNX0xFVkVMPTk7XG52YXIgTUFOWT0xNDQwO1xudmFyIEJNQVggPSAxNTtcblxuLy8gcHJlc2V0IGRpY3Rpb25hcnkgZmxhZyBpbiB6bGliIGhlYWRlclxudmFyIFBSRVNFVF9ESUNUPTB4MjA7XG5cbnZhciBaX05PX0ZMVVNIPTA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIPTE7XG52YXIgWl9TWU5DX0ZMVVNIPTI7XG52YXIgWl9GVUxMX0ZMVVNIPTM7XG52YXIgWl9GSU5JU0g9NDtcblxudmFyIFpfREVGTEFURUQ9ODtcblxudmFyIFpfT0s9MDtcbnZhciBaX1NUUkVBTV9FTkQ9MTtcbnZhciBaX05FRURfRElDVD0yO1xudmFyIFpfRVJSTk89LTE7XG52YXIgWl9TVFJFQU1fRVJST1I9LTI7XG52YXIgWl9EQVRBX0VSUk9SPS0zO1xudmFyIFpfTUVNX0VSUk9SPS00O1xudmFyIFpfQlVGX0VSUk9SPS01O1xudmFyIFpfVkVSU0lPTl9FUlJPUj0tNjtcblxudmFyIE1FVEhPRD0wOyAgIC8vIHdhaXRpbmcgZm9yIG1ldGhvZCBieXRlXG52YXIgRkxBRz0xOyAgICAgLy8gd2FpdGluZyBmb3IgZmxhZyBieXRlXG52YXIgRElDVDQ9MjsgICAgLy8gZm91ciBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgRElDVDM9MzsgICAgLy8gdGhyZWUgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QyPTQ7ICAgIC8vIHR3byBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgRElDVDE9NTsgICAgLy8gb25lIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZSB0byBnb1xudmFyIERJQ1QwPTY7ICAgIC8vIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5XG52YXIgQkxPQ0tTPTc7ICAgLy8gZGVjb21wcmVzc2luZyBibG9ja3NcbnZhciBDSEVDSzQ9ODsgICAvLyBmb3VyIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0szPTk7ICAgLy8gdGhyZWUgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBDSEVDSzI9MTA7ICAvLyB0d28gY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBDSEVDSzE9MTE7ICAvLyBvbmUgY2hlY2sgYnl0ZSB0byBnb1xudmFyIERPTkU9MTI7ICAgIC8vIGZpbmlzaGVkIGNoZWNrLCBkb25lXG52YXIgQkFEPTEzOyAgICAgLy8gZ290IGFuIGVycm9yLS1zdGF5IGhlcmVcblxudmFyIGluZmxhdGVfbWFzayA9IFsweDAwMDAwMDAwLCAweDAwMDAwMDAxLCAweDAwMDAwMDAzLCAweDAwMDAwMDA3LCAweDAwMDAwMDBmLCAweDAwMDAwMDFmLCAweDAwMDAwMDNmLCAweDAwMDAwMDdmLCAweDAwMDAwMGZmLCAweDAwMDAwMWZmLCAweDAwMDAwM2ZmLCAweDAwMDAwN2ZmLCAweDAwMDAwZmZmLCAweDAwMDAxZmZmLCAweDAwMDAzZmZmLCAweDAwMDA3ZmZmLCAweDAwMDBmZmZmXTtcblxudmFyIElCX1RZUEU9MDsgIC8vIGdldCB0eXBlIGJpdHMgKDMsIGluY2x1ZGluZyBlbmQgYml0KVxudmFyIElCX0xFTlM9MTsgIC8vIGdldCBsZW5ndGhzIGZvciBzdG9yZWRcbnZhciBJQl9TVE9SRUQ9MjsvLyBwcm9jZXNzaW5nIHN0b3JlZCBibG9ja1xudmFyIElCX1RBQkxFPTM7IC8vIGdldCB0YWJsZSBsZW5ndGhzXG52YXIgSUJfQlRSRUU9NDsgLy8gZ2V0IGJpdCBsZW5ndGhzIHRyZWUgZm9yIGEgZHluYW1pYyBibG9ja1xudmFyIElCX0RUUkVFPTU7IC8vIGdldCBsZW5ndGgsIGRpc3RhbmNlIHRyZWVzIGZvciBhIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9DT0RFUz02OyAvLyBwcm9jZXNzaW5nIGZpeGVkIG9yIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9EUlk9NzsgICAvLyBvdXRwdXQgcmVtYWluaW5nIHdpbmRvdyBieXRlc1xudmFyIElCX0RPTkU9ODsgIC8vIGZpbmlzaGVkIGxhc3QgYmxvY2ssIGRvbmVcbnZhciBJQl9CQUQ9OTsgICAvLyBvdCBhIGRhdGEgZXJyb3ItLXN0dWNrIGhlcmVcblxudmFyIGZpeGVkX2JsID0gOTtcbnZhciBmaXhlZF9iZCA9IDU7XG5cbnZhciBmaXhlZF90bCA9IFtcbiAgICA5Niw3LDI1NiwgMCw4LDgwLCAwLDgsMTYsIDg0LDgsMTE1LFxuICAgIDgyLDcsMzEsIDAsOCwxMTIsIDAsOCw0OCwgMCw5LDE5MixcbiAgICA4MCw3LDEwLCAwLDgsOTYsIDAsOCwzMiwgMCw5LDE2MCxcbiAgICAwLDgsMCwgMCw4LDEyOCwgMCw4LDY0LCAwLDksMjI0LFxuICAgIDgwLDcsNiwgMCw4LDg4LCAwLDgsMjQsIDAsOSwxNDQsXG4gICAgODMsNyw1OSwgMCw4LDEyMCwgMCw4LDU2LCAwLDksMjA4LFxuICAgIDgxLDcsMTcsIDAsOCwxMDQsIDAsOCw0MCwgMCw5LDE3NixcbiAgICAwLDgsOCwgMCw4LDEzNiwgMCw4LDcyLCAwLDksMjQwLFxuICAgIDgwLDcsNCwgMCw4LDg0LCAwLDgsMjAsIDg1LDgsMjI3LFxuICAgIDgzLDcsNDMsIDAsOCwxMTYsIDAsOCw1MiwgMCw5LDIwMCxcbiAgICA4MSw3LDEzLCAwLDgsMTAwLCAwLDgsMzYsIDAsOSwxNjgsXG4gICAgMCw4LDQsIDAsOCwxMzIsIDAsOCw2OCwgMCw5LDIzMixcbiAgICA4MCw3LDgsIDAsOCw5MiwgMCw4LDI4LCAwLDksMTUyLFxuICAgIDg0LDcsODMsIDAsOCwxMjQsIDAsOCw2MCwgMCw5LDIxNixcbiAgICA4Miw3LDIzLCAwLDgsMTA4LCAwLDgsNDQsIDAsOSwxODQsXG4gICAgMCw4LDEyLCAwLDgsMTQwLCAwLDgsNzYsIDAsOSwyNDgsXG4gICAgODAsNywzLCAwLDgsODIsIDAsOCwxOCwgODUsOCwxNjMsXG4gICAgODMsNywzNSwgMCw4LDExNCwgMCw4LDUwLCAwLDksMTk2LFxuICAgIDgxLDcsMTEsIDAsOCw5OCwgMCw4LDM0LCAwLDksMTY0LFxuICAgIDAsOCwyLCAwLDgsMTMwLCAwLDgsNjYsIDAsOSwyMjgsXG4gICAgODAsNyw3LCAwLDgsOTAsIDAsOCwyNiwgMCw5LDE0OCxcbiAgICA4NCw3LDY3LCAwLDgsMTIyLCAwLDgsNTgsIDAsOSwyMTIsXG4gICAgODIsNywxOSwgMCw4LDEwNiwgMCw4LDQyLCAwLDksMTgwLFxuICAgIDAsOCwxMCwgMCw4LDEzOCwgMCw4LDc0LCAwLDksMjQ0LFxuICAgIDgwLDcsNSwgMCw4LDg2LCAwLDgsMjIsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOCwgMCw4LDU0LCAwLDksMjA0LFxuICAgIDgxLDcsMTUsIDAsOCwxMDIsIDAsOCwzOCwgMCw5LDE3MixcbiAgICAwLDgsNiwgMCw4LDEzNCwgMCw4LDcwLCAwLDksMjM2LFxuICAgIDgwLDcsOSwgMCw4LDk0LCAwLDgsMzAsIDAsOSwxNTYsXG4gICAgODQsNyw5OSwgMCw4LDEyNiwgMCw4LDYyLCAwLDksMjIwLFxuICAgIDgyLDcsMjcsIDAsOCwxMTAsIDAsOCw0NiwgMCw5LDE4OCxcbiAgICAwLDgsMTQsIDAsOCwxNDIsIDAsOCw3OCwgMCw5LDI1MixcbiAgICA5Niw3LDI1NiwgMCw4LDgxLCAwLDgsMTcsIDg1LDgsMTMxLFxuICAgIDgyLDcsMzEsIDAsOCwxMTMsIDAsOCw0OSwgMCw5LDE5NCxcbiAgICA4MCw3LDEwLCAwLDgsOTcsIDAsOCwzMywgMCw5LDE2MixcbiAgICAwLDgsMSwgMCw4LDEyOSwgMCw4LDY1LCAwLDksMjI2LFxuICAgIDgwLDcsNiwgMCw4LDg5LCAwLDgsMjUsIDAsOSwxNDYsXG4gICAgODMsNyw1OSwgMCw4LDEyMSwgMCw4LDU3LCAwLDksMjEwLFxuICAgIDgxLDcsMTcsIDAsOCwxMDUsIDAsOCw0MSwgMCw5LDE3OCxcbiAgICAwLDgsOSwgMCw4LDEzNywgMCw4LDczLCAwLDksMjQyLFxuICAgIDgwLDcsNCwgMCw4LDg1LCAwLDgsMjEsIDgwLDgsMjU4LFxuICAgIDgzLDcsNDMsIDAsOCwxMTcsIDAsOCw1MywgMCw5LDIwMixcbiAgICA4MSw3LDEzLCAwLDgsMTAxLCAwLDgsMzcsIDAsOSwxNzAsXG4gICAgMCw4LDUsIDAsOCwxMzMsIDAsOCw2OSwgMCw5LDIzNCxcbiAgICA4MCw3LDgsIDAsOCw5MywgMCw4LDI5LCAwLDksMTU0LFxuICAgIDg0LDcsODMsIDAsOCwxMjUsIDAsOCw2MSwgMCw5LDIxOCxcbiAgICA4Miw3LDIzLCAwLDgsMTA5LCAwLDgsNDUsIDAsOSwxODYsXG4gICAgMCw4LDEzLCAwLDgsMTQxLCAwLDgsNzcsIDAsOSwyNTAsXG4gICAgODAsNywzLCAwLDgsODMsIDAsOCwxOSwgODUsOCwxOTUsXG4gICAgODMsNywzNSwgMCw4LDExNSwgMCw4LDUxLCAwLDksMTk4LFxuICAgIDgxLDcsMTEsIDAsOCw5OSwgMCw4LDM1LCAwLDksMTY2LFxuICAgIDAsOCwzLCAwLDgsMTMxLCAwLDgsNjcsIDAsOSwyMzAsXG4gICAgODAsNyw3LCAwLDgsOTEsIDAsOCwyNywgMCw5LDE1MCxcbiAgICA4NCw3LDY3LCAwLDgsMTIzLCAwLDgsNTksIDAsOSwyMTQsXG4gICAgODIsNywxOSwgMCw4LDEwNywgMCw4LDQzLCAwLDksMTgyLFxuICAgIDAsOCwxMSwgMCw4LDEzOSwgMCw4LDc1LCAwLDksMjQ2LFxuICAgIDgwLDcsNSwgMCw4LDg3LCAwLDgsMjMsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOSwgMCw4LDU1LCAwLDksMjA2LFxuICAgIDgxLDcsMTUsIDAsOCwxMDMsIDAsOCwzOSwgMCw5LDE3NCxcbiAgICAwLDgsNywgMCw4LDEzNSwgMCw4LDcxLCAwLDksMjM4LFxuICAgIDgwLDcsOSwgMCw4LDk1LCAwLDgsMzEsIDAsOSwxNTgsXG4gICAgODQsNyw5OSwgMCw4LDEyNywgMCw4LDYzLCAwLDksMjIyLFxuICAgIDgyLDcsMjcsIDAsOCwxMTEsIDAsOCw0NywgMCw5LDE5MCxcbiAgICAwLDgsMTUsIDAsOCwxNDMsIDAsOCw3OSwgMCw5LDI1NCxcbiAgICA5Niw3LDI1NiwgMCw4LDgwLCAwLDgsMTYsIDg0LDgsMTE1LFxuICAgIDgyLDcsMzEsIDAsOCwxMTIsIDAsOCw0OCwgMCw5LDE5MyxcblxuICAgIDgwLDcsMTAsIDAsOCw5NiwgMCw4LDMyLCAwLDksMTYxLFxuICAgIDAsOCwwLCAwLDgsMTI4LCAwLDgsNjQsIDAsOSwyMjUsXG4gICAgODAsNyw2LCAwLDgsODgsIDAsOCwyNCwgMCw5LDE0NSxcbiAgICA4Myw3LDU5LCAwLDgsMTIwLCAwLDgsNTYsIDAsOSwyMDksXG4gICAgODEsNywxNywgMCw4LDEwNCwgMCw4LDQwLCAwLDksMTc3LFxuICAgIDAsOCw4LCAwLDgsMTM2LCAwLDgsNzIsIDAsOSwyNDEsXG4gICAgODAsNyw0LCAwLDgsODQsIDAsOCwyMCwgODUsOCwyMjcsXG4gICAgODMsNyw0MywgMCw4LDExNiwgMCw4LDUyLCAwLDksMjAxLFxuICAgIDgxLDcsMTMsIDAsOCwxMDAsIDAsOCwzNiwgMCw5LDE2OSxcbiAgICAwLDgsNCwgMCw4LDEzMiwgMCw4LDY4LCAwLDksMjMzLFxuICAgIDgwLDcsOCwgMCw4LDkyLCAwLDgsMjgsIDAsOSwxNTMsXG4gICAgODQsNyw4MywgMCw4LDEyNCwgMCw4LDYwLCAwLDksMjE3LFxuICAgIDgyLDcsMjMsIDAsOCwxMDgsIDAsOCw0NCwgMCw5LDE4NSxcbiAgICAwLDgsMTIsIDAsOCwxNDAsIDAsOCw3NiwgMCw5LDI0OSxcbiAgICA4MCw3LDMsIDAsOCw4MiwgMCw4LDE4LCA4NSw4LDE2MyxcbiAgICA4Myw3LDM1LCAwLDgsMTE0LCAwLDgsNTAsIDAsOSwxOTcsXG4gICAgODEsNywxMSwgMCw4LDk4LCAwLDgsMzQsIDAsOSwxNjUsXG4gICAgMCw4LDIsIDAsOCwxMzAsIDAsOCw2NiwgMCw5LDIyOSxcbiAgICA4MCw3LDcsIDAsOCw5MCwgMCw4LDI2LCAwLDksMTQ5LFxuICAgIDg0LDcsNjcsIDAsOCwxMjIsIDAsOCw1OCwgMCw5LDIxMyxcbiAgICA4Miw3LDE5LCAwLDgsMTA2LCAwLDgsNDIsIDAsOSwxODEsXG4gICAgMCw4LDEwLCAwLDgsMTM4LCAwLDgsNzQsIDAsOSwyNDUsXG4gICAgODAsNyw1LCAwLDgsODYsIDAsOCwyMiwgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE4LCAwLDgsNTQsIDAsOSwyMDUsXG4gICAgODEsNywxNSwgMCw4LDEwMiwgMCw4LDM4LCAwLDksMTczLFxuICAgIDAsOCw2LCAwLDgsMTM0LCAwLDgsNzAsIDAsOSwyMzcsXG4gICAgODAsNyw5LCAwLDgsOTQsIDAsOCwzMCwgMCw5LDE1NyxcbiAgICA4NCw3LDk5LCAwLDgsMTI2LCAwLDgsNjIsIDAsOSwyMjEsXG4gICAgODIsNywyNywgMCw4LDExMCwgMCw4LDQ2LCAwLDksMTg5LFxuICAgIDAsOCwxNCwgMCw4LDE0MiwgMCw4LDc4LCAwLDksMjUzLFxuICAgIDk2LDcsMjU2LCAwLDgsODEsIDAsOCwxNywgODUsOCwxMzEsXG4gICAgODIsNywzMSwgMCw4LDExMywgMCw4LDQ5LCAwLDksMTk1LFxuICAgIDgwLDcsMTAsIDAsOCw5NywgMCw4LDMzLCAwLDksMTYzLFxuICAgIDAsOCwxLCAwLDgsMTI5LCAwLDgsNjUsIDAsOSwyMjcsXG4gICAgODAsNyw2LCAwLDgsODksIDAsOCwyNSwgMCw5LDE0NyxcbiAgICA4Myw3LDU5LCAwLDgsMTIxLCAwLDgsNTcsIDAsOSwyMTEsXG4gICAgODEsNywxNywgMCw4LDEwNSwgMCw4LDQxLCAwLDksMTc5LFxuICAgIDAsOCw5LCAwLDgsMTM3LCAwLDgsNzMsIDAsOSwyNDMsXG4gICAgODAsNyw0LCAwLDgsODUsIDAsOCwyMSwgODAsOCwyNTgsXG4gICAgODMsNyw0MywgMCw4LDExNywgMCw4LDUzLCAwLDksMjAzLFxuICAgIDgxLDcsMTMsIDAsOCwxMDEsIDAsOCwzNywgMCw5LDE3MSxcbiAgICAwLDgsNSwgMCw4LDEzMywgMCw4LDY5LCAwLDksMjM1LFxuICAgIDgwLDcsOCwgMCw4LDkzLCAwLDgsMjksIDAsOSwxNTUsXG4gICAgODQsNyw4MywgMCw4LDEyNSwgMCw4LDYxLCAwLDksMjE5LFxuICAgIDgyLDcsMjMsIDAsOCwxMDksIDAsOCw0NSwgMCw5LDE4NyxcbiAgICAwLDgsMTMsIDAsOCwxNDEsIDAsOCw3NywgMCw5LDI1MSxcbiAgICA4MCw3LDMsIDAsOCw4MywgMCw4LDE5LCA4NSw4LDE5NSxcbiAgICA4Myw3LDM1LCAwLDgsMTE1LCAwLDgsNTEsIDAsOSwxOTksXG4gICAgODEsNywxMSwgMCw4LDk5LCAwLDgsMzUsIDAsOSwxNjcsXG4gICAgMCw4LDMsIDAsOCwxMzEsIDAsOCw2NywgMCw5LDIzMSxcbiAgICA4MCw3LDcsIDAsOCw5MSwgMCw4LDI3LCAwLDksMTUxLFxuICAgIDg0LDcsNjcsIDAsOCwxMjMsIDAsOCw1OSwgMCw5LDIxNSxcbiAgICA4Miw3LDE5LCAwLDgsMTA3LCAwLDgsNDMsIDAsOSwxODMsXG4gICAgMCw4LDExLCAwLDgsMTM5LCAwLDgsNzUsIDAsOSwyNDcsXG4gICAgODAsNyw1LCAwLDgsODcsIDAsOCwyMywgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE5LCAwLDgsNTUsIDAsOSwyMDcsXG4gICAgODEsNywxNSwgMCw4LDEwMywgMCw4LDM5LCAwLDksMTc1LFxuICAgIDAsOCw3LCAwLDgsMTM1LCAwLDgsNzEsIDAsOSwyMzksXG4gICAgODAsNyw5LCAwLDgsOTUsIDAsOCwzMSwgMCw5LDE1OSxcbiAgICA4NCw3LDk5LCAwLDgsMTI3LCAwLDgsNjMsIDAsOSwyMjMsXG4gICAgODIsNywyNywgMCw4LDExMSwgMCw4LDQ3LCAwLDksMTkxLFxuICAgIDAsOCwxNSwgMCw4LDE0MywgMCw4LDc5LCAwLDksMjU1XG5dO1xudmFyIGZpeGVkX3RkID0gW1xuICAgIDgwLDUsMSwgODcsNSwyNTcsIDgzLDUsMTcsIDkxLDUsNDA5NyxcbiAgICA4MSw1LDUsIDg5LDUsMTAyNSwgODUsNSw2NSwgOTMsNSwxNjM4NSxcbiAgICA4MCw1LDMsIDg4LDUsNTEzLCA4NCw1LDMzLCA5Miw1LDgxOTMsXG4gICAgODIsNSw5LCA5MCw1LDIwNDksIDg2LDUsMTI5LCAxOTIsNSwyNDU3NyxcbiAgICA4MCw1LDIsIDg3LDUsMzg1LCA4Myw1LDI1LCA5MSw1LDYxNDUsXG4gICAgODEsNSw3LCA4OSw1LDE1MzcsIDg1LDUsOTcsIDkzLDUsMjQ1NzcsXG4gICAgODAsNSw0LCA4OCw1LDc2OSwgODQsNSw0OSwgOTIsNSwxMjI4OSxcbiAgICA4Miw1LDEzLCA5MCw1LDMwNzMsIDg2LDUsMTkzLCAxOTIsNSwyNDU3N1xuXTtcblxuICAvLyBUYWJsZXMgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxuICB2YXIgY3BsZW5zID0gWyAvLyBDb3B5IGxlbmd0aHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcbiAgICAgICAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgICAgICAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbiAgXTtcblxuICAvLyBzZWUgbm90ZSAjMTMgYWJvdmUgYWJvdXQgMjU4XG4gIHZhciBjcGxleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMixcbiAgICAgICAgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgMTEyLCAxMTIgIC8vIDExMj09aW52YWxpZFxuICBdO1xuXG4gdmFyIGNwZGlzdCA9IFsgLy8gQ29weSBvZmZzZXRzIGZvciBkaXN0YW5jZSBjb2RlcyAwLi4yOVxuICAgICAgICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gICAgICAgIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgICAgICAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3N1xuICBdO1xuXG4gIHZhciBjcGRleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVzXG4gICAgICAgIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsXG4gICAgICAgIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLFxuICAgICAgICAxMiwgMTIsIDEzLCAxM107XG5cbi8vXG4vLyBaU3RyZWFtLmphdmFcbi8vXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG59XG5cblxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZUluaXQgPSBmdW5jdGlvbih3LCBub3dyYXApIHtcbiAgICBpZiAoIXcpIHtcblx0dyA9IERFRl9XQklUUztcbiAgICB9XG4gICAgaWYgKG5vd3JhcCkge1xuXHRub3dyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc3RhdGUgPSBuZXcgSW5mbGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLmlzdGF0ZS5pbmZsYXRlSW5pdCh0aGlzLCBub3dyYXA/LXc6dyk7XG59XG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGUgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYodGhpcy5pc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gdGhpcy5pc3RhdGUuaW5mbGF0ZSh0aGlzLCBmKTtcbn1cblxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5pc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB2YXIgcmV0PWlzdGF0ZS5pbmZsYXRlRW5kKHRoaXMpO1xuICAgIHRoaXMuaXN0YXRlID0gbnVsbDtcbiAgICByZXR1cm4gcmV0O1xufVxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbigpe1xuICAgIC8vIGlmKGlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGlzdGF0ZS5pbmZsYXRlU3luYyh0aGlzKTtcbn1cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCl7XG4gICAgLy8gaWYoaXN0YXRlID09IG51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xufVxuXG4vKlxuXG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIE1BWF9XQklUUyk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwsIGJvb2xlYW4gbm93cmFwKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIE1BWF9XQklUUywgbm93cmFwKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCwgaW50IGJpdHMpe1xuICAgIHJldHVybiBkZWZsYXRlSW5pdChsZXZlbCwgYml0cywgZmFsc2UpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsLCBpbnQgYml0cywgYm9vbGVhbiBub3dyYXApe1xuICAgIGRzdGF0ZT1uZXcgRGVmbGF0ZSgpO1xuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZUluaXQodGhpcywgbGV2ZWwsIG5vd3JhcD8tYml0czpiaXRzKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGUoaW50IGZsdXNoKXtcbiAgICBpZihkc3RhdGU9PW51bGwpe1xuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGUodGhpcywgZmx1c2gpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUVuZCgpe1xuICAgIGlmKGRzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGludCByZXQ9ZHN0YXRlLmRlZmxhdGVFbmQoKTtcbiAgICBkc3RhdGU9bnVsbDtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZVBhcmFtcyhpbnQgbGV2ZWwsIGludCBzdHJhdGVneSl7XG4gICAgaWYoZHN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlUGFyYW1zKHRoaXMsIGxldmVsLCBzdHJhdGVneSk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlU2V0RGljdGlvbmFyeSAoYnl0ZVtdIGRpY3Rpb25hcnksIGludCBkaWN0TGVuZ3RoKXtcbiAgICBpZihkc3RhdGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xuICB9XG5cbiovXG5cbi8qXG4gIC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAgLy8gdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICAvLyB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+bmV4dF9vdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gIC8vIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAgdm9pZCBmbHVzaF9wZW5kaW5nKCl7XG4gICAgaW50IGxlbj1kc3RhdGUucGVuZGluZztcblxuICAgIGlmKGxlbj5hdmFpbF9vdXQpIGxlbj1hdmFpbF9vdXQ7XG4gICAgaWYobGVuPT0wKSByZXR1cm47XG5cbiAgICBpZihkc3RhdGUucGVuZGluZ19idWYubGVuZ3RoPD1kc3RhdGUucGVuZGluZ19vdXQgfHxcbiAgICAgICBuZXh0X291dC5sZW5ndGg8PW5leHRfb3V0X2luZGV4IHx8XG4gICAgICAgZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aDwoZHN0YXRlLnBlbmRpbmdfb3V0K2xlbikgfHxcbiAgICAgICBuZXh0X291dC5sZW5ndGg8KG5leHRfb3V0X2luZGV4K2xlbikpe1xuICAgICAgU3lzdGVtLm91dC5wcmludGxuKGRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGgrXCIsIFwiK2RzdGF0ZS5wZW5kaW5nX291dCtcblx0XHRcdCBcIiwgXCIrbmV4dF9vdXQubGVuZ3RoK1wiLCBcIituZXh0X291dF9pbmRleCtcIiwgXCIrbGVuKTtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihcImF2YWlsX291dD1cIithdmFpbF9vdXQpO1xuICAgIH1cblxuICAgIFN5c3RlbS5hcnJheWNvcHkoZHN0YXRlLnBlbmRpbmdfYnVmLCBkc3RhdGUucGVuZGluZ19vdXQsXG5cdFx0ICAgICBuZXh0X291dCwgbmV4dF9vdXRfaW5kZXgsIGxlbik7XG5cbiAgICBuZXh0X291dF9pbmRleCs9bGVuO1xuICAgIGRzdGF0ZS5wZW5kaW5nX291dCs9bGVuO1xuICAgIHRvdGFsX291dCs9bGVuO1xuICAgIGF2YWlsX291dC09bGVuO1xuICAgIGRzdGF0ZS5wZW5kaW5nLT1sZW47XG4gICAgaWYoZHN0YXRlLnBlbmRpbmc9PTApe1xuICAgICAgZHN0YXRlLnBlbmRpbmdfb3V0PTA7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICAvLyBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICAvLyB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICAvLyBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+bmV4dF9pbiBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAgLy8gKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gIGludCByZWFkX2J1ZihieXRlW10gYnVmLCBpbnQgc3RhcnQsIGludCBzaXplKSB7XG4gICAgaW50IGxlbj1hdmFpbF9pbjtcblxuICAgIGlmKGxlbj5zaXplKSBsZW49c2l6ZTtcbiAgICBpZihsZW49PTApIHJldHVybiAwO1xuXG4gICAgYXZhaWxfaW4tPWxlbjtcblxuICAgIGlmKGRzdGF0ZS5ub2hlYWRlcj09MCkge1xuICAgICAgYWRsZXI9X2FkbGVyLmFkbGVyMzIoYWRsZXIsIG5leHRfaW4sIG5leHRfaW5faW5kZXgsIGxlbik7XG4gICAgfVxuICAgIFN5c3RlbS5hcnJheWNvcHkobmV4dF9pbiwgbmV4dF9pbl9pbmRleCwgYnVmLCBzdGFydCwgbGVuKTtcbiAgICBuZXh0X2luX2luZGV4ICArPSBsZW47XG4gICAgdG90YWxfaW4gKz0gbGVuO1xuICAgIHJldHVybiBsZW47XG4gIH1cblxuICBwdWJsaWMgdm9pZCBmcmVlKCl7XG4gICAgbmV4dF9pbj1udWxsO1xuICAgIG5leHRfb3V0PW51bGw7XG4gICAgbXNnPW51bGw7XG4gICAgX2FkbGVyPW51bGw7XG4gIH1cbn1cbiovXG5cblxuLy9cbi8vIEluZmxhdGUuamF2YVxuLy9cblxuZnVuY3Rpb24gSW5mbGF0ZSgpIHtcbiAgICB0aGlzLndhcyA9IFswXTtcbn1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVJlc2V0ID0gZnVuY3Rpb24oeikge1xuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgXG4gICAgei50b3RhbF9pbiA9IHoudG90YWxfb3V0ID0gMDtcbiAgICB6Lm1zZyA9IG51bGw7XG4gICAgei5pc3RhdGUubW9kZSA9IHouaXN0YXRlLm5vd3JhcCE9MCA/IEJMT0NLUyA6IE1FVEhPRDtcbiAgICB6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgbnVsbCk7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVFbmQgPSBmdW5jdGlvbih6KXtcbiAgICBpZih0aGlzLmJsb2NrcyAhPSBudWxsKVxuICAgICAgdGhpcy5ibG9ja3MuZnJlZSh6KTtcbiAgICB0aGlzLmJsb2Nrcz1udWxsO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlSW5pdCA9IGZ1bmN0aW9uKHosIHcpe1xuICAgIHoubXNnID0gbnVsbDtcbiAgICB0aGlzLmJsb2NrcyA9IG51bGw7XG5cbiAgICAvLyBoYW5kbGUgdW5kb2N1bWVudGVkIG5vd3JhcCBvcHRpb24gKG5vIHpsaWIgaGVhZGVyIG9yIGNoZWNrKVxuICAgIG5vd3JhcCA9IDA7XG4gICAgaWYodyA8IDApe1xuICAgICAgdyA9IC0gdztcbiAgICAgIG5vd3JhcCA9IDE7XG4gICAgfVxuXG4gICAgLy8gc2V0IHdpbmRvdyBzaXplXG4gICAgaWYodzw4IHx8dz4xNSl7XG4gICAgICB0aGlzLmluZmxhdGVFbmQoeik7XG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICAgIHRoaXMud2JpdHM9dztcblxuICAgIHouaXN0YXRlLmJsb2Nrcz1uZXcgSW5mQmxvY2tzKHosIFxuXHRcdFx0XHQgIHouaXN0YXRlLm5vd3JhcCE9MCA/IG51bGwgOiB0aGlzLFxuXHRcdFx0XHQgIDE8PHcpO1xuXG4gICAgLy8gcmVzZXQgc3RhdGVcbiAgICB0aGlzLmluZmxhdGVSZXNldCh6KTtcbiAgICByZXR1cm4gWl9PSztcbiAgfVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlID0gZnVuY3Rpb24oeiwgZil7XG4gICAgdmFyIHIsIGI7XG5cbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbCB8fCB6Lm5leHRfaW4gPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBmID0gZiA9PSBaX0ZJTklTSCA/IFpfQlVGX0VSUk9SIDogWl9PSztcbiAgICByID0gWl9CVUZfRVJST1I7XG4gICAgd2hpbGUgKHRydWUpe1xuICAgICAgc3dpdGNoICh6LmlzdGF0ZS5tb2RlKXtcbiAgICAgIGNhc2UgTUVUSE9EOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICBpZigoKHouaXN0YXRlLm1ldGhvZCA9IHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10pJjB4ZikhPVpfREVGTEFURUQpe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2c9XCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFwiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKCh6LmlzdGF0ZS5tZXRob2Q+PjQpKzg+ei5pc3RhdGUud2JpdHMpe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2c9XCJpbnZhbGlkIHdpbmRvdyBzaXplXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgei5pc3RhdGUubW9kZT1GTEFHO1xuICAgICAgY2FzZSBGTEFHOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICBiID0gKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10pJjB4ZmY7XG5cbiAgICAgICAgaWYoKCgoei5pc3RhdGUubWV0aG9kIDw8IDgpK2IpICUgMzEpIT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnID0gXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZigoYiZQUkVTRVRfRElDVCk9PTApe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1Q0O1xuICAgICAgY2FzZSBESUNUNDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZD0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDI0KSYweGZmMDAwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPURJQ1QzO1xuICAgICAgY2FzZSBESUNUMzpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwxNikmMHhmZjAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RElDVDI7XG4gICAgICBjYXNlIERJQ1QyOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDgpJjB4ZmYwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1ESUNUMTtcbiAgICAgIGNhc2UgRElDVDE6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQgKz0gKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik7XG4gICAgICAgIHouYWRsZXIgPSB6LmlzdGF0ZS5uZWVkO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDA7XG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIGNhc2UgRElDVDA6XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIHoubXNnID0gXCJuZWVkIGRpY3Rpb25hcnlcIjtcbiAgICAgICAgei5pc3RhdGUubWFya2VyID0gMDsgICAgICAgLy8gY2FuIHRyeSBpbmZsYXRlU3luY1xuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgICBjYXNlIEJMT0NLUzpcblxuICAgICAgICByID0gei5pc3RhdGUuYmxvY2tzLnByb2Moeiwgcik7XG4gICAgICAgIGlmKHIgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7ICAgICAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYociA9PSBaX09LKXtcbiAgICAgICAgICByID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZihyICE9IFpfU1RSRUFNX0VORCl7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IGY7XG4gICAgICAgIHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCB6LmlzdGF0ZS53YXMpO1xuICAgICAgICBpZih6LmlzdGF0ZS5ub3dyYXAhPTApe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGU9RE9ORTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB6LmlzdGF0ZS5tb2RlPUNIRUNLNDtcbiAgICAgIGNhc2UgQ0hFQ0s0OlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MjQpJjB4ZmYwMDAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9Q0hFQ0szO1xuICAgICAgY2FzZSBDSEVDSzM6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MTYpJjB4ZmYwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQ0hFQ0syO1xuICAgICAgY2FzZSBDSEVDSzI6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8OCkmMHhmZjAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQ0hFQ0sxO1xuICAgICAgY2FzZSBDSEVDSzE6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpO1xuXG4gICAgICAgIGlmKCgoei5pc3RhdGUud2FzWzBdKSkgIT0gKCh6LmlzdGF0ZS5uZWVkKSkpe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2cgPSBcImluY29ycmVjdCBkYXRhIGNoZWNrXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oeiwgIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcbiAgICB2YXIgaW5kZXg9MDtcbiAgICB2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcbiAgICBpZih6PT1udWxsIHx8IHouaXN0YXRlID09IG51bGx8fCB6LmlzdGF0ZS5tb2RlICE9IERJQ1QwKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuXG4gICAgaWYoei5fYWRsZXIuYWRsZXIzMigxLCBkaWN0aW9uYXJ5LCAwLCBkaWN0TGVuZ3RoKSE9ei5hZGxlcil7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cblxuICAgIHouYWRsZXIgPSB6Ll9hZGxlci5hZGxlcjMyKDAsIG51bGwsIDAsIDApO1xuXG4gICAgaWYobGVuZ3RoID49ICgxPDx6LmlzdGF0ZS53Yml0cykpe1xuICAgICAgbGVuZ3RoID0gKDE8PHouaXN0YXRlLndiaXRzKS0xO1xuICAgICAgaW5kZXg9ZGljdExlbmd0aCAtIGxlbmd0aDtcbiAgICB9XG4gICAgei5pc3RhdGUuYmxvY2tzLnNldF9kaWN0aW9uYXJ5KGRpY3Rpb25hcnksIGluZGV4LCBsZW5ndGgpO1xuICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XG4gICAgcmV0dXJuIFpfT0s7XG4gIH1cblxuLy8gIHN0YXRpYyBwcml2YXRlIGJ5dGVbXSBtYXJrID0geyhieXRlKTAsIChieXRlKTAsIChieXRlKTB4ZmYsIChieXRlKTB4ZmZ9O1xudmFyIG1hcmsgPSBbMCwgMCwgMjU1LCAyNTVdXG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oeil7XG4gICAgdmFyIG47ICAgICAgIC8vIG51bWJlciBvZiBieXRlcyB0byBsb29rIGF0XG4gICAgdmFyIHA7ICAgICAgIC8vIHBvaW50ZXIgdG8gYnl0ZXNcbiAgICB2YXIgbTsgICAgICAgLy8gbnVtYmVyIG9mIG1hcmtlciBieXRlcyBmb3VuZCBpbiBhIHJvd1xuICAgIHZhciByLCB3OyAgIC8vIHRlbXBvcmFyaWVzIHRvIHNhdmUgdG90YWxfaW4gYW5kIHRvdGFsX291dFxuXG4gICAgLy8gc2V0IHVwXG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgaWYoei5pc3RhdGUubW9kZSAhPSBCQUQpe1xuICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7XG4gICAgfVxuICAgIGlmKChuPXouYXZhaWxfaW4pPT0wKVxuICAgICAgcmV0dXJuIFpfQlVGX0VSUk9SO1xuICAgIHA9ei5uZXh0X2luX2luZGV4O1xuICAgIG09ei5pc3RhdGUubWFya2VyO1xuXG4gICAgLy8gc2VhcmNoXG4gICAgd2hpbGUgKG4hPTAgJiYgbSA8IDQpe1xuICAgICAgaWYoei5uZXh0X2luW3BdID09IG1hcmtbbV0pe1xuICAgICAgICBtKys7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHoubmV4dF9pbltwXSE9MCl7XG4gICAgICAgIG0gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgbSA9IDQgLSBtO1xuICAgICAgfVxuICAgICAgcCsrOyBuLS07XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZVxuICAgIHoudG90YWxfaW4gKz0gcC16Lm5leHRfaW5faW5kZXg7XG4gICAgei5uZXh0X2luX2luZGV4ID0gcDtcbiAgICB6LmF2YWlsX2luID0gbjtcbiAgICB6LmlzdGF0ZS5tYXJrZXIgPSBtO1xuXG4gICAgLy8gcmV0dXJuIG5vIGpveSBvciBzZXQgdXAgdG8gcmVzdGFydCBvbiBhIG5ldyBibG9ja1xuICAgIGlmKG0gIT0gNCl7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgICByPXoudG90YWxfaW47ICB3PXoudG90YWxfb3V0O1xuICAgIHRoaXMuaW5mbGF0ZVJlc2V0KHopO1xuICAgIHoudG90YWxfaW49cjsgIHoudG90YWxfb3V0ID0gdztcbiAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgIHJldHVybiBaX09LO1xufVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXG4gIC8vIGJ5IFpfU1lOQ19GTFVTSCBvciBaX0ZVTExfRkxVU0guIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSBvbmUgUFBQXG4gIC8vIGltcGxlbWVudGF0aW9uIHRvIHByb3ZpZGUgYW4gYWRkaXRpb25hbCBzYWZldHkgY2hlY2suIFBQUCB1c2VzIFpfU1lOQ19GTFVTSFxuICAvLyBidXQgcmVtb3ZlcyB0aGUgbGVuZ3RoIGJ5dGVzIG9mIHRoZSByZXN1bHRpbmcgZW1wdHkgc3RvcmVkIGJsb2NrLiBXaGVuXG4gIC8vIGRlY29tcHJlc3NpbmcsIFBQUCBjaGVja3MgdGhhdCBhdCB0aGUgZW5kIG9mIGlucHV0IHBhY2tldCwgaW5mbGF0ZSBpc1xuICAvLyB3YWl0aW5nIGZvciB0aGVzZSBsZW5ndGggYnl0ZXMuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU3luY1BvaW50ID0gZnVuY3Rpb24oeil7XG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwgfHwgei5pc3RhdGUuYmxvY2tzID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIHouaXN0YXRlLmJsb2Nrcy5zeW5jX3BvaW50KCk7XG59XG5cblxuLy9cbi8vIEluZkJsb2Nrcy5qYXZhXG4vL1xuXG52YXIgSU5GQkxPQ0tTX0JPUkRFUiA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTtcblxuZnVuY3Rpb24gSW5mQmxvY2tzKHosIGNoZWNrZm4sIHcpIHtcbiAgICB0aGlzLmh1ZnRzPW5ldyBJbnQzMkFycmF5KE1BTlkqMyk7XG4gICAgdGhpcy53aW5kb3c9bmV3IFVpbnQ4QXJyYXkodyk7XG4gICAgdGhpcy5lbmQ9dztcbiAgICB0aGlzLmNoZWNrZm4gPSBjaGVja2ZuO1xuICAgIHRoaXMubW9kZSA9IElCX1RZUEU7XG4gICAgdGhpcy5yZXNldCh6LCBudWxsKTtcblxuICAgIHRoaXMubGVmdCA9IDA7ICAgICAgICAgICAgLy8gaWYgU1RPUkVELCBieXRlcyBsZWZ0IHRvIGNvcHkgXG5cbiAgICB0aGlzLnRhYmxlID0gMDsgICAgICAgICAgIC8vIHRhYmxlIGxlbmd0aHMgKDE0IGJpdHMpIFxuICAgIHRoaXMuaW5kZXggPSAwOyAgICAgICAgICAgLy8gaW5kZXggaW50byBibGVucyAob3IgYm9yZGVyKSBcbiAgICB0aGlzLmJsZW5zID0gbnVsbDsgICAgICAgICAvLyBiaXQgbGVuZ3RocyBvZiBjb2RlcyBcbiAgICB0aGlzLmJiPW5ldyBJbnQzMkFycmF5KDEpOyAvLyBiaXQgbGVuZ3RoIHRyZWUgZGVwdGggXG4gICAgdGhpcy50Yj1uZXcgSW50MzJBcnJheSgxKTsgLy8gYml0IGxlbmd0aCBkZWNvZGluZyB0cmVlIFxuXG4gICAgdGhpcy5jb2RlcyA9IG5ldyBJbmZDb2RlcygpO1xuXG4gICAgdGhpcy5sYXN0ID0gMDsgICAgICAgICAgICAvLyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgdGhlIGxhc3QgYmxvY2sgXG5cbiAgLy8gbW9kZSBpbmRlcGVuZGVudCBpbmZvcm1hdGlvbiBcbiAgICB0aGlzLmJpdGsgPSAwOyAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlciBcbiAgICB0aGlzLmJpdGIgPSAwOyAgICAgICAgICAgIC8vIGJpdCBidWZmZXIgXG4gICAgdGhpcy5yZWFkID0gMDsgICAgICAgICAgICAvLyB3aW5kb3cgcmVhZCBwb2ludGVyIFxuICAgIHRoaXMud3JpdGUgPSAwOyAgICAgICAgICAgLy8gd2luZG93IHdyaXRlIHBvaW50ZXIgXG4gICAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgIC8vIGNoZWNrIG9uIG91dHB1dCBcblxuICAgIHRoaXMuaW5mdHJlZT1uZXcgSW5mVHJlZSgpO1xufVxuXG5cblxuXG5JbmZCbG9ja3MucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oeiwgYyl7XG4gICAgaWYoYykgY1swXT10aGlzLmNoZWNrO1xuICAgIGlmKHRoaXMubW9kZT09SUJfQ09ERVMpe1xuICAgICAgdGhpcy5jb2Rlcy5mcmVlKHopO1xuICAgIH1cbiAgICB0aGlzLm1vZGU9SUJfVFlQRTtcbiAgICB0aGlzLmJpdGs9MDtcbiAgICB0aGlzLmJpdGI9MDtcbiAgICB0aGlzLnJlYWQ9dGhpcy53cml0ZT0wO1xuXG4gICAgaWYodGhpcy5jaGVja2ZuKVxuICAgICAgei5hZGxlcj10aGlzLmNoZWNrPXouX2FkbGVyLmFkbGVyMzIoMCwgbnVsbCwgMCwgMCk7XG4gIH1cblxuIEluZkJsb2Nrcy5wcm90b3R5cGUucHJvYyA9IGZ1bmN0aW9uKHosIHIpe1xuICAgIHZhciB0OyAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgICB2YXIgYjsgICAgICAgICAgICAgIC8vIGJpdCBidWZmZXJcbiAgICB2YXIgazsgICAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxuICAgIHZhciBwOyAgICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcbiAgICB2YXIgcTsgICAgICAgICAgICAgIC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxuICAgIHZhciBtOyAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcblxuICAgIC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxuICAgIHtwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj10aGlzLmJpdGI7az10aGlzLmJpdGs7fVxuICAgIHtxPXRoaXMud3JpdGU7bT0ocTx0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7fVxuXG4gICAgLy8gcHJvY2VzcyBpbnB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICBzd2l0Y2ggKHRoaXMubW9kZSl7XG4gICAgICBjYXNlIElCX1RZUEU6XG5cblx0d2hpbGUoazwoMykpe1xuXHQgIGlmKG4hPTApe1xuXHQgICAgcj1aX09LO1xuXHQgIH1cblx0ICBlbHNle1xuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjtcblx0ICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH07XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cdHQgPSAoYiAmIDcpO1xuXHR0aGlzLmxhc3QgPSB0ICYgMTtcblxuXHRzd2l0Y2ggKHQgPj4+IDEpe1xuICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBcbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cbiAgICAgICAgICB0ID0gayAmIDc7ICAgICAgICAgICAgICAgICAgICAvLyBnbyB0byBieXRlIGJvdW5kYXJ5XG5cbiAgICAgICAgICB7Yj4+Pj0odCk7ay09KHQpO31cbiAgICAgICAgICB0aGlzLm1vZGUgPSBJQl9MRU5TOyAgICAgICAgICAgICAgICAgIC8vIGdldCBsZW5ndGggb2Ygc3RvcmVkIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4ZWRcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBibD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgICAgdmFyIGJkPW5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgICB2YXIgdGw9W107XG5cdCAgICAgIHZhciB0ZD1bXTtcblxuXHQgICAgICBpbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkLCB6KTtcbiAgICAgICAgICAgICAgdGhpcy5jb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGxbMF0sIDAsIHRkWzBdLCAwLCB6KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cblxuICAgICAgICAgIHRoaXMubW9kZSA9IElCX0NPREVTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWNcblxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuXG4gICAgICAgICAgdGhpcy5tb2RlID0gSUJfVEFCTEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWxsZWdhbFxuXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG4gICAgICAgICAgdGhpcy5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnID0gXCJpbnZhbGlkIGJsb2NrIHR5cGVcIjtcbiAgICAgICAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgdGhpcy53cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXHRicmVhaztcbiAgICAgIGNhc2UgSUJfTEVOUzpcblx0d2hpbGUoazwoMzIpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdGlmICgoKCh+YikgPj4+IDE2KSAmIDB4ZmZmZikgIT0gKGIgJiAweGZmZmYpKXtcblx0ICB0aGlzLm1vZGUgPSBCQUQ7XG5cdCAgei5tc2cgPSBcImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHNcIjtcblx0ICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgdGhpcy53cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXHR0aGlzLmxlZnQgPSAoYiAmIDB4ZmZmZik7XG5cdGIgPSBrID0gMDsgICAgICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgYml0c1xuXHR0aGlzLm1vZGUgPSB0aGlzLmxlZnQhPTAgPyBJQl9TVE9SRUQgOiAodGhpcy5sYXN0IT0wID8gSUJfRFJZIDogSUJfVFlQRSk7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQl9TVE9SRUQ6XG5cdGlmIChuID09IDApe1xuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHdyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cblx0aWYobT09MCl7XG5cdCAgaWYocT09ZW5kJiZyZWFkIT0wKXtcblx0ICAgIHE9MDsgbT0ocTx0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgfVxuXHQgIGlmKG09PTApe1xuXHQgICAgdGhpcy53cml0ZT1xOyBcblx0ICAgIHI9dGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICBxPXRoaXMud3JpdGU7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0ICAgIGlmKHE9PXRoaXMuZW5kICYmIHRoaXMucmVhZCAhPSAwKXtcblx0ICAgICAgcT0wOyBtID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgICB9XG5cdCAgICBpZihtPT0wKXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0cj1aX09LO1xuXG5cdHQgPSB0aGlzLmxlZnQ7XG5cdGlmKHQ+bikgdCA9IG47XG5cdGlmKHQ+bSkgdCA9IG07XG5cdGFycmF5Q29weSh6Lm5leHRfaW4sIHAsIHRoaXMud2luZG93LCBxLCB0KTtcblx0cCArPSB0OyAgbiAtPSB0O1xuXHRxICs9IHQ7ICBtIC09IHQ7XG5cdGlmICgodGhpcy5sZWZ0IC09IHQpICE9IDApXG5cdCAgYnJlYWs7XG5cdHRoaXMubW9kZSA9ICh0aGlzLmxhc3QgIT0gMCA/IElCX0RSWSA6IElCX1RZUEUpO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUJfVEFCTEU6XG5cblx0d2hpbGUoazwoMTQpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMudGFibGUgPSB0ID0gKGIgJiAweDNmZmYpO1xuXHRpZiAoKHQgJiAweDFmKSA+IDI5IHx8ICgodCA+PiA1KSAmIDB4MWYpID4gMjkpXG5cdCAge1xuXHQgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgICAgei5tc2cgPSBcInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXCI7XG5cdCAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0dCA9IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKTtcblx0aWYodGhpcy5ibGVucz09bnVsbCB8fCB0aGlzLmJsZW5zLmxlbmd0aDx0KXtcblx0ICAgIHRoaXMuYmxlbnM9bmV3IEludDMyQXJyYXkodCk7XG5cdH1cblx0ZWxzZXtcblx0ICBmb3IodmFyIGk9MDsgaTx0OyBpKyspe1xuICAgICAgICAgICAgICB0aGlzLmJsZW5zW2ldPTA7XG4gICAgICAgICAgfVxuXHR9XG5cblx0e2I+Pj49KDE0KTtrLT0oMTQpO31cblxuXHR0aGlzLmluZGV4ID0gMDtcblx0bW9kZSA9IElCX0JUUkVFO1xuICAgICAgY2FzZSBJQl9CVFJFRTpcblx0d2hpbGUgKHRoaXMuaW5kZXggPCA0ICsgKHRoaXMudGFibGUgPj4+IDEwKSl7XG5cdCAgd2hpbGUoazwoMykpe1xuXHQgICAgaWYobiE9MCl7XG5cdCAgICAgIHI9Wl9PSztcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjtcblx0ICAgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfTtcblx0ICAgIG4tLTtcblx0ICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICAgIGsrPTg7XG5cdCAgfVxuXG5cdCAgdGhpcy5ibGVuc1tJTkZCTE9DS1NfQk9SREVSW3RoaXMuaW5kZXgrK11dID0gYiY3O1xuXG5cdCAge2I+Pj49KDMpO2stPSgzKTt9XG5cdH1cblxuXHR3aGlsZSh0aGlzLmluZGV4IDwgMTkpe1xuXHQgIHRoaXMuYmxlbnNbSU5GQkxPQ0tTX0JPUkRFUlt0aGlzLmluZGV4KytdXSA9IDA7XG5cdH1cblxuXHR0aGlzLmJiWzBdID0gNztcblx0dCA9IHRoaXMuaW5mdHJlZS5pbmZsYXRlX3RyZWVzX2JpdHModGhpcy5ibGVucywgdGhpcy5iYiwgdGhpcy50YiwgdGhpcy5odWZ0cywgeik7XG5cdGlmICh0ICE9IFpfT0spe1xuXHQgIHIgPSB0O1xuXHQgIGlmIChyID09IFpfREFUQV9FUlJPUil7XG5cdCAgICB0aGlzLmJsZW5zPW51bGw7XG5cdCAgICB0aGlzLm1vZGUgPSBJQl9CQUQ7XG5cdCAgfVxuXG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgd3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblxuXHR0aGlzLmluZGV4ID0gMDtcblx0dGhpcy5tb2RlID0gSUJfRFRSRUU7XG4gICAgICBjYXNlIElCX0RUUkVFOlxuXHR3aGlsZSAodHJ1ZSl7XG5cdCAgdCA9IHRoaXMudGFibGU7XG5cdCAgaWYoISh0aGlzLmluZGV4IDwgMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpKSl7XG5cdCAgICBicmVhaztcblx0ICB9XG5cblx0ICB2YXIgaDsgLy9pbnRbXVxuXHQgIHZhciBpLCBqLCBjO1xuXG5cdCAgdCA9IHRoaXMuYmJbMF07XG5cblx0ICB3aGlsZShrPCh0KSl7XG5cdCAgICBpZihuIT0wKXtcblx0ICAgICAgcj1aX09LO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9O1xuXHQgICAgbi0tO1xuXHQgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgICAgays9ODtcblx0ICB9XG5cbi8vXHQgIGlmICh0aGlzLnRiWzBdPT0tMSl7XG4vLyAgICAgICAgICAgIGRsb2coXCJudWxsLi4uXCIpO1xuLy9cdCAgfVxuXG5cdCAgdD10aGlzLmh1ZnRzWyh0aGlzLnRiWzBdKyhiICYgaW5mbGF0ZV9tYXNrW3RdKSkqMysxXTtcblx0ICBjPXRoaXMuaHVmdHNbKHRoaXMudGJbMF0rKGIgJiBpbmZsYXRlX21hc2tbdF0pKSozKzJdO1xuXG5cdCAgaWYgKGMgPCAxNil7XG5cdCAgICBiPj4+PSh0KTtrLT0odCk7XG5cdCAgICB0aGlzLmJsZW5zW3RoaXMuaW5kZXgrK10gPSBjO1xuXHQgIH1cblx0ICBlbHNlIHsgLy8gYyA9PSAxNi4uMThcblx0ICAgIGkgPSBjID09IDE4ID8gNyA6IGMgLSAxNDtcblx0ICAgIGogPSBjID09IDE4ID8gMTEgOiAzO1xuXG5cdCAgICB3aGlsZShrPCh0K2kpKXtcblx0ICAgICAgaWYobiE9MCl7XG5cdFx0cj1aX09LO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2V7XG5cdFx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0XHR6LmF2YWlsX2luPW47XG5cdFx0ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdFx0dGhpcy53cml0ZT1xO1xuXHRcdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgICAgfTtcblx0ICAgICAgbi0tO1xuXHQgICAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgICAgIGsrPTg7XG5cdCAgICB9XG5cblx0ICAgIGI+Pj49KHQpO2stPSh0KTtcblxuXHQgICAgaiArPSAoYiAmIGluZmxhdGVfbWFza1tpXSk7XG5cblx0ICAgIGI+Pj49KGkpO2stPShpKTtcblxuXHQgICAgaSA9IHRoaXMuaW5kZXg7XG5cdCAgICB0ID0gdGhpcy50YWJsZTtcblx0ICAgIGlmIChpICsgaiA+IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKSB8fFxuXHRcdChjID09IDE2ICYmIGkgPCAxKSl7XG5cdCAgICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdFwiO1xuXHQgICAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cblx0ICAgIGMgPSBjID09IDE2ID8gdGhpcy5ibGVuc1tpLTFdIDogMDtcblx0ICAgIGRve1xuXHQgICAgICB0aGlzLmJsZW5zW2krK10gPSBjO1xuXHQgICAgfVxuXHQgICAgd2hpbGUgKC0taiE9MCk7XG5cdCAgICB0aGlzLmluZGV4ID0gaTtcblx0ICB9XG5cdH1cblxuXHR0aGlzLnRiWzBdPS0xO1xuXHR7XG5cdCAgICB2YXIgYmw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgYmQ9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgdGw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgdGQ9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICBibFswXSA9IDk7ICAgICAgICAgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcblx0ICAgIGJkWzBdID0gNjsgICAgICAgICAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xuXG5cdCAgICB0ID0gdGhpcy50YWJsZTtcblx0ICAgIHQgPSB0aGlzLmluZnRyZWUuaW5mbGF0ZV90cmVlc19keW5hbWljKDI1NyArICh0ICYgMHgxZiksIFxuXHRcdFx0XHRcdCAgICAgIDEgKyAoKHQgPj4gNSkgJiAweDFmKSxcblx0XHRcdFx0XHQgICAgICB0aGlzLmJsZW5zLCBibCwgYmQsIHRsLCB0ZCwgdGhpcy5odWZ0cywgeik7XG5cblx0ICAgIGlmICh0ICE9IFpfT0spe1xuXHQgICAgICAgIGlmICh0ID09IFpfREFUQV9FUlJPUil7XG5cdCAgICAgICAgICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5tb2RlID0gQkFEO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByID0gdDtcblxuXHQgICAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cdCAgICB0aGlzLmNvZGVzLmluaXQoYmxbMF0sIGJkWzBdLCB0aGlzLmh1ZnRzLCB0bFswXSwgdGhpcy5odWZ0cywgdGRbMF0sIHopO1xuXHR9XG5cdHRoaXMubW9kZSA9IElCX0NPREVTO1xuICAgICAgY2FzZSBJQl9DT0RFUzpcblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rO1xuXHR6LmF2YWlsX2luPW47IHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cblx0aWYgKChyID0gdGhpcy5jb2Rlcy5wcm9jKHRoaXMsIHosIHIpKSAhPSBaX1NUUkVBTV9FTkQpe1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG5cdH1cblx0ciA9IFpfT0s7XG5cdHRoaXMuY29kZXMuZnJlZSh6KTtcblxuXHRwPXoubmV4dF9pbl9pbmRleDsgbj16LmF2YWlsX2luO2I9dGhpcy5iaXRiO2s9dGhpcy5iaXRrO1xuXHRxPXRoaXMud3JpdGU7bSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXG5cdGlmICh0aGlzLmxhc3Q9PTApe1xuXHQgIHRoaXMubW9kZSA9IElCX1RZUEU7XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUJfRFJZO1xuICAgICAgY2FzZSBJQl9EUlk6XG5cdHRoaXMud3JpdGU9cTsgXG5cdHIgPSB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7IFxuXHRxPXRoaXMud3JpdGU7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0aWYgKHRoaXMucmVhZCAhPSB0aGlzLndyaXRlKXtcblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB0aGlzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblx0fVxuXHRtb2RlID0gRE9ORTtcbiAgICAgIGNhc2UgSUJfRE9ORTpcblx0ciA9IFpfU1RSRUFNX0VORDtcblxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcbiAgICAgIGNhc2UgSUJfQkFEOlxuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuXG4gICAgICBkZWZhdWx0OlxuXHRyID0gWl9TVFJFQU1fRVJST1I7XG5cblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbkluZkJsb2Nrcy5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uKHope1xuICAgIHRoaXMucmVzZXQoeiwgbnVsbCk7XG4gICAgdGhpcy53aW5kb3c9bnVsbDtcbiAgICB0aGlzLmh1ZnRzPW51bGw7XG59XG5cbkluZkJsb2Nrcy5wcm90b3R5cGUuc2V0X2RpY3Rpb25hcnkgPSBmdW5jdGlvbihkLCBzdGFydCwgbil7XG4gICAgYXJyYXlDb3B5KGQsIHN0YXJ0LCB3aW5kb3csIDAsIG4pO1xuICAgIHRoaXMucmVhZCA9IHRoaXMud3JpdGUgPSBuO1xufVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXG4gIC8vIGJ5IFpfU1lOQ19GTFVTSCBvciBaX0ZVTExfRkxVU0guIFxuSW5mQmxvY2tzLnByb3RvdHlwZS5zeW5jX3BvaW50ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5tb2RlID09IElCX0xFTlM7XG59XG5cbiAgLy8gY29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIHNsaWRpbmcgd2luZG93IHRvIHRoZSBvdXRwdXQgYXJlYVxuSW5mQmxvY2tzLnByb3RvdHlwZS5pbmZsYXRlX2ZsdXNoID0gZnVuY3Rpb24oeiwgcil7XG4gICAgdmFyIG47XG4gICAgdmFyIHA7XG4gICAgdmFyIHE7XG5cbiAgICAvLyBsb2NhbCBjb3BpZXMgb2Ygc291cmNlIGFuZCBkZXN0aW5hdGlvbiBwb2ludGVyc1xuICAgIHAgPSB6Lm5leHRfb3V0X2luZGV4O1xuICAgIHEgPSB0aGlzLnJlYWQ7XG5cbiAgICAvLyBjb21wdXRlIG51bWJlciBvZiBieXRlcyB0byBjb3B5IGFzIGZhciBhcyBlbmQgb2Ygd2luZG93XG4gICAgbiA9ICgocSA8PSB0aGlzLndyaXRlID8gdGhpcy53cml0ZSA6IHRoaXMuZW5kKSAtIHEpO1xuICAgIGlmIChuID4gei5hdmFpbF9vdXQpIG4gPSB6LmF2YWlsX291dDtcbiAgICBpZiAobiE9MCAmJiByID09IFpfQlVGX0VSUk9SKSByID0gWl9PSztcblxuICAgIC8vIHVwZGF0ZSBjb3VudGVyc1xuICAgIHouYXZhaWxfb3V0IC09IG47XG4gICAgei50b3RhbF9vdXQgKz0gbjtcblxuICAgIC8vIHVwZGF0ZSBjaGVjayBpbmZvcm1hdGlvblxuICAgIGlmKHRoaXMuY2hlY2tmbiAhPSBudWxsKVxuICAgICAgei5hZGxlcj10aGlzLmNoZWNrPXouX2FkbGVyLmFkbGVyMzIodGhpcy5jaGVjaywgdGhpcy53aW5kb3csIHEsIG4pO1xuXG4gICAgLy8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xuICAgIGFycmF5Q29weSh0aGlzLndpbmRvdywgcSwgei5uZXh0X291dCwgcCwgbik7XG4gICAgcCArPSBuO1xuICAgIHEgKz0gbjtcblxuICAgIC8vIHNlZSBpZiBtb3JlIHRvIGNvcHkgYXQgYmVnaW5uaW5nIG9mIHdpbmRvd1xuICAgIGlmIChxID09IHRoaXMuZW5kKXtcbiAgICAgIC8vIHdyYXAgcG9pbnRlcnNcbiAgICAgIHEgPSAwO1xuICAgICAgaWYgKHRoaXMud3JpdGUgPT0gdGhpcy5lbmQpXG4gICAgICAgIHRoaXMud3JpdGUgPSAwO1xuXG4gICAgICAvLyBjb21wdXRlIGJ5dGVzIHRvIGNvcHlcbiAgICAgIG4gPSB0aGlzLndyaXRlIC0gcTtcbiAgICAgIGlmIChuID4gei5hdmFpbF9vdXQpIG4gPSB6LmF2YWlsX291dDtcbiAgICAgIGlmIChuIT0wICYmIHIgPT0gWl9CVUZfRVJST1IpIHIgPSBaX09LO1xuXG4gICAgICAvLyB1cGRhdGUgY291bnRlcnNcbiAgICAgIHouYXZhaWxfb3V0IC09IG47XG4gICAgICB6LnRvdGFsX291dCArPSBuO1xuXG4gICAgICAvLyB1cGRhdGUgY2hlY2sgaW5mb3JtYXRpb25cbiAgICAgIGlmKHRoaXMuY2hlY2tmbiAhPSBudWxsKVxuXHR6LmFkbGVyPXRoaXMuY2hlY2s9ei5fYWRsZXIuYWRsZXIzMih0aGlzLmNoZWNrLCB0aGlzLndpbmRvdywgcSwgbik7XG5cbiAgICAgIC8vIGNvcHlcbiAgICAgIGFycmF5Q29weSh0aGlzLndpbmRvdywgcSwgei5uZXh0X291dCwgcCwgbik7XG4gICAgICBwICs9IG47XG4gICAgICBxICs9IG47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHBvaW50ZXJzXG4gICAgei5uZXh0X291dF9pbmRleCA9IHA7XG4gICAgdGhpcy5yZWFkID0gcTtcblxuICAgIC8vIGRvbmVcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4vL1xuLy8gSW5mQ29kZXMuamF2YVxuLy9cblxudmFyIElDX1NUQVJUPTA7ICAvLyB4OiBzZXQgdXAgZm9yIExFTlxudmFyIElDX0xFTj0xOyAgICAvLyBpOiBnZXQgbGVuZ3RoL2xpdGVyYWwvZW9iIG5leHRcbnZhciBJQ19MRU5FWFQ9MjsgLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcbnZhciBJQ19ESVNUPTM7ICAgLy8gaTogZ2V0IGRpc3RhbmNlIG5leHRcbnZhciBJQ19ESVNURVhUPTQ7Ly8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxudmFyIElDX0NPUFk9NTsgICAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcbnZhciBJQ19MSVQ9NjsgICAgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZVxudmFyIElDX1dBU0g9NzsgICAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBzdGlsbCBvdXRwdXQgd2FpdGluZ1xudmFyIElDX0VORD04OyAgICAvLyB4OiBnb3QgZW9iIGFuZCBhbGwgZGF0YSBmbHVzaGVkXG52YXIgSUNfQkFEQ09ERT05Oy8vIHg6IGdvdCBlcnJvclxuXG5mdW5jdGlvbiBJbmZDb2RlcygpIHtcbn1cblxuSW5mQ29kZXMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCB6KSB7XG4gICAgdGhpcy5tb2RlPUlDX1NUQVJUO1xuICAgIHRoaXMubGJpdHM9Ymw7XG4gICAgdGhpcy5kYml0cz1iZDtcbiAgICB0aGlzLmx0cmVlPXRsO1xuICAgIHRoaXMubHRyZWVfaW5kZXg9dGxfaW5kZXg7XG4gICAgdGhpcy5kdHJlZSA9IHRkO1xuICAgIHRoaXMuZHRyZWVfaW5kZXg9dGRfaW5kZXg7XG4gICAgdGhpcy50cmVlPW51bGw7XG59XG5cbkluZkNvZGVzLnByb3RvdHlwZS5wcm9jID0gZnVuY3Rpb24ocywgeiwgcil7IFxuICAgIHZhciBqOyAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgICB2YXIgdDsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyIChpbnRbXSlcbiAgICB2YXIgdGluZGV4OyAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyXG4gICAgdmFyIGU7ICAgICAgICAgICAgICAvLyBleHRyYSBiaXRzIG9yIG9wZXJhdGlvblxuICAgIHZhciBiPTA7ICAgICAgICAgICAgLy8gYml0IGJ1ZmZlclxuICAgIHZhciBrPTA7ICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyXG4gICAgdmFyIHA9MDsgICAgICAgICAgICAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcbiAgICB2YXIgbjsgICAgICAgICAgICAgIC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxuICAgIHZhciBxOyAgICAgICAgICAgICAgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXG4gICAgdmFyIG07ICAgICAgICAgICAgICAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxuICAgIHZhciBmOyAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byBjb3B5IHN0cmluZ3MgZnJvbVxuXG4gICAgLy8gY29weSBpbnB1dC9vdXRwdXQgaW5mb3JtYXRpb24gdG8gbG9jYWxzIChVUERBVEUgbWFjcm8gcmVzdG9yZXMpXG4gICAgcD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9cy5iaXRiO2s9cy5iaXRrO1xuICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuICAgIC8vIHByb2Nlc3MgaW5wdXQgYW5kIG91dHB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG4gICAgd2hpbGUgKHRydWUpe1xuICAgICAgc3dpdGNoICh0aGlzLm1vZGUpe1xuXHQvLyB3YWl0aW5nIGZvciBcImk6XCI9aW5wdXQsIFwibzpcIj1vdXRwdXQsIFwieDpcIj1ub3RoaW5nXG4gICAgICBjYXNlIElDX1NUQVJUOiAgICAgICAgIC8vIHg6IHNldCB1cCBmb3IgTEVOXG5cdGlmIChtID49IDI1OCAmJiBuID49IDEwKXtcblxuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cdCAgciA9IHRoaXMuaW5mbGF0ZV9mYXN0KHRoaXMubGJpdHMsIHRoaXMuZGJpdHMsIFxuXHRcdFx0ICAgdGhpcy5sdHJlZSwgdGhpcy5sdHJlZV9pbmRleCwgXG5cdFx0XHQgICB0aGlzLmR0cmVlLCB0aGlzLmR0cmVlX2luZGV4LFxuXHRcdFx0ICAgcywgeik7XG5cblx0ICBwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj1zLmJpdGI7az1zLmJpdGs7XG5cdCAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdCAgaWYgKHIgIT0gWl9PSyl7XG5cdCAgICB0aGlzLm1vZGUgPSByID09IFpfU1RSRUFNX0VORCA/IElDX1dBU0ggOiBJQ19CQURDT0RFO1xuXHQgICAgYnJlYWs7XG5cdCAgfVxuXHR9XG5cdHRoaXMubmVlZCA9IHRoaXMubGJpdHM7XG5cdHRoaXMudHJlZSA9IHRoaXMubHRyZWU7XG5cdHRoaXMudHJlZV9pbmRleD10aGlzLmx0cmVlX2luZGV4O1xuXG5cdHRoaXMubW9kZSA9IElDX0xFTjtcbiAgICAgIGNhc2UgSUNfTEVOOiAgICAgICAgICAgLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XG5cdGogPSB0aGlzLm5lZWQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aW5kZXg9KHRoaXMudHJlZV9pbmRleCsoYiZpbmZsYXRlX21hc2tbal0pKSozO1xuXG5cdGI+Pj49KHRoaXMudHJlZVt0aW5kZXgrMV0pO1xuXHRrLT0odGhpcy50cmVlW3RpbmRleCsxXSk7XG5cblx0ZT10aGlzLnRyZWVbdGluZGV4XTtcblxuXHRpZihlID09IDApeyAgICAgICAgICAgICAgIC8vIGxpdGVyYWxcblx0ICB0aGlzLmxpdCA9IHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgdGhpcy5tb2RlID0gSUNfTElUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmKChlICYgMTYpIT0wICl7ICAgICAgICAgIC8vIGxlbmd0aFxuXHQgIHRoaXMuZ2V0ID0gZSAmIDE1O1xuXHQgIHRoaXMubGVuID0gdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICB0aGlzLm1vZGUgPSBJQ19MRU5FWFQ7XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYgKChlICYgNjQpID09IDApeyAgICAgICAgLy8gbmV4dCB0YWJsZVxuXHQgIHRoaXMubmVlZCA9IGU7XG5cdCAgdGhpcy50cmVlX2luZGV4ID0gdGluZGV4LzMgKyB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDMyKSE9MCl7ICAgICAgICAgICAgICAgLy8gZW5kIG9mIGJsb2NrXG5cdCAgdGhpcy5tb2RlID0gSUNfV0FTSDtcblx0ICBicmVhaztcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19CQURDT0RFOyAgICAgICAgLy8gaW52YWxpZCBjb2RlXG5cdHoubXNnID0gXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcIjtcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19MRU5FWFQ6ICAgICAgICAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxuXHRqID0gdGhpcy5nZXQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07IGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGhpcy5sZW4gKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xuXG5cdGI+Pj1qO1xuXHRrLT1qO1xuXG5cdHRoaXMubmVlZCA9IHRoaXMuZGJpdHM7XG5cdHRoaXMudHJlZSA9IHRoaXMuZHRyZWU7XG5cdHRoaXMudHJlZV9pbmRleCA9IHRoaXMuZHRyZWVfaW5kZXg7XG5cdHRoaXMubW9kZSA9IElDX0RJU1Q7XG4gICAgICBjYXNlIElDX0RJU1Q6ICAgICAgICAgIC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XG5cdGogPSB0aGlzLm5lZWQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07IGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGluZGV4PSh0aGlzLnRyZWVfaW5kZXgrKGIgJiBpbmZsYXRlX21hc2tbal0pKSozO1xuXG5cdGI+Pj10aGlzLnRyZWVbdGluZGV4KzFdO1xuXHRrLT10aGlzLnRyZWVbdGluZGV4KzFdO1xuXG5cdGUgPSAodGhpcy50cmVlW3RpbmRleF0pO1xuXHRpZigoZSAmIDE2KSE9MCl7ICAgICAgICAgICAgICAgLy8gZGlzdGFuY2Vcblx0ICB0aGlzLmdldCA9IGUgJiAxNTtcblx0ICB0aGlzLmRpc3QgPSB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIHRoaXMubW9kZSA9IElDX0RJU1RFWFQ7XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYgKChlICYgNjQpID09IDApeyAgICAgICAgLy8gbmV4dCB0YWJsZVxuXHQgIHRoaXMubmVlZCA9IGU7XG5cdCAgdGhpcy50cmVlX2luZGV4ID0gdGluZGV4LzMgKyB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIGJyZWFrO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX0JBRENPREU7ICAgICAgICAvLyBpbnZhbGlkIGNvZGVcblx0ei5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgY29kZVwiO1xuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBjYXNlIElDX0RJU1RFWFQ6ICAgICAgIC8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcblx0aiA9IHRoaXMuZ2V0O1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMuZGlzdCArPSAoYiAmIGluZmxhdGVfbWFza1tqXSk7XG5cblx0Yj4+PWo7XG5cdGstPWo7XG5cblx0dGhpcy5tb2RlID0gSUNfQ09QWTtcbiAgICAgIGNhc2UgSUNfQ09QWTogICAgICAgICAgLy8gbzogY29weWluZyBieXRlcyBpbiB3aW5kb3csIHdhaXRpbmcgZm9yIHNwYWNlXG4gICAgICAgIGYgPSBxIC0gdGhpcy5kaXN0O1xuICAgICAgICB3aGlsZShmIDwgMCl7ICAgICAvLyBtb2R1bG8gd2luZG93IHNpemUtXCJ3aGlsZVwiIGluc3RlYWRcbiAgICAgICAgICBmICs9IHMuZW5kOyAgICAgLy8gb2YgXCJpZlwiIGhhbmRsZXMgaW52YWxpZCBkaXN0YW5jZXNcblx0fVxuXHR3aGlsZSAodGhpcy5sZW4hPTApe1xuXG5cdCAgaWYobT09MCl7XG5cdCAgICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXHQgICAgaWYobT09MCl7XG5cdCAgICAgIHMud3JpdGU9cTsgcj1zLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdCAgICAgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cblx0ICAgICAgaWYobT09MCl7XG5cdFx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdFx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRcdHMud3JpdGU9cTtcblx0XHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICAgIH0gIFxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHMud2luZG93W3ErK109cy53aW5kb3dbZisrXTsgbS0tO1xuXG5cdCAgaWYgKGYgPT0gcy5lbmQpXG4gICAgICAgICAgICBmID0gMDtcblx0ICB0aGlzLmxlbi0tO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX1NUQVJUO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUNfTElUOiAgICAgICAgICAgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZVxuXHRpZihtPT0wKXtcblx0ICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXHQgIGlmKG09PTApe1xuXHQgICAgcy53cml0ZT1xOyByPXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdCAgICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXHQgICAgaWYobT09MCl7XG5cdCAgICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRyPVpfT0s7XG5cblx0cy53aW5kb3dbcSsrXT10aGlzLmxpdDsgbS0tO1xuXG5cdHRoaXMubW9kZSA9IElDX1NUQVJUO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUNfV0FTSDogICAgICAgICAgIC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IG1vcmUgb3V0cHV0XG5cdGlmIChrID4gNyl7ICAgICAgICAvLyByZXR1cm4gdW51c2VkIGJ5dGUsIGlmIGFueVxuXHQgIGsgLT0gODtcblx0ICBuKys7XG5cdCAgcC0tOyAgICAgICAgICAgICAvLyBjYW4gYWx3YXlzIHJldHVybiBvbmVcblx0fVxuXG5cdHMud3JpdGU9cTsgcj1zLmluZmxhdGVfZmx1c2goeixyKTtcblx0cT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdGlmIChzLnJlYWQgIT0gcy53cml0ZSl7XG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblx0ICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfRU5EO1xuICAgICAgY2FzZSBJQ19FTkQ6XG5cdHIgPSBaX1NUUkVBTV9FTkQ7XG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBjYXNlIElDX0JBRENPREU6ICAgICAgIC8vIHg6IGdvdCBlcnJvclxuXG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGRlZmF1bHQ6XG5cdHIgPSBaX1NUUkVBTV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuSW5mQ29kZXMucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbih6KXtcbiAgICAvLyAgWkZSRUUoeiwgYyk7XG59XG5cbiAgLy8gQ2FsbGVkIHdpdGggbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gd3JpdGUgaW4gd2luZG93IGF0IGxlYXN0IDI1OFxuICAvLyAodGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aCkgYW5kIG51bWJlciBvZiBpbnB1dCBieXRlcyBhdmFpbGFibGVcbiAgLy8gYXQgbGVhc3QgdGVuLiAgVGhlIHRlbiBieXRlcyBhcmUgc2l4IGJ5dGVzIGZvciB0aGUgbG9uZ2VzdCBsZW5ndGgvXG4gIC8vIGRpc3RhbmNlIHBhaXIgcGx1cyBmb3VyIGJ5dGVzIGZvciBvdmVybG9hZGluZyB0aGUgYml0IGJ1ZmZlci5cblxuSW5mQ29kZXMucHJvdG90eXBlLmluZmxhdGVfZmFzdCA9IGZ1bmN0aW9uKGJsLCBiZCwgdGwsIHRsX2luZGV4LCB0ZCwgdGRfaW5kZXgsIHMsIHopIHtcbiAgICB2YXIgdDsgICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcbiAgICB2YXIgICB0cDsgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXIgKGludFtdKVxuICAgIHZhciB0cF9pbmRleDsgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlclxuICAgIHZhciBlOyAgICAgICAgICAgICAgICAvLyBleHRyYSBiaXRzIG9yIG9wZXJhdGlvblxuICAgIHZhciBiOyAgICAgICAgICAgICAgICAvLyBiaXQgYnVmZmVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxuICAgIHZhciBwOyAgICAgICAgICAgICAgICAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcbiAgICB2YXIgbjsgICAgICAgICAgICAgICAgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAgIC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxuICAgIHZhciBtOyAgICAgICAgICAgICAgICAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxuICAgIHZhciBtbDsgICAgICAgICAgICAgICAvLyBtYXNrIGZvciBsaXRlcmFsL2xlbmd0aCB0cmVlXG4gICAgdmFyIG1kOyAgICAgICAgICAgICAgIC8vIG1hc2sgZm9yIGRpc3RhbmNlIHRyZWVcbiAgICB2YXIgYzsgICAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gY29weVxuICAgIHZhciBkOyAgICAgICAgICAgICAgICAvLyBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgZnJvbVxuICAgIHZhciByOyAgICAgICAgICAgICAgICAvLyBjb3B5IHNvdXJjZSBwb2ludGVyXG5cbiAgICB2YXIgdHBfaW5kZXhfdF8zOyAgICAgLy8gKHRwX2luZGV4K3QpKjNcblxuICAgIC8vIGxvYWQgaW5wdXQsIG91dHB1dCwgYml0IHZhbHVlc1xuICAgIHA9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXMuYml0YjtrPXMuYml0aztcbiAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cbiAgICAvLyBpbml0aWFsaXplIG1hc2tzXG4gICAgbWwgPSBpbmZsYXRlX21hc2tbYmxdO1xuICAgIG1kID0gaW5mbGF0ZV9tYXNrW2JkXTtcblxuICAgIC8vIGRvIHVudGlsIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IHNwYWNlIGZvciBmYXN0IGxvb3BcbiAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgY2FsbGVkIHdpdGggbSA+PSAyNTggJiYgbiA+PSAxMFxuICAgICAgLy8gZ2V0IGxpdGVyYWwvbGVuZ3RoIGNvZGVcbiAgICAgIHdoaWxlKGs8KDIwKSl7ICAgICAgICAgICAgICAvLyBtYXggYml0cyBmb3IgbGl0ZXJhbC9sZW5ndGggY29kZVxuXHRuLS07XG5cdGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztrKz04O1xuICAgICAgfVxuXG4gICAgICB0PSBiJm1sO1xuICAgICAgdHA9dGw7IFxuICAgICAgdHBfaW5kZXg9dGxfaW5kZXg7XG4gICAgICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG4gICAgICBpZiAoKGUgPSB0cFt0cF9pbmRleF90XzNdKSA9PSAwKXtcblx0Yj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHRzLndpbmRvd1txKytdID0gdHBbdHBfaW5kZXhfdF8zKzJdO1xuXHRtLS07XG5cdGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZG8ge1xuXG5cdGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0aWYoKGUmMTYpIT0wKXtcblx0ICBlICY9IDE1O1xuXHQgIGMgPSB0cFt0cF9pbmRleF90XzMrMl0gKyAoYiAmIGluZmxhdGVfbWFza1tlXSk7XG5cblx0ICBiPj49ZTsgay09ZTtcblxuXHQgIC8vIGRlY29kZSBkaXN0YW5jZSBiYXNlIG9mIGJsb2NrIHRvIGNvcHlcblx0ICB3aGlsZShrPCgxNSkpeyAgICAgICAgICAgLy8gbWF4IGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVcblx0ICAgIG4tLTtcblx0ICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztrKz04O1xuXHQgIH1cblxuXHQgIHQ9IGImbWQ7XG5cdCAgdHA9dGQ7XG5cdCAgdHBfaW5kZXg9dGRfaW5kZXg7XG4gICAgICAgICAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuXHQgIGUgPSB0cFt0cF9pbmRleF90XzNdO1xuXG5cdCAgZG8ge1xuXG5cdCAgICBiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdCAgICBpZigoZSYxNikhPTApe1xuXHQgICAgICAvLyBnZXQgZXh0cmEgYml0cyB0byBhZGQgdG8gZGlzdGFuY2UgYmFzZVxuXHQgICAgICBlICY9IDE1O1xuXHQgICAgICB3aGlsZShrPChlKSl7ICAgICAgICAgLy8gZ2V0IGV4dHJhIGJpdHMgKHVwIHRvIDEzKVxuXHRcdG4tLTtcblx0XHRifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcblx0ICAgICAgfVxuXG5cdCAgICAgIGQgPSB0cFt0cF9pbmRleF90XzMrMl0gKyAoYiZpbmZsYXRlX21hc2tbZV0pO1xuXG5cdCAgICAgIGI+Pj0oZSk7IGstPShlKTtcblxuXHQgICAgICAvLyBkbyB0aGUgY29weVxuXHQgICAgICBtIC09IGM7XG5cdCAgICAgIGlmIChxID49IGQpeyAgICAgICAgICAgICAgICAvLyBvZmZzZXQgYmVmb3JlIGRlc3Rcblx0XHQvLyAganVzdCBjb3B5XG5cdFx0cj1xLWQ7XG5cdFx0aWYocS1yPjAgJiYgMj4ocS1yKSl7ICAgICAgICAgICBcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gbWluaW11bSBjb3VudCBpcyB0aHJlZSxcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gc28gdW5yb2xsIGxvb3AgYSBsaXR0bGVcblx0XHQgIGMtPTI7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIG1pbmltdW0gY291bnQgaXMgdGhyZWUsXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIHNvIHVucm9sbCBsb29wIGEgbGl0dGxlXG5cdFx0ICBjLT0yO1xuXHRcdH1cblx0ICAgICAgfVxuXHQgICAgICBlbHNleyAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugb2Zmc2V0IGFmdGVyIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICAgICAgcj1xLWQ7XG4gICAgICAgICAgICAgICAgZG97XG4gICAgICAgICAgICAgICAgICByKz1zLmVuZDsgICAgICAgICAgLy8gZm9yY2UgcG9pbnRlciBpbiB3aW5kb3dcbiAgICAgICAgICAgICAgICB9d2hpbGUocjwwKTsgICAgICAgICAvLyBjb3ZlcnMgaW52YWxpZCBkaXN0YW5jZXNcblx0XHRlPXMuZW5kLXI7XG5cdFx0aWYoYz5lKXsgICAgICAgICAgICAgLy8gaWYgc291cmNlIGNyb3NzZXMsXG5cdFx0ICBjLT1lOyAgICAgICAgICAgICAgLy8gd3JhcHBlZCBjb3B5XG5cdFx0ICBpZihxLXI+MCAmJiBlPihxLXIpKXsgICAgICAgICAgIFxuXHRcdCAgICBkb3tzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTt9XG5cdFx0ICAgIHdoaWxlKC0tZSE9MCk7XG5cdFx0ICB9XG5cdFx0ICBlbHNle1xuXHRcdCAgICBhcnJheUNvcHkocy53aW5kb3csIHIsIHMud2luZG93LCBxLCBlKTtcblx0XHQgICAgcSs9ZTsgcis9ZTsgZT0wO1xuXHRcdCAgfVxuXHRcdCAgciA9IDA7ICAgICAgICAgICAgICAgICAgLy8gY29weSByZXN0IGZyb20gc3RhcnQgb2Ygd2luZG93XG5cdFx0fVxuXG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBjb3B5IGFsbCBvciB3aGF0J3MgbGVmdFxuICAgICAgICAgICAgICBkb3tzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTt9XG5cdFx0d2hpbGUoLS1jIT0wKTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmKChlJjY0KT09MCl7XG5cdCAgICAgIHQrPXRwW3RwX2luZGV4X3RfMysyXTtcblx0ICAgICAgdCs9KGImaW5mbGF0ZV9tYXNrW2VdKTtcblx0ICAgICAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuXHQgICAgICBlPXRwW3RwX2luZGV4X3RfM107XG5cdCAgICB9XG5cdCAgICBlbHNle1xuXHQgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCI7XG5cblx0ICAgICAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cblx0ICAgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgcy53cml0ZT1xO1xuXG5cdCAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHdoaWxlKHRydWUpO1xuXHQgIGJyZWFrO1xuXHR9XG5cblx0aWYoKGUmNjQpPT0wKXtcblx0ICB0Kz10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgdCs9KGImaW5mbGF0ZV9tYXNrW2VdKTtcblx0ICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG5cdCAgaWYoKGU9dHBbdHBfaW5kZXhfdF8zXSk9PTApe1xuXG5cdCAgICBiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdCAgICBzLndpbmRvd1txKytdPXRwW3RwX2luZGV4X3RfMysyXTtcblx0ICAgIG0tLTtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblx0fVxuXHRlbHNlIGlmKChlJjMyKSE9MCl7XG5cblx0ICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcbiBcblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXG5cdCAgcmV0dXJuIFpfU1RSRUFNX0VORDtcblx0fVxuXHRlbHNle1xuXHQgIHoubXNnPVwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCI7XG5cblx0ICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcblxuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cblx0ICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuXHR9XG4gICAgICB9IFxuICAgICAgd2hpbGUodHJ1ZSk7XG4gICAgfSBcbiAgICB3aGlsZShtPj0yNTggJiYgbj49IDEwKTtcblxuICAgIC8vIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0LS1yZXN0b3JlIHBvaW50ZXJzIGFuZCByZXR1cm5cbiAgICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcblxuICAgIHMuYml0Yj1iO3MuYml0az1rO1xuICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcbiAgICBzLndyaXRlPXE7XG5cbiAgICByZXR1cm4gWl9PSztcbn1cblxuLy9cbi8vIEluZlRyZWUuamF2YVxuLy9cblxuZnVuY3Rpb24gSW5mVHJlZSgpIHtcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaHVmdF9idWlsZCA9IGZ1bmN0aW9uKGIsIGJpbmRleCwgbiwgcywgZCwgZSwgdCwgbSwgaHAsIGhuLCB2KSB7XG5cbiAgICAvLyBHaXZlbiBhIGxpc3Qgb2YgY29kZSBsZW5ndGhzIGFuZCBhIG1heGltdW0gdGFibGUgc2l6ZSwgbWFrZSBhIHNldCBvZlxuICAgIC8vIHRhYmxlcyB0byBkZWNvZGUgdGhhdCBzZXQgb2YgY29kZXMuICBSZXR1cm4gWl9PSyBvbiBzdWNjZXNzLCBaX0JVRl9FUlJPUlxuICAgIC8vIGlmIHRoZSBnaXZlbiBjb2RlIHNldCBpcyBpbmNvbXBsZXRlICh0aGUgdGFibGVzIGFyZSBzdGlsbCBidWlsdCBpbiB0aGlzXG4gICAgLy8gY2FzZSksIFpfREFUQV9FUlJPUiBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZCAoYW4gb3Zlci1zdWJzY3JpYmVkIHNldCBvZlxuICAgIC8vIGxlbmd0aHMpLCBvciBaX01FTV9FUlJPUiBpZiBub3QgZW5vdWdoIG1lbW9yeS5cblxuICAgIHZhciBhOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnRlciBmb3IgY29kZXMgb2YgbGVuZ3RoIGtcbiAgICB2YXIgZjsgICAgICAgICAgICAgICAgICAgICAgIC8vIGkgcmVwZWF0cyBpbiB0YWJsZSBldmVyeSBmIGVudHJpZXNcbiAgICB2YXIgZzsgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heGltdW0gY29kZSBsZW5ndGhcbiAgICB2YXIgaDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhYmxlIGxldmVsXG4gICAgdmFyIGk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyLCBjdXJyZW50IGNvZGVcbiAgICB2YXIgajsgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXJcbiAgICB2YXIgazsgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBiaXRzIGluIGN1cnJlbnQgY29kZVxuICAgIHZhciBsOyAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBwZXIgdGFibGUgKHJldHVybmVkIGluIG0pXG4gICAgdmFyIG1hc2s7ICAgICAgICAgICAgICAgICAgICAvLyAoMSA8PCB3KSAtIDEsIHRvIGF2b2lkIGNjIC1PIGJ1ZyBvbiBIUFxuICAgIHZhciBwOyAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRlciBpbnRvIGNbXSwgYltdLCBvciB2W11cbiAgICB2YXIgcTsgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cyB0byBjdXJyZW50IHRhYmxlXG4gICAgdmFyIHc7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIGJlZm9yZSB0aGlzIHRhYmxlID09IChsICogaClcbiAgICB2YXIgeHA7ICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgaW50byB4XG4gICAgdmFyIHk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgZHVtbXkgY29kZXMgYWRkZWRcbiAgICB2YXIgejsgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBlbnRyaWVzIGluIGN1cnJlbnQgdGFibGVcblxuICAgIC8vIEdlbmVyYXRlIGNvdW50cyBmb3IgZWFjaCBiaXQgbGVuZ3RoXG5cbiAgICBwID0gMDsgaSA9IG47XG4gICAgZG8ge1xuICAgICAgdGhpcy5jW2JbYmluZGV4K3BdXSsrOyBwKys7IGktLTsgICAvLyBhc3N1bWUgYWxsIGVudHJpZXMgPD0gQk1BWFxuICAgIH13aGlsZShpIT0wKTtcblxuICAgIGlmKHRoaXMuY1swXSA9PSBuKXsgICAgICAgICAgICAgICAgLy8gbnVsbCBpbnB1dC0tYWxsIHplcm8gbGVuZ3RoIGNvZGVzXG4gICAgICB0WzBdID0gLTE7XG4gICAgICBtWzBdID0gMDtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8vIEZpbmQgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGgsIGJvdW5kICptIGJ5IHRob3NlXG4gICAgbCA9IG1bMF07XG4gICAgZm9yIChqID0gMTsgaiA8PSBCTUFYOyBqKyspXG4gICAgICBpZih0aGlzLmNbal0hPTApIGJyZWFrO1xuICAgIGsgPSBqOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pbmltdW0gY29kZSBsZW5ndGhcbiAgICBpZihsIDwgail7XG4gICAgICBsID0gajtcbiAgICB9XG4gICAgZm9yIChpID0gQk1BWDsgaSE9MDsgaS0tKXtcbiAgICAgIGlmKHRoaXMuY1tpXSE9MCkgYnJlYWs7XG4gICAgfVxuICAgIGcgPSBpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heGltdW0gY29kZSBsZW5ndGhcbiAgICBpZihsID4gaSl7XG4gICAgICBsID0gaTtcbiAgICB9XG4gICAgbVswXSA9IGw7XG5cbiAgICAvLyBBZGp1c3QgbGFzdCBsZW5ndGggY291bnQgdG8gZmlsbCBvdXQgY29kZXMsIGlmIG5lZWRlZFxuICAgIGZvciAoeSA9IDEgPDwgajsgaiA8IGk7IGorKywgeSA8PD0gMSl7XG4gICAgICBpZiAoKHkgLT0gdGhpcy5jW2pdKSA8IDApe1xuICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHkgLT0gdGhpcy5jW2ldKSA8IDApe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgdGhpcy5jW2ldICs9IHk7XG5cbiAgICAvLyBHZW5lcmF0ZSBzdGFydGluZyBvZmZzZXRzIGludG8gdGhlIHZhbHVlIHRhYmxlIGZvciBlYWNoIGxlbmd0aFxuICAgIHRoaXMueFsxXSA9IGogPSAwO1xuICAgIHAgPSAxOyAgeHAgPSAyO1xuICAgIHdoaWxlICgtLWkhPTApIHsgICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBpID09IGcgZnJvbSBhYm92ZVxuICAgICAgdGhpcy54W3hwXSA9IChqICs9IHRoaXMuY1twXSk7XG4gICAgICB4cCsrO1xuICAgICAgcCsrO1xuICAgIH1cblxuICAgIC8vIE1ha2UgYSB0YWJsZSBvZiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aHNcbiAgICBpID0gMDsgcCA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKChqID0gYltiaW5kZXgrcF0pICE9IDApe1xuICAgICAgICB0aGlzLnZbdGhpcy54W2pdKytdID0gaTtcbiAgICAgIH1cbiAgICAgIHArKztcbiAgICB9XG4gICAgd2hpbGUgKCsraSA8IG4pO1xuICAgIG4gPSB0aGlzLnhbZ107ICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG4gdG8gbGVuZ3RoIG9mIHZcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBIdWZmbWFuIGNvZGVzIGFuZCBmb3IgZWFjaCwgbWFrZSB0aGUgdGFibGUgZW50cmllc1xuICAgIHRoaXMueFswXSA9IGkgPSAwOyAgICAgICAgICAgICAgICAgLy8gZmlyc3QgSHVmZm1hbiBjb2RlIGlzIHplcm9cbiAgICBwID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBncmFiIHZhbHVlcyBpbiBiaXQgb3JkZXJcbiAgICBoID0gLTE7ICAgICAgICAgICAgICAgICAgICAgICAvLyBubyB0YWJsZXMgeWV0LS1sZXZlbCAtMVxuICAgIHcgPSAtbDsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgZGVjb2RlZCA9PSAobCAqIGgpXG4gICAgdGhpcy51WzBdID0gMDsgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHRvIGtlZXAgY29tcGlsZXJzIGhhcHB5XG4gICAgcSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl0dG9cbiAgICB6ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXR0b1xuXG4gICAgLy8gZ28gdGhyb3VnaCB0aGUgYml0IGxlbmd0aHMgKGsgYWxyZWFkeSBpcyBiaXRzIGluIHNob3J0ZXN0IGNvZGUpXG4gICAgZm9yICg7IGsgPD0gZzsgaysrKXtcbiAgICAgIGEgPSB0aGlzLmNba107XG4gICAgICB3aGlsZSAoYS0tIT0wKXtcblx0Ly8gaGVyZSBpIGlzIHRoZSBIdWZmbWFuIGNvZGUgb2YgbGVuZ3RoIGsgYml0cyBmb3IgdmFsdWUgKnBcblx0Ly8gbWFrZSB0YWJsZXMgdXAgdG8gcmVxdWlyZWQgbGV2ZWxcbiAgICAgICAgd2hpbGUgKGsgPiB3ICsgbCl7XG4gICAgICAgICAgaCsrO1xuICAgICAgICAgIHcgKz0gbDsgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHRhYmxlIGFsd2F5cyBsIGJpdHNcblx0ICAvLyBjb21wdXRlIG1pbmltdW0gc2l6ZSB0YWJsZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbCBiaXRzXG4gICAgICAgICAgeiA9IGcgLSB3O1xuICAgICAgICAgIHogPSAoeiA+IGwpID8gbCA6IHo7ICAgICAgICAvLyB0YWJsZSBzaXplIHVwcGVyIGxpbWl0XG4gICAgICAgICAgaWYoKGY9MTw8KGo9ay13KSk+YSsxKXsgICAgIC8vIHRyeSBhIGstdyBiaXQgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9vIGZldyBjb2RlcyBmb3Igay13IGJpdCB0YWJsZVxuICAgICAgICAgICAgZiAtPSBhICsgMTsgICAgICAgICAgICAgICAvLyBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJucyBsZWZ0XG4gICAgICAgICAgICB4cCA9IGs7XG4gICAgICAgICAgICBpZihqIDwgeil7XG4gICAgICAgICAgICAgIHdoaWxlICgrK2ogPCB6KXsgICAgICAgIC8vIHRyeSBzbWFsbGVyIHRhYmxlcyB1cCB0byB6IGJpdHNcbiAgICAgICAgICAgICAgICBpZigoZiA8PD0gMSkgPD0gdGhpcy5jWysreHBdKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAvLyBlbm91Z2ggY29kZXMgdG8gdXNlIHVwIGogYml0c1xuICAgICAgICAgICAgICAgIGYgLT0gdGhpcy5jW3hwXTsgICAgICAgICAgIC8vIGVsc2UgZGVkdWN0IGNvZGVzIGZyb20gcGF0dGVybnNcbiAgICAgICAgICAgICAgfVxuXHQgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB6ID0gMSA8PCBqOyAgICAgICAgICAgICAgICAgLy8gdGFibGUgZW50cmllcyBmb3Igai1iaXQgdGFibGVcblxuXHQgIC8vIGFsbG9jYXRlIG5ldyB0YWJsZVxuICAgICAgICAgIGlmICh0aGlzLmhuWzBdICsgeiA+IE1BTlkpeyAgICAgICAvLyAobm90ZTogZG9lc24ndCBtYXR0ZXIgZm9yIGZpeGVkKVxuICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjsgICAgICAgLy8gb3ZlcmZsb3cgb2YgTUFOWVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVbaF0gPSBxID0gLypocCsqLyB0aGlzLmhuWzBdOyAgIC8vIERFQlVHXG4gICAgICAgICAgdGhpcy5oblswXSArPSB6O1xuIFxuXHQgIC8vIGNvbm5lY3QgdG8gbGFzdCB0YWJsZSwgaWYgdGhlcmUgaXMgb25lXG5cdCAgaWYoaCE9MCl7XG4gICAgICAgICAgICB0aGlzLnhbaF09aTsgICAgICAgICAgIC8vIHNhdmUgcGF0dGVybiBmb3IgYmFja2luZyB1cFxuICAgICAgICAgICAgdGhpcy5yWzBdPWo7ICAgICAvLyBiaXRzIGluIHRoaXMgdGFibGVcbiAgICAgICAgICAgIHRoaXMuclsxXT1sOyAgICAgLy8gYml0cyB0byBkdW1wIGJlZm9yZSB0aGlzIHRhYmxlXG4gICAgICAgICAgICBqPWk+Pj4odyAtIGwpO1xuICAgICAgICAgICAgdGhpcy5yWzJdID0gKHEgLSB0aGlzLnVbaC0xXSAtIGopOyAgICAgICAgICAgICAgIC8vIG9mZnNldCB0byB0aGlzIHRhYmxlXG4gICAgICAgICAgICBhcnJheUNvcHkodGhpcy5yLCAwLCBocCwgKHRoaXMudVtoLTFdK2opKjMsIDMpOyAvLyBjb25uZWN0IHRvIGxhc3QgdGFibGVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRbMF0gPSBxOyAgICAgICAgICAgICAgIC8vIGZpcnN0IHRhYmxlIGlzIHJldHVybmVkIHJlc3VsdFxuXHQgIH1cbiAgICAgICAgfVxuXG5cdC8vIHNldCB1cCB0YWJsZSBlbnRyeSBpbiByXG4gICAgICAgIHRoaXMuclsxXSA9IChrIC0gdyk7XG4gICAgICAgIGlmIChwID49IG4pe1xuICAgICAgICAgIHRoaXMuclswXSA9IDEyOCArIDY0OyAgICAgIC8vIG91dCBvZiB2YWx1ZXMtLWludmFsaWQgY29kZVxuXHR9XG4gICAgICAgIGVsc2UgaWYgKHZbcF0gPCBzKXtcbiAgICAgICAgICB0aGlzLnJbMF0gPSAodGhpcy52W3BdIDwgMjU2ID8gMCA6IDMyICsgNjQpOyAgLy8gMjU2IGlzIGVuZC1vZi1ibG9ja1xuICAgICAgICAgIHRoaXMuclsyXSA9IHRoaXMudltwKytdOyAgICAgICAgICAvLyBzaW1wbGUgY29kZSBpcyBqdXN0IHRoZSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgdGhpcy5yWzBdPShlW3RoaXMudltwXS1zXSsxNis2NCk7IC8vIG5vbi1zaW1wbGUtLWxvb2sgdXAgaW4gbGlzdHNcbiAgICAgICAgICB0aGlzLnJbMl09ZFt0aGlzLnZbcCsrXSAtIHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCBjb2RlLWxpa2UgZW50cmllcyB3aXRoIHJcbiAgICAgICAgZj0xPDwoay13KTtcbiAgICAgICAgZm9yIChqPWk+Pj53O2o8ejtqKz1mKXtcbiAgICAgICAgICBhcnJheUNvcHkodGhpcy5yLCAwLCBocCwgKHEraikqMywgMyk7XG5cdH1cblxuXHQvLyBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBrLWJpdCBjb2RlIGlcbiAgICAgICAgZm9yIChqID0gMSA8PCAoayAtIDEpOyAoaSAmIGopIT0wOyBqID4+Pj0gMSl7XG4gICAgICAgICAgaSBePSBqO1xuXHR9XG4gICAgICAgIGkgXj0gajtcblxuXHQvLyBiYWNrdXAgb3ZlciBmaW5pc2hlZCB0YWJsZXNcbiAgICAgICAgbWFzayA9ICgxIDw8IHcpIC0gMTsgICAgICAvLyBuZWVkZWQgb24gSFAsIGNjIC1PIGJ1Z1xuICAgICAgICB3aGlsZSAoKGkgJiBtYXNrKSAhPSB0aGlzLnhbaF0pe1xuICAgICAgICAgIGgtLTsgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IG5lZWQgdG8gdXBkYXRlIHFcbiAgICAgICAgICB3IC09IGw7XG4gICAgICAgICAgbWFzayA9ICgxIDw8IHcpIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gWl9CVUZfRVJST1IgaWYgd2Ugd2VyZSBnaXZlbiBhbiBpbmNvbXBsZXRlIHRhYmxlXG4gICAgcmV0dXJuIHkgIT0gMCAmJiBnICE9IDEgPyBaX0JVRl9FUlJPUiA6IFpfT0s7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmluZmxhdGVfdHJlZXNfYml0cyA9IGZ1bmN0aW9uKGMsIGJiLCB0YiwgaHAsIHopIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRoaXMuaW5pdFdvcmtBcmVhKDE5KTtcbiAgICB0aGlzLmhuWzBdPTA7XG4gICAgcmVzdWx0ID0gdGhpcy5odWZ0X2J1aWxkKGMsIDAsIDE5LCAxOSwgbnVsbCwgbnVsbCwgdGIsIGJiLCBocCwgdGhpcy5obiwgdGhpcy52KTtcblxuICAgIGlmKHJlc3VsdCA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgei5tc2cgPSBcIm92ZXJzdWJzY3JpYmVkIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmKHJlc3VsdCA9PSBaX0JVRl9FUlJPUiB8fCBiYlswXSA9PSAwKXtcbiAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVwiO1xuICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5pbmZsYXRlX3RyZWVzX2R5bmFtaWMgPSBmdW5jdGlvbihubCwgbmQsIGMsIGJsLCBiZCwgdGwsIHRkLCBocCwgeikge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBidWlsZCBsaXRlcmFsL2xlbmd0aCB0cmVlXG4gICAgdGhpcy5pbml0V29ya0FyZWEoMjg4KTtcbiAgICB0aGlzLmhuWzBdPTA7XG4gICAgcmVzdWx0ID0gdGhpcy5odWZ0X2J1aWxkKGMsIDAsIG5sLCAyNTcsIGNwbGVucywgY3BsZXh0LCB0bCwgYmwsIGhwLCB0aGlzLmhuLCB0aGlzLnYpO1xuICAgIGlmIChyZXN1bHQgIT0gWl9PSyB8fCBibFswXSA9PSAwKXtcbiAgICAgIGlmKHJlc3VsdCA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwib3ZlcnN1YnNjcmliZWQgbGl0ZXJhbC9sZW5ndGggdHJlZVwiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcImluY29tcGxldGUgbGl0ZXJhbC9sZW5ndGggdHJlZVwiO1xuICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIGRpc3RhbmNlIHRyZWVcbiAgICB0aGlzLmluaXRXb3JrQXJlYSgyODgpO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCBubCwgbmQsIDAsIGNwZGlzdCwgY3BkZXh0LCB0ZCwgYmQsIGhwLCB0aGlzLmhuLCB0aGlzLnYpO1xuXG4gICAgaWYgKHJlc3VsdCAhPSBaX09LIHx8IChiZFswXSA9PSAwICYmIG5sID4gMjU3KSl7XG4gICAgICBpZiAocmVzdWx0ID09IFpfREFUQV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJvdmVyc3Vic2NyaWJlZCBkaXN0YW5jZSB0cmVlXCI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZXN1bHQgPT0gWl9CVUZfRVJST1IpIHtcbiAgICAgICAgei5tc2cgPSBcImluY29tcGxldGUgZGlzdGFuY2UgdHJlZVwiO1xuICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZXN1bHQgIT0gWl9NRU1fRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwiZW1wdHkgZGlzdGFuY2UgdHJlZSB3aXRoIGxlbmd0aHNcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gWl9PSztcbn1cbi8qXG4gIHN0YXRpYyBpbnQgaW5mbGF0ZV90cmVlc19maXhlZChpbnRbXSBibCwgIC8vbGl0ZXJhbCBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFtdIGJkLCAgLy9kaXN0YW5jZSBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFtdW10gdGwsLy9saXRlcmFsL2xlbmd0aCB0cmVlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50W11bXSB0ZCwvL2Rpc3RhbmNlIHRyZWUgcmVzdWx0IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWlN0cmVhbSB6ICAvL2ZvciBtZW1vcnkgYWxsb2NhdGlvblxuXHRcdFx0XHQgKXtcblxuKi9cblxuZnVuY3Rpb24gaW5mbGF0ZV90cmVlc19maXhlZChibCwgYmQsIHRsLCB0ZCwgeikge1xuICAgIGJsWzBdPWZpeGVkX2JsO1xuICAgIGJkWzBdPWZpeGVkX2JkO1xuICAgIHRsWzBdPWZpeGVkX3RsO1xuICAgIHRkWzBdPWZpeGVkX3RkO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5pbml0V29ya0FyZWEgPSBmdW5jdGlvbih2c2l6ZSl7XG4gICAgaWYodGhpcy5obj09bnVsbCl7XG4gICAgICAgIHRoaXMuaG49bmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgIHRoaXMudj1uZXcgSW50MzJBcnJheSh2c2l6ZSk7XG4gICAgICAgIHRoaXMuYz1uZXcgSW50MzJBcnJheShCTUFYKzEpO1xuICAgICAgICB0aGlzLnI9bmV3IEludDMyQXJyYXkoMyk7XG4gICAgICAgIHRoaXMudT1uZXcgSW50MzJBcnJheShCTUFYKTtcbiAgICAgICAgdGhpcy54PW5ldyBJbnQzMkFycmF5KEJNQVgrMSk7XG4gICAgfVxuICAgIGlmKHRoaXMudi5sZW5ndGg8dnNpemUpeyBcbiAgICAgICAgdGhpcy52PW5ldyBJbnQzMkFycmF5KHZzaXplKTsgXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPHZzaXplOyBpKyspe3RoaXMudltpXT0wO31cbiAgICBmb3IodmFyIGk9MDsgaTxCTUFYKzE7IGkrKyl7dGhpcy5jW2ldPTA7fVxuICAgIGZvcih2YXIgaT0wOyBpPDM7IGkrKyl7dGhpcy5yW2ldPTA7fVxuLy8gIGZvcihpbnQgaT0wOyBpPEJNQVg7IGkrKyl7dVtpXT0wO31cbiAgICBhcnJheUNvcHkodGhpcy5jLCAwLCB0aGlzLnUsIDAsIEJNQVgpO1xuLy8gIGZvcihpbnQgaT0wOyBpPEJNQVgrMTsgaSsrKXt4W2ldPTA7fVxuICAgIGFycmF5Q29weSh0aGlzLmMsIDAsIHRoaXMueCwgMCwgQk1BWCsxKTtcbn1cblxudmFyIHRlc3RBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpO1xudmFyIGhhc1N1YmFycmF5ID0gKHR5cGVvZiB0ZXN0QXJyYXkuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicpO1xudmFyIGhhc1NsaWNlID0gZmFsc2U7IC8qICh0eXBlb2YgdGVzdEFycmF5LnNsaWNlID09PSAnZnVuY3Rpb24nKTsgKi8gLy8gQ2hyb21lIHNsaWNlIHBlcmZvcm1hbmNlIGlzIHNvIGRpcmUgdGhhdCB3ZSdyZSBjdXJyZW50bHkgbm90IHVzaW5nIGl0Li4uXG5cbmZ1bmN0aW9uIGFycmF5Q29weShzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBcbiAgICBpZiAoIXNyYykge1xuICAgICAgICB0aHJvdyBcIlVuZGVmIHNyY1wiO1xuICAgIH0gZWxzZSBpZiAoIWRlc3QpIHtcbiAgICAgICAgdGhyb3cgXCJVbmRlZiBkZXN0XCI7XG4gICAgfVxuXG4gICAgaWYgKHNyY09mZnNldCA9PSAwICYmIGNvdW50ID09IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgYXJyYXlDb3B5X2Zhc3Qoc3JjLCBkZXN0LCBkZXN0T2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKGhhc1N1YmFycmF5KSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KHNyYy5zdWJhcnJheShzcmNPZmZzZXQsIHNyY09mZnNldCArIGNvdW50KSwgZGVzdCwgZGVzdE9mZnNldCk7IFxuICAgIH0gZWxzZSBpZiAoc3JjLkJZVEVTX1BFUl9FTEVNRU5UID09IDEgJiYgY291bnQgPiAxMDApIHtcbiAgICAgICAgYXJyYXlDb3B5X2Zhc3QobmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQgKyBzcmNPZmZzZXQsIGNvdW50KSwgZGVzdCwgZGVzdE9mZnNldCk7XG4gICAgfSBlbHNlIHsgXG4gICAgICAgIGFycmF5Q29weV9zbG93KHNyYywgc3JjT2Zmc2V0LCBkZXN0LCBkZXN0T2Zmc2V0LCBjb3VudCk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGFycmF5Q29weV9zbG93KHNyYywgc3JjT2Zmc2V0LCBkZXN0LCBkZXN0T2Zmc2V0LCBjb3VudCkge1xuXG4gICAgLy8gZGxvZygnX3Nsb3cgY2FsbDogc3JjT2Zmc2V0PScgKyBzcmNPZmZzZXQgKyAnOyBkZXN0T2Zmc2V0PScgKyBkZXN0T2Zmc2V0ICsgJzsgY291bnQ9JyArIGNvdW50KTtcblxuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgaV0gPSBzcmNbc3JjT2Zmc2V0ICsgaV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcnJheUNvcHlfZmFzdChzcmMsIGRlc3QsIGRlc3RPZmZzZXQpIHtcbiAgICBkZXN0LnNldChzcmMsIGRlc3RPZmZzZXQpO1xufVxuXG5cbiAgLy8gbGFyZ2VzdCBwcmltZSBzbWFsbGVyIHRoYW4gNjU1MzZcbnZhciBBRExFUl9CQVNFPTY1NTIxOyBcbiAgLy8gTk1BWCBpcyB0aGUgbGFyZ2VzdCBuIHN1Y2ggdGhhdCAyNTVuKG4rMSkvMiArIChuKzEpKEJBU0UtMSkgPD0gMl4zMi0xXG52YXIgQURMRVJfTk1BWD01NTUyO1xuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCAvKiBieXRlW10gKi8gYnVmLCAgaW5kZXgsIGxlbil7XG4gICAgaWYoYnVmID09IG51bGwpeyByZXR1cm4gMTsgfVxuXG4gICAgdmFyIHMxPWFkbGVyJjB4ZmZmZjtcbiAgICB2YXIgczI9KGFkbGVyPj4xNikmMHhmZmZmO1xuICAgIHZhciBrO1xuXG4gICAgd2hpbGUobGVuID4gMCkge1xuICAgICAgaz1sZW48QURMRVJfTk1BWD9sZW46QURMRVJfTk1BWDtcbiAgICAgIGxlbi09aztcbiAgICAgIHdoaWxlKGs+PTE2KXtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIGstPTE2O1xuICAgICAgfVxuICAgICAgaWYoayE9MCl7XG4gICAgICAgIGRve1xuICAgICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKC0tayE9MCk7XG4gICAgICB9XG4gICAgICBzMSU9QURMRVJfQkFTRTtcbiAgICAgIHMyJT1BRExFUl9CQVNFO1xuICAgIH1cbiAgICByZXR1cm4gKHMyPDwxNil8czE7XG59XG5cblxuXG5mdW5jdGlvbiBqc3psaWJfaW5mbGF0ZV9idWZmZXIoYnVmZmVyLCBzdGFydCwgbGVuZ3RoLCBhZnRlclVuY09mZnNldCkge1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBzdGFydCwgYnVmZmVyLmJ5dGVMZW5ndGggLSBzdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBzdGFydCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IG5ldyBaU3RyZWFtKCk7XG4gICAgei5pbmZsYXRlSW5pdChERUZfV0JJVFMsIHRydWUpO1xuICAgIHoubmV4dF9pbiA9IGJ1ZmZlcjtcbiAgICB6Lm5leHRfaW5faW5kZXggPSAwO1xuICAgIHouYXZhaWxfaW4gPSBidWZmZXIubGVuZ3RoO1xuXG4gICAgdmFyIG9CbG9ja0xpc3QgPSBbXTtcbiAgICB2YXIgdG90YWxTaXplID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgb2J1ZiA9IG5ldyBVaW50OEFycmF5KDMyMDAwKTtcbiAgICAgICAgei5uZXh0X291dCA9IG9idWY7XG4gICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xuICAgICAgICB6LmF2YWlsX291dCA9IG9idWYubGVuZ3RoO1xuICAgICAgICB2YXIgc3RhdHVzID0gei5pbmZsYXRlKFpfTk9fRkxVU0gpO1xuICAgICAgICBpZiAoc3RhdHVzICE9IFpfT0sgJiYgc3RhdHVzICE9IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT0gWl9CVUZfRVJST1IpIHtcbiAgICAgICAgICAgIHRocm93IHoubXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6LmF2YWlsX291dCAhPSAwKSB7XG4gICAgICAgICAgICB2YXIgbmV3b2IgPSBuZXcgVWludDhBcnJheShvYnVmLmxlbmd0aCAtIHouYXZhaWxfb3V0KTtcbiAgICAgICAgICAgIGFycmF5Q29weShvYnVmLCAwLCBuZXdvYiwgMCwgKG9idWYubGVuZ3RoIC0gei5hdmFpbF9vdXQpKTtcbiAgICAgICAgICAgIG9idWYgPSBuZXdvYjtcbiAgICAgICAgfVxuICAgICAgICBvQmxvY2tMaXN0LnB1c2gob2J1Zik7XG4gICAgICAgIHRvdGFsU2l6ZSArPSBvYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSBaX1NUUkVBTV9FTkQgfHwgc3RhdHVzID09IFpfQlVGX0VSUk9SKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhZnRlclVuY09mZnNldCkge1xuICAgICAgICBhZnRlclVuY09mZnNldFswXSA9IChzdGFydCB8fCAwKSArIHoubmV4dF9pbl9pbmRleDtcbiAgICB9XG5cbiAgICBpZiAob0Jsb2NrTGlzdC5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gb0Jsb2NrTGlzdFswXS5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7XG4gICAgICAgIHZhciBjdXJzb3IgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9CbG9ja0xpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBiID0gb0Jsb2NrTGlzdFtpXTtcbiAgICAgICAgICAgIGFycmF5Q29weShiLCAwLCBvdXQsIGN1cnNvciwgYi5sZW5ndGgpO1xuICAgICAgICAgICAgY3Vyc29yICs9IGIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuYnVmZmVyO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpbmZsYXRlQnVmZmVyOiBqc3psaWJfaW5mbGF0ZV9idWZmZXIsXG4gICAgYXJyYXlDb3B5OiBhcnJheUNvcHlcbiAgfTtcbn1cbiIsIi8qIVxuXHRQYXBhIFBhcnNlXG5cdHY0LjEuNFxuXHRodHRwczovL2dpdGh1Yi5jb20vbWhvbHQvUGFwYVBhcnNlXG4qL1xuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpXG57XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdHtcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cylcblx0e1xuXHRcdC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuXHRcdC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuXHRcdC8vIGxpa2UgTm9kZS5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuXHRcdHJvb3QuUGFwYSA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbigpXG57XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZ2xvYmFsID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbHRlcm5hdGl2ZSBtZXRob2QsIHNpbWlsYXIgdG8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG5cdFx0Ly8gYnV0IHdpdGhvdXQgdXNpbmcgYGV2YWxgICh3aGljaCBpcyBkaXNhYmxlZCB3aGVuXG5cdFx0Ly8gdXNpbmcgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuXG5cdFx0aWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG5cdFx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cblxuICAgICAgICAvLyBXaGVuIHJ1bm5pbmcgdGVzdHMgbm9uZSBvZiB0aGUgYWJvdmUgaGF2ZSBiZWVuIGRlZmluZWRcbiAgICAgICAgcmV0dXJuIHt9O1xuXHR9KSgpO1xuXG5cblx0dmFyIElTX1dPUktFUiA9ICFnbG9iYWwuZG9jdW1lbnQgJiYgISFnbG9iYWwucG9zdE1lc3NhZ2UsXG5cdFx0SVNfUEFQQV9XT1JLRVIgPSBJU19XT1JLRVIgJiYgLyhcXD98JilwYXBhd29ya2VyKD18JnwkKS8udGVzdChnbG9iYWwubG9jYXRpb24uc2VhcmNoKSxcblx0XHRMT0FERURfU1lOQyA9IGZhbHNlLCBBVVRPX1NDUklQVF9QQVRIO1xuXHR2YXIgd29ya2VycyA9IHt9LCB3b3JrZXJJZENvdW50ZXIgPSAwO1xuXG5cdHZhciBQYXBhID0ge307XG5cblx0UGFwYS5wYXJzZSA9IENzdlRvSnNvbjtcblx0UGFwYS51bnBhcnNlID0gSnNvblRvQ3N2O1xuXG5cdFBhcGEuUkVDT1JEX1NFUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzApO1xuXHRQYXBhLlVOSVRfU0VQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMSk7XG5cdFBhcGEuQllURV9PUkRFUl9NQVJLID0gJ1xcdWZlZmYnO1xuXHRQYXBhLkJBRF9ERUxJTUlURVJTID0gWydcXHInLCAnXFxuJywgJ1wiJywgUGFwYS5CWVRFX09SREVSX01BUktdO1xuXHRQYXBhLldPUktFUlNfU1VQUE9SVEVEID0gIUlTX1dPUktFUiAmJiAhIWdsb2JhbC5Xb3JrZXI7XG5cdFBhcGEuU0NSSVBUX1BBVEggPSBudWxsO1x0Ly8gTXVzdCBiZSBzZXQgYnkgeW91ciBjb2RlIGlmIHlvdSB1c2Ugd29ya2VycyBhbmQgdGhpcyBsaWIgaXMgbG9hZGVkIGFzeW5jaHJvbm91c2x5XG5cblx0Ly8gQ29uZmlndXJhYmxlIGNodW5rIHNpemVzIGZvciBsb2NhbCBhbmQgcmVtb3RlIGZpbGVzLCByZXNwZWN0aXZlbHlcblx0UGFwYS5Mb2NhbENodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogMTA7XHQvLyAxMCBNQlxuXHRQYXBhLlJlbW90ZUNodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogNTtcdC8vIDUgTUJcblx0UGFwYS5EZWZhdWx0RGVsaW1pdGVyID0gJywnO1x0XHRcdC8vIFVzZWQgaWYgbm90IHNwZWNpZmllZCBhbmQgZGV0ZWN0aW9uIGZhaWxzXG5cblx0Ly8gRXhwb3NlZCBmb3IgdGVzdGluZyBhbmQgZGV2ZWxvcG1lbnQgb25seVxuXHRQYXBhLlBhcnNlciA9IFBhcnNlcjtcblx0UGFwYS5QYXJzZXJIYW5kbGUgPSBQYXJzZXJIYW5kbGU7XG5cdFBhcGEuTmV0d29ya1N0cmVhbWVyID0gTmV0d29ya1N0cmVhbWVyO1xuXHRQYXBhLkZpbGVTdHJlYW1lciA9IEZpbGVTdHJlYW1lcjtcblx0UGFwYS5TdHJpbmdTdHJlYW1lciA9IFN0cmluZ1N0cmVhbWVyO1xuXG5cdGlmIChnbG9iYWwualF1ZXJ5KVxuXHR7XG5cdFx0dmFyICQgPSBnbG9iYWwualF1ZXJ5O1xuXHRcdCQuZm4ucGFyc2UgPSBmdW5jdGlvbihvcHRpb25zKVxuXHRcdHtcblx0XHRcdHZhciBjb25maWcgPSBvcHRpb25zLmNvbmZpZyB8fCB7fTtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oaWR4KVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgc3VwcG9ydGVkID0gJCh0aGlzKS5wcm9wKCd0YWdOYW1lJykudG9VcHBlckNhc2UoKSA9PT0gJ0lOUFVUJ1xuXHRcdFx0XHRcdFx0XHRcdCYmICQodGhpcykuYXR0cigndHlwZScpLnRvTG93ZXJDYXNlKCkgPT09ICdmaWxlJ1xuXHRcdFx0XHRcdFx0XHRcdCYmIGdsb2JhbC5GaWxlUmVhZGVyO1xuXG5cdFx0XHRcdGlmICghc3VwcG9ydGVkIHx8ICF0aGlzLmZpbGVzIHx8IHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1x0Ly8gY29udGludWUgdG8gbmV4dCBpbnB1dCBlbGVtZW50XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdFx0XHRmaWxlOiB0aGlzLmZpbGVzW2ldLFxuXHRcdFx0XHRcdFx0aW5wdXRFbGVtOiB0aGlzLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2VDb25maWc6ICQuZXh0ZW5kKHt9LCBjb25maWcpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRwYXJzZU5leHRGaWxlKCk7XHQvLyBiZWdpbiBwYXJzaW5nXG5cdFx0XHRyZXR1cm4gdGhpcztcdFx0Ly8gbWFpbnRhaW5zIGNoYWluYWJpbGl0eVxuXG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlTmV4dEZpbGUoKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocXVldWUubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jb21wbGV0ZSkpXG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGYgPSBxdWV1ZVswXTtcblxuXHRcdFx0XHRpZiAoaXNGdW5jdGlvbihvcHRpb25zLmJlZm9yZSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBvcHRpb25zLmJlZm9yZShmLmZpbGUsIGYuaW5wdXRFbGVtKTtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgcmV0dXJuZWQgPT09ICdvYmplY3QnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChyZXR1cm5lZC5hY3Rpb24gPT09ICdhYm9ydCcpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVycm9yKCdBYm9ydEVycm9yJywgZi5maWxlLCBmLmlucHV0RWxlbSwgcmV0dXJuZWQucmVhc29uKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1x0Ly8gQWJvcnRzIGFsbCBxdWV1ZWQgZmlsZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHJldHVybmVkLmFjdGlvbiA9PT0gJ3NraXAnKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmaWxlQ29tcGxldGUoKTtcdC8vIHBhcnNlIHRoZSBuZXh0IGZpbGUgaW4gdGhlIHF1ZXVlLCBpZiBhbnlcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIHJldHVybmVkLmNvbmZpZyA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdFx0XHRcdGYuaW5zdGFuY2VDb25maWcgPSAkLmV4dGVuZChmLmluc3RhbmNlQ29uZmlnLCByZXR1cm5lZC5jb25maWcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChyZXR1cm5lZCA9PT0gJ3NraXAnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZpbGVDb21wbGV0ZSgpO1x0Ly8gcGFyc2UgdGhlIG5leHQgZmlsZSBpbiB0aGUgcXVldWUsIGlmIGFueVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdyYXAgdXAgdGhlIHVzZXIncyBjb21wbGV0ZSBjYWxsYmFjaywgaWYgYW55LCBzbyB0aGF0IG91cnMgYWxzbyBnZXRzIGV4ZWN1dGVkXG5cdFx0XHRcdHZhciB1c2VyQ29tcGxldGVGdW5jID0gZi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZTtcblx0XHRcdFx0Zi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZSA9IGZ1bmN0aW9uKHJlc3VsdHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaXNGdW5jdGlvbih1c2VyQ29tcGxldGVGdW5jKSlcblx0XHRcdFx0XHRcdHVzZXJDb21wbGV0ZUZ1bmMocmVzdWx0cywgZi5maWxlLCBmLmlucHV0RWxlbSk7XG5cdFx0XHRcdFx0ZmlsZUNvbXBsZXRlKCk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0UGFwYS5wYXJzZShmLmZpbGUsIGYuaW5zdGFuY2VDb25maWcpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBlcnJvcihuYW1lLCBmaWxlLCBlbGVtLCByZWFzb24pXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuZXJyb3IpKVxuXHRcdFx0XHRcdG9wdGlvbnMuZXJyb3Ioe25hbWU6IG5hbWV9LCBmaWxlLCBlbGVtLCByZWFzb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBmaWxlQ29tcGxldGUoKVxuXHRcdFx0e1xuXHRcdFx0XHRxdWV1ZS5zcGxpY2UoMCwgMSk7XG5cdFx0XHRcdHBhcnNlTmV4dEZpbGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdGlmIChJU19QQVBBX1dPUktFUilcblx0e1xuXHRcdGdsb2JhbC5vbm1lc3NhZ2UgPSB3b3JrZXJUaHJlYWRSZWNlaXZlZE1lc3NhZ2U7XG5cdH1cblx0ZWxzZSBpZiAoUGFwYS5XT1JLRVJTX1NVUFBPUlRFRClcblx0e1xuXHRcdEFVVE9fU0NSSVBUX1BBVEggPSBnZXRTY3JpcHRQYXRoKCk7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgc2NyaXB0IHdhcyBsb2FkZWQgc3luY2hyb25vdXNseVxuXHRcdGlmICghZG9jdW1lbnQuYm9keSlcblx0XHR7XG5cdFx0XHQvLyBCb2R5IGRvZXNuJ3QgZXhpc3QgeWV0LCBtdXN0IGJlIHN5bmNocm9ub3VzXG5cdFx0XHRMT0FERURfU1lOQyA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRMT0FERURfU1lOQyA9IHRydWU7XG5cdFx0XHR9LCB0cnVlKTtcblx0XHR9XG5cdH1cblxuXG5cblxuXHRmdW5jdGlvbiBDc3ZUb0pzb24oX2lucHV0LCBfY29uZmlnKVxuXHR7XG5cdFx0X2NvbmZpZyA9IF9jb25maWcgfHwge307XG5cdFx0X2NvbmZpZy5keW5hbWljVHlwaW5nID0gX2NvbmZpZy5keW5hbWljVHlwaW5nIHx8IGZhbHNlO1xuXG5cdFx0aWYgKF9jb25maWcud29ya2VyICYmIFBhcGEuV09SS0VSU19TVVBQT1JURUQpXG5cdFx0e1xuXHRcdFx0dmFyIHcgPSBuZXdXb3JrZXIoKTtcblxuXHRcdFx0dy51c2VyU3RlcCA9IF9jb25maWcuc3RlcDtcblx0XHRcdHcudXNlckNodW5rID0gX2NvbmZpZy5jaHVuaztcblx0XHRcdHcudXNlckNvbXBsZXRlID0gX2NvbmZpZy5jb21wbGV0ZTtcblx0XHRcdHcudXNlckVycm9yID0gX2NvbmZpZy5lcnJvcjtcblxuXHRcdFx0X2NvbmZpZy5zdGVwID0gaXNGdW5jdGlvbihfY29uZmlnLnN0ZXApO1xuXHRcdFx0X2NvbmZpZy5jaHVuayA9IGlzRnVuY3Rpb24oX2NvbmZpZy5jaHVuayk7XG5cdFx0XHRfY29uZmlnLmNvbXBsZXRlID0gaXNGdW5jdGlvbihfY29uZmlnLmNvbXBsZXRlKTtcblx0XHRcdF9jb25maWcuZXJyb3IgPSBpc0Z1bmN0aW9uKF9jb25maWcuZXJyb3IpO1xuXHRcdFx0ZGVsZXRlIF9jb25maWcud29ya2VyO1x0Ly8gcHJldmVudCBpbmZpbml0ZSBsb29wXG5cblx0XHRcdHcucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRpbnB1dDogX2lucHV0LFxuXHRcdFx0XHRjb25maWc6IF9jb25maWcsXG5cdFx0XHRcdHdvcmtlcklkOiB3LmlkXG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzdHJlYW1lciA9IG51bGw7XG5cdFx0aWYgKHR5cGVvZiBfaW5wdXQgPT09ICdzdHJpbmcnKVxuXHRcdHtcblx0XHRcdGlmIChfY29uZmlnLmRvd25sb2FkKVxuXHRcdFx0XHRzdHJlYW1lciA9IG5ldyBOZXR3b3JrU3RyZWFtZXIoX2NvbmZpZyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHN0cmVhbWVyID0gbmV3IFN0cmluZ1N0cmVhbWVyKF9jb25maWcpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoZ2xvYmFsLkZpbGUgJiYgX2lucHV0IGluc3RhbmNlb2YgRmlsZSkgfHwgX2lucHV0IGluc3RhbmNlb2YgT2JqZWN0KVx0Ly8gLi4uU2FmYXJpLiAoc2VlIGlzc3VlICMxMDYpXG5cdFx0XHRzdHJlYW1lciA9IG5ldyBGaWxlU3RyZWFtZXIoX2NvbmZpZyk7XG5cblx0XHRyZXR1cm4gc3RyZWFtZXIuc3RyZWFtKF9pbnB1dCk7XG5cdH1cblxuXG5cblxuXG5cblx0ZnVuY3Rpb24gSnNvblRvQ3N2KF9pbnB1dCwgX2NvbmZpZylcblx0e1xuXHRcdHZhciBfb3V0cHV0ID0gJyc7XG5cdFx0dmFyIF9maWVsZHMgPSBbXTtcblxuXHRcdC8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuXG5cdFx0LyoqIHdoZXRoZXIgdG8gc3Vycm91bmQgZXZlcnkgZGF0dW0gd2l0aCBxdW90ZXMgKi9cblx0XHR2YXIgX3F1b3RlcyA9IGZhbHNlO1xuXG5cdFx0LyoqIHdoZXRoZXIgdG8gd3JpdGUgaGVhZGVycyAqL1xuXHRcdHZhciBfd3JpdGVIZWFkZXIgPSB0cnVlO1xuXG5cdFx0LyoqIGRlbGltaXRpbmcgY2hhcmFjdGVyICovXG5cdFx0dmFyIF9kZWxpbWl0ZXIgPSAnLCc7XG5cblx0XHQvKiogbmV3bGluZSBjaGFyYWN0ZXIocykgKi9cblx0XHR2YXIgX25ld2xpbmUgPSAnXFxyXFxuJztcblxuXHRcdC8qKiBxdW90ZSBjaGFyYWN0ZXIgKi9cblx0XHR2YXIgX3F1b3RlQ2hhciA9ICdcIic7XG5cblx0XHR1bnBhY2tDb25maWcoKTtcblxuXHRcdHZhciBxdW90ZUNoYXJSZWdleCA9IG5ldyBSZWdFeHAoX3F1b3RlQ2hhciwgJ2cnKTtcblxuXHRcdGlmICh0eXBlb2YgX2lucHV0ID09PSAnc3RyaW5nJylcblx0XHRcdF9pbnB1dCA9IEpTT04ucGFyc2UoX2lucHV0KTtcblxuXHRcdGlmIChfaW5wdXQgaW5zdGFuY2VvZiBBcnJheSlcblx0XHR7XG5cdFx0XHRpZiAoIV9pbnB1dC5sZW5ndGggfHwgX2lucHV0WzBdIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRcdHJldHVybiBzZXJpYWxpemUobnVsbCwgX2lucHV0KTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBfaW5wdXRbMF0gPT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm4gc2VyaWFsaXplKG9iamVjdEtleXMoX2lucHV0WzBdKSwgX2lucHV0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ29iamVjdCcpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBfaW5wdXQuZGF0YSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdF9pbnB1dC5kYXRhID0gSlNPTi5wYXJzZShfaW5wdXQuZGF0YSk7XG5cblx0XHRcdGlmIChfaW5wdXQuZGF0YSBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIV9pbnB1dC5maWVsZHMpXG5cdFx0XHRcdFx0X2lucHV0LmZpZWxkcyA9ICBfaW5wdXQubWV0YSAmJiBfaW5wdXQubWV0YS5maWVsZHM7XG5cblx0XHRcdFx0aWYgKCFfaW5wdXQuZmllbGRzKVxuXHRcdFx0XHRcdF9pbnB1dC5maWVsZHMgPSAgX2lucHV0LmRhdGFbMF0gaW5zdGFuY2VvZiBBcnJheVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBfaW5wdXQuZmllbGRzXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IG9iamVjdEtleXMoX2lucHV0LmRhdGFbMF0pO1xuXG5cdFx0XHRcdGlmICghKF9pbnB1dC5kYXRhWzBdIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBfaW5wdXQuZGF0YVswXSAhPT0gJ29iamVjdCcpXG5cdFx0XHRcdFx0X2lucHV0LmRhdGEgPSBbX2lucHV0LmRhdGFdO1x0Ly8gaGFuZGxlcyBpbnB1dCBsaWtlIFsxLDIsM10gb3IgWydhc2RmJ11cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNlcmlhbGl6ZShfaW5wdXQuZmllbGRzIHx8IFtdLCBfaW5wdXQuZGF0YSB8fCBbXSk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCAoYW55IHZhbGlkIHBhdGhzIHNob3VsZCByZXR1cm4gYmVmb3JlIHRoaXMpXG5cdFx0dGhyb3cgJ2V4Y2VwdGlvbjogVW5hYmxlIHRvIHNlcmlhbGl6ZSB1bnJlY29nbml6ZWQgaW5wdXQnO1xuXG5cblx0XHRmdW5jdGlvbiB1bnBhY2tDb25maWcoKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZyAhPT0gJ29iamVjdCcpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLmRlbGltaXRlciA9PT0gJ3N0cmluZydcblx0XHRcdFx0JiYgX2NvbmZpZy5kZWxpbWl0ZXIubGVuZ3RoID09PSAxXG5cdFx0XHRcdCYmIFBhcGEuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihfY29uZmlnLmRlbGltaXRlcikgPT09IC0xKVxuXHRcdFx0e1xuXHRcdFx0XHRfZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5xdW90ZXMgPT09ICdib29sZWFuJ1xuXHRcdFx0XHR8fCBfY29uZmlnLnF1b3RlcyBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdFx0XHRfcXVvdGVzID0gX2NvbmZpZy5xdW90ZXM7XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5uZXdsaW5lID09PSAnc3RyaW5nJylcblx0XHRcdFx0X25ld2xpbmUgPSBfY29uZmlnLm5ld2xpbmU7XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5xdW90ZUNoYXIgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRfcXVvdGVDaGFyID0gX2NvbmZpZy5xdW90ZUNoYXI7XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5oZWFkZXIgPT09ICdib29sZWFuJylcblx0XHRcdFx0X3dyaXRlSGVhZGVyID0gX2NvbmZpZy5oZWFkZXI7XG5cdFx0fVxuXG5cblx0XHQvKiogVHVybnMgYW4gb2JqZWN0J3Mga2V5cyBpbnRvIGFuIGFycmF5ICovXG5cdFx0ZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmopXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR2YXIga2V5cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG9iailcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHRyZXR1cm4ga2V5cztcblx0XHR9XG5cblx0XHQvKiogVGhlIGRvdWJsZSBmb3IgbG9vcCB0aGF0IGl0ZXJhdGVzIHRoZSBkYXRhIGFuZCB3cml0ZXMgb3V0IGEgQ1NWIHN0cmluZyBpbmNsdWRpbmcgaGVhZGVyIHJvdyAqL1xuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMsIGRhdGEpXG5cdFx0e1xuXHRcdFx0dmFyIGNzdiA9ICcnO1xuXG5cdFx0XHRpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGZpZWxkcyA9IEpTT04ucGFyc2UoZmllbGRzKTtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG5cdFx0XHR2YXIgaGFzSGVhZGVyID0gZmllbGRzIGluc3RhbmNlb2YgQXJyYXkgJiYgZmllbGRzLmxlbmd0aCA+IDA7XG5cdFx0XHR2YXIgZGF0YUtleWVkQnlGaWVsZCA9ICEoZGF0YVswXSBpbnN0YW5jZW9mIEFycmF5KTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgYSBoZWFkZXIgcm93LCB3cml0ZSBpdCBmaXJzdFxuXHRcdFx0aWYgKGhhc0hlYWRlciAmJiBfd3JpdGVIZWFkZXIpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGkgPiAwKVxuXHRcdFx0XHRcdFx0Y3N2ICs9IF9kZWxpbWl0ZXI7XG5cdFx0XHRcdFx0Y3N2ICs9IHNhZmUoZmllbGRzW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGF0YS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGNzdiArPSBfbmV3bGluZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlbiB3cml0ZSBvdXQgdGhlIGRhdGFcblx0XHRcdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGRhdGEubGVuZ3RoOyByb3crKylcblx0XHRcdHtcblx0XHRcdFx0dmFyIG1heENvbCA9IGhhc0hlYWRlciA/IGZpZWxkcy5sZW5ndGggOiBkYXRhW3Jvd10ubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1heENvbDsgY29sKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY29sID4gMClcblx0XHRcdFx0XHRcdGNzdiArPSBfZGVsaW1pdGVyO1xuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBoYXNIZWFkZXIgJiYgZGF0YUtleWVkQnlGaWVsZCA/IGZpZWxkc1tjb2xdIDogY29sO1xuXHRcdFx0XHRcdGNzdiArPSBzYWZlKGRhdGFbcm93XVtjb2xJZHhdLCBjb2wpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJvdyA8IGRhdGEubGVuZ3RoIC0gMSlcblx0XHRcdFx0XHRjc3YgKz0gX25ld2xpbmU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjc3Y7XG5cdFx0fVxuXG5cdFx0LyoqIEVuY2xvc2VzIGEgdmFsdWUgYXJvdW5kIHF1b3RlcyBpZiBuZWVkZWQgKG1ha2VzIGEgdmFsdWUgc2FmZSBmb3IgQ1NWIGluc2VydGlvbikgKi9cblx0XHRmdW5jdGlvbiBzYWZlKHN0ciwgY29sKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyB8fCBzdHIgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiAnJztcblxuXHRcdFx0c3RyID0gc3RyLnRvU3RyaW5nKCkucmVwbGFjZShxdW90ZUNoYXJSZWdleCwgX3F1b3RlQ2hhcitfcXVvdGVDaGFyKTtcblxuXHRcdFx0dmFyIG5lZWRzUXVvdGVzID0gKHR5cGVvZiBfcXVvdGVzID09PSAnYm9vbGVhbicgJiYgX3F1b3Rlcylcblx0XHRcdFx0XHRcdFx0fHwgKF9xdW90ZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBfcXVvdGVzW2NvbF0pXG5cdFx0XHRcdFx0XHRcdHx8IGhhc0FueShzdHIsIFBhcGEuQkFEX0RFTElNSVRFUlMpXG5cdFx0XHRcdFx0XHRcdHx8IHN0ci5pbmRleE9mKF9kZWxpbWl0ZXIpID4gLTFcblx0XHRcdFx0XHRcdFx0fHwgc3RyLmNoYXJBdCgwKSA9PT0gJyAnXG5cdFx0XHRcdFx0XHRcdHx8IHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnICc7XG5cblx0XHRcdHJldHVybiBuZWVkc1F1b3RlcyA/IF9xdW90ZUNoYXIgKyBzdHIgKyBfcXVvdGVDaGFyIDogc3RyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhc0FueShzdHIsIHN1YnN0cmluZ3MpXG5cdFx0e1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzdHJpbmdzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRpZiAoc3RyLmluZGV4T2Yoc3Vic3RyaW5nc1tpXSkgPiAtMSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKiogQ2h1bmtTdHJlYW1lciBpcyB0aGUgYmFzZSBwcm90b3R5cGUgZm9yIHZhcmlvdXMgc3RyZWFtZXIgaW1wbGVtZW50YXRpb25zLiAqL1xuXHRmdW5jdGlvbiBDaHVua1N0cmVhbWVyKGNvbmZpZylcblx0e1xuXHRcdHRoaXMuX2hhbmRsZSA9IG51bGw7XG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pbnB1dCA9IG51bGw7XG5cdFx0dGhpcy5fYmFzZUluZGV4ID0gMDtcblx0XHR0aGlzLl9wYXJ0aWFsTGluZSA9ICcnO1xuXHRcdHRoaXMuX3Jvd0NvdW50ID0gMDtcblx0XHR0aGlzLl9zdGFydCA9IDA7XG5cdFx0dGhpcy5fbmV4dENodW5rID0gbnVsbDtcblx0XHR0aGlzLmlzRmlyc3RDaHVuayA9IHRydWU7XG5cdFx0dGhpcy5fY29tcGxldGVSZXN1bHRzID0ge1xuXHRcdFx0ZGF0YTogW10sXG5cdFx0XHRlcnJvcnM6IFtdLFxuXHRcdFx0bWV0YToge31cblx0XHR9O1xuXHRcdHJlcGxhY2VDb25maWcuY2FsbCh0aGlzLCBjb25maWcpO1xuXG5cdFx0dGhpcy5wYXJzZUNodW5rID0gZnVuY3Rpb24oY2h1bmspXG5cdFx0e1xuXHRcdFx0Ly8gRmlyc3QgY2h1bmsgcHJlLXByb2Nlc3Npbmdcblx0XHRcdGlmICh0aGlzLmlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIG1vZGlmaWVkQ2h1bmsgPSB0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuayhjaHVuayk7XG5cdFx0XHRcdGlmIChtb2RpZmllZENodW5rICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0Y2h1bmsgPSBtb2RpZmllZENodW5rO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcblxuXHRcdFx0Ly8gUmVqb2luIHRoZSBsaW5lIHdlIGxpa2VseSBqdXN0IHNwbGl0IGluIHR3byBieSBjaHVua2luZyB0aGUgZmlsZVxuXHRcdFx0dmFyIGFnZ3JlZ2F0ZSA9IHRoaXMuX3BhcnRpYWxMaW5lICsgY2h1bms7XG5cdFx0XHR0aGlzLl9wYXJ0aWFsTGluZSA9ICcnO1xuXG5cdFx0XHR2YXIgcmVzdWx0cyA9IHRoaXMuX2hhbmRsZS5wYXJzZShhZ2dyZWdhdGUsIHRoaXMuX2Jhc2VJbmRleCwgIXRoaXMuX2ZpbmlzaGVkKTtcblxuXHRcdFx0aWYgKHRoaXMuX2hhbmRsZS5wYXVzZWQoKSB8fCB0aGlzLl9oYW5kbGUuYWJvcnRlZCgpKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdHZhciBsYXN0SW5kZXggPSByZXN1bHRzLm1ldGEuY3Vyc29yO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2ZpbmlzaGVkKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9wYXJ0aWFsTGluZSA9IGFnZ3JlZ2F0ZS5zdWJzdHJpbmcobGFzdEluZGV4IC0gdGhpcy5fYmFzZUluZGV4KTtcblx0XHRcdFx0dGhpcy5fYmFzZUluZGV4ID0gbGFzdEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzdWx0cyAmJiByZXN1bHRzLmRhdGEpXG5cdFx0XHRcdHRoaXMuX3Jvd0NvdW50ICs9IHJlc3VsdHMuZGF0YS5sZW5ndGg7XG5cblx0XHRcdHZhciBmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgPSB0aGlzLl9maW5pc2hlZCB8fCAodGhpcy5fY29uZmlnLnByZXZpZXcgJiYgdGhpcy5fcm93Q291bnQgPj0gdGhpcy5fY29uZmlnLnByZXZpZXcpO1xuXG5cdFx0XHRpZiAoSVNfUEFQQV9XT1JLRVIpXG5cdFx0XHR7XG5cdFx0XHRcdGdsb2JhbC5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdFx0cmVzdWx0czogcmVzdWx0cyxcblx0XHRcdFx0XHR3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG5cdFx0XHRcdFx0ZmluaXNoZWQ6IGZpbmlzaGVkSW5jbHVkaW5nUHJldmlld1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmNodW5rKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fY29uZmlnLmNodW5rKHJlc3VsdHMsIHRoaXMuX2hhbmRsZSk7XG5cdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRyZXN1bHRzID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fY29uZmlnLnN0ZXAgJiYgIXRoaXMuX2NvbmZpZy5jaHVuaykge1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZGF0YSA9IHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5kYXRhLmNvbmNhdChyZXN1bHRzLmRhdGEpO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZXJyb3JzID0gdGhpcy5fY29tcGxldGVSZXN1bHRzLmVycm9ycy5jb25jYXQocmVzdWx0cy5lcnJvcnMpO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMubWV0YSA9IHJlc3VsdHMubWV0YTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyAmJiBpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb21wbGV0ZSkgJiYgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLm1ldGEuYWJvcnRlZCkpXG5cdFx0XHRcdHRoaXMuX2NvbmZpZy5jb21wbGV0ZSh0aGlzLl9jb21wbGV0ZVJlc3VsdHMsIHRoaXMuX2lucHV0KTtcblxuXHRcdFx0aWYgKCFmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgJiYgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLm1ldGEucGF1c2VkKSlcblx0XHRcdFx0dGhpcy5fbmV4dENodW5rKCk7XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0XHR0aGlzLl9zZW5kRXJyb3IgPSBmdW5jdGlvbihlcnJvcilcblx0XHR7XG5cdFx0XHRpZiAoaXNGdW5jdGlvbih0aGlzLl9jb25maWcuZXJyb3IpKVxuXHRcdFx0XHR0aGlzLl9jb25maWcuZXJyb3IoZXJyb3IpO1xuXHRcdFx0ZWxzZSBpZiAoSVNfUEFQQV9XT1JLRVIgJiYgdGhpcy5fY29uZmlnLmVycm9yKVxuXHRcdFx0e1xuXHRcdFx0XHRnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRcdHdvcmtlcklkOiBQYXBhLldPUktFUl9JRCxcblx0XHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHRcdFx0ZmluaXNoZWQ6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXBsYWNlQ29uZmlnKGNvbmZpZylcblx0XHR7XG5cdFx0XHQvLyBEZWVwLWNvcHkgdGhlIGNvbmZpZyBzbyB3ZSBjYW4gZWRpdCBpdFxuXHRcdFx0dmFyIGNvbmZpZ0NvcHkgPSBjb3B5KGNvbmZpZyk7XG5cdFx0XHRjb25maWdDb3B5LmNodW5rU2l6ZSA9IHBhcnNlSW50KGNvbmZpZ0NvcHkuY2h1bmtTaXplKTtcdC8vIHBhcnNlSW50IFZFUlkgaW1wb3J0YW50IHNvIHdlIGRvbid0IGNvbmNhdGVuYXRlIHN0cmluZ3MhXG5cdFx0XHRpZiAoIWNvbmZpZy5zdGVwICYmICFjb25maWcuY2h1bmspXG5cdFx0XHRcdGNvbmZpZ0NvcHkuY2h1bmtTaXplID0gbnVsbDsgIC8vIGRpc2FibGUgUmFuZ2UgaGVhZGVyIGlmIG5vdCBzdHJlYW1pbmc7IGJhZCB2YWx1ZXMgYnJlYWsgSUlTIC0gc2VlIGlzc3VlICMxOTZcblx0XHRcdHRoaXMuX2hhbmRsZSA9IG5ldyBQYXJzZXJIYW5kbGUoY29uZmlnQ29weSk7XG5cdFx0XHR0aGlzLl9oYW5kbGUuc3RyZWFtZXIgPSB0aGlzO1xuXHRcdFx0dGhpcy5fY29uZmlnID0gY29uZmlnQ29weTtcdC8vIHBlcnNpc3QgdGhlIGNvcHkgdG8gdGhlIGNhbGxlclxuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gTmV0d29ya1N0cmVhbWVyKGNvbmZpZylcblx0e1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRpZiAoIWNvbmZpZy5jaHVua1NpemUpXG5cdFx0XHRjb25maWcuY2h1bmtTaXplID0gUGFwYS5SZW1vdGVDaHVua1NpemU7XG5cdFx0Q2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR2YXIgeGhyO1xuXG5cdFx0aWYgKElTX1dPUktFUilcblx0XHR7XG5cdFx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3JlYWRDaHVuaygpO1xuXHRcdFx0XHR0aGlzLl9jaHVua0xvYWRlZCgpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fcmVhZENodW5rKCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXMuc3RyZWFtID0gZnVuY3Rpb24odXJsKVxuXHRcdHtcblx0XHRcdHRoaXMuX2lucHV0ID0gdXJsO1xuXHRcdFx0dGhpcy5fbmV4dENodW5rKCk7XHQvLyBTdGFydHMgc3RyZWFtaW5nXG5cdFx0fTtcblxuXHRcdHRoaXMuX3JlYWRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fZmluaXNoZWQpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2NodW5rTG9hZGVkKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0eGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdGlmICh0aGlzLl9jb25maWcud2l0aENyZWRlbnRpYWxzKVxuXHRcdFx0e1xuXHRcdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy5fY29uZmlnLndpdGhDcmVkZW50aWFscztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFJU19XT1JLRVIpXG5cdFx0XHR7XG5cdFx0XHRcdHhoci5vbmxvYWQgPSBiaW5kRnVuY3Rpb24odGhpcy5fY2h1bmtMb2FkZWQsIHRoaXMpO1xuXHRcdFx0XHR4aHIub25lcnJvciA9IGJpbmRGdW5jdGlvbih0aGlzLl9jaHVua0Vycm9yLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0eGhyLm9wZW4oJ0dFVCcsIHRoaXMuX2lucHV0LCAhSVNfV09SS0VSKTtcblxuXHRcdFx0aWYgKHRoaXMuX2NvbmZpZy5jaHVua1NpemUpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBlbmQgPSB0aGlzLl9zdGFydCArIHRoaXMuX2NvbmZpZy5jaHVua1NpemUgLSAxO1x0Ly8gbWludXMgb25lIGJlY2F1c2UgYnl0ZSByYW5nZSBpcyBpbmNsdXNpdmVcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScrdGhpcy5fc3RhcnQrJy0nK2VuZCk7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdJZi1Ob25lLU1hdGNoJywgJ3dlYmtpdC1uby1jYWNoZScpOyAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODI2NzJcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0eGhyLnNlbmQoKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdFx0dGhpcy5fY2h1bmtFcnJvcihlcnIubWVzc2FnZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChJU19XT1JLRVIgJiYgeGhyLnN0YXR1cyA9PT0gMClcblx0XHRcdFx0dGhpcy5fY2h1bmtFcnJvcigpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLl9zdGFydCArPSB0aGlzLl9jb25maWcuY2h1bmtTaXplO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NodW5rTG9hZGVkID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPSA0KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPj0gNDAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9jaHVua0Vycm9yKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZmluaXNoZWQgPSAhdGhpcy5fY29uZmlnLmNodW5rU2l6ZSB8fCB0aGlzLl9zdGFydCA+IGdldEZpbGVTaXplKHhocik7XG5cdFx0XHR0aGlzLnBhcnNlQ2h1bmsoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2h1bmtFcnJvciA9IGZ1bmN0aW9uKGVycm9yTWVzc2FnZSlcblx0XHR7XG5cdFx0XHR2YXIgZXJyb3JUZXh0ID0geGhyLnN0YXR1c1RleHQgfHwgZXJyb3JNZXNzYWdlO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGVycm9yVGV4dCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RmlsZVNpemUoeGhyKVxuXHRcdHtcblx0XHRcdHZhciBjb250ZW50UmFuZ2UgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtUmFuZ2UnKTtcblx0XHRcdGlmIChjb250ZW50UmFuZ2UgPT09IG51bGwpIHsgLy8gbm8gY29udGVudCByYW5nZSwgdGhlbiBmaW5pc2ghXG4gICAgICAgIFx0XHRcdHJldHVybiAtMTtcbiAgICAgICAgICAgIFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQoY29udGVudFJhbmdlLnN1YnN0cihjb250ZW50UmFuZ2UubGFzdEluZGV4T2YoJy8nKSArIDEpKTtcblx0XHR9XG5cdH1cblx0TmV0d29ya1N0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2h1bmtTdHJlYW1lci5wcm90b3R5cGUpO1xuXHROZXR3b3JrU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmV0d29ya1N0cmVhbWVyO1xuXG5cblx0ZnVuY3Rpb24gRmlsZVN0cmVhbWVyKGNvbmZpZylcblx0e1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRpZiAoIWNvbmZpZy5jaHVua1NpemUpXG5cdFx0XHRjb25maWcuY2h1bmtTaXplID0gUGFwYS5Mb2NhbENodW5rU2l6ZTtcblx0XHRDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHRcdHZhciByZWFkZXIsIHNsaWNlO1xuXG5cdFx0Ly8gRmlsZVJlYWRlciBpcyBiZXR0ZXIgdGhhbiBGaWxlUmVhZGVyU3luYyAoZXZlbiBpbiB3b3JrZXIpIC0gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzI0NzA4NjQ5LzEwNDg4NjJcblx0XHQvLyBCdXQgRmlyZWZveCBpcyBhIHBpbGwsIHRvbyAtIHNlZSBpc3N1ZSAjNzY6IGh0dHBzOi8vZ2l0aHViLmNvbS9taG9sdC9QYXBhUGFyc2UvaXNzdWVzLzc2XG5cdFx0dmFyIHVzaW5nQXN5bmNSZWFkZXIgPSB0eXBlb2YgRmlsZVJlYWRlciAhPT0gJ3VuZGVmaW5lZCc7XHQvLyBTYWZhcmkgZG9lc24ndCBjb25zaWRlciBpdCBhIGZ1bmN0aW9uIC0gc2VlIGlzc3VlICMxMDVcblxuXHRcdHRoaXMuc3RyZWFtID0gZnVuY3Rpb24oZmlsZSlcblx0XHR7XG5cdFx0XHR0aGlzLl9pbnB1dCA9IGZpbGU7XG5cdFx0XHRzbGljZSA9IGZpbGUuc2xpY2UgfHwgZmlsZS53ZWJraXRTbGljZSB8fCBmaWxlLm1velNsaWNlO1xuXG5cdFx0XHRpZiAodXNpbmdBc3luY1JlYWRlcilcblx0XHRcdHtcblx0XHRcdFx0cmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcdFx0Ly8gUHJlZmVycmVkIG1ldGhvZCBvZiByZWFkaW5nIGZpbGVzLCBldmVuIGluIHdvcmtlcnNcblx0XHRcdFx0cmVhZGVyLm9ubG9hZCA9IGJpbmRGdW5jdGlvbih0aGlzLl9jaHVua0xvYWRlZCwgdGhpcyk7XG5cdFx0XHRcdHJlYWRlci5vbmVycm9yID0gYmluZEZ1bmN0aW9uKHRoaXMuX2NodW5rRXJyb3IsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZWFkZXIgPSBuZXcgRmlsZVJlYWRlclN5bmMoKTtcdC8vIEhhY2sgZm9yIHJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyIGluIEZpcmVmb3hcblxuXHRcdFx0dGhpcy5fbmV4dENodW5rKCk7XHQvLyBTdGFydHMgc3RyZWFtaW5nXG5cdFx0fTtcblxuXHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAoIXRoaXMuX2ZpbmlzaGVkICYmICghdGhpcy5fY29uZmlnLnByZXZpZXcgfHwgdGhpcy5fcm93Q291bnQgPCB0aGlzLl9jb25maWcucHJldmlldykpXG5cdFx0XHRcdHRoaXMuX3JlYWRDaHVuaygpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlYWRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcblx0XHRcdGlmICh0aGlzLl9jb25maWcuY2h1bmtTaXplKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZW5kID0gTWF0aC5taW4odGhpcy5fc3RhcnQgKyB0aGlzLl9jb25maWcuY2h1bmtTaXplLCB0aGlzLl9pbnB1dC5zaXplKTtcblx0XHRcdFx0aW5wdXQgPSBzbGljZS5jYWxsKGlucHV0LCB0aGlzLl9zdGFydCwgZW5kKTtcblx0XHRcdH1cblx0XHRcdHZhciB0eHQgPSByZWFkZXIucmVhZEFzVGV4dChpbnB1dCwgdGhpcy5fY29uZmlnLmVuY29kaW5nKTtcblx0XHRcdGlmICghdXNpbmdBc3luY1JlYWRlcilcblx0XHRcdFx0dGhpcy5fY2h1bmtMb2FkZWQoeyB0YXJnZXQ6IHsgcmVzdWx0OiB0eHQgfSB9KTtcdC8vIG1pbWljIHRoZSBhc3luYyBzaWduYXR1cmVcblx0XHR9XG5cblx0XHR0aGlzLl9jaHVua0xvYWRlZCA9IGZ1bmN0aW9uKGV2ZW50KVxuXHRcdHtcblx0XHRcdC8vIFZlcnkgaW1wb3J0YW50IHRvIGluY3JlbWVudCBzdGFydCBlYWNoIHRpbWUgYmVmb3JlIGhhbmRsaW5nIHJlc3VsdHNcblx0XHRcdHRoaXMuX3N0YXJ0ICs9IHRoaXMuX2NvbmZpZy5jaHVua1NpemU7XG5cdFx0XHR0aGlzLl9maW5pc2hlZCA9ICF0aGlzLl9jb25maWcuY2h1bmtTaXplIHx8IHRoaXMuX3N0YXJ0ID49IHRoaXMuX2lucHV0LnNpemU7XG5cdFx0XHR0aGlzLnBhcnNlQ2h1bmsoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2h1bmtFcnJvciA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IocmVhZGVyLmVycm9yKTtcblx0XHR9XG5cblx0fVxuXHRGaWxlU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaHVua1N0cmVhbWVyLnByb3RvdHlwZSk7XG5cdEZpbGVTdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaWxlU3RyZWFtZXI7XG5cblxuXHRmdW5jdGlvbiBTdHJpbmdTdHJlYW1lcihjb25maWcpXG5cdHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0Q2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR2YXIgc3RyaW5nO1xuXHRcdHZhciByZW1haW5pbmc7XG5cdFx0dGhpcy5zdHJlYW0gPSBmdW5jdGlvbihzKVxuXHRcdHtcblx0XHRcdHN0cmluZyA9IHM7XG5cdFx0XHRyZW1haW5pbmcgPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXMuX25leHRDaHVuaygpO1xuXHRcdH1cblx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHRoaXMuX2NvbmZpZy5jaHVua1NpemU7XG5cdFx0XHR2YXIgY2h1bmsgPSBzaXplID8gcmVtYWluaW5nLnN1YnN0cigwLCBzaXplKSA6IHJlbWFpbmluZztcblx0XHRcdHJlbWFpbmluZyA9IHNpemUgPyByZW1haW5pbmcuc3Vic3RyKHNpemUpIDogJyc7XG5cdFx0XHR0aGlzLl9maW5pc2hlZCA9ICFyZW1haW5pbmc7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNodW5rKGNodW5rKTtcblx0XHR9XG5cdH1cblx0U3RyaW5nU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJpbmdTdHJlYW1lci5wcm90b3R5cGUpO1xuXHRTdHJpbmdTdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdHJpbmdTdHJlYW1lcjtcblxuXG5cblx0Ly8gVXNlIG9uZSBQYXJzZXJIYW5kbGUgcGVyIGVudGlyZSBDU1YgZmlsZSBvciBzdHJpbmdcblx0ZnVuY3Rpb24gUGFyc2VySGFuZGxlKF9jb25maWcpXG5cdHtcblx0XHQvLyBPbmUgZ29hbCBpcyB0byBtaW5pbWl6ZSB0aGUgdXNlIG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMuLi5cblx0XHR2YXIgRkxPQVQgPSAvXlxccyotPyhcXGQqXFwuP1xcZCt8XFxkK1xcLj9cXGQqKShlWy0rXT9cXGQrKT9cXHMqJC9pO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBfc3RlcENvdW50ZXIgPSAwO1x0Ly8gTnVtYmVyIG9mIHRpbWVzIHN0ZXAgd2FzIGNhbGxlZCAobnVtYmVyIG9mIHJvd3MgcGFyc2VkKVxuXHRcdHZhciBfaW5wdXQ7XHRcdFx0XHQvLyBUaGUgaW5wdXQgYmVpbmcgcGFyc2VkXG5cdFx0dmFyIF9wYXJzZXI7XHRcdFx0Ly8gVGhlIGNvcmUgcGFyc2VyIGJlaW5nIHVzZWRcblx0XHR2YXIgX3BhdXNlZCA9IGZhbHNlO1x0Ly8gV2hldGhlciB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuXHRcdHZhciBfYWJvcnRlZCA9IGZhbHNlOyAgIC8vIFdoZXRoZXIgdGhlIHBhcnNlciBoYXMgYWJvcnRlZCBvciBub3Rcblx0XHR2YXIgX2RlbGltaXRlckVycm9yO1x0Ly8gVGVtcG9yYXJ5IHN0YXRlIGJldHdlZW4gZGVsaW1pdGVyIGRldGVjdGlvbiBhbmQgcHJvY2Vzc2luZyByZXN1bHRzXG5cdFx0dmFyIF9maWVsZHMgPSBbXTtcdFx0Ly8gRmllbGRzIGFyZSBmcm9tIHRoZSBoZWFkZXIgcm93IG9mIHRoZSBpbnB1dCwgaWYgdGhlcmUgaXMgb25lXG5cdFx0dmFyIF9yZXN1bHRzID0ge1x0XHQvLyBUaGUgbGFzdCByZXN1bHRzIHJldHVybmVkIGZyb20gdGhlIHBhcnNlclxuXHRcdFx0ZGF0YTogW10sXG5cdFx0XHRlcnJvcnM6IFtdLFxuXHRcdFx0bWV0YToge31cblx0XHR9O1xuXG5cdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5zdGVwKSlcblx0XHR7XG5cdFx0XHR2YXIgdXNlclN0ZXAgPSBfY29uZmlnLnN0ZXA7XG5cdFx0XHRfY29uZmlnLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHRzKVxuXHRcdFx0e1xuXHRcdFx0XHRfcmVzdWx0cyA9IHJlc3VsdHM7XG5cblx0XHRcdFx0aWYgKG5lZWRzSGVhZGVyUm93KCkpXG5cdFx0XHRcdFx0cHJvY2Vzc1Jlc3VsdHMoKTtcblx0XHRcdFx0ZWxzZVx0Ly8gb25seSBjYWxsIHVzZXIncyBzdGVwIGZ1bmN0aW9uIGFmdGVyIGhlYWRlciByb3dcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHByb2Nlc3NSZXN1bHRzKCk7XG5cblx0XHRcdFx0XHQvLyBJdCdzIHBvc3NiaWxlIHRoYXQgdGhpcyBsaW5lIHdhcyBlbXB0eSBhbmQgdGhlcmUncyBubyByb3cgaGVyZSBhZnRlciBhbGxcblx0XHRcdFx0XHRpZiAoX3Jlc3VsdHMuZGF0YS5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRfc3RlcENvdW50ZXIgKz0gcmVzdWx0cy5kYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAoX2NvbmZpZy5wcmV2aWV3ICYmIF9zdGVwQ291bnRlciA+IF9jb25maWcucHJldmlldylcblx0XHRcdFx0XHRcdF9wYXJzZXIuYWJvcnQoKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR1c2VyU3RlcChfcmVzdWx0cywgc2VsZik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUGFyc2VzIGlucHV0LiBNb3N0IHVzZXJzIHdvbid0IG5lZWQsIGFuZCBzaG91bGRuJ3QgbWVzcyB3aXRoLCB0aGUgYmFzZUluZGV4XG5cdFx0ICogYW5kIGlnbm9yZUxhc3RSb3cgcGFyYW1ldGVycy4gVGhleSBhcmUgdXNlZCBieSBzdHJlYW1lcnMgKHdyYXBwZXIgZnVuY3Rpb25zKVxuXHRcdCAqIHdoZW4gYW4gaW5wdXQgY29tZXMgaW4gbXVsdGlwbGUgY2h1bmtzLCBsaWtlIGZyb20gYSBmaWxlLlxuXHRcdCAqL1xuXHRcdHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgYmFzZUluZGV4LCBpZ25vcmVMYXN0Um93KVxuXHRcdHtcblx0XHRcdGlmICghX2NvbmZpZy5uZXdsaW5lKVxuXHRcdFx0XHRfY29uZmlnLm5ld2xpbmUgPSBndWVzc0xpbmVFbmRpbmdzKGlucHV0KTtcblxuXHRcdFx0X2RlbGltaXRlckVycm9yID0gZmFsc2U7XG5cdFx0XHRpZiAoIV9jb25maWcuZGVsaW1pdGVyKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZGVsaW1HdWVzcyA9IGd1ZXNzRGVsaW1pdGVyKGlucHV0LCBfY29uZmlnLm5ld2xpbmUpO1xuXHRcdFx0XHRpZiAoZGVsaW1HdWVzcy5zdWNjZXNzZnVsKVxuXHRcdFx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gZGVsaW1HdWVzcy5iZXN0RGVsaW1pdGVyO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfZGVsaW1pdGVyRXJyb3IgPSB0cnVlO1x0Ly8gYWRkIGVycm9yIGFmdGVyIHBhcnNpbmcgKG90aGVyd2lzZSBpdCB3b3VsZCBiZSBvdmVyd3JpdHRlbilcblx0XHRcdFx0XHRfY29uZmlnLmRlbGltaXRlciA9IFBhcGEuRGVmYXVsdERlbGltaXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVzdWx0cy5tZXRhLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZih0eXBlb2YgX2NvbmZpZy5kZWxpbWl0ZXIgPT09ICdmdW5jdGlvbicpXG5cdFx0XHR7XG5cdFx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXIoaW5wdXQpO1xuXHRcdFx0XHRfcmVzdWx0cy5tZXRhLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyc2VyQ29uZmlnID0gY29weShfY29uZmlnKTtcblx0XHRcdGlmIChfY29uZmlnLnByZXZpZXcgJiYgX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdHBhcnNlckNvbmZpZy5wcmV2aWV3Kys7XHQvLyB0byBjb21wZW5zYXRlIGZvciBoZWFkZXIgcm93XG5cblx0XHRcdF9pbnB1dCA9IGlucHV0O1xuXHRcdFx0X3BhcnNlciA9IG5ldyBQYXJzZXIocGFyc2VyQ29uZmlnKTtcblx0XHRcdF9yZXN1bHRzID0gX3BhcnNlci5wYXJzZShfaW5wdXQsIGJhc2VJbmRleCwgaWdub3JlTGFzdFJvdyk7XG5cdFx0XHRwcm9jZXNzUmVzdWx0cygpO1xuXHRcdFx0cmV0dXJuIF9wYXVzZWQgPyB7IG1ldGE6IHsgcGF1c2VkOiB0cnVlIH0gfSA6IChfcmVzdWx0cyB8fCB7IG1ldGE6IHsgcGF1c2VkOiBmYWxzZSB9IH0pO1xuXHRcdH07XG5cblx0XHR0aGlzLnBhdXNlZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX3BhdXNlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5wYXVzZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRfcGF1c2VkID0gdHJ1ZTtcblx0XHRcdF9wYXJzZXIuYWJvcnQoKTtcblx0XHRcdF9pbnB1dCA9IF9pbnB1dC5zdWJzdHIoX3BhcnNlci5nZXRDaGFySW5kZXgoKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdF9wYXVzZWQgPSBmYWxzZTtcblx0XHRcdHNlbGYuc3RyZWFtZXIucGFyc2VDaHVuayhfaW5wdXQpO1xuXHRcdH07XG5cblx0XHR0aGlzLmFib3J0ZWQgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfYWJvcnRlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5hYm9ydCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRfYWJvcnRlZCA9IHRydWU7XG5cdFx0XHRfcGFyc2VyLmFib3J0KCk7XG5cdFx0XHRfcmVzdWx0cy5tZXRhLmFib3J0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5jb21wbGV0ZSkpXG5cdFx0XHRcdF9jb25maWcuY29tcGxldGUoX3Jlc3VsdHMpO1xuXHRcdFx0X2lucHV0ID0gJyc7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHRzKClcblx0XHR7XG5cdFx0XHRpZiAoX3Jlc3VsdHMgJiYgX2RlbGltaXRlckVycm9yKVxuXHRcdFx0e1xuXHRcdFx0XHRhZGRFcnJvcignRGVsaW1pdGVyJywgJ1VuZGV0ZWN0YWJsZURlbGltaXRlcicsICdVbmFibGUgdG8gYXV0by1kZXRlY3QgZGVsaW1pdGluZyBjaGFyYWN0ZXI7IGRlZmF1bHRlZCB0byBcXCcnK1BhcGEuRGVmYXVsdERlbGltaXRlcisnXFwnJyk7XG5cdFx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2NvbmZpZy5za2lwRW1wdHlMaW5lcylcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBfcmVzdWx0cy5kYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdGlmIChfcmVzdWx0cy5kYXRhW2ldLmxlbmd0aCA9PT0gMSAmJiBfcmVzdWx0cy5kYXRhW2ldWzBdID09PSAnJylcblx0XHRcdFx0XHRcdF9yZXN1bHRzLmRhdGEuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZWVkc0hlYWRlclJvdygpKVxuXHRcdFx0XHRmaWxsSGVhZGVyRmllbGRzKCk7XG5cblx0XHRcdHJldHVybiBhcHBseUhlYWRlckFuZER5bmFtaWNUeXBpbmcoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZWVkc0hlYWRlclJvdygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9jb25maWcuaGVhZGVyICYmIF9maWVsZHMubGVuZ3RoID09PSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbGxIZWFkZXJGaWVsZHMoKVxuXHRcdHtcblx0XHRcdGlmICghX3Jlc3VsdHMpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBuZWVkc0hlYWRlclJvdygpICYmIGkgPCBfcmVzdWx0cy5kYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IF9yZXN1bHRzLmRhdGFbaV0ubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0X2ZpZWxkcy5wdXNoKF9yZXN1bHRzLmRhdGFbaV1bal0pO1xuXHRcdFx0X3Jlc3VsdHMuZGF0YS5zcGxpY2UoMCwgMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VEeW5hbWljKGZpZWxkLCB2YWx1ZSlcblx0XHR7XG5cdFx0XHRpZiAoKF9jb25maWcuZHluYW1pY1R5cGluZ1tmaWVsZF0gfHwgX2NvbmZpZy5keW5hbWljVHlwaW5nKSA9PT0gdHJ1ZSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdUUlVFJylcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0ZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICdGQUxTRScpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIHRyeVBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFwcGx5SGVhZGVyQW5kRHluYW1pY1R5cGluZygpXG5cdFx0e1xuXHRcdFx0aWYgKCFfcmVzdWx0cyB8fCAoIV9jb25maWcuaGVhZGVyICYmICFfY29uZmlnLmR5bmFtaWNUeXBpbmcpKVxuXHRcdFx0XHRyZXR1cm4gX3Jlc3VsdHM7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgX3Jlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0dmFyIHJvdyA9IF9jb25maWcuaGVhZGVyID8ge30gOiBbXTtcblxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IF9yZXN1bHRzLmRhdGFbaV0ubGVuZ3RoOyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgZmllbGQgPSBqO1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IF9yZXN1bHRzLmRhdGFbaV1bal07XG5cblx0XHRcdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdFx0XHRmaWVsZCA9IGogPj0gX2ZpZWxkcy5sZW5ndGggPyAnX19wYXJzZWRfZXh0cmEnIDogX2ZpZWxkc1tqXTtcblxuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2VEeW5hbWljKGZpZWxkLCB2YWx1ZSk7XG5cblx0XHRcdFx0XHRpZiAoZmllbGQgPT09ICdfX3BhcnNlZF9leHRyYScpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cm93W2ZpZWxkXSA9IHJvd1tmaWVsZF0gfHwgW107XG5cdFx0XHRcdFx0XHRyb3dbZmllbGRdLnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyb3dbZmllbGRdID0gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfcmVzdWx0cy5kYXRhW2ldID0gcm93O1xuXG5cdFx0XHRcdGlmIChfY29uZmlnLmhlYWRlcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChqID4gX2ZpZWxkcy5sZW5ndGgpXG5cdFx0XHRcdFx0XHRhZGRFcnJvcignRmllbGRNaXNtYXRjaCcsICdUb29NYW55RmllbGRzJywgJ1RvbyBtYW55IGZpZWxkczogZXhwZWN0ZWQgJyArIF9maWVsZHMubGVuZ3RoICsgJyBmaWVsZHMgYnV0IHBhcnNlZCAnICsgaiwgaSk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoaiA8IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoJ0ZpZWxkTWlzbWF0Y2gnLCAnVG9vRmV3RmllbGRzJywgJ1RvbyBmZXcgZmllbGRzOiBleHBlY3RlZCAnICsgX2ZpZWxkcy5sZW5ndGggKyAnIGZpZWxkcyBidXQgcGFyc2VkICcgKyBqLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIgJiYgX3Jlc3VsdHMubWV0YSlcblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5maWVsZHMgPSBfZmllbGRzO1xuXHRcdFx0cmV0dXJuIF9yZXN1bHRzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGd1ZXNzRGVsaW1pdGVyKGlucHV0LCBuZXdsaW5lKVxuXHRcdHtcblx0XHRcdHZhciBkZWxpbUNob2ljZXMgPSBbJywnLCAnXFx0JywgJ3wnLCAnOycsIFBhcGEuUkVDT1JEX1NFUCwgUGFwYS5VTklUX1NFUF07XG5cdFx0XHR2YXIgYmVzdERlbGltLCBiZXN0RGVsdGEsIGZpZWxkQ291bnRQcmV2Um93O1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlbGltQ2hvaWNlcy5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0dmFyIGRlbGltID0gZGVsaW1DaG9pY2VzW2ldO1xuXHRcdFx0XHR2YXIgZGVsdGEgPSAwLCBhdmdGaWVsZENvdW50ID0gMDtcblx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0dmFyIHByZXZpZXcgPSBuZXcgUGFyc2VyKHtcblx0XHRcdFx0XHRkZWxpbWl0ZXI6IGRlbGltLFxuXHRcdFx0XHRcdG5ld2xpbmU6IG5ld2xpbmUsXG5cdFx0XHRcdFx0cHJldmlldzogMTBcblx0XHRcdFx0fSkucGFyc2UoaW5wdXQpO1xuXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcHJldmlldy5kYXRhLmxlbmd0aDsgaisrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGZpZWxkQ291bnQgPSBwcmV2aWV3LmRhdGFbal0ubGVuZ3RoO1xuXHRcdFx0XHRcdGF2Z0ZpZWxkQ291bnQgKz0gZmllbGRDb3VudDtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZmllbGRDb3VudFByZXZSb3cgPT09ICd1bmRlZmluZWQnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZpZWxkQ291bnRQcmV2Um93ID0gZmllbGRDb3VudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChmaWVsZENvdW50ID4gMSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkZWx0YSArPSBNYXRoLmFicyhmaWVsZENvdW50IC0gZmllbGRDb3VudFByZXZSb3cpO1xuXHRcdFx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSBmaWVsZENvdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcmV2aWV3LmRhdGEubGVuZ3RoID4gMClcblx0XHRcdFx0XHRhdmdGaWVsZENvdW50IC89IHByZXZpZXcuZGF0YS5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCh0eXBlb2YgYmVzdERlbHRhID09PSAndW5kZWZpbmVkJyB8fCBkZWx0YSA8IGJlc3REZWx0YSlcblx0XHRcdFx0XHQmJiBhdmdGaWVsZENvdW50ID4gMS45OSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGJlc3REZWx0YSA9IGRlbHRhO1xuXHRcdFx0XHRcdGJlc3REZWxpbSA9IGRlbGltO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gYmVzdERlbGltO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdWNjZXNzZnVsOiAhIWJlc3REZWxpbSxcblx0XHRcdFx0YmVzdERlbGltaXRlcjogYmVzdERlbGltXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ3Vlc3NMaW5lRW5kaW5ncyhpbnB1dClcblx0XHR7XG5cdFx0XHRpbnB1dCA9IGlucHV0LnN1YnN0cigwLCAxMDI0KjEwMjQpO1x0Ly8gbWF4IGxlbmd0aCAxIE1CXG5cblx0XHRcdHZhciByID0gaW5wdXQuc3BsaXQoJ1xccicpO1xuXG5cdFx0XHR2YXIgbiA9IGlucHV0LnNwbGl0KCdcXG4nKTtcblxuXHRcdFx0dmFyIG5BcHBlYXJzRmlyc3QgPSAobi5sZW5ndGggPiAxICYmIG5bMF0ubGVuZ3RoIDwgclswXS5sZW5ndGgpO1xuXG5cdFx0XHRpZiAoci5sZW5ndGggPT09IDEgfHwgbkFwcGVhcnNGaXJzdClcblx0XHRcdFx0cmV0dXJuICdcXG4nO1xuXG5cdFx0XHR2YXIgbnVtV2l0aE4gPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocltpXVswXSA9PT0gJ1xcbicpXG5cdFx0XHRcdFx0bnVtV2l0aE4rKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bVdpdGhOID49IHIubGVuZ3RoIC8gMiA/ICdcXHJcXG4nIDogJ1xccic7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJ5UGFyc2VGbG9hdCh2YWwpXG5cdFx0e1xuXHRcdFx0dmFyIGlzTnVtYmVyID0gRkxPQVQudGVzdCh2YWwpO1xuXHRcdFx0cmV0dXJuIGlzTnVtYmVyID8gcGFyc2VGbG9hdCh2YWwpIDogdmFsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEVycm9yKHR5cGUsIGNvZGUsIG1zZywgcm93KVxuXHRcdHtcblx0XHRcdF9yZXN1bHRzLmVycm9ycy5wdXNoKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Y29kZTogY29kZSxcblx0XHRcdFx0bWVzc2FnZTogbXNnLFxuXHRcdFx0XHRyb3c6IHJvd1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXG5cblxuXHQvKiogVGhlIGNvcmUgcGFyc2VyIGltcGxlbWVudHMgc3BlZWR5IGFuZCBjb3JyZWN0IENTViBwYXJzaW5nICovXG5cdGZ1bmN0aW9uIFBhcnNlcihjb25maWcpXG5cdHtcblx0XHQvLyBVbnBhY2sgdGhlIGNvbmZpZyBvYmplY3Rcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0dmFyIGRlbGltID0gY29uZmlnLmRlbGltaXRlcjtcblx0XHR2YXIgbmV3bGluZSA9IGNvbmZpZy5uZXdsaW5lO1xuXHRcdHZhciBjb21tZW50cyA9IGNvbmZpZy5jb21tZW50cztcblx0XHR2YXIgc3RlcCA9IGNvbmZpZy5zdGVwO1xuXHRcdHZhciBwcmV2aWV3ID0gY29uZmlnLnByZXZpZXc7XG5cdFx0dmFyIGZhc3RNb2RlID0gY29uZmlnLmZhc3RNb2RlO1xuXHRcdHZhciBxdW90ZUNoYXIgPSBjb25maWcucXVvdGVDaGFyIHx8ICdcIic7XG5cblx0XHQvLyBEZWxpbWl0ZXIgbXVzdCBiZSB2YWxpZFxuXHRcdGlmICh0eXBlb2YgZGVsaW0gIT09ICdzdHJpbmcnXG5cdFx0XHR8fCBQYXBhLkJBRF9ERUxJTUlURVJTLmluZGV4T2YoZGVsaW0pID4gLTEpXG5cdFx0XHRkZWxpbSA9ICcsJztcblxuXHRcdC8vIENvbW1lbnQgY2hhcmFjdGVyIG11c3QgYmUgdmFsaWRcblx0XHRpZiAoY29tbWVudHMgPT09IGRlbGltKVxuXHRcdFx0dGhyb3cgJ0NvbW1lbnQgY2hhcmFjdGVyIHNhbWUgYXMgZGVsaW1pdGVyJztcblx0XHRlbHNlIGlmIChjb21tZW50cyA9PT0gdHJ1ZSlcblx0XHRcdGNvbW1lbnRzID0gJyMnO1xuXHRcdGVsc2UgaWYgKHR5cGVvZiBjb21tZW50cyAhPT0gJ3N0cmluZydcblx0XHRcdHx8IFBhcGEuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihjb21tZW50cykgPiAtMSlcblx0XHRcdGNvbW1lbnRzID0gZmFsc2U7XG5cblx0XHQvLyBOZXdsaW5lIG11c3QgYmUgdmFsaWQ6IFxcciwgXFxuLCBvciBcXHJcXG5cblx0XHRpZiAobmV3bGluZSAhPSAnXFxuJyAmJiBuZXdsaW5lICE9ICdcXHInICYmIG5ld2xpbmUgIT0gJ1xcclxcbicpXG5cdFx0XHRuZXdsaW5lID0gJ1xcbic7XG5cblx0XHQvLyBXZSdyZSBnb25uYSBuZWVkIHRoZXNlIGF0IHRoZSBQYXJzZXIgc2NvcGVcblx0XHR2YXIgY3Vyc29yID0gMDtcblx0XHR2YXIgYWJvcnRlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBiYXNlSW5kZXgsIGlnbm9yZUxhc3RSb3cpXG5cdFx0e1xuXHRcdFx0Ly8gRm9yIHNvbWUgcmVhc29uLCBpbiBDaHJvbWUsIHRoaXMgc3BlZWRzIHRoaW5ncyB1cCAoIT8pXG5cdFx0XHRpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJylcblx0XHRcdFx0dGhyb3cgJ0lucHV0IG11c3QgYmUgYSBzdHJpbmcnO1xuXG5cdFx0XHQvLyBXZSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgc29tZSBvZiB0aGVzZSBldmVyeSB0aW1lIHBhcnNlKCkgaXMgY2FsbGVkLFxuXHRcdFx0Ly8gYnV0IGhhdmluZyB0aGVtIGluIGEgbW9yZSBsb2NhbCBzY29wZSBzZWVtcyB0byBwZXJmb3JtIGJldHRlclxuXHRcdFx0dmFyIGlucHV0TGVuID0gaW5wdXQubGVuZ3RoLFxuXHRcdFx0XHRkZWxpbUxlbiA9IGRlbGltLmxlbmd0aCxcblx0XHRcdFx0bmV3bGluZUxlbiA9IG5ld2xpbmUubGVuZ3RoLFxuXHRcdFx0XHRjb21tZW50c0xlbiA9IGNvbW1lbnRzLmxlbmd0aDtcblx0XHRcdHZhciBzdGVwSXNGdW5jdGlvbiA9IHR5cGVvZiBzdGVwID09PSAnZnVuY3Rpb24nO1xuXG5cdFx0XHQvLyBFc3RhYmxpc2ggc3RhcnRpbmcgc3RhdGVcblx0XHRcdGN1cnNvciA9IDA7XG5cdFx0XHR2YXIgZGF0YSA9IFtdLCBlcnJvcnMgPSBbXSwgcm93ID0gW10sIGxhc3RDdXJzb3IgPSAwO1xuXG5cdFx0XHRpZiAoIWlucHV0KVxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXG5cdFx0XHRpZiAoZmFzdE1vZGUgfHwgKGZhc3RNb2RlICE9PSBmYWxzZSAmJiBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhcikgPT09IC0xKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHJvd3MgPSBpbnB1dC5zcGxpdChuZXdsaW5lKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIHJvdyA9IHJvd3NbaV07XG5cdFx0XHRcdFx0Y3Vyc29yICs9IHJvdy5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKGkgIT09IHJvd3MubGVuZ3RoIC0gMSlcblx0XHRcdFx0XHRcdGN1cnNvciArPSBuZXdsaW5lLmxlbmd0aDtcblx0XHRcdFx0XHRlbHNlIGlmIChpZ25vcmVMYXN0Um93KVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHRpZiAoY29tbWVudHMgJiYgcm93LnN1YnN0cigwLCBjb21tZW50c0xlbikgPT09IGNvbW1lbnRzKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRhdGEgPSBbXTtcblx0XHRcdFx0XHRcdHB1c2hSb3cocm93LnNwbGl0KGRlbGltKSk7XG5cdFx0XHRcdFx0XHRkb1N0ZXAoKTtcblx0XHRcdFx0XHRcdGlmIChhYm9ydGVkKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRwdXNoUm93KHJvdy5zcGxpdChkZWxpbSkpO1xuXHRcdFx0XHRcdGlmIChwcmV2aWV3ICYmIGkgPj0gcHJldmlldylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YS5zbGljZSgwLCBwcmV2aWV3KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdHZhciBuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdHZhciBxdW90ZUNoYXJSZWdleCA9IG5ldyBSZWdFeHAocXVvdGVDaGFyK3F1b3RlQ2hhciwgJ2cnKTtcblxuXHRcdFx0Ly8gUGFyc2VyIGxvb3Bcblx0XHRcdGZvciAoOzspXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEZpZWxkIGhhcyBvcGVuaW5nIHF1b3RlXG5cdFx0XHRcdGlmIChpbnB1dFtjdXJzb3JdID09PSBxdW90ZUNoYXIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBTdGFydCBvdXIgc2VhcmNoIGZvciB0aGUgY2xvc2luZyBxdW90ZSB3aGVyZSB0aGUgY3Vyc29yIGlzXG5cdFx0XHRcdFx0dmFyIHF1b3RlU2VhcmNoID0gY3Vyc29yO1xuXG5cdFx0XHRcdFx0Ly8gU2tpcCB0aGUgb3BlbmluZyBxdW90ZVxuXHRcdFx0XHRcdGN1cnNvcisrO1xuXG5cdFx0XHRcdFx0Zm9yICg7Oylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBGaW5kIGNsb3NpbmcgcXVvdGVcblx0XHRcdFx0XHRcdHZhciBxdW90ZVNlYXJjaCA9IGlucHV0LmluZGV4T2YocXVvdGVDaGFyLCBxdW90ZVNlYXJjaCsxKTtcblxuXHRcdFx0XHRcdFx0aWYgKHF1b3RlU2VhcmNoID09PSAtMSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCFpZ25vcmVMYXN0Um93KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm8gY2xvc2luZyBxdW90ZS4uLiB3aGF0IGEgcGl0eVxuXHRcdFx0XHRcdFx0XHRcdGVycm9ycy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29kZTogJ01pc3NpbmdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ1F1b3RlZCBmaWVsZCB1bnRlcm1pbmF0ZWQnLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm93OiBkYXRhLmxlbmd0aCxcdC8vIHJvdyBoYXMgeWV0IHRvIGJlIGluc2VydGVkXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleDogY3Vyc29yXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZpbmlzaCgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAocXVvdGVTZWFyY2ggPT09IGlucHV0TGVuLTEpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIENsb3NpbmcgcXVvdGUgYXQgRU9GXG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmluaXNoKHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBxdW90ZSBpcyBlc2NhcGVkLCBpdCdzIHBhcnQgb2YgdGhlIGRhdGE7IHNraXAgaXRcblx0XHRcdFx0XHRcdGlmIChpbnB1dFtxdW90ZVNlYXJjaCsxXSA9PT0gcXVvdGVDaGFyKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRxdW90ZVNlYXJjaCsrO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGlucHV0W3F1b3RlU2VhcmNoKzFdID09PSBkZWxpbSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2xvc2luZyBxdW90ZSBmb2xsb3dlZCBieSBkZWxpbWl0ZXJcblx0XHRcdFx0XHRcdFx0cm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcikpO1xuXHRcdFx0XHRcdFx0XHRjdXJzb3IgPSBxdW90ZVNlYXJjaCArIDEgKyBkZWxpbUxlbjtcblx0XHRcdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdFx0XHRcdFx0bmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoaW5wdXQuc3Vic3RyKHF1b3RlU2VhcmNoKzEsIG5ld2xpbmVMZW4pID09PSBuZXdsaW5lKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBDbG9zaW5nIHF1b3RlIGZvbGxvd2VkIGJ5IG5ld2xpbmVcblx0XHRcdFx0XHRcdFx0cm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcikpO1xuXHRcdFx0XHRcdFx0XHRzYXZlUm93KHF1b3RlU2VhcmNoICsgMSArIG5ld2xpbmVMZW4pO1xuXHRcdFx0XHRcdFx0XHRuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1x0Ly8gYmVjYXVzZSB3ZSBtYXkgaGF2ZSBza2lwcGVkIHRoZSBuZXh0RGVsaW0gaW4gdGhlIHF1b3RlZCBmaWVsZFxuXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwSXNGdW5jdGlvbilcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChhYm9ydGVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChwcmV2aWV3ICYmIGRhdGEubGVuZ3RoID49IHByZXZpZXcpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb21tZW50IGZvdW5kIGF0IHN0YXJ0IG9mIG5ldyBsaW5lXG5cdFx0XHRcdGlmIChjb21tZW50cyAmJiByb3cubGVuZ3RoID09PSAwICYmIGlucHV0LnN1YnN0cihjdXJzb3IsIGNvbW1lbnRzTGVuKSA9PT0gY29tbWVudHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAobmV4dE5ld2xpbmUgPT09IC0xKVx0Ly8gQ29tbWVudCBlbmRzIGF0IEVPRlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHRjdXJzb3IgPSBuZXh0TmV3bGluZSArIG5ld2xpbmVMZW47XG5cdFx0XHRcdFx0bmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG5cdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE5leHQgZGVsaW1pdGVyIGNvbWVzIGJlZm9yZSBuZXh0IG5ld2xpbmUsIHNvIHdlJ3ZlIHJlYWNoZWQgZW5kIG9mIGZpZWxkXG5cdFx0XHRcdGlmIChuZXh0RGVsaW0gIT09IC0xICYmIChuZXh0RGVsaW0gPCBuZXh0TmV3bGluZSB8fCBuZXh0TmV3bGluZSA9PT0gLTEpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgbmV4dERlbGltKSk7XG5cdFx0XHRcdFx0Y3Vyc29yID0gbmV4dERlbGltICsgZGVsaW1MZW47XG5cdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuZCBvZiByb3dcblx0XHRcdFx0aWYgKG5leHROZXdsaW5lICE9PSAtMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIG5leHROZXdsaW5lKSk7XG5cdFx0XHRcdFx0c2F2ZVJvdyhuZXh0TmV3bGluZSArIG5ld2xpbmVMZW4pO1xuXG5cdFx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRcdFx0aWYgKGFib3J0ZWQpXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldylcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXG5cdFx0XHRyZXR1cm4gZmluaXNoKCk7XG5cblxuXHRcdFx0ZnVuY3Rpb24gcHVzaFJvdyhyb3cpXG5cdFx0XHR7XG5cdFx0XHRcdGRhdGEucHVzaChyb3cpO1xuXHRcdFx0XHRsYXN0Q3Vyc29yID0gY3Vyc29yO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFwcGVuZHMgdGhlIHJlbWFpbmluZyBpbnB1dCBmcm9tIGN1cnNvciB0byB0aGUgZW5kIGludG9cblx0XHRcdCAqIHJvdywgc2F2ZXMgdGhlIHJvdywgY2FsbHMgc3RlcCwgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGZpbmlzaCh2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGlnbm9yZUxhc3RSb3cpXG5cdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRcdFx0dmFsdWUgPSBpbnB1dC5zdWJzdHIoY3Vyc29yKTtcblx0XHRcdFx0cm93LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjdXJzb3IgPSBpbnB1dExlbjtcdC8vIGltcG9ydGFudCBpbiBjYXNlIHBhcnNpbmcgaXMgcGF1c2VkXG5cdFx0XHRcdHB1c2hSb3cocm93KTtcblx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFwcGVuZHMgdGhlIGN1cnJlbnQgcm93IHRvIHRoZSByZXN1bHRzLiBJdCBzZXRzIHRoZSBjdXJzb3Jcblx0XHRcdCAqIHRvIG5ld0N1cnNvciBhbmQgZmluZHMgdGhlIG5leHROZXdsaW5lLiBUaGUgY2FsbGVyIHNob3VsZFxuXHRcdFx0ICogdGFrZSBjYXJlIHRvIGV4ZWN1dGUgdXNlcidzIHN0ZXAgZnVuY3Rpb24gYW5kIGNoZWNrIGZvclxuXHRcdFx0ICogcHJldmlldyBhbmQgZW5kIHBhcnNpbmcgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBzYXZlUm93KG5ld0N1cnNvcilcblx0XHRcdHtcblx0XHRcdFx0Y3Vyc29yID0gbmV3Q3Vyc29yO1xuXHRcdFx0XHRwdXNoUm93KHJvdyk7XG5cdFx0XHRcdHJvdyA9IFtdO1xuXHRcdFx0XHRuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdH1cblxuXHRcdFx0LyoqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHJlc3VsdHMsIGVycm9ycywgYW5kIG1ldGEuICovXG5cdFx0XHRmdW5jdGlvbiByZXR1cm5hYmxlKHN0b3BwZWQpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0XHRlcnJvcnM6IGVycm9ycyxcblx0XHRcdFx0XHRtZXRhOiB7XG5cdFx0XHRcdFx0XHRkZWxpbWl0ZXI6IGRlbGltLFxuXHRcdFx0XHRcdFx0bGluZWJyZWFrOiBuZXdsaW5lLFxuXHRcdFx0XHRcdFx0YWJvcnRlZDogYWJvcnRlZCxcblx0XHRcdFx0XHRcdHRydW5jYXRlZDogISFzdG9wcGVkLFxuXHRcdFx0XHRcdFx0Y3Vyc29yOiBsYXN0Q3Vyc29yICsgKGJhc2VJbmRleCB8fCAwKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0LyoqIEV4ZWN1dGVzIHRoZSB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhbmQgcmVzZXRzIGRhdGEgJiBlcnJvcnMuICovXG5cdFx0XHRmdW5jdGlvbiBkb1N0ZXAoKVxuXHRcdFx0e1xuXHRcdFx0XHRzdGVwKHJldHVybmFibGUoKSk7XG5cdFx0XHRcdGRhdGEgPSBbXSwgZXJyb3JzID0gW107XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKiBTZXRzIHRoZSBhYm9ydCBmbGFnICovXG5cdFx0dGhpcy5hYm9ydCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRhYm9ydGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqIEdldHMgdGhlIGN1cnNvciBwb3NpdGlvbiAqL1xuXHRcdHRoaXMuZ2V0Q2hhckluZGV4ID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBjdXJzb3I7XG5cdFx0fTtcblx0fVxuXG5cblx0Ly8gSWYgeW91IG5lZWQgdG8gbG9hZCBQYXBhIFBhcnNlIGFzeW5jaHJvbm91c2x5IGFuZCB5b3UgYWxzbyBuZWVkIHdvcmtlciB0aHJlYWRzLCBoYXJkLWNvZGVcblx0Ly8gdGhlIHNjcmlwdCBwYXRoIGhlcmUuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZS9pc3N1ZXMvODcjaXNzdWVjb21tZW50LTU3ODg1MzU4XG5cdGZ1bmN0aW9uIGdldFNjcmlwdFBhdGgoKVxuXHR7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cdFx0cmV0dXJuIHNjcmlwdHMubGVuZ3RoID8gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyYyA6ICcnO1xuXHR9XG5cblx0ZnVuY3Rpb24gbmV3V29ya2VyKClcblx0e1xuXHRcdGlmICghUGFwYS5XT1JLRVJTX1NVUFBPUlRFRClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAoIUxPQURFRF9TWU5DICYmIFBhcGEuU0NSSVBUX1BBVEggPT09IG51bGwpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdTY3JpcHQgcGF0aCBjYW5ub3QgYmUgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5IHdoZW4gUGFwYSBQYXJzZSBpcyBsb2FkZWQgYXN5bmNocm9ub3VzbHkuICcgK1xuXHRcdFx0XHQnWW91IG5lZWQgdG8gc2V0IFBhcGEuU0NSSVBUX1BBVEggbWFudWFsbHkuJ1xuXHRcdFx0KTtcblx0XHR2YXIgd29ya2VyVXJsID0gUGFwYS5TQ1JJUFRfUEFUSCB8fCBBVVRPX1NDUklQVF9QQVRIO1xuXHRcdC8vIEFwcGVuZCAncGFwYXdvcmtlcicgdG8gdGhlIHNlYXJjaCBzdHJpbmcgdG8gdGVsbCBwYXBhcGFyc2UgdGhhdCB0aGlzIGlzIG91ciB3b3JrZXIuXG5cdFx0d29ya2VyVXJsICs9ICh3b3JrZXJVcmwuaW5kZXhPZignPycpICE9PSAtMSA/ICcmJyA6ICc/JykgKyAncGFwYXdvcmtlcic7XG5cdFx0dmFyIHcgPSBuZXcgZ2xvYmFsLldvcmtlcih3b3JrZXJVcmwpO1xuXHRcdHcub25tZXNzYWdlID0gbWFpblRocmVhZFJlY2VpdmVkTWVzc2FnZTtcblx0XHR3LmlkID0gd29ya2VySWRDb3VudGVyKys7XG5cdFx0d29ya2Vyc1t3LmlkXSA9IHc7XG5cdFx0cmV0dXJuIHc7XG5cdH1cblxuXHQvKiogQ2FsbGJhY2sgd2hlbiBtYWluIHRocmVhZCByZWNlaXZlcyBhIG1lc3NhZ2UgKi9cblx0ZnVuY3Rpb24gbWFpblRocmVhZFJlY2VpdmVkTWVzc2FnZShlKVxuXHR7XG5cdFx0dmFyIG1zZyA9IGUuZGF0YTtcblx0XHR2YXIgd29ya2VyID0gd29ya2Vyc1ttc2cud29ya2VySWRdO1xuXHRcdHZhciBhYm9ydGVkID0gZmFsc2U7XG5cblx0XHRpZiAobXNnLmVycm9yKVxuXHRcdFx0d29ya2VyLnVzZXJFcnJvcihtc2cuZXJyb3IsIG1zZy5maWxlKTtcblx0XHRlbHNlIGlmIChtc2cucmVzdWx0cyAmJiBtc2cucmVzdWx0cy5kYXRhKVxuXHRcdHtcblx0XHRcdHZhciBhYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0Y29tcGxldGVXb3JrZXIobXNnLndvcmtlcklkLCB7IGRhdGE6IFtdLCBlcnJvcnM6IFtdLCBtZXRhOiB7IGFib3J0ZWQ6IHRydWUgfSB9KTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBoYW5kbGUgPSB7XG5cdFx0XHRcdGFib3J0OiBhYm9ydCxcblx0XHRcdFx0cGF1c2U6IG5vdEltcGxlbWVudGVkLFxuXHRcdFx0XHRyZXN1bWU6IG5vdEltcGxlbWVudGVkXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoaXNGdW5jdGlvbih3b3JrZXIudXNlclN0ZXApKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5yZXN1bHRzLmRhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR3b3JrZXIudXNlclN0ZXAoe1xuXHRcdFx0XHRcdFx0ZGF0YTogW21zZy5yZXN1bHRzLmRhdGFbaV1dLFxuXHRcdFx0XHRcdFx0ZXJyb3JzOiBtc2cucmVzdWx0cy5lcnJvcnMsXG5cdFx0XHRcdFx0XHRtZXRhOiBtc2cucmVzdWx0cy5tZXRhXG5cdFx0XHRcdFx0fSwgaGFuZGxlKTtcblx0XHRcdFx0XHRpZiAoYWJvcnRlZClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBtc2cucmVzdWx0cztcdC8vIGZyZWUgbWVtb3J5IEFTQVBcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlzRnVuY3Rpb24od29ya2VyLnVzZXJDaHVuaykpXG5cdFx0XHR7XG5cdFx0XHRcdHdvcmtlci51c2VyQ2h1bmsobXNnLnJlc3VsdHMsIGhhbmRsZSwgbXNnLmZpbGUpO1xuXHRcdFx0XHRkZWxldGUgbXNnLnJlc3VsdHM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1zZy5maW5pc2hlZCAmJiAhYWJvcnRlZClcblx0XHRcdGNvbXBsZXRlV29ya2VyKG1zZy53b3JrZXJJZCwgbXNnLnJlc3VsdHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGxldGVXb3JrZXIod29ya2VySWQsIHJlc3VsdHMpIHtcblx0XHR2YXIgd29ya2VyID0gd29ya2Vyc1t3b3JrZXJJZF07XG5cdFx0aWYgKGlzRnVuY3Rpb24od29ya2VyLnVzZXJDb21wbGV0ZSkpXG5cdFx0XHR3b3JrZXIudXNlckNvbXBsZXRlKHJlc3VsdHMpO1xuXHRcdHdvcmtlci50ZXJtaW5hdGUoKTtcblx0XHRkZWxldGUgd29ya2Vyc1t3b3JrZXJJZF07XG5cdH1cblxuXHRmdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcblx0XHR0aHJvdyAnTm90IGltcGxlbWVudGVkLic7XG5cdH1cblxuXHQvKiogQ2FsbGJhY2sgd2hlbiB3b3JrZXIgdGhyZWFkIHJlY2VpdmVzIGEgbWVzc2FnZSAqL1xuXHRmdW5jdGlvbiB3b3JrZXJUaHJlYWRSZWNlaXZlZE1lc3NhZ2UoZSlcblx0e1xuXHRcdHZhciBtc2cgPSBlLmRhdGE7XG5cblx0XHRpZiAodHlwZW9mIFBhcGEuV09SS0VSX0lEID09PSAndW5kZWZpbmVkJyAmJiBtc2cpXG5cdFx0XHRQYXBhLldPUktFUl9JRCA9IG1zZy53b3JrZXJJZDtcblxuXHRcdGlmICh0eXBlb2YgbXNnLmlucHV0ID09PSAnc3RyaW5nJylcblx0XHR7XG5cdFx0XHRnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHR3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG5cdFx0XHRcdHJlc3VsdHM6IFBhcGEucGFyc2UobXNnLmlucHV0LCBtc2cuY29uZmlnKSxcblx0XHRcdFx0ZmluaXNoZWQ6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoZ2xvYmFsLkZpbGUgJiYgbXNnLmlucHV0IGluc3RhbmNlb2YgRmlsZSkgfHwgbXNnLmlucHV0IGluc3RhbmNlb2YgT2JqZWN0KVx0Ly8gdGhhbmsgeW91LCBTYWZhcmkgKHNlZSBpc3N1ZSAjMTA2KVxuXHRcdHtcblx0XHRcdHZhciByZXN1bHRzID0gUGFwYS5wYXJzZShtc2cuaW5wdXQsIG1zZy5jb25maWcpO1xuXHRcdFx0aWYgKHJlc3VsdHMpXG5cdFx0XHRcdGdsb2JhbC5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdFx0d29ya2VySWQ6IFBhcGEuV09SS0VSX0lELFxuXHRcdFx0XHRcdHJlc3VsdHM6IHJlc3VsdHMsXG5cdFx0XHRcdFx0ZmluaXNoZWQ6IHRydWVcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIE1ha2VzIGEgZGVlcCBjb3B5IG9mIGFuIGFycmF5IG9yIG9iamVjdCAobW9zdGx5KSAqL1xuXHRmdW5jdGlvbiBjb3B5KG9iailcblx0e1xuXHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jylcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0dmFyIGNweSA9IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fTtcblx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKVxuXHRcdFx0Y3B5W2tleV0gPSBjb3B5KG9ialtrZXldKTtcblx0XHRyZXR1cm4gY3B5O1xuXHR9XG5cblx0ZnVuY3Rpb24gYmluZEZ1bmN0aW9uKGYsIHNlbGYpXG5cdHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYylcblx0e1xuXHRcdHJldHVybiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cdHJldHVybiBQYXBhO1xufSkpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vICBSYW1kYSB2MC4yMS4wXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL3JhbWRhL3JhbWRhXG4vLyAgKGMpIDIwMTMtMjAxNiBTY290dCBTYXV5ZXQsIE1pY2hhZWwgSHVybGV5LCBhbmQgRGF2aWQgQ2hhbWJlcnNcbi8vICBSYW1kYSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuOyhmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAgICogQSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIHVzZWQgdG8gc3BlY2lmeSBcImdhcHNcIiB3aXRoaW4gY3VycmllZCBmdW5jdGlvbnMsXG4gICAgICogYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mXG4gICAgICogdGhlaXIgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogSWYgYGdgIGlzIGEgY3VycmllZCB0ZXJuYXJ5IGZ1bmN0aW9uIGFuZCBgX2AgaXMgYFIuX19gLCB0aGUgZm9sbG93aW5nIGFyZVxuICAgICAqIGVxdWl2YWxlbnQ6XG4gICAgICpcbiAgICAgKiAgIC0gYGcoMSwgMiwgMylgXG4gICAgICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICAgICAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAgICAgKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gICAgICogICAtIGBnKF8sIDIsIF8pKDEsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSwgMylgXG4gICAgICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICAgICAqXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGdyZWV0ID0gUi5yZXBsYWNlKCd7bmFtZX0nLCBSLl9fLCAnSGVsbG8sIHtuYW1lfSEnKTtcbiAgICAgKiAgICAgIGdyZWV0KCdBbGljZScpOyAvLz0+ICdIZWxsbywgQWxpY2UhJ1xuICAgICAqL1xuICAgIHZhciBfXyA9IHsgJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlcic6IHRydWUgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgdmFyIF9hcml0eSA9IGZ1bmN0aW9uIF9hcml0eShuLCBmbikge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBfYXJpdHkgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG5vIGdyZWF0ZXIgdGhhbiB0ZW4nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX2FycmF5RnJvbUl0ZXJhdG9yID0gZnVuY3Rpb24gX2FycmF5RnJvbUl0ZXJhdG9yKGl0ZXIpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKG5leHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICB2YXIgX2FycmF5T2YgPSBmdW5jdGlvbiBfYXJyYXlPZigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBfY2xvbmVSZWdFeHAgPSBmdW5jdGlvbiBfY2xvbmVSZWdFeHAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4uZ2xvYmFsID8gJ2cnIDogJycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChwYXR0ZXJuLm11bHRpbGluZSA/ICdtJyA6ICcnKSArIChwYXR0ZXJuLnN0aWNreSA/ICd5JyA6ICcnKSArIChwYXR0ZXJuLnVuaWNvZGUgPyAndScgOiAnJykpO1xuICAgIH07XG5cbiAgICB2YXIgX2NvbXBsZW1lbnQgPSBmdW5jdGlvbiBfY29tcGxlbWVudChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBgY29uY2F0YCBmdW5jdGlvbiB0byBtZXJnZSB0d28gYXJyYXktbGlrZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDE9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBbc2V0Mj1bXV0gQW4gYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3LCBtZXJnZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgX2NvbmNhdChbNCwgNSwgNl0sIFsxLCAyLCAzXSk7IC8vPT4gWzQsIDUsIDYsIDEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiBfY29uY2F0KHNldDEsIHNldDIpIHtcbiAgICAgICAgc2V0MSA9IHNldDEgfHwgW107XG4gICAgICAgIHNldDIgPSBzZXQyIHx8IFtdO1xuICAgICAgICB2YXIgaWR4O1xuICAgICAgICB2YXIgbGVuMSA9IHNldDEubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuMiA9IHNldDIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4xKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBzZXQxW2lkeF07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuMikge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MltpZHhdO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIF9jb250YWluc1dpdGggPSBmdW5jdGlvbiBfY29udGFpbnNXaXRoKHByZWQsIHgsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHByZWQoeCwgbGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIF9maWx0ZXIoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBfZm9yY2VSZWR1Y2VkID0gZnVuY3Rpb24gX2ZvcmNlUmVkdWNlZCh4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gU3RyaW5nKHggPT4geCkgZXZhbHVhdGVzIHRvIFwieCA9PiB4XCIsIHNvIHRoZSBwYXR0ZXJuIG1heSBub3QgbWF0Y2guXG4gICAgdmFyIF9mdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiBfZnVuY3Rpb25OYW1lKGYpIHtcbiAgICAgICAgLy8gU3RyaW5nKHggPT4geCkgZXZhbHVhdGVzIHRvIFwieCA9PiB4XCIsIHNvIHRoZSBwYXR0ZXJuIG1heSBub3QgbWF0Y2guXG4gICAgICAgIHZhciBtYXRjaCA9IFN0cmluZyhmKS5tYXRjaCgvXmZ1bmN0aW9uIChcXHcqKS8pO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/ICcnIDogbWF0Y2hbMV07XG4gICAgfTtcblxuICAgIHZhciBfaGFzID0gZnVuY3Rpb24gX2hhcyhwcm9wLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICAgIH07XG5cbiAgICB2YXIgX2lkZW50aXR5ID0gZnVuY3Rpb24gX2lkZW50aXR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcblxuICAgIHZhciBfaXNBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZ3VtZW50cykgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nID8gZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgICAgICAgfSA6IGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7XG4gICAgICAgICAgICByZXR1cm4gX2hhcygnY2FsbGVlJywgeCk7XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWxgIGlzIGFuIGFycmF5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBfaXNBcnJheShbXSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIF9pc0FycmF5KHt9KTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gX2lzQXJyYXkodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoID49IDAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIHZhciBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc051bWJlcih4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEBjYXRlZ29yeSBUeXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgX2lzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gX2lzSW50ZWdlcihuKSB7XG4gICAgICAgIHJldHVybiBuIDw8IDAgPT09IG47XG4gICAgfTtcblxuICAgIHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9O1xuXG4gICAgdmFyIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH07XG5cbiAgICB2YXIgX2lzUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiBfaXNQbGFjZWhvbGRlcihhKSB7XG4gICAgICAgIHJldHVybiBhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGFbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgX2lzUmVnRXhwID0gZnVuY3Rpb24gX2lzUmVnRXhwKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG4gICAgfTtcblxuICAgIHZhciBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9O1xuXG4gICAgdmFyIF9pc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24gX2lzVHJhbnNmb3JtZXIob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqWydAQHRyYW5zZHVjZXIvc3RlcCddID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIF9tYXAoZm4sIGZ1bmN0b3IpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBmdW5jdG9yLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbik7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gZm4oZnVuY3RvcltpZHhdKTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAgICB2YXIgX29iamVjdEFzc2lnbiA9IGZ1bmN0aW9uIF9vYmplY3RBc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICB2YXIgaWR4ID0gMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzKG5leHRLZXksIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIHZhciBfb2YgPSBmdW5jdGlvbiBfb2YoeCkge1xuICAgICAgICByZXR1cm4gW3hdO1xuICAgIH07XG5cbiAgICB2YXIgX3BpcGUgPSBmdW5jdGlvbiBfcGlwZShmLCBnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZy5jYWxsKHRoaXMsIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfcGlwZVAgPSBmdW5jdGlvbiBfcGlwZVAoZiwgZykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnLmNhbGwoY3R4LCB4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIHZhciBfcXVvdGUgPSBmdW5jdGlvbiBfcXVvdGUocykge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IHMucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9bXFxiXS9nLCAnXFxcXGInKSAgICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykucmVwbGFjZSgvXFx2L2csICdcXFxcdicpLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIic7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlZCA9IGZ1bmN0aW9uIF9yZWR1Y2VkKHgpIHtcbiAgICAgICAgcmV0dXJuIHggJiYgeFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IHggOiB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW1pemVkLCBwcml2YXRlIGFycmF5IGBzbGljZWAgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5fSBhcmdzIFRoZSBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0IHRvIGNvbnNpZGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbT0wXSBUaGUgYXJyYXkgaW5kZXggdG8gc2xpY2UgZnJvbSwgaW5jbHVzaXZlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdG89YXJncy5sZW5ndGhdIFRoZSBhcnJheSBpbmRleCB0byBzbGljZSB0bywgZXhjbHVzaXZlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldywgc2xpY2VkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIF9zbGljZShbMSwgMiwgMywgNCwgNV0sIDEsIDMpOyAvLz0+IFsyLCAzXVxuICAgICAqXG4gICAgICogICAgICB2YXIgZmlyc3RUaHJlZUFyZ3MgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgICogICAgICAgIHJldHVybiBfc2xpY2UoYXJndW1lbnRzLCAwLCAzKTtcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBmaXJzdFRocmVlQXJncygxLCAyLCAzLCA0KTsgLy89PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgX3NsaWNlID0gZnVuY3Rpb24gX3NsaWNlKGFyZ3MsIGZyb20sIHRvKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3NsaWNlKGFyZ3MsIDAsIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9zbGljZShhcmdzLCBmcm9tLCBhcmdzLmxlbmd0aCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYXJncy5sZW5ndGgsIHRvKSAtIGZyb20pO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGxpc3RbaWR4XSA9IGFyZ3NbZnJvbSArIGlkeF07XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nPi5cbiAgICAgKi9cbiAgICB2YXIgX3RvSVNPU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFkID0gZnVuY3Rpb24gcGFkKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAobiA8IDEwID8gJzAnIDogJycpICsgbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIF90b0lTT1N0cmluZyhkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC50b0lTT1N0cmluZygpO1xuICAgICAgICB9IDogZnVuY3Rpb24gX3RvSVNPU3RyaW5nKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgKyBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICsgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICsgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChkLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTAwMCkudG9GaXhlZCgzKS5zbGljZSgyLCA1KSArICdaJztcbiAgICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hmQmFzZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF94d3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWFdyYXAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMuZiA9IGZuO1xuICAgICAgICB9XG4gICAgICAgIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBub3QgaW1wbGVtZW50ZWQgb24gWFdyYXAnKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAoYWNjKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9O1xuICAgICAgICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mKGFjYywgeCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBfeHdyYXAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWFdyYXAoZm4pO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBfYXBlcnR1cmUgPSBmdW5jdGlvbiBfYXBlcnR1cmUobiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxpbWl0ID0gbGlzdC5sZW5ndGggLSAobiAtIDEpO1xuICAgICAgICB2YXIgYWNjID0gbmV3IEFycmF5KGxpbWl0ID49IDAgPyBsaW1pdCA6IDApO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGltaXQpIHtcbiAgICAgICAgICAgIGFjY1tpZHhdID0gX3NsaWNlKGxpc3QsIGlkeCwgaWR4ICsgbik7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH07XG5cbiAgICB2YXIgX2Fzc2lnbiA9IHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmFzc2lnbiA6IF9vYmplY3RBc3NpZ247XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGhhc01ldGhvZCwgdGhpcyBjaGVja3Mgd2hldGhlciBhIGZ1bmN0aW9uIGhhcyBhIFttZXRob2RuYW1lXVxuICAgICAqIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhbiBhcnJheSBpdCB3aWxsIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiBvdGhlcndpc2UgaXRcbiAgICAgKiB3aWxsIGRlZmF1bHQgdG8gdGhlIHJhbWRhIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiByYW1kYSBpbXBsZW10YXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kbmFtZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFdoYXRldmVyIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1ldGhvZCBpcy5cbiAgICAgKi9cbiAgICB2YXIgX2NoZWNrRm9yTWV0aG9kID0gZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gX2lzQXJyYXkob2JqKSB8fCB0eXBlb2Ygb2JqW21ldGhvZG5hbWVdICE9PSAnZnVuY3Rpb24nID8gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9ialttZXRob2RuYW1lXS5hcHBseShvYmosIF9zbGljZShhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIGludGVybmFsIG9uZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgX2N1cnJ5MSA9IGZ1bmN0aW9uIF9jdXJyeTEoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYxKGEpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IF9pc1BsYWNlaG9sZGVyKGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgX2N1cnJ5MiA9IGZ1bmN0aW9uIF9jdXJyeTIoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYyKGEsIGIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmMiA6IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBfYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IGYyIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oX2EsIGIpO1xuICAgICAgICAgICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkxKGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgX2IpO1xuICAgICAgICAgICAgICAgIH0pIDogZm4oYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBpbnRlcm5hbCB0aHJlZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgX2N1cnJ5MyA9IGZ1bmN0aW9uIF9jdXJyeTMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYzKGEsIGIsIGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBmMztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmMyA6IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihfYSwgYiwgX2MpO1xuICAgICAgICAgICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBfYyk7XG4gICAgICAgICAgICAgICAgfSkgOiBfY3VycnkxKGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgYiwgX2MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihfYSwgX2IsIGMpO1xuICAgICAgICAgICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uIChfYSwgX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgICAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBjKTtcbiAgICAgICAgICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBjKTtcbiAgICAgICAgICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIF9jKTtcbiAgICAgICAgICAgICAgICB9KSA6IGZuKGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjdXJyeU4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IG9mIHRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBfY3VycnlOID0gZnVuY3Rpb24gX2N1cnJ5TihsZW5ndGgsIHJlY2VpdmVkLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgICAgICAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCAmJiAoIV9pc1BsYWNlaG9sZGVyKHJlY2VpdmVkW2NvbWJpbmVkSWR4XSkgfHwgYXJnc0lkeCA+PSBhcmd1bWVudHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlZFtjb21iaW5lZElkeF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2FyZ3NJZHhdO1xuICAgICAgICAgICAgICAgICAgICBhcmdzSWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbWJpbmVkW2NvbWJpbmVkSWR4XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc1BsYWNlaG9sZGVyKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21iaW5lZElkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnQgPD0gMCA/IGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKSA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgd2l0aCBkaWZmZXJlbnQgc3RyYXRlZ2llcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvbiAobGFzdCBhcmd1bWVudCkuIElmIGl0IGlzIGFuIGFycmF5LCBleGVjdXRlcyBbZm5dLlxuICAgICAqIE90aGVyd2lzZSwgaWYgaXQgaGFzIGEgZnVuY3Rpb24gd2l0aCBbbWV0aG9kbmFtZV0sIGl0IHdpbGwgZXhlY3V0ZSB0aGF0XG4gICAgICogZnVuY3Rpb24gKGZ1bmN0b3IgY2FzZSkuIE90aGVyd2lzZSwgaWYgaXQgaXMgYSB0cmFuc2Zvcm1lciwgdXNlcyB0cmFuc2R1Y2VyXG4gICAgICogW3hmXSB0byByZXR1cm4gYSBuZXcgdHJhbnNmb3JtZXIgKHRyYW5zZHVjZXIgY2FzZSkuIE90aGVyd2lzZSwgaXQgd2lsbFxuICAgICAqIGRlZmF1bHQgdG8gZXhlY3V0aW5nIFtmbl0uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIHRyYW5zZHVjZXIgdG8gaW5pdGlhbGl6ZSBpZiBvYmplY3QgaXMgdHJhbnNmb3JtZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBkZWZhdWx0IHJhbWRhIGltcGxlbWVudGF0aW9uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gICAgICovXG4gICAgdmFyIF9kaXNwYXRjaGFibGUgPSBmdW5jdGlvbiBfZGlzcGF0Y2hhYmxlKG1ldGhvZG5hbWUsIHhmLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFfaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfc2xpY2UoYXJndW1lbnRzLCAwLCBsZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialttZXRob2RuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZG5hbWVdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2R1Y2VyID0geGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2R1Y2VyKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfZHJvcExhc3RXaGlsZSA9IGZ1bmN0aW9uIGRyb3BMYXN0V2hpbGUocHJlZCwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDAgJiYgcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QsIDAsIGlkeCArIDEpO1xuICAgIH07XG5cbiAgICB2YXIgX3hhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhBbGwoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgICAgICB0aGlzLmFsbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgWEFsbC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGFsbChmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYQWxsKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94YW55ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYQW55KGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICAgICAgdGhpcy5hbnkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEFueS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbnkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hhbnkoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEFueShmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGFwZXJ0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYQXBlcnR1cmUobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIH1cbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYQXBlcnR1cmUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbCA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmdldENvcHkoKSkgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIFhBcGVydHVyZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjW3RoaXMucG9zXSA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5hY2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZnVsbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFhBcGVydHVyZS5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29uY2F0KF9zbGljZSh0aGlzLmFjYywgdGhpcy5wb3MpLCBfc2xpY2UodGhpcy5hY2MsIDAsIHRoaXMucG9zKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94YXBlcnR1cmUobiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEFwZXJ0dXJlKG4sIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWERyb3AobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMubiA9IG47XG4gICAgICAgIH1cbiAgICAgICAgWERyb3AucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm4gLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcChuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRHJvcChuLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGRyb3BMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRHJvcExhc3QobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIH1cbiAgICAgICAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5hY2NbdGhpcy5wb3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmUoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgWERyb3BMYXN0LnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5hY2NbdGhpcy5wb3NdID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmFjYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdChuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRHJvcExhc3QobiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hkcm9wUmVwZWF0c1dpdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucHJlZCA9IHByZWQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2VlbkZpcnN0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBzYW1lQXNMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VlbkZpcnN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVkKHRoaXMubGFzdFZhbHVlLCBpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBzYW1lQXNMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gaW5wdXQ7XG4gICAgICAgICAgICByZXR1cm4gc2FtZUFzTGFzdCA/IHJlc3VsdCA6IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hkcm9wV2hpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhEcm9wV2hpbGUoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgICAgICAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wV2hpbGUoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWERyb3BXaGlsZShmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWEZpbHRlcihmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgfVxuICAgICAgICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmlsdGVyKGYsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhGaWx0ZXIoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hmaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmluZChmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kKGYsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhGaW5kKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZmluZEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmluZEluZGV4KGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICAgICAgdGhpcy5pZHggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEZpbmRJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaWR4ICs9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlkeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kSW5kZXgoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbmRJbmRleChmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGZpbmRMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmluZExhc3QoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgWEZpbmRMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEZpbmRMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5sYXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmluZExhc3QoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbmRMYXN0KGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZmluZExhc3RJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWEZpbmRMYXN0SW5kZXgoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgICAgICB0aGlzLmlkeCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5sYXN0SWR4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgWEZpbmRMYXN0SW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMubGFzdElkeCkpO1xuICAgICAgICB9O1xuICAgICAgICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5pZHggKz0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0SWR4ID0gdGhpcy5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRMYXN0SW5kZXgoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbmRMYXN0SW5kZXgoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3htYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhNYXAoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgICAgICAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmYoaW5wdXQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3htYXAoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1hcChmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeHRha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhUYWtlKG4sIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLm4gPSBuO1xuICAgICAgICB9XG4gICAgICAgIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgICAgICAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZWQocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94dGFrZShuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYVGFrZShuLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeHRha2VXaGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWFRha2VXaGlsZShmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgfVxuICAgICAgICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWFRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiBfcmVkdWNlZChyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeHRha2VXaGlsZShmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYVGFrZVdoaWxlKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBzZWUgUi5zdWJ0cmFjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuYWRkKDIsIDMpOyAgICAgICAvLz0+ICA1XG4gICAgICogICAgICBSLmFkZCg3KSgxMCk7ICAgICAgLy89PiAxN1xuICAgICAqL1xuICAgIHZhciBhZGQgPSBfY3VycnkyKGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoYSkgKyBOdW1iZXIoYik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCBvZiBhbiBhcnJheSwgcmV0dXJuaW5nIGFcbiAgICAgKiBuZXcgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggcmVwbGFjZWQgd2l0aCB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IGEpIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBsaXN0IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHdob3NlIHZhbHVlXG4gICAgICogICAgICAgIGF0IHRoZSBzdXBwbGllZCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgdGhlIHN1cHBsaWVkIGFycmF5LWxpa2Ugb2JqZWN0IHdpdGhcbiAgICAgKiAgICAgICAgIHRoZSBlbGVtZW50IGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlXG4gICAgICogICAgICAgICByZXR1cm5lZCBieSBhcHBseWluZyBgZm5gIHRvIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgICAqIEBzZWUgUi51cGRhdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFkanVzdChSLmFkZCgxMCksIDEsIFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAgICAgKiAgICAgIFIuYWRqdXN0KFIuYWRkKDEwKSkoMSkoWzAsIDEsIDJdKTsgICAgIC8vPT4gWzAsIDExLCAyXVxuICAgICAqL1xuICAgIHZhciBhZGp1c3QgPSBfY3VycnkzKGZ1bmN0aW9uIGFkanVzdChmbiwgaWR4LCBsaXN0KSB7XG4gICAgICAgIGlmIChpZHggPj0gbGlzdC5sZW5ndGggfHwgaWR4IDwgLWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBpZHggPCAwID8gbGlzdC5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgX2lkeCA9IHN0YXJ0ICsgaWR4O1xuICAgICAgICB2YXIgX2xpc3QgPSBfY29uY2F0KGxpc3QpO1xuICAgICAgICBfbGlzdFtfaWR4XSA9IGZuKGxpc3RbX2lkeF0pO1xuICAgICAgICByZXR1cm4gX2xpc3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYCBpZlxuICAgICAqIHRoZXJlIGFyZSBhbnkgdGhhdCBkb24ndC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbGxgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCBieSBldmVyeSBlbGVtZW50LCBgZmFsc2VgXG4gICAgICogICAgICAgICBvdGhlcndpc2UuXG4gICAgICogQHNlZSBSLmFueSwgUi5ub25lLCBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBsZXNzVGhhbjIgPSBSLmZsaXAoUi5sdCkoMik7XG4gICAgICogICAgICB2YXIgbGVzc1RoYW4zID0gUi5mbGlwKFIubHQpKDMpO1xuICAgICAqICAgICAgUi5hbGwobGVzc1RoYW4yKShbMSwgMl0pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmFsbChsZXNzVGhhbjMpKFsxLCAyXSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBhbGwgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2FsbCcsIF94YWxsLCBmdW5jdGlvbiBhbGwoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIGdpdmVuIHZhbHVlLiBOb3RlIHRoYXQgZm9yXG4gICAgICogbm9uLXByaW1pdGl2ZXMgdGhlIHZhbHVlIHJldHVybmVkIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMga25vd24gYXMgYGNvbnN0YCwgYGNvbnN0YW50YCwgb3IgYEtgIChmb3IgSyBjb21iaW5hdG9yKSBpblxuICAgICAqIG90aGVyIGxhbmd1YWdlcyBhbmQgbGlicmFyaWVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIGEgLT4gKCogLT4gYSlcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgRnVuY3Rpb24gOjogKiAtPiB2YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHQgPSBSLmFsd2F5cygnVGVlJyk7XG4gICAgICogICAgICB0KCk7IC8vPT4gJ1RlZSdcbiAgICAgKi9cbiAgICB2YXIgYWx3YXlzID0gX2N1cnJ5MShmdW5jdGlvbiBhbHdheXModmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBhcmd1bWVudHMgYXJlIGB0cnVlYDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKiAtPiAqIC0+ICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGEgQSBib29sZWFuIHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBiIEEgYm9vbGVhbiB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBib3RoIGFyZ3VtZW50cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgICAqIEBzZWUgUi5ib3RoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hbmQodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5hbmQodHJ1ZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmFuZChmYWxzZSwgdHJ1ZSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuYW5kKGZhbHNlLCBmYWxzZSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgYW5kID0gX2N1cnJ5MihmdW5jdGlvbiBhbmQoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAmJiBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIG9mIGVsZW1lbnRzIG9mIHRoZSBsaXN0IG1hdGNoIHRoZSBwcmVkaWNhdGUsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgYW55YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQgYnkgYXQgbGVhc3Qgb25lIGVsZW1lbnQsIGBmYWxzZWBcbiAgICAgKiAgICAgICAgIG90aGVyd2lzZS5cbiAgICAgKiBAc2VlIFIuYWxsLCBSLm5vbmUsIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGxlc3NUaGFuMCA9IFIuZmxpcChSLmx0KSgwKTtcbiAgICAgKiAgICAgIHZhciBsZXNzVGhhbjIgPSBSLmZsaXAoUi5sdCkoMik7XG4gICAgICogICAgICBSLmFueShsZXNzVGhhbjApKFsxLCAyXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuYW55KGxlc3NUaGFuMikoWzEsIDJdKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGFueSA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnYW55JywgX3hhbnksIGZ1bmN0aW9uIGFueShmbiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCwgY29tcG9zZWQgb2Ygbi10dXBsZXMgb2YgY29uc2VjdXRpdmUgZWxlbWVudHMgSWYgYG5gIGlzXG4gICAgICogZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGxpc3QsIGFuIGVtcHR5IGxpc3QgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgYXBlcnR1cmVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW1thXV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgdHVwbGVzIHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc3BsaXQgaW50byBgbmAtdHVwbGVzXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hcGVydHVyZSgyLCBbMSwgMiwgMywgNCwgNV0pOyAvLz0+IFtbMSwgMl0sIFsyLCAzXSwgWzMsIDRdLCBbNCwgNV1dXG4gICAgICogICAgICBSLmFwZXJ0dXJlKDMsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW1sxLCAyLCAzXSwgWzIsIDMsIDRdLCBbMywgNCwgNV1dXG4gICAgICogICAgICBSLmFwZXJ0dXJlKDcsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW11cbiAgICAgKi9cbiAgICB2YXIgYXBlcnR1cmUgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2FwZXJ0dXJlJywgX3hhcGVydHVyZSwgX2FwZXJ0dXJlKSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgY29udGVudHMgb2YgdGhlIGdpdmVuIGxpc3QsIGZvbGxvd2VkIGJ5XG4gICAgICogdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IGVsIFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBuZXcgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHdob3NlIGNvbnRlbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgb3V0cHV0XG4gICAgICogICAgICAgIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgY29udGVudHMgb2YgdGhlIG9sZCBsaXN0IGZvbGxvd2VkIGJ5IGBlbGAuXG4gICAgICogQHNlZSBSLnByZXBlbmRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFwcGVuZCgndGVzdHMnLCBbJ3dyaXRlJywgJ21vcmUnXSk7IC8vPT4gWyd3cml0ZScsICdtb3JlJywgJ3Rlc3RzJ11cbiAgICAgKiAgICAgIFIuYXBwZW5kKCd0ZXN0cycsIFtdKTsgLy89PiBbJ3Rlc3RzJ11cbiAgICAgKiAgICAgIFIuYXBwZW5kKFsndGVzdHMnXSwgWyd3cml0ZScsICdtb3JlJ10pOyAvLz0+IFsnd3JpdGUnLCAnbW9yZScsIFsndGVzdHMnXV1cbiAgICAgKi9cbiAgICB2YXIgYXBwZW5kID0gX2N1cnJ5MihmdW5jdGlvbiBhcHBlbmQoZWwsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9jb25jYXQobGlzdCwgW2VsXSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZ1bmN0aW9uIGBmbmAgdG8gdGhlIGFyZ3VtZW50IGxpc3QgYGFyZ3NgLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiBjcmVhdGluZyBhIGZpeGVkLWFyaXR5IGZ1bmN0aW9uIGZyb20gYSB2YXJpYWRpYyBmdW5jdGlvbi4gYGZuYCBzaG91bGQgYmUgYVxuICAgICAqIGJvdW5kIGZ1bmN0aW9uIGlmIGNvbnRleHQgaXMgc2lnbmlmaWNhbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCouLi4gLT4gYSkgLT4gWypdIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5jYWxsLCBSLnVuYXBwbHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbnVtcyA9IFsxLCAyLCAzLCAtOTksIDQyLCA2LCA3XTtcbiAgICAgKiAgICAgIFIuYXBwbHkoTWF0aC5tYXgsIG51bXMpOyAvLz0+IDQyXG4gICAgICovXG4gICAgdmFyIGFwcGx5ID0gX2N1cnJ5MihmdW5jdGlvbiBhcHBseShmbiwgYXJncykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIHNwZWNpZmllZFxuICAgICAqIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIHZhbHVlLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZVxuICAgICAqIHByb3BlcnRpZXMgb250byB0aGUgbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIGNvcGllZCBieSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBhIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCB0aGUgcHJvcGVydHkgbmFtZSB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbCB0aGUgbmV3IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIGNsb25lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3Qgc2ltaWxhciB0byB0aGUgb3JpZ2luYWwgZXhjZXB0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICAgICAqIEBzZWUgUi5kaXNzb2NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFzc29jKCdjJywgMywge2E6IDEsIGI6IDJ9KTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAgICAgKi9cbiAgICB2YXIgYXNzb2MgPSBfY3VycnkzKGZ1bmN0aW9uIGFzc29jKHByb3AsIHZhbCwgb2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIG5vZGVzIHJlcXVpcmVkXG4gICAgICogdG8gY3JlYXRlIHRoZSBnaXZlbiBwYXRoLCBhbmQgcGxhY2luZyB0aGUgc3BlY2lmaWMgdmFsdWUgYXQgdGhlIHRhaWwgZW5kIG9mXG4gICAgICogdGhhdCBwYXRoLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9udG8gdGhlXG4gICAgICogbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBbU3RyaW5nXSAtPiBhIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIHRoZSBwYXRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsIHRoZSBuZXcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCBzaW1pbGFyIHRvIHRoZSBvcmlnaW5hbCBleGNlcHQgYWxvbmcgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqIEBzZWUgUi5kaXNzb2NQYXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCA0Miwge2E6IHtiOiB7YzogMH19fSk7IC8vPT4ge2E6IHtiOiB7YzogNDJ9fX1cbiAgICAgKi9cbiAgICB2YXIgYXNzb2NQYXRoID0gX2N1cnJ5MyhmdW5jdGlvbiBhc3NvY1BhdGgocGF0aCwgdmFsLCBvYmopIHtcbiAgICAgICAgc3dpdGNoIChwYXRoLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYXNzb2MocGF0aFswXSwgdmFsLCBvYmopO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGFzc29jKHBhdGhbMF0sIGFzc29jUGF0aChfc2xpY2UocGF0aCwgMSksIHZhbCwgT2JqZWN0KG9ialtwYXRoWzBdXSkpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBib3VuZCB0byBhIGNvbnRleHQuXG4gICAgICogTm90ZTogYFIuYmluZGAgZG9lcyBub3QgcHJvdmlkZSB0aGUgYWRkaXRpb25hbCBhcmd1bWVudC1iaW5kaW5nIGNhcGFiaWxpdGllcyBvZlxuICAgICAqIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnICgqIC0+ICopIC0+IHsqfSAtPiAoKiAtPiAqKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc09iaiBUaGUgY29udGV4dCB0byBiaW5kIGBmbmAgdG9cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiBgdGhpc09iamAuXG4gICAgICogQHNlZSBSLnBhcnRpYWxcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IF9jdXJyeTIoZnVuY3Rpb24gYmluZChmbiwgdGhpc09iaikge1xuICAgICAgICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNPYmosIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVzdHJpY3RzIGEgbnVtYmVyIHRvIGJlIHdpdGhpbiBhIHJhbmdlLlxuICAgICAqXG4gICAgICogQWxzbyB3b3JrcyBmb3Igb3RoZXIgb3JkZXJlZCB0eXBlcyBzdWNoIGFzIFN0cmluZ3MgYW5kIERhdGVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yMC4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYSAtPiBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbmltdW0gbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW0gbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgdmFsdWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmNsYW1wKDEsIDEwLCAtMSkgLy8gPT4gMVxuICAgICAqICAgICAgUi5jbGFtcCgxLCAxMCwgMTEpIC8vID0+IDEwXG4gICAgICogICAgICBSLmNsYW1wKDEsIDEwLCA0KSAgLy8gPT4gNFxuICAgICAqL1xuICAgIHZhciBjbGFtcCA9IF9jdXJyeTMoZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWluIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggaW4gY2xhbXAobWluLCBtYXgsIHZhbHVlKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXBvcnRzIHdoZXRoZXIgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoYSwgYiAtPiBCb29sZWFuKSAtPiAoYSwgYiAtPiBOdW1iZXIpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvbiBvZiBhcml0eSB0d28uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgRnVuY3Rpb24gOjogYSAtPiBiIC0+IEludCB0aGF0IHJldHVybnMgYC0xYCBpZiBhIDwgYiwgYDFgIGlmIGIgPCBhLCBvdGhlcndpc2UgYDBgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjbXAgPSBSLmNvbXBhcmF0b3IoKGEsIGIpID0+IGEuYWdlIDwgYi5hZ2UpO1xuICAgICAqICAgICAgdmFyIHBlb3BsZSA9IFtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICBdO1xuICAgICAqICAgICAgUi5zb3J0KGNtcCwgcGVvcGxlKTtcbiAgICAgKi9cbiAgICB2YXIgY29tcGFyYXRvciA9IF9jdXJyeTEoZnVuY3Rpb24gY29tcGFyYXRvcihwcmVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHByZWQoYSwgYikgPyAtMSA6IHByZWQoYiwgYSkgPyAxIDogMDtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBhcml0eS4gVGhlIGN1cnJpZWQgZnVuY3Rpb24gaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0c1xuICAgICAqIGFyZ3VtZW50cyBuZWVkbid0IGJlIHByb3ZpZGVkIG9uZSBhdCBhIHRpbWUuIElmIGBnYCBpcyBgUi5jdXJyeU4oMywgZilgLCB0aGVcbiAgICAgKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gICAgICpcbiAgICAgKiAgIC0gYGcoMSkoMikoMylgXG4gICAgICogICAtIGBnKDEpKDIsIDMpYFxuICAgICAqICAgLSBgZygxLCAyKSgzKWBcbiAgICAgKiAgIC0gYGcoMSwgMiwgMylgXG4gICAgICpcbiAgICAgKiBTZWNvbmRseSwgdGhlIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUgYFIuX19gIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAgICAgKiBcImdhcHNcIiwgYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLFxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBgUi5fX2AsIHRoZVxuICAgICAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAgICAgKlxuICAgICAqICAgLSBgZygxLCAyLCAzKWBcbiAgICAgKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gICAgICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICAgICAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSkoMylgXG4gICAgICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcsIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHNlZSBSLmN1cnJ5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHN1bUFyZ3MgPSAoLi4uYXJncykgPT4gUi5zdW0oYXJncyk7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5Tig0LCBzdW1BcmdzKTtcbiAgICAgKiAgICAgIHZhciBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICAgICAqICAgICAgdmFyIGcgPSBmKDMpO1xuICAgICAqICAgICAgZyg0KTsgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciBjdXJyeU4gPSBfY3VycnkyKGZ1bmN0aW9uIGN1cnJ5TihsZW5ndGgsIGZuKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3VycnkxKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FyaXR5KGxlbmd0aCwgX2N1cnJ5TihsZW5ndGgsIFtdLCBmbikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGVjcmVtZW50cyBpdHMgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQHNlZSBSLmluY1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZGVjKDQyKTsgLy89PiA0MVxuICAgICAqL1xuICAgIHZhciBkZWMgPSBhZGQoLTEpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Vjb25kIGFyZ3VtZW50IGlmIGl0IGlzIG5vdCBgbnVsbGAsIGB1bmRlZmluZWRgIG9yIGBOYU5gXG4gICAgICogb3RoZXJ3aXNlIHRoZSBmaXJzdCBhcmd1bWVudCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgYSAtPiBiIC0+IGEgfCBiXG4gICAgICogQHBhcmFtIHthfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtifSB2YWwgVGhlIHZhbHVlIHRvIHJldHVybiBpZiBpdCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdGhlIHNlY29uZCB2YWx1ZSBvciB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBkZWZhdWx0VG80MiA9IFIuZGVmYXVsdFRvKDQyKTtcbiAgICAgKlxuICAgICAqICAgICAgZGVmYXVsdFRvNDIobnVsbCk7ICAvLz0+IDQyXG4gICAgICogICAgICBkZWZhdWx0VG80Mih1bmRlZmluZWQpOyAgLy89PiA0MlxuICAgICAqICAgICAgZGVmYXVsdFRvNDIoJ1JhbWRhJyk7ICAvLz0+ICdSYW1kYSdcbiAgICAgKiAgICAgIGRlZmF1bHRUbzQyKHBhcnNlSW50KCdzdHJpbmcnKSk7IC8vPT4gNDJcbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdFRvID0gX2N1cnJ5MihmdW5jdGlvbiBkZWZhdWx0VG8oZCwgdikge1xuICAgICAgICByZXR1cm4gdiA9PSBudWxsIHx8IHYgIT09IHYgPyBkIDogdjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBmaXJzdCBsaXN0IG5vdFxuICAgICAqIGNvbnRhaW5lZCBpbiB0aGUgc2Vjb25kIGxpc3QuIER1cGxpY2F0aW9uIGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgKGEgLT4gYSAtPiBCb29sZWFuKSAtPiBbKl0gLT4gWypdIC0+IFsqXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIHRoYXQgYXJlIG5vdCBpbiBgbGlzdDJgLlxuICAgICAqIEBzZWUgUi5kaWZmZXJlbmNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGNtcCA9ICh4LCB5KSA9PiB4LmEgPT09IHkuYTtcbiAgICAgKiAgICAgIHZhciBsMSA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAgICAgKiAgICAgIHZhciBsMiA9IFt7YTogM30sIHthOiA0fV07XG4gICAgICogICAgICBSLmRpZmZlcmVuY2VXaXRoKGNtcCwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gX2N1cnJ5MyhmdW5jdGlvbiBkaWZmZXJlbmNlV2l0aChwcmVkLCBmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBmaXJzdExlbiA9IGZpcnN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGZpcnN0TGVuKSB7XG4gICAgICAgICAgICBpZiAoIV9jb250YWluc1dpdGgocHJlZCwgZmlyc3RbaWR4XSwgc2Vjb25kKSAmJiAhX2NvbnRhaW5zV2l0aChwcmVkLCBmaXJzdFtpZHhdLCBvdXQpKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goZmlyc3RbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgYHByb3BgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgU3RyaW5nIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZGlzc29jaWF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHNpbWlsYXIgdG8gdGhlIG9yaWdpbmFsIGJ1dCB3aXRob3V0IHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgICAgKiBAc2VlIFIuYXNzb2NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRpc3NvYygnYicsIHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4ge2E6IDEsIGM6IDN9XG4gICAgICovXG4gICAgdmFyIGRpc3NvYyA9IF9jdXJyeTIoZnVuY3Rpb24gZGlzc29jKHByb3AsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAocCAhPT0gcHJvcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdCwgb21pdHRpbmcgdGhlIHByb3BlcnR5IGF0IHRoZSBnaXZlbiBwYXRoLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGNvcGllcyBhbmQgZmxhdHRlbnMgcHJvdG90eXBlIHByb3BlcnRpZXMgb250byB0aGUgbmV3IG9iamVjdFxuICAgICAqIGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBbU3RyaW5nXSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCB0aGUgcGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCB3aXRob3V0IHRoZSBwcm9wZXJ0eSBhdCBwYXRoXG4gICAgICogQHNlZSBSLmFzc29jUGF0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZGlzc29jUGF0aChbJ2EnLCAnYicsICdjJ10sIHthOiB7Yjoge2M6IDQyfX19KTsgLy89PiB7YToge2I6IHt9fX1cbiAgICAgKi9cbiAgICB2YXIgZGlzc29jUGF0aCA9IF9jdXJyeTIoZnVuY3Rpb24gZGlzc29jUGF0aChwYXRoLCBvYmopIHtcbiAgICAgICAgc3dpdGNoIChwYXRoLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZGlzc29jKHBhdGhbMF0sIG9iaik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHBhdGhbMF07XG4gICAgICAgICAgICB2YXIgdGFpbCA9IF9zbGljZShwYXRoLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBvYmpbaGVhZF0gPT0gbnVsbCA/IG9iaiA6IGFzc29jKGhlYWQsIGRpc3NvY1BhdGgodGFpbCwgb2JqW2hlYWRdKSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAvIGJgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgLyBiYC5cbiAgICAgKiBAc2VlIFIubXVsdGlwbHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRpdmlkZSg3MSwgMTAwKTsgLy89PiAwLjcxXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBoYWxmID0gUi5kaXZpZGUoUi5fXywgMik7XG4gICAgICogICAgICBoYWxmKDQyKTsgLy89PiAyMVxuICAgICAqXG4gICAgICogICAgICB2YXIgcmVjaXByb2NhbCA9IFIuZGl2aWRlKDEpO1xuICAgICAqICAgICAgcmVjaXByb2NhbCg0KTsgICAvLz0+IDAuMjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gX2N1cnJ5MihmdW5jdGlvbiBkaXZpZGUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0LCBwYXNzaW5nXG4gICAgICogZWFjaCB2YWx1ZSB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBza2lwcGluZyBlbGVtZW50cyB3aGlsZSB0aGVcbiAgICAgKiBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZVxuICAgICAqIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgZHJvcFdoaWxlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi50YWtlV2hpbGUsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGx0ZVR3byA9IHggPT4geCA8PSAyO1xuICAgICAqXG4gICAgICogICAgICBSLmRyb3BXaGlsZShsdGVUd28sIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzMsIDQsIDMsIDIsIDFdXG4gICAgICovXG4gICAgdmFyIGRyb3BXaGlsZSA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnZHJvcFdoaWxlJywgX3hkcm9wV2hpbGUsIGZ1bmN0aW9uIGRyb3BXaGlsZShwcmVkLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4gJiYgcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QsIGlkeCk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW1wdHkgdmFsdWUgb2YgaXRzIGFyZ3VtZW50J3MgdHlwZS4gUmFtZGEgZGVmaW5lcyB0aGUgZW1wdHlcbiAgICAgKiB2YWx1ZSBvZiBBcnJheSAoYFtdYCksIE9iamVjdCAoYHt9YCksIFN0cmluZyAoYCcnYCksIGFuZCBBcmd1bWVudHMuIE90aGVyXG4gICAgICogdHlwZXMgYXJlIHN1cHBvcnRlZCBpZiB0aGV5IGRlZmluZSBgPFR5cGU+LmVtcHR5YCBhbmQvb3JcbiAgICAgKiBgPFR5cGU+LnByb3RvdHlwZS5lbXB0eWAuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgZW1wdHlgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgYSAtPiBhXG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmVtcHR5KEp1c3QoNDIpKTsgICAgICAvLz0+IE5vdGhpbmcoKVxuICAgICAqICAgICAgUi5lbXB0eShbMSwgMiwgM10pOyAgICAgLy89PiBbXVxuICAgICAqICAgICAgUi5lbXB0eSgndW5pY29ybnMnKTsgICAgLy89PiAnJ1xuICAgICAqICAgICAgUi5lbXB0eSh7eDogMSwgeTogMn0pOyAgLy89PiB7fVxuICAgICAqL1xuICAgIC8vIGVsc2VcbiAgICB2YXIgZW1wdHkgPSBfY3VycnkxKGZ1bmN0aW9uIGVtcHR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeC5lbXB0eSA9PT0gJ2Z1bmN0aW9uJyA/IHguZW1wdHkoKSA6IHggIT0gbnVsbCAmJiB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiYgdHlwZW9mIHguY29uc3RydWN0b3IuZW1wdHkgPT09ICdmdW5jdGlvbicgPyB4LmNvbnN0cnVjdG9yLmVtcHR5KCkgOiBfaXNBcnJheSh4KSA/IFtdIDogX2lzU3RyaW5nKHgpID8gJycgOiBfaXNPYmplY3QoeCkgPyB7fSA6IF9pc0FyZ3VtZW50cyh4KSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHM7XG4gICAgICAgIH0oKSA6IC8vIGVsc2VcbiAgICAgICAgdm9pZCAwO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgYnkgcmVjdXJzaXZlbHkgZXZvbHZpbmcgYSBzaGFsbG93IGNvcHkgb2YgYG9iamVjdGAsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9ucy4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllc1xuICAgICAqIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgaXRzIGNvcnJlc3BvbmRpbmcga2V5XG4gICAgICogZG9lcyBub3QgZXhpc3QgaW4gdGhlIGV2b2x2ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7azogKHYgLT4gdil9IC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtYXRpb25zIFRoZSBvYmplY3Qgc3BlY2lmeWluZyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYXBwbHlcbiAgICAgKiAgICAgICAgdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJhbnNmb3JtZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0b21hdG8gID0ge2ZpcnN0TmFtZTogJyAgVG9tYXRvICcsIGRhdGE6IHtlbGFwc2VkOiAxMDAsIHJlbWFpbmluZzogMTQwMH0sIGlkOjEyM307XG4gICAgICogICAgICB2YXIgdHJhbnNmb3JtYXRpb25zID0ge1xuICAgICAqICAgICAgICBmaXJzdE5hbWU6IFIudHJpbSxcbiAgICAgKiAgICAgICAgbGFzdE5hbWU6IFIudHJpbSwgLy8gV2lsbCBub3QgZ2V0IGludm9rZWQuXG4gICAgICogICAgICAgIGRhdGE6IHtlbGFwc2VkOiBSLmFkZCgxKSwgcmVtYWluaW5nOiBSLmFkZCgtMSl9XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgUi5ldm9sdmUodHJhbnNmb3JtYXRpb25zLCB0b21hdG8pOyAvLz0+IHtmaXJzdE5hbWU6ICdUb21hdG8nLCBkYXRhOiB7ZWxhcHNlZDogMTAxLCByZW1haW5pbmc6IDEzOTl9LCBpZDoxMjN9XG4gICAgICovXG4gICAgdmFyIGV2b2x2ZSA9IF9jdXJyeTIoZnVuY3Rpb24gZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgb2JqZWN0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uLCBrZXksIHR5cGU7XG4gICAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbnNba2V5XTtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlb2YgdHJhbnNmb3JtYXRpb247XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGUgPT09ICdmdW5jdGlvbicgPyB0cmFuc2Zvcm1hdGlvbihvYmplY3Rba2V5XSkgOiB0eXBlID09PSAnb2JqZWN0JyA/IGV2b2x2ZSh0cmFuc2Zvcm1hdGlvbnNba2V5XSwgb2JqZWN0W2tleV0pIDogb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvclxuICAgICAqIGB1bmRlZmluZWRgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaW5kYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBhIHwgdW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAgICAgKiAgICAgICAgZGVzaXJlZCBvbmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4cyA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAgICAgKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDIpKSh4cyk7IC8vPT4ge2E6IDJ9XG4gICAgICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHZhciBmaW5kID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaW5kJywgX3hmaW5kLCBmdW5jdGlvbiBmaW5kKGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGVcbiAgICAgKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRJbmRleGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMVxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAgICAgKiBkZXNpcmVkIG9uZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBmb3VuZCwgb3IgYC0xYC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhzID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICAgICAqICAgICAgUi5maW5kSW5kZXgoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IDFcbiAgICAgKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBmaW5kSW5kZXggPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2ZpbmRJbmRleCcsIF94ZmluZEluZGV4LCBmdW5jdGlvbiBmaW5kSW5kZXgoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yXG4gICAgICogYHVuZGVmaW5lZGAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRMYXN0YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBhIHwgdW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAgICAgKiBkZXNpcmVkIG9uZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBlbGVtZW50IGZvdW5kLCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhzID0gW3thOiAxLCBiOiAwfSwge2E6MSwgYjogMX1dO1xuICAgICAqICAgICAgUi5maW5kTGFzdChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4ge2E6IDEsIGI6IDF9XG4gICAgICogICAgICBSLmZpbmRMYXN0KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2ZpbmRMYXN0JywgX3hmaW5kTGFzdCwgZnVuY3Rpb24gZmluZExhc3QoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGVcbiAgICAgKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRMYXN0SW5kZXhgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gICAgICogZGVzaXJlZCBvbmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZm91bmQsIG9yIGAtMWAuXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4cyA9IFt7YTogMSwgYjogMH0sIHthOjEsIGI6IDF9XTtcbiAgICAgKiAgICAgIFIuZmluZExhc3RJbmRleChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4gMVxuICAgICAqICAgICAgUi5maW5kTGFzdEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEluZGV4ID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaW5kTGFzdEluZGV4JywgX3hmaW5kTGFzdEluZGV4LCBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpZHggPj0gMCkge1xuICAgICAgICAgICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgb3ZlciBhbiBpbnB1dCBgbGlzdGAsIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBgZm5gIGZvciBlYWNoXG4gICAgICogZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIGBmbmAgcmVjZWl2ZXMgb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBOb3RlOiBgUi5mb3JFYWNoYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAgICAgKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZC4gRm9yIG1vcmVcbiAgICAgKiBkZXRhaWxzIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoI0Rlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBBbHNvIG5vdGUgdGhhdCwgdW5saWtlIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAsIFJhbWRhJ3MgYGZvckVhY2hgIHJldHVybnNcbiAgICAgKiB0aGUgb3JpZ2luYWwgYXJyYXkuIEluIHNvbWUgbGlicmFyaWVzIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGVhY2hgLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZvckVhY2hgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gKikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuIFJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9yaWdpbmFsIGxpc3QuXG4gICAgICogQHNlZSBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHByaW50WFBsdXNGaXZlID0geCA9PiBjb25zb2xlLmxvZyh4ICsgNSk7XG4gICAgICogICAgICBSLmZvckVhY2gocHJpbnRYUGx1c0ZpdmUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICogICAgICAvLy0+IDZcbiAgICAgKiAgICAgIC8vLT4gN1xuICAgICAqICAgICAgLy8tPiA4XG4gICAgICovXG4gICAgdmFyIGZvckVhY2ggPSBfY3VycnkyKF9jaGVja0Zvck1ldGhvZCgnZm9yRWFjaCcsIGZ1bmN0aW9uIGZvckVhY2goZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgZm4obGlzdFtpZHhdKTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IG91dCBvZiBhIGxpc3Qga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW1trLHZdXSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiB0d28tZWxlbWVudCBhcnJheXMgdGhhdCB3aWxsIGJlIHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgb2JqZWN0IG1hZGUgYnkgcGFpcmluZyB1cCBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICAgICAqIEBzZWUgUi50b1BhaXJzLCBSLnBhaXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdLCAgWydjJywgM11dKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAgICAgKi9cbiAgICB2YXIgZnJvbVBhaXJzID0gX2N1cnJ5MShmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBwYWlycy5sZW5ndGg7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKF9pc0FycmF5KHBhaXJzW2lkeF0pICYmIHBhaXJzW2lkeF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0W3BhaXJzW2lkeF1bMF1dID0gcGFpcnNbaWR4XVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGxpc3QgYW5kIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzIHdoZXJlIGVhY2ggc3VibGlzdCdzIGVsZW1lbnRzIGFyZVxuICAgICAqIGFsbCBcImVxdWFsXCIgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBlcXVhbGl0eSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSwgYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW1thXV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gZ2l2ZW4gKGFkamFjZW50KVxuICAgICAqICAgICAgICBlbGVtZW50cyBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBncm91cC4gQWxzbyBhY2NlcHRzIGEgc3RyaW5nLCB3aGljaCB3aWxsIGJlXG4gICAgICogICAgICAgIHRyZWF0ZWQgYXMgYSBsaXN0IG9mIGNoYXJhY3RlcnMuXG4gICAgICogQHJldHVybiB7TGlzdH0gQSBsaXN0IHRoYXQgY29udGFpbnMgc3VibGlzdHMgb2YgZXF1YWwgZWxlbWVudHMsXG4gICAgICogICAgICAgICB3aG9zZSBjb25jYXRlbmF0aW9ucyBpcyBlcXVhbCB0byB0aGUgb3JpZ2luYWwgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgZ3JvdXBXaXRoKFIuZXF1YWxzLCBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxXSlcbiAgICAgKiAgICAvLyBbWzBdLCBbMSwgMV0sIFsyLCAzLCA1LCA4LCAxMywgMjFdXVxuICAgICAqXG4gICAgICogICAgZ3JvdXBXaXRoKChhLCBiKSA9PiBhICUgMiA9PT0gYiAlIDIsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICAgICAqICAgIC8vIFtbMF0sIFsxLCAxXSwgWzJdLCBbMywgNV0sIFs4XSwgWzEzLCAyMV1dXG4gICAgICpcbiAgICAgKiAgICBSLmdyb3VwV2l0aChSLmVxQnkoaXNWb3dlbCksICdhZXN0aW91JylcbiAgICAgKiAgICAvLyBbJ2FlJywgJ3N0JywgJ2lvdSddXG4gICAgICovXG4gICAgdmFyIGdyb3VwV2l0aCA9IF9jdXJyeTIoZnVuY3Rpb24gKGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgdmFyIG5leHRpZHggPSBpZHggKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5leHRpZHggPCBsZW4gJiYgZm4obGlzdFtpZHhdLCBsaXN0W25leHRpZHhdKSkge1xuICAgICAgICAgICAgICAgIG5leHRpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKGxpc3Quc2xpY2UoaWR4LCBuZXh0aWR4KSk7XG4gICAgICAgICAgICBpZHggPSBuZXh0aWR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQ7IGBmYWxzZWBcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZ3QoMiwgMSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5ndCgyLCAyKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ndCgyLCAzKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ndCgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZ3QoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBfY3VycnkyKGZ1bmN0aW9uIGd0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDMpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmd0ZSgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZ3RlKCd6JywgJ2EnKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IF9jdXJyeTIoZnVuY3Rpb24gZ3RlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPj0gYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgcyAtPiB7czogeH0gLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaGFzTmFtZSA9IFIuaGFzKCduYW1lJyk7XG4gICAgICogICAgICBoYXNOYW1lKHtuYW1lOiAnYWxpY2UnfSk7ICAgLy89PiB0cnVlXG4gICAgICogICAgICBoYXNOYW1lKHtuYW1lOiAnYm9iJ30pOyAgICAgLy89PiB0cnVlXG4gICAgICogICAgICBoYXNOYW1lKHt9KTsgICAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcG9pbnQgPSB7eDogMCwgeTogMH07XG4gICAgICogICAgICB2YXIgcG9pbnRIYXMgPSBSLmhhcyhSLl9fLCBwb2ludCk7XG4gICAgICogICAgICBwb2ludEhhcygneCcpOyAgLy89PiB0cnVlXG4gICAgICogICAgICBwb2ludEhhcygneScpOyAgLy89PiB0cnVlXG4gICAgICogICAgICBwb2ludEhhcygneicpOyAgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBoYXMgPSBfY3VycnkyKF9oYXMpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgYSBwcm9wZXJ0eSB3aXRoXG4gICAgICogdGhlIHNwZWNpZmllZCBuYW1lXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHMgLT4ge3M6IHh9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgZnVuY3Rpb24gUmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgKiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAqICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgICAqICAgICAgfTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNxdWFyZSA9IG5ldyBSZWN0YW5nbGUoMiwgMik7XG4gICAgICogICAgICBSLmhhc0luKCd3aWR0aCcsIHNxdWFyZSk7ICAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaGFzSW4oJ2FyZWEnLCBzcXVhcmUpOyAgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGhhc0luID0gX2N1cnJ5MihmdW5jdGlvbiBoYXNJbihwcm9wLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHByb3AgaW4gb2JqO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGl0cyBhcmd1bWVudHMgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlLiBWYWx1ZXMgYXJlXG4gICAgICogaWRlbnRpY2FsIGlmIHRoZXkgcmVmZXJlbmNlIHRoZSBzYW1lIG1lbW9yeS4gYE5hTmAgaXMgaWRlbnRpY2FsIHRvIGBOYU5gO1xuICAgICAqIGAwYCBhbmQgYC0wYCBhcmUgbm90IGlkZW50aWNhbC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTUuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBvID0ge307XG4gICAgICogICAgICBSLmlkZW50aWNhbChvLCBvKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlkZW50aWNhbCgxLCAxKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlkZW50aWNhbCgxLCAnMScpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlkZW50aWNhbChbXSwgW10pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlkZW50aWNhbCgwLCAtMCk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaWRlbnRpY2FsKE5hTiwgTmFOKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICB2YXIgaWRlbnRpY2FsID0gX2N1cnJ5MihmdW5jdGlvbiBpZGVudGljYWwoYSwgYikge1xuICAgICAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgICAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgICAgICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90aGluZyBidXQgcmV0dXJuIHRoZSBwYXJhbWV0ZXIgc3VwcGxpZWQgdG8gaXQuIEdvb2RcbiAgICAgKiBhcyBhIGRlZmF1bHQgb3IgcGxhY2Vob2xkZXIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgYSAtPiBhXG4gICAgICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byByZXR1cm4uXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGlucHV0IHZhbHVlLCBgeGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pZGVudGl0eSgxKTsgLy89PiAxXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgKiAgICAgIFIuaWRlbnRpdHkob2JqKSA9PT0gb2JqOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaWRlbnRpdHkgPSBfY3VycnkxKF9pZGVudGl0eSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2Nlc3MgZWl0aGVyIHRoZSBgb25UcnVlYCBvciB0aGUgYG9uRmFsc2VgXG4gICAgICogZnVuY3Rpb24gZGVwZW5kaW5nIHVwb24gdGhlIHJlc3VsdCBvZiB0aGUgYGNvbmRpdGlvbmAgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+ICopXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25UcnVlIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZhbHNlIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gIGV2YWx1YXRlcyB0byBhIGZhbHN5IHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyB1bmFyeSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVwZW5kaW5nIHVwb24gdGhlIHJlc3VsdCBvZiB0aGUgYGNvbmRpdGlvbmAgcHJlZGljYXRlLlxuICAgICAqIEBzZWUgUi51bmxlc3MsIFIud2hlblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpbmNDb3VudCA9IFIuaWZFbHNlKFxuICAgICAqICAgICAgICBSLmhhcygnY291bnQnKSxcbiAgICAgKiAgICAgICAgUi5vdmVyKFIubGVuc1Byb3AoJ2NvdW50JyksIFIuaW5jKSxcbiAgICAgKiAgICAgICAgUi5hc3NvYygnY291bnQnLCAxKVxuICAgICAqICAgICAgKTtcbiAgICAgKiAgICAgIGluY0NvdW50KHt9KTsgICAgICAgICAgIC8vPT4geyBjb3VudDogMSB9XG4gICAgICogICAgICBpbmNDb3VudCh7IGNvdW50OiAxIH0pOyAvLz0+IHsgY291bnQ6IDIgfVxuICAgICAqL1xuICAgIHZhciBpZkVsc2UgPSBfY3VycnkzKGZ1bmN0aW9uIGlmRWxzZShjb25kaXRpb24sIG9uVHJ1ZSwgb25GYWxzZSkge1xuICAgICAgICByZXR1cm4gY3VycnlOKE1hdGgubWF4KGNvbmRpdGlvbi5sZW5ndGgsIG9uVHJ1ZS5sZW5ndGgsIG9uRmFsc2UubGVuZ3RoKSwgZnVuY3Rpb24gX2lmRWxzZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IG9uVHJ1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb25GYWxzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEluY3JlbWVudHMgaXRzIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBzZWUgUi5kZWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluYyg0Mik7IC8vPT4gNDNcbiAgICAgKi9cbiAgICB2YXIgaW5jID0gYWRkKDEpO1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgc3VwcGxpZWQgZWxlbWVudCBpbnRvIHRoZSBsaXN0LCBhdCBpbmRleCBgaW5kZXhgLiBfTm90ZSB0aGF0XG4gICAgICogdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICAgICAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMlxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0geyp9IGVsdCBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGluc2VydCBpbnRvXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGVsdGAgaW5zZXJ0ZWQgYXQgYGluZGV4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluc2VydCgyLCAneCcsIFsxLDIsMyw0XSk7IC8vPT4gWzEsMiwneCcsMyw0XVxuICAgICAqL1xuICAgIHZhciBpbnNlcnQgPSBfY3VycnkzKGZ1bmN0aW9uIGluc2VydChpZHgsIGVsdCwgbGlzdCkge1xuICAgICAgICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3NsaWNlKGxpc3QpO1xuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgZWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIHN1Yi1saXN0IGludG8gdGhlIGxpc3QsIGF0IGluZGV4IGBpbmRleGAuIF9Ob3RlIHRoYXQgdGhpcyBpcyBub3RcbiAgICAgKiBkZXN0cnVjdGl2ZV86IGl0IHJldHVybnMgYSBjb3B5IG9mIHRoZSBsaXN0IHdpdGggdGhlIGNoYW5nZXMuXG4gICAgICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSBzdWItbGlzdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsdHMgVGhlIHN1Yi1saXN0IHRvIGluc2VydCBpbnRvIHRoZSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IHRoZSBzdWItbGlzdCBpbnRvXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGVsdHNgIGluc2VydGVkIHN0YXJ0aW5nIGF0IGBpbmRleGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pbnNlcnRBbGwoMiwgWyd4JywneScsJ3onXSwgWzEsMiwzLDRdKTsgLy89PiBbMSwyLCd4JywneScsJ3onLDMsNF1cbiAgICAgKi9cbiAgICB2YXIgaW5zZXJ0QWxsID0gX2N1cnJ5MyhmdW5jdGlvbiBpbnNlcnRBbGwoaWR4LCBlbHRzLCBsaXN0KSB7XG4gICAgICAgIGlkeCA9IGlkeCA8IGxpc3QubGVuZ3RoICYmIGlkeCA+PSAwID8gaWR4IDogbGlzdC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBfY29uY2F0KF9jb25jYXQoX3NsaWNlKGxpc3QsIDAsIGlkeCksIGVsdHMpLCBfc2xpY2UobGlzdCwgaWR4KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3Qgd2l0aCB0aGUgc2VwYXJhdG9yIGludGVycG9zZWQgYmV0d2VlbiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBpbnRlcnNwZXJzZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHsqfSBzZXBhcmF0b3IgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gYmUgaW50ZXJwb3NlZC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW50ZXJzcGVyc2UoJ24nLCBbJ2JhJywgJ2EnLCAnYSddKTsgLy89PiBbJ2JhJywgJ24nLCAnYScsICduJywgJ2EnXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNwZXJzZSA9IF9jdXJyeTIoX2NoZWNrRm9yTWV0aG9kKCdpbnRlcnNwZXJzZScsIGZ1bmN0aW9uIGludGVyc3BlcnNlKHNlcGFyYXRvciwgbGlzdCkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpZHggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsaXN0W2lkeF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsaXN0W2lkeF0sIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBpZiBhbiBvYmplY3QgKGB2YWxgKSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3VwcGxpZWQgY29uc3RydWN0b3IuIFRoaXNcbiAgICAgKiBmdW5jdGlvbiB3aWxsIGNoZWNrIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVHlwZVxuICAgICAqIEBzaWcgKCogLT4geyp9KSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3RvciBBIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCB7fSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pcyhOdW1iZXIsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCAxKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pcyhTdHJpbmcsICdzJyk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pcyhTdHJpbmcsIG5ldyBTdHJpbmcoJycpKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzKE9iamVjdCwgbmV3IFN0cmluZygnJykpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCAncycpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlzKE51bWJlciwge30pOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzID0gX2N1cnJ5MihmdW5jdGlvbiBpcyhDdG9yLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQ3RvciB8fCB2YWwgaW5zdGFuY2VvZiBDdG9yO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIHNpbWlsYXIgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBUeXBlXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBoYXMgYSBudW1lcmljIGxlbmd0aCBwcm9wZXJ0eSBhbmQgZXh0cmVtZSBpbmRpY2VzIGRlZmluZWQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UoW10pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UodHJ1ZSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlzQXJyYXlMaWtlKHtsZW5ndGg6IDEwfSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UoezA6ICd6ZXJvJywgOTogJ25pbmUnLCBsZW5ndGg6IDEwfSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5TGlrZSA9IF9jdXJyeTEoZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICAgICAgICBpZiAoX2lzQXJyYXkoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gISF4Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4Lmhhc093blByb3BlcnR5KDApICYmIHguaGFzT3duUHJvcGVydHkoeC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IFR5cGVcbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pc05pbChudWxsKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pc05pbCgwKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pc05pbChbXSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNOaWwgPSBfY3VycnkxKGZ1bmN0aW9uIGlzTmlsKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZlxuICAgICAqIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAgICAgKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5rZXlzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgLy8gY292ZXIgSUUgPCA5IGtleXMgaXNzdWVzXG4gICAgLy8gU2FmYXJpIGJ1Z1xuICAgIHZhciBrZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb3ZlciBJRSA8IDkga2V5cyBpc3N1ZXNcbiAgICAgICAgdmFyIGhhc0VudW1CdWcgPSAheyB0b1N0cmluZzogbnVsbCB9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICAgICAgICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gW1xuICAgICAgICAgICAgJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgICAgICd0b0xvY2FsZVN0cmluZydcbiAgICAgICAgXTtcbiAgICAgICAgLy8gU2FmYXJpIGJ1Z1xuICAgICAgICB2YXIgaGFzQXJnc0VudW1CdWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKTtcbiAgICAgICAgfSgpO1xuICAgICAgICB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0W2lkeF0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmICFoYXNBcmdzRW51bUJ1ZyA/IF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qob2JqKSAhPT0gb2JqID8gW10gOiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9KSA6IF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3AsIG5JZHg7XG4gICAgICAgICAgICB2YXIga3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBjaGVja0FyZ3NMZW5ndGggPSBoYXNBcmdzRW51bUJ1ZyAmJiBfaXNBcmd1bWVudHMob2JqKTtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBvYmopICYmICghY2hlY2tBcmdzTGVuZ3RoIHx8IHByb3AgIT09ICdsZW5ndGgnKSkge1xuICAgICAgICAgICAgICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRW51bUJ1Zykge1xuICAgICAgICAgICAgICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobklkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbklkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgIWNvbnRhaW5zKGtzLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbklkeCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrcztcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBwbGllZFxuICAgICAqIG9iamVjdCwgaW5jbHVkaW5nIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gICAgICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtrOiB2fSAtPiBba11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBwcm9wZXJ0aWVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICAgICAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAgICAgKiAgICAgIHZhciBmID0gbmV3IEYoKTtcbiAgICAgKiAgICAgIFIua2V5c0luKGYpOyAvLz0+IFsneCcsICd5J11cbiAgICAgKi9cbiAgICB2YXIga2V5c0luID0gX2N1cnJ5MShmdW5jdGlvbiBrZXlzSW4ob2JqKSB7XG4gICAgICAgIHZhciBwcm9wO1xuICAgICAgICB2YXIga3MgPSBbXTtcbiAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSBieSByZXR1cm5pbmcgYGxpc3QubGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMy4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5sZW5ndGgoW10pOyAvLz0+IDBcbiAgICAgKiAgICAgIFIubGVuZ3RoKFsxLCAyLCAzXSk7IC8vPT4gM1xuICAgICAqL1xuICAgIHZhciBsZW5ndGggPSBfY3VycnkxKGZ1bmN0aW9uIGxlbmd0aChsaXN0KSB7XG4gICAgICAgIHJldHVybiBsaXN0ICE9IG51bGwgJiYgaXMoTnVtYmVyLCBsaXN0Lmxlbmd0aCkgPyBsaXN0Lmxlbmd0aCA6IE5hTjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZDsgYGZhbHNlYFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5sdCgyLCAxKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5sdCgyLCAyKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5sdCgyLCAzKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0KCdhJywgJ3onKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0KCd6JywgJ2EnKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IF9jdXJyeTIoZnVuY3Rpb24gbHQoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIuZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5sdGUoMiwgMSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIubHRlKDIsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubHRlKDIsIDMpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubHRlKCdhJywgJ3onKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0ZSgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gX2N1cnJ5MihmdW5jdGlvbiBsdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8PSBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcEFjY3VtIGZ1bmN0aW9uIGJlaGF2ZXMgbGlrZSBhIGNvbWJpbmF0aW9uIG9mIG1hcCBhbmQgcmVkdWNlOyBpdFxuICAgICAqIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBwYXNzaW5nIGFuIGFjY3VtdWxhdGluZ1xuICAgICAqIHBhcmFtZXRlciBmcm9tIGxlZnQgdG8gcmlnaHQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzXG4gICAgICogYWNjdW11bGF0b3IgdG9nZXRoZXIgd2l0aCB0aGUgbmV3IGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKmFjYyogYW5kICp2YWx1ZSosIGFuZCBzaG91bGRcbiAgICAgKiByZXR1cm4gYSB0dXBsZSAqW2FjYywgdmFsdWVdKi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYWNjIC0+IHggLT4gKGFjYywgeSkpIC0+IGFjYyAtPiBbeF0gLT4gKGFjYywgW3ldKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgaW5wdXQgYGxpc3RgLlxuICAgICAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5hZGRJbmRleFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBkaWdpdHMgPSBbJzEnLCAnMicsICczJywgJzQnXTtcbiAgICAgKiAgICAgIHZhciBhcHBlbmRlciA9IChhLCBiKSA9PiBbYSArIGIsIGEgKyBiXTtcbiAgICAgKlxuICAgICAqICAgICAgUi5tYXBBY2N1bShhcHBlbmRlciwgMCwgZGlnaXRzKTsgLy89PiBbJzAxMjM0JywgWycwMScsICcwMTInLCAnMDEyMycsICcwMTIzNCddXVxuICAgICAqL1xuICAgIHZhciBtYXBBY2N1bSA9IF9jdXJyeTMoZnVuY3Rpb24gbWFwQWNjdW0oZm4sIGFjYywgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciB0dXBsZSA9IFthY2NdO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0dXBsZVswXSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcEFjY3VtUmlnaHQgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGEgY29tYmluYXRpb24gb2YgbWFwIGFuZCByZWR1Y2U7IGl0XG4gICAgICogYXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBvZiBhIGxpc3QsIHBhc3NpbmcgYW4gYWNjdW11bGF0aW5nXG4gICAgICogcGFyYW1ldGVyIGZyb20gcmlnaHQgdG8gbGVmdCwgYW5kIHJldHVybmluZyBhIGZpbmFsIHZhbHVlIG9mIHRoaXNcbiAgICAgKiBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAgICAgKlxuICAgICAqIFNpbWlsYXIgdG8gYG1hcEFjY3VtYCwgZXhjZXB0IG1vdmVzIHRocm91Z2ggdGhlIGlucHV0IGxpc3QgZnJvbSB0aGUgcmlnaHQgdG9cbiAgICAgKiB0aGUgbGVmdC5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gYXJndW1lbnRzLCAqYWNjKiBhbmQgKnZhbHVlKiwgYW5kIHNob3VsZFxuICAgICAqIHJldHVybiBhIHR1cGxlICpbYWNjLCB2YWx1ZV0qLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhY2MgLT4geCAtPiAoYWNjLCB5KSkgLT4gYWNjIC0+IFt4XSAtPiAoYWNjLCBbeV0pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRpZ2l0cyA9IFsnMScsICcyJywgJzMnLCAnNCddO1xuICAgICAqICAgICAgdmFyIGFwcGVuZCA9IChhLCBiKSA9PiBbYSArIGIsIGEgKyBiXTtcbiAgICAgKlxuICAgICAqICAgICAgUi5tYXBBY2N1bVJpZ2h0KGFwcGVuZCwgMCwgZGlnaXRzKTsgLy89PiBbJzA0MzIxJywgWycwNDMyMScsICcwNDMyJywgJzA0MycsICcwNCddXVxuICAgICAqL1xuICAgIHZhciBtYXBBY2N1bVJpZ2h0ID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXBBY2N1bVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdHVwbGUgPSBbYWNjXTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0dXBsZVswXSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgYSByZWd1bGFyIGV4cHJlc3Npb24gYWdhaW5zdCBhIFN0cmluZy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgICAqIHJldHVybiBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLiBUaGlzIGRpZmZlcnMgZnJvbVxuICAgICAqIFtgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9tYXRjaClcbiAgICAgKiB3aGljaCByZXR1cm5zIGBudWxsYCB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyBSZWdFeHAgLT4gU3RyaW5nIC0+IFtTdHJpbmcgfCBVbmRlZmluZWRdXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJ4IEEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIG1hdGNoZXMgb3IgZW1wdHkgYXJyYXkuXG4gICAgICogQHNlZSBSLnRlc3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1hdGNoKC8oW2Etel1hKS9nLCAnYmFuYW5hcycpOyAvLz0+IFsnYmEnLCAnbmEnLCAnbmEnXVxuICAgICAqICAgICAgUi5tYXRjaCgvYS8sICdiJyk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIubWF0Y2goL2EvLCBudWxsKTsgLy89PiBUeXBlRXJyb3I6IG51bGwgZG9lcyBub3QgaGF2ZSBhIG1ldGhvZCBuYW1lZCBcIm1hdGNoXCJcbiAgICAgKi9cbiAgICB2YXIgbWF0Y2ggPSBfY3VycnkyKGZ1bmN0aW9uIG1hdGNoKHJ4LCBzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5tYXRjaChyeCkgfHwgW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBtYXRoTW9kIGJlaGF2ZXMgbGlrZSB0aGUgbW9kdWxvIG9wZXJhdG9yIHNob3VsZCBtYXRoZW1hdGljYWxseSwgdW5saWtlIHRoZVxuICAgICAqIGAlYCBvcGVyYXRvciAoYW5kIGJ5IGV4dGVuc2lvbiwgUi5tb2R1bG8pLiBTbyB3aGlsZSBcIi0xNyAlIDVcIiBpcyAtMixcbiAgICAgKiBtYXRoTW9kKC0xNywgNSkgaXMgMy4gbWF0aE1vZCByZXF1aXJlcyBJbnRlZ2VyIGFyZ3VtZW50cywgYW5kIHJldHVybnMgTmFOXG4gICAgICogd2hlbiB0aGUgbW9kdWx1cyBpcyB6ZXJvIG9yIG5lZ2F0aXZlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbSBUaGUgZGl2aWRlbmQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHAgdGhlIG1vZHVsdXMuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBiIG1vZCBhYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1hdGhNb2QoLTE3LCA1KTsgIC8vPT4gM1xuICAgICAqICAgICAgUi5tYXRoTW9kKDE3LCA1KTsgICAvLz0+IDJcbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgLTUpOyAgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgMCk7ICAgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNy4yLCA1KTsgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgNS4zKTsgLy89PiBOYU5cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGNsb2NrID0gUi5tYXRoTW9kKFIuX18sIDEyKTtcbiAgICAgKiAgICAgIGNsb2NrKDE1KTsgLy89PiAzXG4gICAgICogICAgICBjbG9jaygyNCk7IC8vPT4gMFxuICAgICAqXG4gICAgICogICAgICB2YXIgc2V2ZW50ZWVuTW9kID0gUi5tYXRoTW9kKDE3KTtcbiAgICAgKiAgICAgIHNldmVudGVlbk1vZCgzKTsgIC8vPT4gMlxuICAgICAqICAgICAgc2V2ZW50ZWVuTW9kKDQpOyAgLy89PiAxXG4gICAgICogICAgICBzZXZlbnRlZW5Nb2QoMTApOyAvLz0+IDdcbiAgICAgKi9cbiAgICB2YXIgbWF0aE1vZCA9IF9jdXJyeTIoZnVuY3Rpb24gbWF0aE1vZChtLCBwKSB7XG4gICAgICAgIGlmICghX2lzSW50ZWdlcihtKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9pc0ludGVnZXIocCkgfHwgcCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtICUgcCArIHApICUgcDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhcmdlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLm1heEJ5LCBSLm1pblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWF4KDc4OSwgMTIzKTsgLy89PiA3ODlcbiAgICAgKiAgICAgIFIubWF4KCdhJywgJ2InKTsgLy89PiAnYidcbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gX2N1cnJ5MihmdW5jdGlvbiBtYXgoYSwgYikge1xuICAgICAgICByZXR1cm4gYiA+IGEgPyBiIDogYTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAgICAgKiBsYXJnZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOC4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5tYXgsIFIubWluQnlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyAgc3F1YXJlIDo6IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiAgICAgIHZhciBzcXVhcmUgPSBuID0+IG4gKiBuO1xuICAgICAqXG4gICAgICogICAgICBSLm1heEJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IC0zXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVkdWNlKFIubWF4Qnkoc3F1YXJlKSwgMCwgWzMsIC01LCA0LCAxLCAtMl0pOyAvLz0+IC01XG4gICAgICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFtdKTsgLy89PiAwXG4gICAgICovXG4gICAgdmFyIG1heEJ5ID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXhCeShmLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBmKGIpID4gZihhKSA/IGIgOiBhO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgZmlyc3Qgb2JqZWN0IG1lcmdlZCB3aXRoXG4gICAgICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLFxuICAgICAqIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWNvbmQgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqIEBzZWUgUi5tZXJnZVdpdGgsIFIubWVyZ2VXaXRoS2V5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZXJnZSh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMTAgfSwgeyAnYWdlJzogNDAgfSk7XG4gICAgICogICAgICAvLz0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAgICAgIHZhciByZXNldFRvRGVmYXVsdCA9IFIubWVyZ2UoUi5fXywge3g6IDB9KTtcbiAgICAgKiAgICAgIHJlc2V0VG9EZWZhdWx0KHt4OiA1LCB5OiAyfSk7IC8vPT4ge3g6IDAsIHk6IDJ9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gX2N1cnJ5MihmdW5jdGlvbiBtZXJnZShsLCByKSB7XG4gICAgICAgIHJldHVybiBfYXNzaWduKHt9LCBsLCByKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhIGxpc3Qgb2Ygb2JqZWN0cyB0b2dldGhlciBpbnRvIG9uZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW3trOiB2fV0gLT4ge2s6IHZ9XG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIG1lcmdlZCBvYmplY3QuXG4gICAgICogQHNlZSBSLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWVyZ2VBbGwoW3tmb286MX0se2JhcjoyfSx7YmF6OjN9XSk7IC8vPT4ge2ZvbzoxLGJhcjoyLGJhejozfVxuICAgICAqICAgICAgUi5tZXJnZUFsbChbe2ZvbzoxfSx7Zm9vOjJ9LHtiYXI6Mn1dKTsgLy89PiB7Zm9vOjIsYmFyOjJ9XG4gICAgICovXG4gICAgdmFyIG1lcmdlQWxsID0gX2N1cnJ5MShmdW5jdGlvbiBtZXJnZUFsbChsaXN0KSB7XG4gICAgICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIFt7fV0uY29uY2F0KGxpc3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy4gSWZcbiAgICAgKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUga2V5XG4gICAgICogYW5kIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gZWFjaCBvYmplY3QsIHdpdGggdGhlIHJlc3VsdCBiZWluZ1xuICAgICAqIHVzZWQgYXMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIHRoZSByZXR1cm5lZCBvYmplY3QuIFRoZSBrZXlcbiAgICAgKiB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJldHVybmVkIG9iamVjdCBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyAoU3RyaW5nIC0+IGEgLT4gYSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2VlIFIubWVyZ2UsIFIubWVyZ2VXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgbGV0IGNvbmNhdFZhbHVlcyA9IChrLCBsLCByKSA9PiBrID09ICd2YWx1ZXMnID8gUi5jb25jYXQobCwgcikgOiByXG4gICAgICogICAgICBSLm1lcmdlV2l0aEtleShjb25jYXRWYWx1ZXMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHRoaW5nOiAnZm9vJywgdmFsdWVzOiBbMTAsIDIwXSB9LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCB0aGluZzogJ2JhcicsIHZhbHVlczogWzE1LCAzNV0gfSk7XG4gICAgICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGhLZXkgPSBfY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aEtleShmbiwgbCwgcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBrO1xuICAgICAgICBmb3IgKGsgaW4gbCkge1xuICAgICAgICAgICAgaWYgKF9oYXMoaywgbCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba10gPSBfaGFzKGssIHIpID8gZm4oaywgbFtrXSwgcltrXSkgOiBsW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoayBpbiByKSB7XG4gICAgICAgICAgICBpZiAoX2hhcyhrLCByKSAmJiAhX2hhcyhrLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gcltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc21hbGxlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLm1pbkJ5LCBSLm1heFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWluKDc4OSwgMTIzKTsgLy89PiAxMjNcbiAgICAgKiAgICAgIFIubWluKCdhJywgJ2InKTsgLy89PiAnYSdcbiAgICAgKi9cbiAgICB2YXIgbWluID0gX2N1cnJ5MihmdW5jdGlvbiBtaW4oYSwgYikge1xuICAgICAgICByZXR1cm4gYiA8IGEgPyBiIDogYTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAgICAgKiBzbWFsbGVyIHJlc3VsdCB3aGVuIHBhc3NlZCB0byB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHBhcmFtIHsqfSBhXG4gICAgICogQHBhcmFtIHsqfSBiXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIubWluLCBSLm1heEJ5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gIHNxdWFyZSA6OiBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogICAgICB2YXIgc3F1YXJlID0gbiA9PiBuICogbjtcbiAgICAgKlxuICAgICAqICAgICAgUi5taW5CeShzcXVhcmUsIC0zLCAyKTsgLy89PiAyXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVkdWNlKFIubWluQnkoc3F1YXJlKSwgSW5maW5pdHksIFszLCAtNSwgNCwgMSwgLTJdKTsgLy89PiAxXG4gICAgICogICAgICBSLnJlZHVjZShSLm1pbkJ5KHNxdWFyZSksIEluZmluaXR5LCBbXSk7IC8vPT4gSW5maW5pdHlcbiAgICAgKi9cbiAgICB2YXIgbWluQnkgPSBfY3VycnkzKGZ1bmN0aW9uIG1pbkJ5KGYsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGYoYikgPCBmKGEpID8gYiA6IGE7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGJ5IHRoZSBmaXJzdCBhbmQgcmV0dXJucyB0aGUgcmVtYWluZGVyLiBOb3RlXG4gICAgICogdGhhdCB0aGlzIGZ1bmN0aW9uIHByZXNlcnZlcyB0aGUgSmF2YVNjcmlwdC1zdHlsZSBiZWhhdmlvciBmb3IgbW9kdWxvLiBGb3JcbiAgICAgKiBtYXRoZW1hdGljYWwgbW9kdWxvIHNlZSBgbWF0aE1vZGAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMVxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSB2YWx1ZSB0byB0aGUgZGl2aWRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBwc2V1ZG8tbW9kdWx1c1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYiAlIGFgLlxuICAgICAqIEBzZWUgUi5tYXRoTW9kXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tb2R1bG8oMTcsIDMpOyAvLz0+IDJcbiAgICAgKiAgICAgIC8vIEpTIGJlaGF2aW9yOlxuICAgICAqICAgICAgUi5tb2R1bG8oLTE3LCAzKTsgLy89PiAtMlxuICAgICAqICAgICAgUi5tb2R1bG8oMTcsIC0zKTsgLy89PiAyXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc09kZCA9IFIubW9kdWxvKFIuX18sIDIpO1xuICAgICAqICAgICAgaXNPZGQoNDIpOyAvLz0+IDBcbiAgICAgKiAgICAgIGlzT2RkKDIxKTsgLy89PiAxXG4gICAgICovXG4gICAgdmFyIG1vZHVsbyA9IF9jdXJyeTIoZnVuY3Rpb24gbW9kdWxvKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgJSBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAqIGJgIGJ1dCBjdXJyaWVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgKiBiYC5cbiAgICAgKiBAc2VlIFIuZGl2aWRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRvdWJsZSA9IFIubXVsdGlwbHkoMik7XG4gICAgICogICAgICB2YXIgdHJpcGxlID0gUi5tdWx0aXBseSgzKTtcbiAgICAgKiAgICAgIGRvdWJsZSgzKTsgICAgICAgLy89PiAgNlxuICAgICAqICAgICAgdHJpcGxlKDQpOyAgICAgICAvLz0+IDEyXG4gICAgICogICAgICBSLm11bHRpcGx5KDIsIDUpOyAgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IF9jdXJyeTIoZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gICAgICogZXhhY3RseSBgbmAgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGRlc2lyZWQgYXJpdHkgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gICAgICogICAgICAgICBhcml0eSBgbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHRha2VzVHdvQXJncyA9IChhLCBiKSA9PiBbYSwgYl07XG4gICAgICpcbiAgICAgKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICAgICAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIpOyAvLz0+IFsxLCAyXVxuICAgICAqXG4gICAgICogICAgICB2YXIgdGFrZXNPbmVBcmcgPSBSLm5BcnkoMSwgdGFrZXNUd29BcmdzKTtcbiAgICAgKiAgICAgIHRha2VzT25lQXJnLmxlbmd0aDsgLy89PiAxXG4gICAgICogICAgICAvLyBPbmx5IGBuYCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICAgICAqICAgICAgdGFrZXNPbmVBcmcoMSwgMik7IC8vPT4gWzEsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICB2YXIgbkFyeSA9IF9jdXJyeTIoZnVuY3Rpb24gbkFyeShuLCBmbikge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNik7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gbkFyeSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGl0cyBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm5lZ2F0ZSg0Mik7IC8vPT4gLTQyXG4gICAgICovXG4gICAgdmFyIG5lZ2F0ZSA9IF9jdXJyeTEoZnVuY3Rpb24gbmVnYXRlKG4pIHtcbiAgICAgICAgcmV0dXJuIC1uO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgbm8gZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkIGJ5IGV2ZXJ5IGVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIEBzZWUgUi5hbGwsIFIuYW55XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzRXZlbiA9IG4gPT4gbiAlIDIgPT09IDA7XG4gICAgICpcbiAgICAgKiAgICAgIFIubm9uZShpc0V2ZW4sIFsxLCAzLCA1LCA3LCA5LCAxMV0pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubm9uZShpc0V2ZW4sIFsxLCAzLCA1LCA3LCA4LCAxMV0pOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG5vbmUgPSBfY3VycnkyKF9jb21wbGVtZW50KF9kaXNwYXRjaGFibGUoJ2FueScsIF94YW55LCBhbnkpKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYCFgIG9mIGl0cyBhcmd1bWVudC4gSXQgd2lsbCByZXR1cm4gYHRydWVgIHdoZW5cbiAgICAgKiBwYXNzZWQgZmFsc2UteSB2YWx1ZSwgYW5kIGBmYWxzZWAgd2hlbiBwYXNzZWQgYSB0cnV0aC15IG9uZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAqIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGEgYW55IHZhbHVlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdGhlIGxvZ2ljYWwgaW52ZXJzZSBvZiBwYXNzZWQgYXJndW1lbnQuXG4gICAgICogQHNlZSBSLmNvbXBsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm5vdCh0cnVlKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ub3QoZmFsc2UpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubm90KDApOyA9PiB0cnVlXG4gICAgICogICAgICBSLm5vdCgxKTsgPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbm90ID0gX2N1cnJ5MShmdW5jdGlvbiBub3QoYSkge1xuICAgICAgICByZXR1cm4gIWE7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIElmIG4gaXMgbmVnYXRpdmUgdGhlXG4gICAgICogZWxlbWVudCBhdCBpbmRleCBsZW5ndGggKyBuIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICAgKiBAcGFyYW0geyp9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBsaXN0ID0gWydmb28nLCAnYmFyJywgJ2JheicsICdxdXV4J107XG4gICAgICogICAgICBSLm50aCgxLCBsaXN0KTsgLy89PiAnYmFyJ1xuICAgICAqICAgICAgUi5udGgoLTEsIGxpc3QpOyAvLz0+ICdxdXV4J1xuICAgICAqICAgICAgUi5udGgoLTk5LCBsaXN0KTsgLy89PiB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqICAgICAgUi5udGgoMiwgJ2FiYycpOyAvLz0+ICdjJ1xuICAgICAqICAgICAgUi5udGgoMywgJ2FiYycpOyAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIG50aCA9IF9jdXJyeTIoZnVuY3Rpb24gbnRoKG9mZnNldCwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gb2Zmc2V0IDwgMCA/IGxpc3QubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5jaGFyQXQoaWR4KSA6IGxpc3RbaWR4XTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGl0cyBudGggYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICouLi4gLT4gKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5udGhBcmcoMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2InXG4gICAgICogICAgICBSLm50aEFyZygtMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2MnXG4gICAgICovXG4gICAgdmFyIG50aEFyZyA9IF9jdXJyeTEoZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudGgobiwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzaW5nbGUga2V5OnZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7U3RyaW5nOmF9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqIEBzZWUgUi5wYWlyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hdGNoUGhyYXNlcyA9IFIuY29tcG9zZShcbiAgICAgKiAgICAgICAgUi5vYmpPZignbXVzdCcpLFxuICAgICAqICAgICAgICBSLm1hcChSLm9iak9mKCdtYXRjaF9waHJhc2UnKSlcbiAgICAgKiAgICAgICk7XG4gICAgICogICAgICBtYXRjaFBocmFzZXMoWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiB7bXVzdDogW3ttYXRjaF9waHJhc2U6ICdmb28nfSwge21hdGNoX3BocmFzZTogJ2Jhcid9LCB7bWF0Y2hfcGhyYXNlOiAnYmF6J31dfVxuICAgICAqL1xuICAgIHZhciBvYmpPZiA9IF9jdXJyeTIoZnVuY3Rpb24gb2JqT2Yoa2V5LCB2YWwpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW5nbGV0b24gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgYG9mYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgRVM2IGBvZmA7IFNlZVxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29mXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgYSAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IHggYW55IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IHdyYXBwaW5nIGB4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm9mKG51bGwpOyAvLz0+IFtudWxsXVxuICAgICAqICAgICAgUi5vZihbNDJdKTsgLy89PiBbWzQyXV1cbiAgICAgKi9cbiAgICB2YXIgb2YgPSBfY3VycnkxKF9vZik7XG5cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ3VhcmRzIGludm9jYXRpb24gb2ZcbiAgICAgKiBgZm5gIHN1Y2ggdGhhdCBgZm5gIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSB0aW1lc1xuICAgICAqIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBpbnZva2VkLiBUaGUgZmlyc3QgdmFsdWUgY2FsY3VsYXRlZCBpcyByZXR1cm5lZCBpblxuICAgICAqIHN1YnNlcXVlbnQgaW52b2NhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKGEuLi4gLT4gYikgLT4gKGEuLi4gLT4gYilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcCBpbiBhIGNhbGwtb25seS1vbmNlIHdyYXBwZXIuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhZGRPbmVPbmNlID0gUi5vbmNlKHggPT4geCArIDEpO1xuICAgICAqICAgICAgYWRkT25lT25jZSgxMCk7IC8vPT4gMTFcbiAgICAgKiAgICAgIGFkZE9uZU9uY2UoYWRkT25lT25jZSg1MCkpOyAvLz0+IDExXG4gICAgICovXG4gICAgdmFyIG9uY2UgPSBfY3VycnkxKGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIGJvdGggb2YgaXRzIGFyZ3VtZW50cyBhcmUgYHRydWVgLiBSZXR1cm5zIGBmYWxzZWBcbiAgICAgKiBpZiBib3RoIGFyZ3VtZW50cyBhcmUgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAqIC0+ICogLT4gKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYSBBIGJvb2xlYW4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGIgQSBib29sZWFuIHZhbHVlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIG9uZSBvciBib3RoIGFyZ3VtZW50cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgICAqIEBzZWUgUi5laXRoZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm9yKHRydWUsIHRydWUpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIub3IodHJ1ZSwgZmFsc2UpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIub3IoZmFsc2UsIHRydWUpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIub3IoZmFsc2UsIGZhbHNlKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvciA9IF9jdXJyeTIoZnVuY3Rpb24gb3IoYSwgYikge1xuICAgICAgICByZXR1cm4gYSB8fCBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIFwic2V0dGluZ1wiIHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHN0cnVjdHVyZVxuICAgICAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG9cbiAgICAgKiB0aGUgZm9jdXNlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICAgICAqIEBzaWcgTGVucyBzIGEgLT4gKGEgLT4gYSkgLT4gcyAtPiBzXG4gICAgICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gICAgICogQHBhcmFtIHsqfSB2XG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaGVhZExlbnMgPSBSLmxlbnNJbmRleCgwKTtcbiAgICAgKlxuICAgICAqICAgICAgUi5vdmVyKGhlYWRMZW5zLCBSLnRvVXBwZXIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydGT08nLCAnYmFyJywgJ2JheiddXG4gICAgICovXG4gICAgLy8gYElkZW50aXR5YCBpcyBhIGZ1bmN0b3IgdGhhdCBob2xkcyBhIHNpbmdsZSB2YWx1ZSwgd2hlcmUgYG1hcGAgc2ltcGx5XG4gICAgLy8gdHJhbnNmb3JtcyB0aGUgaGVsZCB2YWx1ZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiBpcyBmaXJzdCB0cmFuc2Zvcm1lZCB3aXRoIGBmYCxcbiAgICAvLyB0aGVuIHNldCBhcyB0aGUgdmFsdWUgb2YgYW4gYElkZW50aXR5YC4gVGhpcyBpcyB0aGVuIG1hcHBlZCBvdmVyIHdpdGggdGhlXG4gICAgLy8gc2V0dGVyIGZ1bmN0aW9uIG9mIHRoZSBsZW5zLlxuICAgIHZhciBvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBgSWRlbnRpdHlgIGlzIGEgZnVuY3RvciB0aGF0IGhvbGRzIGEgc2luZ2xlIHZhbHVlLCB3aGVyZSBgbWFwYCBzaW1wbHlcbiAgICAgICAgLy8gdHJhbnNmb3JtcyB0aGUgaGVsZCB2YWx1ZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAgICAgdmFyIElkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgICAgICAgICAgbWFwOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpdHkoZih4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTMoZnVuY3Rpb24gb3ZlcihsZW5zLCBmLCB4KSB7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiBpcyBmaXJzdCB0cmFuc2Zvcm1lZCB3aXRoIGBmYCxcbiAgICAgICAgICAgIC8vIHRoZW4gc2V0IGFzIHRoZSB2YWx1ZSBvZiBhbiBgSWRlbnRpdHlgLiBUaGlzIGlzIHRoZW4gbWFwcGVkIG92ZXIgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHNldHRlciBmdW5jdGlvbiBvZiB0aGUgbGVucy5cbiAgICAgICAgICAgIHJldHVybiBsZW5zKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElkZW50aXR5KGYoeSkpO1xuICAgICAgICAgICAgfSkoeCkudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHR3byBhcmd1bWVudHMsIGBmc3RgIGFuZCBgc25kYCwgYW5kIHJldHVybnMgYFtmc3QsIHNuZF1gLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gYiAtPiAoYSxiKVxuICAgICAqIEBwYXJhbSB7Kn0gZnN0XG4gICAgICogQHBhcmFtIHsqfSBzbmRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAc2VlIFIub2JqT2YsIFIub2ZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnBhaXIoJ2ZvbycsICdiYXInKTsgLy89PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIHZhciBwYWlyID0gX2N1cnJ5MihmdW5jdGlvbiBwYWlyKGZzdCwgc25kKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmc3QsXG4gICAgICAgICAgICBzbmRcbiAgICAgICAgXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IHtrOiB2fSAtPiB2IHwgVW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydHkgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gICAgICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHZhciBwYXRoID0gX2N1cnJ5MihmdW5jdGlvbiBwYXRoKHBhdGhzLCBvYmopIHtcbiAgICAgICAgdmFyIHZhbCA9IG9iajtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBwYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IHZhbFtwYXRoc1tpZHhdXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aCwgcmV0dXJucyB0aGVcbiAgICAgKiB2YWx1ZSBhdCB0aGF0IHBhdGguIE90aGVyd2lzZSByZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0IHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgYSAtPiBbU3RyaW5nXSAtPiBPYmplY3QgLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gZCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwIFRoZSBwYXRoIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmV0cmlldmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSBmcm9tLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBkYXRhIGF0IGBwYXRoYCBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGF0aE9yKCdOL0EnLCBbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7IC8vPT4gMlxuICAgICAqICAgICAgUi5wYXRoT3IoJ04vQScsIFsnYScsICdiJ10sIHtjOiB7YjogMn19KTsgLy89PiBcIk4vQVwiXG4gICAgICovXG4gICAgdmFyIHBhdGhPciA9IF9jdXJyeTMoZnVuY3Rpb24gcGF0aE9yKGQsIHAsIG9iaikge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFRvKGQsIHBhdGgocCwgb2JqKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBhdCBnaXZlbiBwYXRoIHNhdGlzZmllcyB0aGVcbiAgICAgKiBnaXZlbiBwcmVkaWNhdGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbU3RyaW5nXSAtPiBPYmplY3QgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wUGF0aFxuICAgICAqIEBwYXJhbSB7Kn0gb2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIucHJvcFNhdGlzZmllcywgUi5wYXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5wYXRoU2F0aXNmaWVzKHkgPT4geSA+IDAsIFsneCcsICd5J10sIHt4OiB7eTogMn19KTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIHBhdGhTYXRpc2ZpZXMgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhTYXRpc2ZpZXMocHJlZCwgcHJvcFBhdGgsIG9iaikge1xuICAgICAgICByZXR1cm4gcHJvcFBhdGgubGVuZ3RoID4gMCAmJiBwcmVkKHBhdGgocHJvcFBhdGgsIG9iaikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBrZXlzIHNwZWNpZmllZC4gSWZcbiAgICAgKiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGUgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gY29weSBvbnRvIGEgbmV3IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyBmcm9tIGBuYW1lc2Agb24gaXQuXG4gICAgICogQHNlZSBSLm9taXQsIFIucHJvcHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnBpY2soWydhJywgJ2QnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZDogNH1cbiAgICAgKiAgICAgIFIucGljayhbJ2EnLCAnZScsICdmJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2E6IDF9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBfY3VycnkyKGZ1bmN0aW9uIHBpY2sobmFtZXMsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobmFtZXNbaWR4XSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbmFtZXNbaWR4XV0gPSBvYmpbbmFtZXNbaWR4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBgcGlja2AgZXhjZXB0IHRoYXQgdGhpcyBvbmUgaW5jbHVkZXMgYSBga2V5OiB1bmRlZmluZWRgIHBhaXIgZm9yXG4gICAgICogcHJvcGVydGllcyB0aGF0IGRvbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBvbiBpdC5cbiAgICAgKiBAc2VlIFIucGlja1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGlja0FsbChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICAgICAqICAgICAgUi5waWNrQWxsKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZTogdW5kZWZpbmVkLCBmOiB1bmRlZmluZWR9XG4gICAgICovXG4gICAgdmFyIHBpY2tBbGwgPSBfY3VycnkyKGZ1bmN0aW9uIHBpY2tBbGwobmFtZXMsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2lkeF07XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBrZXlzIHRoYXQgc2F0aXNmeVxuICAgICAqIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnICh2LCBrIC0+IEJvb2xlYW4pIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGtleVxuICAgICAqICAgICAgICBzaG91bGQgYmUgaW5jbHVkZWQgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIHRoYXQgc2F0aXNmeSBgcHJlZGBcbiAgICAgKiAgICAgICAgIG9uIGl0LlxuICAgICAqIEBzZWUgUi5waWNrLCBSLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc1VwcGVyQ2FzZSA9ICh2YWwsIGtleSkgPT4ga2V5LnRvVXBwZXJDYXNlKCkgPT09IGtleTtcbiAgICAgKiAgICAgIFIucGlja0J5KGlzVXBwZXJDYXNlLCB7YTogMSwgYjogMiwgQTogMywgQjogNH0pOyAvLz0+IHtBOiAzLCBCOiA0fVxuICAgICAqL1xuICAgIHZhciBwaWNrQnkgPSBfY3VycnkyKGZ1bmN0aW9uIHBpY2tCeSh0ZXN0LCBvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHRlc3Qob2JqW3Byb3BdLCBwcm9wLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aCB0aGUgZ2l2ZW4gZWxlbWVudCBhdCB0aGUgZnJvbnQsIGZvbGxvd2VkIGJ5IHRoZVxuICAgICAqIGNvbnRlbnRzIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHsqfSBlbCBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGhlYWQgb2YgdGhlIG91dHB1dCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGFkZCB0byB0aGUgdGFpbCBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi5hcHBlbmRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByZXBlbmQoJ2ZlZScsIFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+IFsnZmVlJywgJ2ZpJywgJ2ZvJywgJ2Z1bSddXG4gICAgICovXG4gICAgdmFyIHByZXBlbmQgPSBfY3VycnkyKGZ1bmN0aW9uIHByZXBlbmQoZWwsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9jb25jYXQoW2VsXSwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIHN1cHBsaWVkIGFuIG9iamVjdCByZXR1cm5zIHRoZSBpbmRpY2F0ZWRcbiAgICAgKiBwcm9wZXJ0eSBvZiB0aGF0IG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBzIC0+IHtzOiBhfSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgYG9iai5wYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3AoJ3gnLCB7eDogMTAwfSk7IC8vPT4gMTAwXG4gICAgICogICAgICBSLnByb3AoJ3gnLCB7fSk7IC8vPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgdmFyIHByb3AgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3AocCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbcF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLFxuICAgICAqIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0XG4gICAgICogdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIGEgLT4gU3RyaW5nIC0+IE9iamVjdCAtPiBhXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFsaWNlID0ge1xuICAgICAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICAgICAqICAgICAgICBhZ2U6IDEwMVxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBmYXZvcml0ZSA9IFIucHJvcCgnZmF2b3JpdGVMaWJyYXJ5Jyk7XG4gICAgICogICAgICB2YXIgZmF2b3JpdGVXaXRoRGVmYXVsdCA9IFIucHJvcE9yKCdSYW1kYScsICdmYXZvcml0ZUxpYnJhcnknKTtcbiAgICAgKlxuICAgICAqICAgICAgZmF2b3JpdGUoYWxpY2UpOyAgLy89PiB1bmRlZmluZWRcbiAgICAgKiAgICAgIGZhdm9yaXRlV2l0aERlZmF1bHQoYWxpY2UpOyAgLy89PiAnUmFtZGEnXG4gICAgICovXG4gICAgdmFyIHByb3BPciA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcE9yKHZhbCwgcCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfaGFzKHAsIG9iaikgPyBvYmpbcF0gOiB2YWw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBzYXRpc2ZpZXMgdGhlIGdpdmVuXG4gICAgICogcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IHtTdHJpbmc6IGF9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLnByb3BFcSwgUi5wcm9wSXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3BTYXRpc2ZpZXMoeCA9PiB4ID4gMCwgJ3gnLCB7eDogMSwgeTogMn0pOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgcHJvcFNhdGlzZmllcyA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcFNhdGlzZmllcyhwcmVkLCBuYW1lLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHByZWQob2JqW25hbWVdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFjdHMgYXMgbXVsdGlwbGUgYHByb3BgOiBhcnJheSBvZiBrZXlzIGluLCBhcnJheSBvZiB2YWx1ZXMgb3V0LiBQcmVzZXJ2ZXNcbiAgICAgKiBvcmRlci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiBbdl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzIG9yIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucHJvcHMoWyd4JywgJ3knXSwge3g6IDEsIHk6IDJ9KTsgLy89PiBbMSwgMl1cbiAgICAgKiAgICAgIFIucHJvcHMoWydjJywgJ2EnLCAnYiddLCB7YjogMiwgYTogMX0pOyAvLz0+IFt1bmRlZmluZWQsIDEsIDJdXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBmdWxsTmFtZSA9IFIuY29tcG9zZShSLmpvaW4oJyAnKSwgUi5wcm9wcyhbJ2ZpcnN0JywgJ2xhc3QnXSkpO1xuICAgICAqICAgICAgZnVsbE5hbWUoe2xhc3Q6ICdCdWxsZXQtVG9vdGgnLCBhZ2U6IDMzLCBmaXJzdDogJ1RvbnknfSk7IC8vPT4gJ1RvbnkgQnVsbGV0LVRvb3RoJ1xuICAgICAqL1xuICAgIHZhciBwcm9wcyA9IF9jdXJyeTIoZnVuY3Rpb24gcHJvcHMocHMsIG9iaikge1xuICAgICAgICB2YXIgbGVuID0gcHMubGVuZ3RoO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBvdXRbaWR4XSA9IG9ialtwc1tpZHhdXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBudW1iZXJzIGZyb20gYGZyb21gIChpbmNsdXNpdmUpIHRvIGB0b2AgKGV4Y2x1c2l2ZSkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFtOdW1iZXJdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb20gVGhlIGZpcnN0IG51bWJlciBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG8gT25lIG1vcmUgdGhhbiB0aGUgbGFzdCBudW1iZXIgaW4gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIG51bWJlcnMgaW4gdHRoZSBzZXQgYFthLCBiKWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yYW5nZSgxLCA1KTsgICAgLy89PiBbMSwgMiwgMywgNF1cbiAgICAgKiAgICAgIFIucmFuZ2UoNTAsIDUzKTsgIC8vPT4gWzUwLCA1MSwgNTJdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gX2N1cnJ5MihmdW5jdGlvbiByYW5nZShmcm9tLCB0bykge1xuICAgICAgICBpZiAoIShfaXNOdW1iZXIoZnJvbSkgJiYgX2lzTnVtYmVyKHRvKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggYXJndW1lbnRzIHRvIHJhbmdlIG11c3QgYmUgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIG4gPSBmcm9tO1xuICAgICAgICB3aGlsZSAobiA8IHRvKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuKTtcbiAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICAgICAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIGByZWR1Y2VgLCBleGNlcHQgbW92ZXMgdGhyb3VnaCB0aGUgaW5wdXQgbGlzdCBmcm9tIHRoZSByaWdodCB0b1xuICAgICAqIHRoZSBsZWZ0LlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqXG4gICAgICpcbiAgICAgKiBOb3RlOiBgUi5yZWR1Y2VSaWdodGAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gICAgICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZC4gRm9yIG1vcmUgZGV0YWlsc1xuICAgICAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2VSaWdodCNEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsYiAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICAgICAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHBhaXJzID0gWyBbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdIF07XG4gICAgICogICAgICB2YXIgZmxhdHRlblBhaXJzID0gKGFjYywgcGFpcikgPT4gYWNjLmNvbmNhdChwYWlyKTtcbiAgICAgKlxuICAgICAqICAgICAgUi5yZWR1Y2VSaWdodChmbGF0dGVuUGFpcnMsIFtdLCBwYWlycyk7IC8vPT4gWyAnYycsIDMsICdiJywgMiwgJ2EnLCAxIF1cbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlUmlnaHQgPSBfY3VycnkzKGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBhY2MgPSBmbihhY2MsIGxpc3RbaWR4XSk7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHZhbHVlIHdyYXBwZWQgdG8gaW5kaWNhdGUgdGhhdCBpdCBpcyB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIHJlZHVjZVxuICAgICAqIGFuZCB0cmFuc2R1Y2UgZnVuY3Rpb25zLiBUaGUgcmV0dXJuZWQgdmFsdWUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBibGFja1xuICAgICAqIGJveDogdGhlIGludGVybmFsIHN0cnVjdHVyZSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzdGFibGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG9wdGltaXphdGlvbiBpcyB1bmF2YWlsYWJsZSB0byBmdW5jdGlvbnMgbm90IGV4cGxpY2l0bHkgbGlzdGVkXG4gICAgICogYWJvdmUuIEZvciBpbnN0YW5jZSwgaXQgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgcmVkdWNlUmlnaHQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE1LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiAqXG4gICAgICogQHBhcmFtIHsqfSB4IFRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgcmVkdWNlLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5yZWR1Y2UsIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZWR1Y2UoXG4gICAgICogICAgICAgIFIucGlwZShSLmFkZCwgUi53aGVuKFIuZ3RlKFIuX18sIDEwKSwgUi5yZWR1Y2VkKSksXG4gICAgICogICAgICAgIDAsXG4gICAgICogICAgICAgIFsxLCAyLCAzLCA0LCA1XSkgLy8gMTBcbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlZCA9IF9jdXJyeTEoX3JlZHVjZWQpO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3ViLWxpc3Qgb2YgYGxpc3RgIHN0YXJ0aW5nIGF0IGluZGV4IGBzdGFydGAgYW5kIGNvbnRhaW5pbmdcbiAgICAgKiBgY291bnRgIGVsZW1lbnRzLiBfTm90ZSB0aGF0IHRoaXMgaXMgbm90IGRlc3RydWN0aXZlXzogaXQgcmV0dXJucyBhIGNvcHkgb2ZcbiAgICAgKiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICAgICAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMlxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgVGhlIHBvc2l0aW9uIHRvIHN0YXJ0IHJlbW92aW5nIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byByZW1vdmUgZnJvbVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBBcnJheSB3aXRoIGBjb3VudGAgZWxlbWVudHMgZnJvbSBgc3RhcnRgIHJlbW92ZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZW1vdmUoMiwgMywgWzEsMiwzLDQsNSw2LDcsOF0pOyAvLz0+IFsxLDIsNiw3LDhdXG4gICAgICovXG4gICAgdmFyIHJlbW92ZSA9IF9jdXJyeTMoZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBjb3VudCwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChfc2xpY2UobGlzdCwgMCwgTWF0aC5taW4oc3RhcnQsIGxpc3QubGVuZ3RoKSksIF9zbGljZShsaXN0LCBNYXRoLm1pbihsaXN0Lmxlbmd0aCwgc3RhcnQgKyBjb3VudCkpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYSBzdWJzdHJpbmcgb3IgcmVnZXggbWF0Y2ggaW4gYSBzdHJpbmcgd2l0aCBhIHJlcGxhY2VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyBSZWdFeHB8U3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBwYXR0ZXJuIEEgcmVndWxhciBleHByZXNzaW9uIG9yIGEgc3Vic3RyaW5nIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIHJlcGxhY2UgdGhlIG1hdGNoZXMgd2l0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gZG8gdGhlIHNlYXJjaCBhbmQgcmVwbGFjZW1lbnQgaW4uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzdWx0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVwbGFjZSgnZm9vJywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgZm9vIGZvbydcbiAgICAgKiAgICAgIFIucmVwbGFjZSgvZm9vLywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgZm9vIGZvbydcbiAgICAgKlxuICAgICAqICAgICAgLy8gVXNlIHRoZSBcImdcIiAoZ2xvYmFsKSBmbGFnIHRvIHJlcGxhY2UgYWxsIG9jY3VycmVuY2VzOlxuICAgICAqICAgICAgUi5yZXBsYWNlKC9mb28vZywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgYmFyIGJhcidcbiAgICAgKi9cbiAgICB2YXIgcmVwbGFjZSA9IF9jdXJyeTMoZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgcmVwbGFjZW1lbnQsIHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIHJlcGxhY2VtZW50KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCBvciBzdHJpbmcgd2l0aCB0aGUgZWxlbWVudHMgb3IgY2hhcmFjdGVycyBpbiByZXZlcnNlXG4gICAgICogb3JkZXIuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZXZlcnNlKFsxLCAyLCAzXSk7ICAvLz0+IFszLCAyLCAxXVxuICAgICAqICAgICAgUi5yZXZlcnNlKFsxLCAyXSk7ICAgICAvLz0+IFsyLCAxXVxuICAgICAqICAgICAgUi5yZXZlcnNlKFsxXSk7ICAgICAgICAvLz0+IFsxXVxuICAgICAqICAgICAgUi5yZXZlcnNlKFtdKTsgICAgICAgICAvLz0+IFtdXG4gICAgICpcbiAgICAgKiAgICAgIFIucmV2ZXJzZSgnYWJjJyk7ICAgICAgLy89PiAnY2JhJ1xuICAgICAqICAgICAgUi5yZXZlcnNlKCdhYicpOyAgICAgICAvLz0+ICdiYSdcbiAgICAgKiAgICAgIFIucmV2ZXJzZSgnYScpOyAgICAgICAgLy89PiAnYSdcbiAgICAgKiAgICAgIFIucmV2ZXJzZSgnJyk7ICAgICAgICAgLy89PiAnJ1xuICAgICAqL1xuICAgIHZhciByZXZlcnNlID0gX2N1cnJ5MShmdW5jdGlvbiByZXZlcnNlKGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9pc1N0cmluZyhsaXN0KSA/IGxpc3Quc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IF9zbGljZShsaXN0KS5yZXZlcnNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTY2FuIGlzIHNpbWlsYXIgdG8gcmVkdWNlLCBidXQgcmV0dXJucyBhIGxpc3Qgb2Ygc3VjY2Vzc2l2ZWx5IHJlZHVjZWQgdmFsdWVzXG4gICAgICogZnJvbSB0aGUgbGVmdFxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhLGIgLT4gYSkgLT4gYSAtPiBbYl0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICAgICAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiBhbGwgaW50ZXJtZWRpYXRlbHkgcmVkdWNlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gICAgICogICAgICB2YXIgZmFjdG9yaWFscyA9IFIuc2NhbihSLm11bHRpcGx5LCAxLCBudW1iZXJzKTsgLy89PiBbMSwgMSwgMiwgNiwgMjRdXG4gICAgICovXG4gICAgdmFyIHNjYW4gPSBfY3VycnkzKGZ1bmN0aW9uIHNjYW4oZm4sIGFjYywgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW2FjY107XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIGFjYyA9IGZuKGFjYywgbGlzdFtpZHhdKTtcbiAgICAgICAgICAgIHJlc3VsdFtpZHggKyAxXSA9IGFjYztcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgXCJzZXR0aW5nXCIgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlXG4gICAgICogZm9jdXNlZCBieSB0aGUgZ2l2ZW4gbGVucyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIExlbnMgcyBhIC0+IGEgLT4gcyAtPiBzXG4gICAgICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gICAgICogQHBhcmFtIHsqfSB2XG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gICAgICpcbiAgICAgKiAgICAgIFIuc2V0KHhMZW5zLCA0LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogNCwgeTogMn1cbiAgICAgKiAgICAgIFIuc2V0KHhMZW5zLCA4LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogOCwgeTogMn1cbiAgICAgKi9cbiAgICB2YXIgc2V0ID0gX2N1cnJ5MyhmdW5jdGlvbiBzZXQobGVucywgdiwgeCkge1xuICAgICAgICByZXR1cm4gb3ZlcihsZW5zLCBhbHdheXModiksIHgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3Qgd2l0aCBhIGBzbGljZWBcbiAgICAgKiBtZXRob2QpIGZyb20gYGZyb21JbmRleGAgKGluY2x1c2l2ZSkgdG8gYHRvSW5kZXhgIChleGNsdXNpdmUpLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjRcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4IFRoZSBzdGFydCBpbmRleCAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4IChleGNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7Kn0gbGlzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zbGljZSgxLCAzLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgICAvLz0+IFsnYicsICdjJ11cbiAgICAgKiAgICAgIFIuc2xpY2UoMSwgSW5maW5pdHksIFsnYScsICdiJywgJ2MnLCAnZCddKTsgLy89PiBbJ2InLCAnYycsICdkJ11cbiAgICAgKiAgICAgIFIuc2xpY2UoMCwgLTEsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKiAgICAgIFIuc2xpY2UoLTMsIC0xLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgLy89PiBbJ2InLCAnYyddXG4gICAgICogICAgICBSLnNsaWNlKDAsIDMsICdyYW1kYScpOyAgICAgICAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAgICAgKi9cbiAgICB2YXIgc2xpY2UgPSBfY3VycnkzKF9jaGVja0Zvck1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShmcm9tSW5kZXgsIHRvSW5kZXgsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3QsIHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24sXG4gICAgICogd2hpY2ggc2hvdWxkIGFjY2VwdCB0d28gdmFsdWVzIGF0IGEgdGltZSBhbmQgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyIGlmIHRoZVxuICAgICAqIGZpcnN0IHZhbHVlIGlzIHNtYWxsZXIsIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGl0J3MgbGFyZ2VyLCBhbmQgemVybyBpZiB0aGV5XG4gICAgICogYXJlIGVxdWFsLiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgaXMgYSAqKmNvcHkqKiBvZiB0aGUgbGlzdC4gSXQgZG9lcyBub3RcbiAgICAgKiBtb2RpZnkgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsYSAtPiBOdW1iZXIpIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIEEgc29ydGluZyBmdW5jdGlvbiA6OiBhIC0+IGIgLT4gSW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0XG4gICAgICogQHJldHVybiB7QXJyYXl9IGEgbmV3IGFycmF5IHdpdGggaXRzIGVsZW1lbnRzIHNvcnRlZCBieSB0aGUgY29tcGFyYXRvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZGlmZiA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuICAgICAqICAgICAgUi5zb3J0KGRpZmYsIFs0LDIsNyw1XSk7IC8vPT4gWzIsIDQsIDUsIDddXG4gICAgICovXG4gICAgdmFyIHNvcnQgPSBfY3VycnkyKGZ1bmN0aW9uIHNvcnQoY29tcGFyYXRvciwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QpLnNvcnQoY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc29ydC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgbGlzdCBzb3J0ZWQgYnkgdGhlIGtleXMgZ2VuZXJhdGVkIGJ5IGBmbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNvcnRCeUZpcnN0SXRlbSA9IFIuc29ydEJ5KFIucHJvcCgwKSk7XG4gICAgICogICAgICB2YXIgc29ydEJ5TmFtZUNhc2VJbnNlbnNpdGl2ZSA9IFIuc29ydEJ5KFIuY29tcG9zZShSLnRvTG93ZXIsIFIucHJvcCgnbmFtZScpKSk7XG4gICAgICogICAgICB2YXIgcGFpcnMgPSBbWy0xLCAxXSwgWy0yLCAyXSwgWy0zLCAzXV07XG4gICAgICogICAgICBzb3J0QnlGaXJzdEl0ZW0ocGFpcnMpOyAvLz0+IFtbLTMsIDNdLCBbLTIsIDJdLCBbLTEsIDFdXVxuICAgICAqICAgICAgdmFyIGFsaWNlID0ge1xuICAgICAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICAgICAqICAgICAgICBhZ2U6IDEwMVxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBib2IgPSB7XG4gICAgICogICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAqICAgICAgICBhZ2U6IC0xMFxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBjbGFyYSA9IHtcbiAgICAgKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAgICAgKiAgICAgICAgYWdlOiAzMTQuMTU5XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdmFyIHBlb3BsZSA9IFtjbGFyYSwgYm9iLCBhbGljZV07XG4gICAgICogICAgICBzb3J0QnlOYW1lQ2FzZUluc2Vuc2l0aXZlKHBlb3BsZSk7IC8vPT4gW2FsaWNlLCBib2IsIGNsYXJhXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBfY3VycnkyKGZ1bmN0aW9uIHNvcnRCeShmbiwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhYSA9IGZuKGEpO1xuICAgICAgICAgICAgdmFyIGJiID0gZm4oYik7XG4gICAgICAgICAgICByZXR1cm4gYWEgPCBiYiA/IC0xIDogYWEgPiBiYiA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFtTdHJpbmcsIFN0cmluZ11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBhcnJheS9zdHJpbmcgaXMgc3BsaXQuXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFycmF5IFRoZSBhcnJheS9zdHJpbmcgdG8gYmUgc3BsaXQuXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zcGxpdEF0KDEsIFsxLCAyLCAzXSk7ICAgICAgICAgIC8vPT4gW1sxXSwgWzIsIDNdXVxuICAgICAqICAgICAgUi5zcGxpdEF0KDUsICdoZWxsbyB3b3JsZCcpOyAgICAgIC8vPT4gWydoZWxsbycsICcgd29ybGQnXVxuICAgICAqICAgICAgUi5zcGxpdEF0KC0xLCAnZm9vYmFyJyk7ICAgICAgICAgIC8vPT4gWydmb29iYScsICdyJ11cbiAgICAgKi9cbiAgICB2YXIgc3BsaXRBdCA9IF9jdXJyeTIoZnVuY3Rpb24gc3BsaXRBdChpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNsaWNlKDAsIGluZGV4LCBhcnJheSksXG4gICAgICAgICAgICBzbGljZShpbmRleCwgbGVuZ3RoKGFycmF5KSwgYXJyYXkpXG4gICAgICAgIF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBjb2xsZWN0aW9uIGludG8gc2xpY2VzIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW1thXV1cbiAgICAgKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnNwbGl0RXZlcnkoMywgWzEsIDIsIDMsIDQsIDUsIDYsIDddKTsgLy89PiBbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3XV1cbiAgICAgKiAgICAgIFIuc3BsaXRFdmVyeSgzLCAnZm9vYmFyYmF6Jyk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gICAgICovXG4gICAgdmFyIHNwbGl0RXZlcnkgPSBfY3VycnkyKGZ1bmN0aW9uIHNwbGl0RXZlcnkobiwgbGlzdCkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHNwbGl0RXZlcnkgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsaWNlKGlkeCwgaWR4ICs9IG4sIGxpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBsaXN0IGFuZCBhIHByZWRpY2F0ZSBhbmQgcmV0dXJucyBhIHBhaXIgb2YgbGlzdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiAgLSB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIHR3byBvdXRwdXQgbGlzdHMgaXMgZXF1aXZhbGVudCB0byB0aGUgaW5wdXQgbGlzdDtcbiAgICAgKiAgLSBub25lIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZmlyc3Qgb3V0cHV0IGxpc3Qgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IGFuZFxuICAgICAqICAtIGlmIHRoZSBzZWNvbmQgb3V0cHV0IGxpc3QgaXMgbm9uLWVtcHR5LCBpdHMgZmlyc3QgZWxlbWVudCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW1thXSwgW2FdXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgVGhlIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMgd2hlcmUgdGhlIGFycmF5IGlzIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGJlIHNwbGl0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuc3BsaXRXaGVuKFIuZXF1YWxzKDIpLCBbMSwgMiwgMywgMSwgMiwgM10pOyAgIC8vPT4gW1sxXSwgWzIsIDMsIDEsIDIsIDNdXVxuICAgICAqL1xuICAgIHZhciBzcGxpdFdoZW4gPSBfY3VycnkyKGZ1bmN0aW9uIHNwbGl0V2hlbihwcmVkLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBwcmVmaXggPSBbXTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbiAmJiAhcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBwcmVmaXgucHVzaChsaXN0W2lkeF0pO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIF9zbGljZShsaXN0LCBpZHgpXG4gICAgICAgIF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgaXRzIHNlY29uZCBhcmd1bWVudCBmcm9tIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhIC0gYmAuXG4gICAgICogQHNlZSBSLmFkZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuc3VidHJhY3QoMTAsIDgpOyAvLz0+IDJcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1pbnVzNSA9IFIuc3VidHJhY3QoUi5fXywgNSk7XG4gICAgICogICAgICBtaW51czUoMTcpOyAvLz0+IDEyXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjb21wbGVtZW50YXJ5QW5nbGUgPSBSLnN1YnRyYWN0KDkwKTtcbiAgICAgKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSgzMCk7IC8vPT4gNjBcbiAgICAgKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSg3Mik7IC8vPT4gMThcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBfY3VycnkyKGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcgKG9yIG9iamVjdFxuICAgICAqIHdpdGggYSBgdGFpbGAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV1cbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5oZWFkLCBSLmluaXQsIFIubGFzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudGFpbChbMSwgMiwgM10pOyAgLy89PiBbMiwgM11cbiAgICAgKiAgICAgIFIudGFpbChbMSwgMl0pOyAgICAgLy89PiBbMl1cbiAgICAgKiAgICAgIFIudGFpbChbMV0pOyAgICAgICAgLy89PiBbXVxuICAgICAqICAgICAgUi50YWlsKFtdKTsgICAgICAgICAvLz0+IFtdXG4gICAgICpcbiAgICAgKiAgICAgIFIudGFpbCgnYWJjJyk7ICAvLz0+ICdiYydcbiAgICAgKiAgICAgIFIudGFpbCgnYWInKTsgICAvLz0+ICdiJ1xuICAgICAqICAgICAgUi50YWlsKCdhJyk7ICAgIC8vPT4gJydcbiAgICAgKiAgICAgIFIudGFpbCgnJyk7ICAgICAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIHRhaWwgPSBfY2hlY2tGb3JNZXRob2QoJ3RhaWwnLCBzbGljZSgxLCBJbmZpbml0eSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gICAgICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgdGFrZWAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIuZHJvcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudGFrZSgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJ11cbiAgICAgKiAgICAgIFIudGFrZSgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gICAgICogICAgICBSLnRha2UoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAgICAgKiAgICAgIFIudGFrZSg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlKDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHBlcnNvbm5lbCA9IFtcbiAgICAgKiAgICAgICAgJ0RhdmUgQnJ1YmVjaycsXG4gICAgICogICAgICAgICdQYXVsIERlc21vbmQnLFxuICAgICAqICAgICAgICAnRXVnZW5lIFdyaWdodCcsXG4gICAgICogICAgICAgICdKb2UgTW9yZWxsbycsXG4gICAgICogICAgICAgICdHZXJyeSBNdWxsaWdhbicsXG4gICAgICogICAgICAgICdCb2IgQmF0ZXMnLFxuICAgICAqICAgICAgICAnSm9lIERvZGdlJyxcbiAgICAgKiAgICAgICAgJ1JvbiBDcm90dHknXG4gICAgICogICAgICBdO1xuICAgICAqXG4gICAgICogICAgICB2YXIgdGFrZUZpdmUgPSBSLnRha2UoNSk7XG4gICAgICogICAgICB0YWtlRml2ZShwZXJzb25uZWwpO1xuICAgICAqICAgICAgLy89PiBbJ0RhdmUgQnJ1YmVjaycsICdQYXVsIERlc21vbmQnLCAnRXVnZW5lIFdyaWdodCcsICdKb2UgTW9yZWxsbycsICdHZXJyeSBNdWxsaWdhbiddXG4gICAgICovXG4gICAgdmFyIHRha2UgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ3Rha2UnLCBfeHRha2UsIGZ1bmN0aW9uIHRha2UobiwgeHMpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKDAsIG4gPCAwID8gSW5maW5pdHkgOiBuLCB4cyk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgcGFzc2luZ1xuICAgICAqIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW4gdGhlXG4gICAgICogcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC4gRXhjbHVkZXMgdGhlIGVsZW1lbnQgdGhhdCBjYXVzZWQgdGhlXG4gICAgICogcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDpcbiAgICAgKiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gICAgICogQHNlZSBSLmRyb3BMYXN0V2hpbGUsIFIuYWRkSW5kZXhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaXNOb3RPbmUgPSB4ID0+IHggIT09IDE7XG4gICAgICpcbiAgICAgKiAgICAgIFIudGFrZUxhc3RXaGlsZShpc05vdE9uZSwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICB2YXIgdGFrZUxhc3RXaGlsZSA9IF9jdXJyeTIoZnVuY3Rpb24gdGFrZUxhc3RXaGlsZShmbiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDAgJiYgZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zbGljZShsaXN0LCBpZHggKyAxLCBJbmZpbml0eSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCxcbiAgICAgKiBwYXNzaW5nIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW5cbiAgICAgKiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC4gRXhjbHVkZXMgdGhlIGVsZW1lbnQgdGhhdCBjYXVzZWQgdGhlXG4gICAgICogcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDpcbiAgICAgKiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgdGFrZVdoaWxlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi5kcm9wV2hpbGUsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzTm90Rm91ciA9IHggPT4geCAhPT0gNDtcbiAgICAgKlxuICAgICAqICAgICAgUi50YWtlV2hpbGUoaXNOb3RGb3VyLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciB0YWtlV2hpbGUgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ3Rha2VXaGlsZScsIF94dGFrZVdoaWxlLCBmdW5jdGlvbiB0YWtlV2hpbGUoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbiAmJiBmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QsIDAsIGlkeCk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoYSAtPiAqKSAtPiBhIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGB4YC4gVGhlIHJldHVybiB2YWx1ZSBvZiBgZm5gIHdpbGwgYmUgdGhyb3duIGF3YXkuXG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn0gYHhgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzYXlYID0geCA9PiBjb25zb2xlLmxvZygneCBpcyAnICsgeCk7XG4gICAgICogICAgICBSLnRhcChzYXlYLCAxMDApOyAvLz0+IDEwMFxuICAgICAqICAgICAgLy8tPiAneCBpcyAxMDAnXG4gICAgICovXG4gICAgdmFyIHRhcCA9IF9jdXJyeTIoZnVuY3Rpb24gdGFwKGZuLCB4KSB7XG4gICAgICAgIGZuKHgpO1xuICAgICAgICByZXR1cm4geDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENhbGxzIGFuIGlucHV0IGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiB0aG9zZSBmdW5jdGlvbiBjYWxscy5cbiAgICAgKlxuICAgICAqIGBmbmAgaXMgcGFzc2VkIG9uZSBhcmd1bWVudDogVGhlIGN1cnJlbnQgdmFsdWUgb2YgYG5gLCB3aGljaCBiZWdpbnMgYXQgYDBgXG4gICAgICogYW5kIGlzIGdyYWR1YWxseSBpbmNyZW1lbnRlZCB0byBgbiAtIDFgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yLjNcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKE51bWJlciAtPiBhKSAtPiBOdW1iZXIgLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUGFzc2VkIG9uZSBhcmd1bWVudCwgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYG5gLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGBuIC0gMWAuIEluY3JlbWVudHMgYWZ0ZXIgZWFjaCBmdW5jdGlvbiBjYWxsLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCBjYWxscyB0byBgZm5gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudGltZXMoUi5pZGVudGl0eSwgNSk7IC8vPT4gWzAsIDEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgdmFyIHRpbWVzID0gX2N1cnJ5MihmdW5jdGlvbiB0aW1lcyhmbiwgbikge1xuICAgICAgICB2YXIgbGVuID0gTnVtYmVyKG4pO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgIGlmIChsZW4gPCAwIHx8IGlzTmFOKGxlbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCduIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdCA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBsaXN0W2lkeF0gPSBmbihpZHgpO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gT25seSB0aGUgb2JqZWN0J3NcbiAgICAgKiBvd24gcHJvcGVydGllcyBhcmUgdXNlZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICAgICAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmcm9tXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzIGZyb20gdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAgICAqIEBzZWUgUi5mcm9tUGFpcnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRvUGFpcnMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV1cbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IF9jdXJyeTEoZnVuY3Rpb24gdG9QYWlycyhvYmopIHtcbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gVGhlIG9iamVjdCdzIG93blxuICAgICAqIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFyZSB1c2VkLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZVxuICAgICAqIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50IGFjcm9zcyBkaWZmZXJlbnQgSlNcbiAgICAgKiBwbGF0Zm9ybXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtTdHJpbmc6ICp9IC0+IFtbU3RyaW5nLCpdXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMgZnJvbSB0aGUgb2JqZWN0J3Mgb3duXG4gICAgICogICAgICAgICBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICAgICAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAgICAgKiAgICAgIHZhciBmID0gbmV3IEYoKTtcbiAgICAgKiAgICAgIFIudG9QYWlyc0luKGYpOyAvLz0+IFtbJ3gnLCdYJ10sIFsneScsJ1knXV1cbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gX2N1cnJ5MShmdW5jdGlvbiB0b1BhaXJzSW4ob2JqKSB7XG4gICAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtcbiAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgIG9ialtwcm9wXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIGEgMkQgbGlzdC5cbiAgICAgKiBXaGVuIHBhc3NlZCBhIGxpc3Qgb2YgYG5gIGxpc3RzIG9mIGxlbmd0aCBgeGAsXG4gICAgICogcmV0dXJucyBhIGxpc3Qgb2YgYHhgIGxpc3RzIG9mIGxlbmd0aCBgbmAuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbW2FdXSAtPiBbW2FdXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQSAyRCBsaXN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgMkQgbGlzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudHJhbnNwb3NlKFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXSkgLy89PiBbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dXG4gICAgICogICAgICBSLnRyYW5zcG9zZShbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dKSAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICAgICAqXG4gICAgICogSWYgc29tZSBvZiB0aGUgcm93cyBhcmUgc2hvcnRlciB0aGFuIHRoZSBmb2xsb3dpbmcgcm93cywgdGhlaXIgZWxlbWVudHMgYXJlIHNraXBwZWQ6XG4gICAgICpcbiAgICAgKiAgICAgIFIudHJhbnNwb3NlKFtbMTAsIDExXSwgWzIwXSwgW10sIFszMCwgMzEsIDMyXV0pIC8vPT4gW1sxMCwgMjAsIDMwXSwgWzExLCAzMV0sIFszMl1dXG4gICAgICovXG4gICAgdmFyIHRyYW5zcG9zZSA9IF9jdXJyeTEoZnVuY3Rpb24gdHJhbnNwb3NlKG91dGVybGlzdCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGkgPCBvdXRlcmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJsaXN0ID0gb3V0ZXJsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBpbm5lcmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbal0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbal0ucHVzaChpbm5lcmxpc3Rbal0pO1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyAoc3RyaXBzKSB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHRoZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRyaW1tZWQgdmVyc2lvbiBvZiBgc3RyYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRyaW0oJyAgIHh5eiAgJyk7IC8vPT4gJ3h5eidcbiAgICAgKiAgICAgIFIubWFwKFIudHJpbSwgUi5zcGxpdCgnLCcsICd4LCB5LCB6JykpOyAvLz0+IFsneCcsICd5JywgJ3onXVxuICAgICAqL1xuICAgIHZhciB0cmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3MgPSAnXFx0XFxuXFx4MEJcXGZcXHIgXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICsgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArICdcXHUyMDI5XFx1RkVGRic7XG4gICAgICAgIHZhciB6ZXJvV2lkdGggPSAnXFx1MjAwQic7XG4gICAgICAgIHZhciBoYXNQcm90b1RyaW0gPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoIWhhc1Byb3RvVHJpbSB8fCAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVnaW5SeCA9IG5ldyBSZWdFeHAoJ15bJyArIHdzICsgJ11bJyArIHdzICsgJ10qJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFJ4ID0gbmV3IFJlZ0V4cCgnWycgKyB3cyArICddWycgKyB3cyArICddKiQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYmVnaW5SeCwgJycpLnJlcGxhY2UoZW5kUngsICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYHRyeUNhdGNoYCB0YWtlcyB0d28gZnVuY3Rpb25zLCBhIGB0cnllcmAgYW5kIGEgYGNhdGNoZXJgLiBUaGUgcmV0dXJuZWRcbiAgICAgKiBmdW5jdGlvbiBldmFsdWF0ZXMgdGhlIGB0cnllcmA7IGlmIGl0IGRvZXMgbm90IHRocm93LCBpdCBzaW1wbHkgcmV0dXJucyB0aGVcbiAgICAgKiByZXN1bHQuIElmIHRoZSBgdHJ5ZXJgICpkb2VzKiB0aHJvdywgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0aGVcbiAgICAgKiBgY2F0Y2hlcmAgZnVuY3Rpb24gYW5kIHJldHVybnMgaXRzIHJlc3VsdC4gTm90ZSB0aGF0IGZvciBlZmZlY3RpdmVcbiAgICAgKiBjb21wb3NpdGlvbiB3aXRoIHRoaXMgZnVuY3Rpb24sIGJvdGggdGhlIGB0cnllcmAgYW5kIGBjYXRjaGVyYCBmdW5jdGlvbnNcbiAgICAgKiBtdXN0IHJldHVybiB0aGUgc2FtZSB0eXBlIG9mIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICguLi54IC0+IGEpIC0+ICgoZSwgLi4ueCkgLT4gYSkgLT4gKC4uLnggLT4gYSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cnllciBUaGUgZnVuY3Rpb24gdGhhdCBtYXkgdGhyb3cuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2F0Y2hlciBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCBpZiBgdHJ5ZXJgIHRocm93cy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIGNhdGNoIGV4Y2VwdGlvbnMgYW5kIHNlbmQgdGhlbiB0byB0aGUgY2F0Y2hlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRyeUNhdGNoKFIucHJvcCgneCcpLCBSLkYsIHt4OiB0cnVlfSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi50cnlDYXRjaChSLnByb3AoJ3gnKSwgUi5GLCBudWxsKTsgICAgICAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIHRyeUNhdGNoID0gX2N1cnJ5MihmdW5jdGlvbiBfdHJ5Q2F0Y2godHJ5ZXIsIGNhdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIF9hcml0eSh0cnllci5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdGNoZXIuYXBwbHkodGhpcywgX2NvbmNhdChbZV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVzIGEgc2luZ2xlLXdvcmQgc3RyaW5nIGRlc2NyaXB0aW9uIG9mIHRoZSAobmF0aXZlKSB0eXBlIG9mIGEgdmFsdWUsXG4gICAgICogcmV0dXJuaW5nIHN1Y2ggYW5zd2VycyBhcyAnT2JqZWN0JywgJ051bWJlcicsICdBcnJheScsIG9yICdOdWxsJy4gRG9lcyBub3RcbiAgICAgKiBhdHRlbXB0IHRvIGRpc3Rpbmd1aXNoIHVzZXIgT2JqZWN0IHR5cGVzIGFueSBmdXJ0aGVyLCByZXBvcnRpbmcgdGhlbSBhbGwgYXNcbiAgICAgKiAnT2JqZWN0Jy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOC4wXG4gICAgICogQGNhdGVnb3J5IFR5cGVcbiAgICAgKiBAc2lnICgqIC0+IHsqfSkgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50eXBlKHt9KTsgLy89PiBcIk9iamVjdFwiXG4gICAgICogICAgICBSLnR5cGUoMSk7IC8vPT4gXCJOdW1iZXJcIlxuICAgICAqICAgICAgUi50eXBlKGZhbHNlKTsgLy89PiBcIkJvb2xlYW5cIlxuICAgICAqICAgICAgUi50eXBlKCdzJyk7IC8vPT4gXCJTdHJpbmdcIlxuICAgICAqICAgICAgUi50eXBlKG51bGwpOyAvLz0+IFwiTnVsbFwiXG4gICAgICogICAgICBSLnR5cGUoW10pOyAvLz0+IFwiQXJyYXlcIlxuICAgICAqICAgICAgUi50eXBlKC9bQS16XS8pOyAvLz0+IFwiUmVnRXhwXCJcbiAgICAgKi9cbiAgICB2YXIgdHlwZSA9IF9jdXJyeTEoZnVuY3Rpb24gdHlwZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/ICdOdWxsJyA6IHZhbCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGZ1bmN0aW9uIGBmbmAsIHdoaWNoIHRha2VzIGEgc2luZ2xlIGFycmF5IGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhXG4gICAgICogZnVuY3Rpb24gd2hpY2g6XG4gICAgICpcbiAgICAgKiAgIC0gdGFrZXMgYW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cztcbiAgICAgKiAgIC0gcGFzc2VzIHRoZXNlIGFyZ3VtZW50cyB0byBgZm5gIGFzIGFuIGFycmF5OyBhbmRcbiAgICAgKiAgIC0gcmV0dXJucyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogSW4gb3RoZXIgd29yZHMsIFIudW5hcHBseSBkZXJpdmVzIGEgdmFyaWFkaWMgZnVuY3Rpb24gZnJvbSBhIGZ1bmN0aW9uIHdoaWNoXG4gICAgICogdGFrZXMgYW4gYXJyYXkuIFIudW5hcHBseSBpcyB0aGUgaW52ZXJzZSBvZiBSLmFwcGx5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIChbKi4uLl0gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5hcHBseVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5hcHBseShKU09OLnN0cmluZ2lmeSkoMSwgMiwgMyk7IC8vPT4gJ1sxLDIsM10nXG4gICAgICovXG4gICAgdmFyIHVuYXBwbHkgPSBfY3VycnkxKGZ1bmN0aW9uIHVuYXBwbHkoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbihfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gICAgICogZXhhY3RseSAxIHBhcmFtZXRlci4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCogLT4gYikgLT4gKGEgLT4gYilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gICAgICogICAgICAgICBhcml0eSAxLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICAgICAgIHJldHVybiBbYSwgYl07XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gICAgICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMik7IC8vPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc09uZUFyZyA9IFIudW5hcnkodGFrZXNUd29BcmdzKTtcbiAgICAgKiAgICAgIHRha2VzT25lQXJnLmxlbmd0aDsgLy89PiAxXG4gICAgICogICAgICAvLyBPbmx5IDEgYXJndW1lbnQgaXMgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gICAgICogICAgICB0YWtlc09uZUFyZygxLCAyKTsgLy89PiBbMSwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIHZhciB1bmFyeSA9IF9jdXJyeTEoZnVuY3Rpb24gdW5hcnkoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5BcnkoMSwgZm4pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIG9mIGFyaXR5IGBuYCBmcm9tIGEgKG1hbnVhbGx5KSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBOdW1iZXIgLT4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB1bmN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIFIuY3VycnlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWRkRm91ciA9IGEgPT4gYiA9PiBjID0+IGQgPT4gYSArIGIgKyBjICsgZDtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHVuY3VycmllZEFkZEZvdXIgPSBSLnVuY3VycnlOKDQsIGFkZEZvdXIpO1xuICAgICAqICAgICAgdW5jdXJyaWVkQWRkRm91cigxLCAyLCAzLCA0KTsgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciB1bmN1cnJ5TiA9IF9jdXJyeTIoZnVuY3Rpb24gdW5jdXJyeU4oZGVwdGgsIGZuKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4oZGVwdGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGVwdGggPSAxO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZm47XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBlbmRJZHg7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudERlcHRoIDw9IGRlcHRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVuZElkeCA9IGN1cnJlbnREZXB0aCA9PT0gZGVwdGggPyBhcmd1bWVudHMubGVuZ3RoIDogaWR4ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkodGhpcywgX3NsaWNlKGFyZ3VtZW50cywgaWR4LCBlbmRJZHgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGVwdGggKz0gMTtcbiAgICAgICAgICAgICAgICBpZHggPSBlbmRJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgbGlzdCBmcm9tIGEgc2VlZCB2YWx1ZS4gQWNjZXB0cyBhbiBpdGVyYXRvciBmdW5jdGlvbiwgd2hpY2ggcmV0dXJuc1xuICAgICAqIGVpdGhlciBmYWxzZSB0byBzdG9wIGl0ZXJhdGlvbiBvciBhbiBhcnJheSBvZiBsZW5ndGggMiBjb250YWluaW5nIHRoZSB2YWx1ZVxuICAgICAqIHRvIGFkZCB0byB0aGUgcmVzdWx0aW5nIGxpc3QgYW5kIHRoZSBzZWVkIHRvIGJlIHVzZWQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGVcbiAgICAgKiBpdGVyYXRvciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyBvbmUgYXJndW1lbnQ6ICooc2VlZCkqLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFtiXSkgLT4gKiAtPiBbYl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYHNlZWRgLCBhbmQgcmV0dXJuc1xuICAgICAqICAgICAgICBlaXRoZXIgZmFsc2UgdG8gcXVpdCBpdGVyYXRpb24gb3IgYW4gYXJyYXkgb2YgbGVuZ3RoIHR3byB0byBwcm9jZWVkLiBUaGUgZWxlbWVudFxuICAgICAqICAgICAgICBhdCBpbmRleCAwIG9mIHRoaXMgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIGFycmF5LCBhbmQgdGhlIGVsZW1lbnRcbiAgICAgKiAgICAgICAgYXQgaW5kZXggMSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbmV4dCBjYWxsIHRvIGBmbmAuXG4gICAgICogQHBhcmFtIHsqfSBzZWVkIFRoZSBzZWVkIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmluYWwgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZiA9IG4gPT4gbiA+IDUwID8gZmFsc2UgOiBbLW4sIG4gKyAxMF07XG4gICAgICogICAgICBSLnVuZm9sZChmLCAxMCk7IC8vPT4gWy0xMCwgLTIwLCAtMzAsIC00MCwgLTUwXVxuICAgICAqL1xuICAgIHZhciB1bmZvbGQgPSBfY3VycnkyKGZ1bmN0aW9uIHVuZm9sZChmbiwgc2VlZCkge1xuICAgICAgICB2YXIgcGFpciA9IGZuKHNlZWQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChwYWlyICYmIHBhaXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBwYWlyWzBdO1xuICAgICAgICAgICAgcGFpciA9IGZuKHBhaXJbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgKiBsaXN0LCBiYXNlZCB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvXG4gICAgICogdHdvIGxpc3QgZWxlbWVudHMuIFByZWZlcnMgdGhlIGZpcnN0IGl0ZW0gaWYgdHdvIGl0ZW1zIGNvbXBhcmUgZXF1YWwgYmFzZWRcbiAgICAgKiBvbiB0aGUgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsIGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzdHJFcSA9IFIuZXFCeShTdHJpbmcpO1xuICAgICAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoWzEsICcxJywgMiwgMV0pOyAvLz0+IFsxLCAyXVxuICAgICAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoW3t9LCB7fV0pOyAgICAgICAvLz0+IFt7fV1cbiAgICAgKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsxLCAnMScsIDFdKTsgICAgLy89PiBbMV1cbiAgICAgKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsnMScsIDEsIDFdKTsgICAgLy89PiBbJzEnXVxuICAgICAqL1xuICAgIHZhciB1bmlxV2l0aCA9IF9jdXJyeTIoZnVuY3Rpb24gdW5pcVdpdGgocHJlZCwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgaWYgKCFfY29udGFpbnNXaXRoKHByZWQsIGl0ZW0sIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gICAgICogdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICAgICAqIGNhbGxpbmcgdGhlIGB3aGVuRmFsc2VGbmAgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBhcmd1bWVudC4gSWYgdGhlIHByZWRpY2F0ZVxuICAgICAqIGlzIHNhdGlzZmllZCwgdGhlIGFyZ3VtZW50IGlzIHJldHVybmVkIGFzIGlzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOC4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkICAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdoZW5GYWxzZUZuIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBwcmVkYCBldmFsdWF0ZXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIGZhbHN5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgIHggICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzIHRvIGB3aGVuRmFsc2VGbmAgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEByZXR1cm4geyp9IEVpdGhlciBgeGAgb3IgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgeGAgdG8gYHdoZW5GYWxzZUZuYC5cbiAgICAgKiBAc2VlIFIuaWZFbHNlLCBSLndoZW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBjb2VyY2VBcnJheSA6OiAoYXxbYV0pIC0+IFthXVxuICAgICAqICAgICAgdmFyIGNvZXJjZUFycmF5ID0gUi51bmxlc3MoUi5pc0FycmF5TGlrZSwgUi5vZik7XG4gICAgICogICAgICBjb2VyY2VBcnJheShbMSwgMiwgM10pOyAvLz0+IFsxLCAyLCAzXVxuICAgICAqICAgICAgY29lcmNlQXJyYXkoMSk7ICAgICAgICAgLy89PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgdW5sZXNzID0gX2N1cnJ5MyhmdW5jdGlvbiB1bmxlc3MocHJlZCwgd2hlbkZhbHNlRm4sIHgpIHtcbiAgICAgICAgcmV0dXJuIHByZWQoeCkgPyB4IDogd2hlbkZhbHNlRm4oeCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHByZWRpY2F0ZSwgYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiwgYW5kIGFuIGluaXRpYWwgdmFsdWUsXG4gICAgICogYW5kIHJldHVybnMgYSB2YWx1ZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEl0IGRvZXMgc28gYnkgYXBwbHlpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIHVudGlsIHRoZSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkLFxuICAgICAqIGF0IHdoaWNoIHBvaW50IGl0IHJldHVybnMgdGhlIHNhdGlzZmFjdG9yeSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMjAuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gaW5pdCBJbml0aWFsIHZhbHVlXG4gICAgICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWUgdGhhdCBzYXRpc2ZpZXMgcHJlZGljYXRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi51bnRpbChSLmd0KFIuX18sIDEwMCksIFIubXVsdGlwbHkoMikpKDEpIC8vID0+IDEyOFxuICAgICAqL1xuICAgIHZhciB1bnRpbCA9IF9jdXJyeTMoZnVuY3Rpb24gdW50aWwocHJlZCwgZm4sIGluaXQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGluaXQ7XG4gICAgICAgIHdoaWxlICghcHJlZCh2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSBmbih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGNvcHkgb2YgdGhlIGFycmF5IHdpdGggdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4XG4gICAgICogcmVwbGFjZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IGEgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIGV4aXN0IGF0IHRoZSBnaXZlbiBpbmRleCBvZiB0aGUgcmV0dXJuZWQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IGxpc3QgVGhlIHNvdXJjZSBhcnJheS1saWtlIG9iamVjdCB0byBiZSB1cGRhdGVkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgYGxpc3RgIHdpdGggdGhlIHZhbHVlIGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggYHhgLlxuICAgICAqIEBzZWUgUi5hZGp1c3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnVwZGF0ZSgxLCAxMSwgWzAsIDEsIDJdKTsgICAgIC8vPT4gWzAsIDExLCAyXVxuICAgICAqICAgICAgUi51cGRhdGUoMSkoMTEpKFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAgICAgKi9cbiAgICB2YXIgdXBkYXRlID0gX2N1cnJ5MyhmdW5jdGlvbiB1cGRhdGUoaWR4LCB4LCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBhZGp1c3QoYWx3YXlzKHgpLCBpZHgsIGxpc3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIGZ1bmN0aW9uIGBmbmAgYW5kIGEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnMgYW5kIHJldHVybnMgYVxuICAgICAqIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLiBXaGVuIHRoZSBuZXcgZnVuY3Rpb24gaXMgaW52b2tlZCwgaXQgY2FsbHMgdGhlXG4gICAgICogZnVuY3Rpb24gYGZuYCB3aXRoIHBhcmFtZXRlcnMgY29uc2lzdGluZyBvZiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZWFjaFxuICAgICAqIHN1cHBsaWVkIGhhbmRsZXIgb24gc3VjY2Vzc2l2ZSBhcmd1bWVudHMgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIElmIG1vcmUgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRoYW4gdHJhbnNmb3JtZXJcbiAgICAgKiBmdW5jdGlvbnMsIHRob3NlIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGRpcmVjdGx5IHRvIGBmbmAgYXMgYWRkaXRpb25hbFxuICAgICAqIHBhcmFtZXRlcnMuIElmIHlvdSBleHBlY3QgYWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBkb24ndCBuZWVkIHRvIGJlXG4gICAgICogdHJhbnNmb3JtZWQsIGFsdGhvdWdoIHlvdSBjYW4gaWdub3JlIHRoZW0sIGl0J3MgYmVzdCB0byBwYXNzIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gc28gdGhhdCB0aGUgbmV3IGZ1bmN0aW9uIHJlcG9ydHMgdGhlIGNvcnJlY3QgYXJpdHkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKHgxIC0+IHgyIC0+IC4uLiAtPiB6KSAtPiBbKGEgLT4geDEpLCAoYiAtPiB4MiksIC4uLl0gLT4gKGEgLT4gYiAtPiAuLi4gLT4geilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1lcnMgQSBsaXN0IG9mIHRyYW5zZm9ybWVyIGZ1bmN0aW9uc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmlkZW50aXR5LCBSLmlkZW50aXR5XSkoMywgNCk7IC8vPT4gODFcbiAgICAgKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuaWRlbnRpdHksIFIuaWRlbnRpdHldKSgzKSg0KTsgLy89PiA4MVxuICAgICAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMywgNCk7IC8vPT4gMzJcbiAgICAgKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuZGVjLCBSLmluY10pKDMpKDQpOyAvLz0+IDMyXG4gICAgICovXG4gICAgdmFyIHVzZVdpdGggPSBfY3VycnkyKGZ1bmN0aW9uIHVzZVdpdGgoZm4sIHRyYW5zZm9ybWVycykge1xuICAgICAgICByZXR1cm4gY3VycnlOKHRyYW5zZm9ybWVycy5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCB0cmFuc2Zvcm1lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHRyYW5zZm9ybWVyc1tpZHhdLmNhbGwodGhpcywgYXJndW1lbnRzW2lkeF0pKTtcbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChfc2xpY2UoYXJndW1lbnRzLCB0cmFuc2Zvcm1lcnMubGVuZ3RoKSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0LlxuICAgICAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZGlmZmVyZW50XG4gICAgICogSlMgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7azogdn0gLT4gW3ZdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgdmFsdWVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi52YWx1ZXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgdmFsdWVzID0gX2N1cnJ5MShmdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHNbaWR4XSA9IG9ialtwcm9wc1tpZHhdXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgcHJvdG90eXBlIHByb3BlcnRpZXMsIG9mIHRoZVxuICAgICAqIHN1cHBsaWVkIG9iamVjdC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICAgICAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7azogdn0gLT4gW3ZdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgdmFsdWVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIGFuZCBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkgeyB0aGlzLnggPSAnWCc7IH07XG4gICAgICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICAgICAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICAgICAqICAgICAgUi52YWx1ZXNJbihmKTsgLy89PiBbJ1gnLCAnWSddXG4gICAgICovXG4gICAgdmFyIHZhbHVlc0luID0gX2N1cnJ5MShmdW5jdGlvbiB2YWx1ZXNJbihvYmopIHtcbiAgICAgICAgdmFyIHByb3A7XG4gICAgICAgIHZhciB2cyA9IFtdO1xuICAgICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICB2c1t2cy5sZW5ndGhdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2cztcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBcInZpZXdcIiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmUsIGRldGVybWluZWQgYnkgdGhlIGdpdmVuIGxlbnMuXG4gICAgICogVGhlIGxlbnMncyBmb2N1cyBkZXRlcm1pbmVzIHdoaWNoIHBvcnRpb24gb2YgdGhlIGRhdGEgc3RydWN0dXJlIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIExlbnMgcyBhIC0+IHMgLT4gYVxuICAgICAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICAgICAqXG4gICAgICogICAgICBSLnZpZXcoeExlbnMsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IDFcbiAgICAgKiAgICAgIFIudmlldyh4TGVucywge3g6IDQsIHk6IDJ9KTsgIC8vPT4gNFxuICAgICAqL1xuICAgIC8vIGBDb25zdGAgaXMgYSBmdW5jdG9yIHRoYXQgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgZnVuY3Rpb24gZ2l2ZW4gdG8gYG1hcGAuXG4gICAgLy8gVXNpbmcgYENvbnN0YCBlZmZlY3RpdmVseSBpZ25vcmVzIHRoZSBzZXR0ZXIgZnVuY3Rpb24gb2YgdGhlIGBsZW5zYCxcbiAgICAvLyBsZWF2aW5nIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIHVubW9kaWZpZWQuXG4gICAgdmFyIHZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGBDb25zdGAgaXMgYSBmdW5jdG9yIHRoYXQgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgZnVuY3Rpb24gZ2l2ZW4gdG8gYG1hcGAuXG4gICAgICAgIHZhciBDb25zdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgICAgICAgIG1hcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiB2aWV3KGxlbnMsIHgpIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIGBDb25zdGAgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgc2V0dGVyIGZ1bmN0aW9uIG9mIHRoZSBgbGVuc2AsXG4gICAgICAgICAgICAvLyBsZWF2aW5nIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIHVubW9kaWZpZWQuXG4gICAgICAgICAgICByZXR1cm4gbGVucyhDb25zdCkoeCkudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gICAgICogdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAgICAgKiB0aGUgYHdoZW5UcnVlRm5gIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgYXJndW1lbnQuIElmIHRoZSBwcmVkaWNhdGUgaXMgbm90XG4gICAgICogc2F0aXNmaWVkLCB0aGUgYXJndW1lbnQgaXMgcmV0dXJuZWQgYXMgaXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3aGVuVHJ1ZUZuIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZXMgdG8gYSB0cnV0aHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICBBbiBvYmplY3QgdG8gdGVzdCB3aXRoIHRoZSBgcHJlZGAgZnVuY3Rpb24gYW5kXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzIHRvIGB3aGVuVHJ1ZUZuYCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHJldHVybiB7Kn0gRWl0aGVyIGB4YCBvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGB4YCB0byBgd2hlblRydWVGbmAuXG4gICAgICogQHNlZSBSLmlmRWxzZSwgUi51bmxlc3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyB0cnVuY2F0ZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogICAgICB2YXIgdHJ1bmNhdGUgPSBSLndoZW4oXG4gICAgICogICAgICAgIFIucHJvcFNhdGlzZmllcyhSLmd0KFIuX18sIDEwKSwgJ2xlbmd0aCcpLFxuICAgICAqICAgICAgICBSLnBpcGUoUi50YWtlKDEwKSwgUi5hcHBlbmQoJ+KApicpLCBSLmpvaW4oJycpKVxuICAgICAqICAgICAgKTtcbiAgICAgKiAgICAgIHRydW5jYXRlKCcxMjM0NScpOyAgICAgICAgIC8vPT4gJzEyMzQ1J1xuICAgICAqICAgICAgdHJ1bmNhdGUoJzAxMjM0NTY3ODlBQkMnKTsgLy89PiAnMDEyMzQ1Njc4OeKApidcbiAgICAgKi9cbiAgICB2YXIgd2hlbiA9IF9jdXJyeTMoZnVuY3Rpb24gd2hlbihwcmVkLCB3aGVuVHJ1ZUZuLCB4KSB7XG4gICAgICAgIHJldHVybiBwcmVkKHgpID8gd2hlblRydWVGbih4KSA6IHg7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHNwZWMgb2JqZWN0IGFuZCBhIHRlc3Qgb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgdGhlIHRlc3Qgc2F0aXNmaWVzXG4gICAgICogdGhlIHNwZWMuIEVhY2ggb2YgdGhlIHNwZWMncyBvd24gcHJvcGVydGllcyBtdXN0IGJlIGEgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAqIEVhY2ggcHJlZGljYXRlIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG9mIHRoZVxuICAgICAqIHRlc3Qgb2JqZWN0LiBgd2hlcmVgIHJldHVybnMgdHJ1ZSBpZiBhbGwgdGhlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUsIGZhbHNlXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogYHdoZXJlYCBpcyB3ZWxsIHN1aXRlZCB0byBkZWNsYXJhdGl2ZWx5IGV4cHJlc3NpbmcgY29uc3RyYWludHMgZm9yIG90aGVyXG4gICAgICogZnVuY3Rpb25zIHN1Y2ggYXMgYGZpbHRlcmAgYW5kIGBmaW5kYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge1N0cmluZzogKCogLT4gQm9vbGVhbil9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gICAgICogICAgICB2YXIgcHJlZCA9IFIud2hlcmUoe1xuICAgICAqICAgICAgICBhOiBSLmVxdWFscygnZm9vJyksXG4gICAgICogICAgICAgIGI6IFIuY29tcGxlbWVudChSLmVxdWFscygnYmFyJykpLFxuICAgICAqICAgICAgICB4OiBSLmd0KF8sIDEwKSxcbiAgICAgKiAgICAgICAgeTogUi5sdChfLCAyMClcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDExLCB5OiAxOX0pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIHByZWQoe2E6ICd4eHgnLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAnYmFyJywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTAsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDIwfSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgd2hlcmUgPSBfY3VycnkyKGZ1bmN0aW9uIHdoZXJlKHNwZWMsIHRlc3RPYmopIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBzcGVjKSAmJiAhc3BlY1twcm9wXSh0ZXN0T2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdyYXAgYSBmdW5jdGlvbiBpbnNpZGUgYW5vdGhlciB0byBhbGxvdyB5b3UgdG8gbWFrZSBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBwYXJhbWV0ZXJzLCBvciBkbyBvdGhlciBwcm9jZXNzaW5nIGVpdGhlciBiZWZvcmUgdGhlIGludGVybmFsIGZ1bmN0aW9uIGlzXG4gICAgICogY2FsbGVkIG9yIHdpdGggaXRzIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKGEuLi4gLT4gYikgLT4gKChhLi4uIC0+IGIpIC0+IGEuLi4gLT4gYykgLT4gKGEuLi4gLT4gYylcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZ3JlZXQgPSBuYW1lID0+ICdIZWxsbyAnICsgbmFtZTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNob3V0ZWRHcmVldCA9IFIud3JhcChncmVldCwgKGdyLCBuYW1lKSA9PiBncihuYW1lKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgKlxuICAgICAqICAgICAgc2hvdXRlZEdyZWV0KFwiS2F0aHlcIik7IC8vPT4gXCJIRUxMTyBLQVRIWVwiXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzaG9ydGVuZWRHcmVldCA9IFIud3JhcChncmVldCwgZnVuY3Rpb24oZ3IsIG5hbWUpIHtcbiAgICAgKiAgICAgICAgcmV0dXJuIGdyKG5hbWUuc3Vic3RyaW5nKDAsIDMpKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqICAgICAgc2hvcnRlbmVkR3JlZXQoXCJSb2JlcnRcIik7IC8vPT4gXCJIZWxsbyBSb2JcIlxuICAgICAqL1xuICAgIHZhciB3cmFwID0gX2N1cnJ5MihmdW5jdGlvbiB3cmFwKGZuLCB3cmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4oZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5hcHBseSh0aGlzLCBfY29uY2F0KFtmbl0sIGFyZ3VtZW50cykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBjcmVhdGluZyBlYWNoIHBvc3NpYmxlIHBhaXJcbiAgICAgKiBmcm9tIHRoZSBsaXN0cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYl0gLT4gW1thLGJdXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFzIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJzIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgZWFjaCBwb3NzaWJsZSBwYWlyIGZyb21cbiAgICAgKiAgICAgICAgIGBhc2AgYW5kIGBic2AgaW50byBwYWlycyAoYFthLCBiXWApLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIueHByb2QoWzEsIDJdLCBbJ2EnLCAnYiddKTsgLy89PiBbWzEsICdhJ10sIFsxLCAnYiddLCBbMiwgJ2EnXSwgWzIsICdiJ11dXG4gICAgICovXG4gICAgLy8gPSB4cHJvZFdpdGgocHJlcGVuZCk7ICh0YWtlcyBhYm91dCAzIHRpbWVzIGFzIGxvbmcuLi4pXG4gICAgdmFyIHhwcm9kID0gX2N1cnJ5MihmdW5jdGlvbiB4cHJvZChhLCBiKSB7XG4gICAgICAgIC8vID0geHByb2RXaXRoKHByZXBlbmQpOyAodGFrZXMgYWJvdXQgMyB0aW1lcyBhcyBsb25nLi4uKVxuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGlsZW4gPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBqbGVuID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBqbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gW1xuICAgICAgICAgICAgICAgICAgICBhW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIGJbal1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgcGFpcmluZyB1cCBlcXVhbGx5LXBvc2l0aW9uZWRcbiAgICAgKiBpdGVtcyBmcm9tIGJvdGggbGlzdHMuIFRoZSByZXR1cm5lZCBsaXN0IGlzIHRydW5jYXRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAqIHNob3J0ZXIgb2YgdGhlIHR3byBpbnB1dCBsaXN0cy5cbiAgICAgKiBOb3RlOiBgemlwYCBpcyBlcXVpdmFsZW50IHRvIGB6aXBXaXRoKGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIFthLCBiXSB9KWAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuemlwKFsxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gX2N1cnJ5MihmdW5jdGlvbiB6aXAoYSwgYikge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBydltpZHhdID0gW1xuICAgICAgICAgICAgICAgIGFbaWR4XSxcbiAgICAgICAgICAgICAgICBiW2lkeF1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBvdXQgb2YgYSBsaXN0IG9mIGtleXMgYW5kIGEgbGlzdCBvZiB2YWx1ZXMuXG4gICAgICogS2V5L3ZhbHVlIHBhaXJpbmcgaXMgdHJ1bmNhdGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBsaXN0cy5cbiAgICAgKiBOb3RlOiBgemlwT2JqYCBpcyBlcXVpdmFsZW50IHRvIGBwaXBlKHppcFdpdGgocGFpciksIGZyb21QYWlycylgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW1N0cmluZ10gLT4gWypdIC0+IHtTdHJpbmc6ICp9XG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgdGhhdCB3aWxsIGJlIHByb3BlcnRpZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBsaXN0IG9mIHZhbHVlcyBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuemlwT2JqKFsnYScsICdiJywgJ2MnXSwgWzEsIDIsIDNdKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAgICAgKi9cbiAgICB2YXIgemlwT2JqID0gX2N1cnJ5MihmdW5jdGlvbiB6aXBPYmooa2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oa2V5cy5sZW5ndGgsIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIG91dFtrZXlzW2lkeF1dID0gdmFsdWVzW2lkeF07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byBlYWNoXG4gICAgICogZXF1YWxseS1wb3NpdGlvbmVkIHBhaXIgaW4gdGhlIGxpc3RzLiBUaGUgcmV0dXJuZWQgbGlzdCBpcyB0cnVuY2F0ZWQgdG8gdGhlXG4gICAgICogbGVuZ3RoIG9mIHRoZSBzaG9ydGVyIG9mIHRoZSB0d28gaW5wdXQgbGlzdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsYiAtPiBjKSAtPiBbYV0gLT4gW2JdIC0+IFtjXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbWJpbmUgdGhlIHR3byBlbGVtZW50cyBpbnRvIG9uZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgc2FtZS1pbmRleGVkIGVsZW1lbnRzIG9mIGBsaXN0MWAgYW5kIGBsaXN0MmBcbiAgICAgKiAgICAgICAgIHVzaW5nIGBmbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGYgPSAoeCwgeSkgPT4ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBSLnppcFdpdGgoZiwgWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10pO1xuICAgICAqICAgICAgLy89PiBbZigxLCAnYScpLCBmKDIsICdiJyksIGYoMywgJ2MnKV1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IF9jdXJyeTMoZnVuY3Rpb24gemlwV2l0aChmbiwgYSwgYikge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBydltpZHhdID0gZm4oYVtpZHhdLCBiW2lkeF0pO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuIEFueSBwYXNzZWQgaW4gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAqIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIuYWx3YXlzLCBSLlRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLkYoKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBGID0gYWx3YXlzKGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAuIEFueSBwYXNzZWQgaW4gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAqIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIuYWx3YXlzLCBSLkZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLlQoKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIFQgPSBhbHdheXModHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjb3BpZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSByZWZGcm9tIEFycmF5IGNvbnRhaW5pbmcgdGhlIHNvdXJjZSByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHtBcnJheX0gcmVmVG8gQXJyYXkgY29udGFpbmluZyB0aGUgY29waWVkIHNvdXJjZSByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwIFdoZXRoZXIgb3Igbm90IHRvIHBlcmZvcm0gZGVlcCBjbG9uaW5nLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBjb3BpZWQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIF9jbG9uZSA9IGZ1bmN0aW9uIF9jbG9uZSh2YWx1ZSwgcmVmRnJvbSwgcmVmVG8sIGRlZXApIHtcbiAgICAgICAgdmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KGNvcGllZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVmRnJvbS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlZkZyb21baWR4XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmVG9baWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZGcm9tW2lkeCArIDFdID0gdmFsdWU7XG4gICAgICAgICAgICByZWZUb1tpZHggKyAxXSA9IGNvcGllZFZhbHVlO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29waWVkVmFsdWVba2V5XSA9IGRlZXAgPyBfY2xvbmUodmFsdWVba2V5XSwgcmVmRnJvbSwgcmVmVG8sIHRydWUpIDogdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3BpZWRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoICh0eXBlKHZhbHVlKSkge1xuICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgICAgcmV0dXJuIGNvcHkoe30pO1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gY29weShbXSk7XG4gICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSk7XG4gICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKGNvbmNhdCkge1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfYXJpdHkoTWF0aC5tYXgoMCwgZm4ubGVuZ3RoIC0gYXJncy5sZW5ndGgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGNvbmNhdChhcmdzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIF9kcm9wTGFzdCA9IGZ1bmN0aW9uIGRyb3BMYXN0KG4sIHhzKSB7XG4gICAgICAgIHJldHVybiB0YWtlKG4gPCB4cy5sZW5ndGggPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xuICAgIH07XG5cbiAgICAvLyBWYWx1ZXMgb2Ygb3RoZXIgdHlwZXMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsLlxuICAgIHZhciBfZXF1YWxzID0gZnVuY3Rpb24gX2VxdWFscyhhLCBiLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgICBpZiAoaWRlbnRpY2FsKGEsIGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZShhKSAhPT0gdHlwZShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYS5lcXVhbHMoYikgJiYgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmIGIuZXF1YWxzKGEpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZShhKSkge1xuICAgICAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGEuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgX2Z1bmN0aW9uTmFtZShhLmNvbnN0cnVjdG9yKSA9PT0gJ1Byb21pc2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgaWRlbnRpY2FsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgaWYgKCFpZGVudGljYWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFcnJvcic6XG4gICAgICAgICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2U7XG4gICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICBpZiAoIShhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlICYmIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJiBhLnN0aWNreSA9PT0gYi5zdGlja3kgJiYgYS51bmljb2RlID09PSBiLnVuaWNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgICAgICBpZiAoIV9lcXVhbHMoX2FycmF5RnJvbUl0ZXJhdG9yKGEuZW50cmllcygpKSwgX2FycmF5RnJvbUl0ZXJhdG9yKGIuZW50cmllcygpKSwgc3RhY2tBLCBzdGFja0IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgICAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgICAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBWYWx1ZXMgb2Ygb3RoZXIgdHlwZXMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzQSA9IGtleXMoYSk7XG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIGlmIChzdGFja0FbaWR4XSA9PT0gYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja0JbaWR4XSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgICBzdGFja0IucHVzaChiKTtcbiAgICAgICAgaWR4ID0ga2V5c0EubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcbiAgICAgICAgICAgIGlmICghKF9oYXMoa2V5LCBiKSAmJiBfZXF1YWxzKGJba2V5XSwgYVtrZXldLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgICBzdGFja0IucG9wKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBgX21ha2VGbGF0YCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBvbmUtbGV2ZWwgb3IgZnVsbHkgcmVjdXJzaXZlXG4gICAgICogZnVuY3Rpb24gYmFzZWQgb24gdGhlIGZsYWcgcGFzc2VkIGluLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX21ha2VGbGF0ID0gZnVuY3Rpb24gX21ha2VGbGF0KHJlY3Vyc2l2ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZmxhdHQobGlzdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBqbGVuLCBqO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgaWxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UobGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlY3Vyc2l2ZSA/IGZsYXR0KGxpc3RbaWR4XSkgOiBsaXN0W2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICBqbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGpsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgYWNjID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10oYWNjLCBsaXN0W2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9IGFjY1snQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2l0ZXJhYmxlUmVkdWNlKHhmLCBhY2MsIGl0ZXIpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gaXRlci5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgICAgIGFjYyA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKGFjYywgc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjYyAmJiBhY2NbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX21ldGhvZFJlZHVjZSh4ZiwgYWNjLCBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKG9iai5yZWR1Y2UoYmluZCh4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSwgeGYpLCBhY2MpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltSXRlcmF0b3IgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5pdGVyYXRvciA6ICdAQGl0ZXJhdG9yJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9yZWR1Y2UoZm4sIGFjYywgbGlzdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZuID0gX3h3cmFwKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZShsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYXJyYXlSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3QucmVkdWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlzdFtzeW1JdGVyYXRvcl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdFtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3QubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2U6IGxpc3QgbXVzdCBiZSBhcnJheSBvciBpdGVyYWJsZScpO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBfc3RlcENhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9zdGVwQ2F0QXJyYXkgPSB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBBcnJheSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uICh4cywgeCkge1xuICAgICAgICAgICAgICAgIHhzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfc3RlcENhdFN0cmluZyA9IHtcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IFN0cmluZyxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfc3RlcENhdE9iamVjdCA9IHtcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IE9iamVjdCxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hc3NpZ24ocmVzdWx0LCBpc0FycmF5TGlrZShpbnB1dCkgPyBvYmpPZihpbnB1dFswXSwgaW5wdXRbMV0pIDogaW5wdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBfc3RlcENhdChvYmopIHtcbiAgICAgICAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdGVwQ2F0QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0ZXBDYXRTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0ZXBDYXRPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgdHJhbnNmb3JtZXIgZm9yICcgKyBvYmopO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBfeGRyb3BMYXN0V2hpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhEcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICAgICAgICAgICAgdGhpcy5mID0gZm47XG4gICAgICAgICAgICB0aGlzLnJldGFpbmVkID0gW107XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgIH1cbiAgICAgICAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMucmV0YWluZWQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZihpbnB1dCkgPyB0aGlzLnJldGFpbihyZXN1bHQsIGlucHV0KSA6IHRoaXMuZmx1c2gocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfcmVkdWNlKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10sIHJlc3VsdCwgdGhpcy5yZXRhaW5lZCk7XG4gICAgICAgICAgICB0aGlzLnJldGFpbmVkID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLnJldGFpbmVkLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRHJvcExhc3RXaGlsZShmbiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hncm91cEJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYR3JvdXBCeShmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgWEdyb3VwQnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYR3JvdXBCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiB0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGlmIChfaGFzKGtleSwgdGhpcy5pbnB1dHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlucHV0c1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYR3JvdXBCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZihpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0c1trZXldID0gdGhpcy5pbnB1dHNba2V5XSB8fCBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5pbnB1dHNba2V5XVsxXSA9IGFwcGVuZChpbnB1dCwgdGhpcy5pbnB1dHNba2V5XVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGdyb3VwQnkoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEdyb3VwQnkoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIGZyb20gYW4gZXhpc3Rpbmcgb25lIGJ5IGFkZGluZyB0d28gbmV3XG4gICAgICogcGFyYW1ldGVycyB0byBpdHMgY2FsbGJhY2sgZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4LCBhbmQgdGhlIGVudGlyZSBsaXN0LlxuICAgICAqXG4gICAgICogVGhpcyB3b3VsZCB0dXJuLCBmb3IgaW5zdGFuY2UsIFJhbWRhJ3Mgc2ltcGxlIGBtYXBgIGZ1bmN0aW9uIGludG8gb25lIHRoYXRcbiAgICAgKiBtb3JlIGNsb3NlbHkgcmVzZW1ibGVzIGBBcnJheS5wcm90b3R5cGUubWFwYC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmtcbiAgICAgKiBmb3IgZnVuY3Rpb25zIGluIHdoaWNoIHRoZSBpdGVyYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGZpcnN0XG4gICAgICogcGFyYW1ldGVyLCBhbmQgd2hlcmUgdGhlIGxpc3QgaXMgdGhlIGxhc3QgcGFyYW1ldGVyLiAoVGhpcyBsYXR0ZXIgbWlnaHQgYmVcbiAgICAgKiB1bmltcG9ydGFudCBpZiB0aGUgbGlzdCBwYXJhbWV0ZXIgaXMgbm90IHVzZWQuKVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICgoYSAuLi4gLT4gYikgLi4uIC0+IFthXSAtPiAqKSAtPiAoYSAuLi4sIEludCwgW2FdIC0+IGIpIC4uLiAtPiBbYV0gLT4gKilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgcGFzcyBpbmRleCBvciBsaXN0IHRvIGl0cyBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBbiBhbHRlcmVkIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIChpdGVtLCBpbmRleCwgbGlzdCkgdG8gaXRzIGNhbGxiYWNrXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hcEluZGV4ZWQgPSBSLmFkZEluZGV4KFIubWFwKTtcbiAgICAgKiAgICAgIG1hcEluZGV4ZWQoKHZhbCwgaWR4KSA9PiBpZHggKyAnLScgKyB2YWwsIFsnZicsICdvJywgJ28nLCAnYicsICdhJywgJ3InXSk7XG4gICAgICogICAgICAvLz0+IFsnMC1mJywgJzEtbycsICcyLW8nLCAnMy1iJywgJzQtYScsICc1LXInXVxuICAgICAqL1xuICAgIHZhciBhZGRJbmRleCA9IF9jdXJyeTEoZnVuY3Rpb24gYWRkSW5kZXgoZm4pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIG9yaWdGbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gX3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzWzBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnRm4uYXBwbHkodGhpcywgX2NvbmNhdChhcmd1bWVudHMsIFtcbiAgICAgICAgICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgICAgICAgICBsaXN0XG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgZnVuY3Rpb24gb2YgYW55IGFyaXR5IChpbmNsdWRpbmcgbnVsbGFyeSkgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHNcbiAgICAgKiBleGFjdGx5IDIgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCogLT4gYykgLT4gKGEsIGIgLT4gYylcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gICAgICogICAgICAgICBhcml0eSAyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc1RocmVlQXJncyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgICAgICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICB0YWtlc1RocmVlQXJncy5sZW5ndGg7IC8vPT4gM1xuICAgICAqICAgICAgdGFrZXNUaHJlZUFyZ3MoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSBSLmJpbmFyeSh0YWtlc1RocmVlQXJncyk7XG4gICAgICogICAgICB0YWtlc1R3b0FyZ3MubGVuZ3RoOyAvLz0+IDJcbiAgICAgKiAgICAgIC8vIE9ubHkgMiBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICAgICAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgdmFyIGJpbmFyeSA9IF9jdXJyeTEoZnVuY3Rpb24gYmluYXJ5KGZuKSB7XG4gICAgICAgIHJldHVybiBuQXJ5KDIsIGZuKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIHZhbHVlIHdoaWNoIG1heSBjb250YWluIChuZXN0ZWQpIGBBcnJheWBzIGFuZFxuICAgICAqIGBPYmplY3RgcywgYE51bWJlcmBzLCBgU3RyaW5nYHMsIGBCb29sZWFuYHMgYW5kIGBEYXRlYHMuIGBGdW5jdGlvbmBzIGFyZSBub3RcbiAgICAgKiBjb3BpZWQsIGJ1dCBhc3NpZ25lZCBieSB0aGVpciByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIGEgYGNsb25lYCBtZXRob2QgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgeyp9IC0+IHsqfVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG9iamVjdCBvciBhcnJheSB0byBjbG9uZVxuICAgICAqIEByZXR1cm4geyp9IEEgbmV3IG9iamVjdCBvciBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgb2JqZWN0cyA9IFt7fSwge30sIHt9XTtcbiAgICAgKiAgICAgIHZhciBvYmplY3RzQ2xvbmUgPSBSLmNsb25lKG9iamVjdHMpO1xuICAgICAqICAgICAgb2JqZWN0c1swXSA9PT0gb2JqZWN0c0Nsb25lWzBdOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGNsb25lID0gX2N1cnJ5MShmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuY2xvbmUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5jbG9uZSgpIDogX2Nsb25lKHZhbHVlLCBbXSwgW10sIHRydWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uIFRoZSBjdXJyaWVkIGZ1bmN0aW9uXG4gICAgICogaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0cyBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmVcbiAgICAgKiBhdCBhIHRpbWUuIElmIGBmYCBpcyBhIHRlcm5hcnkgZnVuY3Rpb24gYW5kIGBnYCBpcyBgUi5jdXJyeShmKWAsIHRoZVxuICAgICAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAgICAgKlxuICAgICAqICAgLSBgZygxKSgyKSgzKWBcbiAgICAgKiAgIC0gYGcoMSkoMiwgMylgXG4gICAgICogICAtIGBnKDEsIDIpKDMpYFxuICAgICAqICAgLSBgZygxLCAyLCAzKWBcbiAgICAgKlxuICAgICAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICAgICAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuIElmIGBnYCBpcyBhcyBhYm92ZSBhbmQgYF9gIGlzIGBSLl9fYCwgdGhlXG4gICAgICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICAgICAqXG4gICAgICogICAtIGBnKDEsIDIsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAgICAgKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gICAgICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICAgICAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSwgMylgXG4gICAgICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIFIuY3VycnlOXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZEZvdXJOdW1iZXJzID0gKGEsIGIsIGMsIGQpID0+IGEgKyBiICsgYyArIGQ7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5KGFkZEZvdXJOdW1iZXJzKTtcbiAgICAgKiAgICAgIHZhciBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICAgICAqICAgICAgdmFyIGcgPSBmKDMpO1xuICAgICAqICAgICAgZyg0KTsgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciBjdXJyeSA9IF9jdXJyeTEoZnVuY3Rpb24gY3VycnkoZm4pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZuKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gICAgICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgZHJvcGAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIudGFrZSwgUi50cmFuc2R1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRyb3AoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi5kcm9wKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICAgICAqICAgICAgUi5kcm9wKDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIuZHJvcCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gICAgICogICAgICBSLmRyb3AoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnZGEnXG4gICAgICovXG4gICAgdmFyIGRyb3AgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2Ryb3AnLCBfeGRyb3AsIGZ1bmN0aW9uIGRyb3AobiwgeHMpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKE1hdGgubWF4KDAsIG4pLCBJbmZpbml0eSwgeHMpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgYWxsIGJ1dCB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGBsaXN0YC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIGB4c2AgdG8gc2tpcC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgY29sbGVjdGlvbiB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAc2VlIFIudGFrZUxhc3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRyb3BMYXN0KDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKiAgICAgIFIuZHJvcExhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gICAgICogICAgICBSLmRyb3BMYXN0KDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIuZHJvcExhc3QoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICAgICAqICAgICAgUi5kcm9wTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdyYSdcbiAgICAgKi9cbiAgICB2YXIgZHJvcExhc3QgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2Ryb3BMYXN0JywgX3hkcm9wTGFzdCwgX2Ryb3BMYXN0KSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBhbGwgYnV0IGxhc3QgdGhlYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCxcbiAgICAgKiBwYXNzaW5nIGVhY2ggdmFsdWUgZnJvbSB0aGUgcmlnaHQgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbixcbiAgICAgKiBza2lwcGluZyBlbGVtZW50cyB3aGlsZSB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgLiBUaGUgcHJlZGljYXRlXG4gICAgICogZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDogKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gICAgICogQHNlZSBSLnRha2VMYXN0V2hpbGUsIFIuYWRkSW5kZXhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbHRlVGhyZWUgPSB4ID0+IHggPD0gMztcbiAgICAgKlxuICAgICAqICAgICAgUi5kcm9wTGFzdFdoaWxlKGx0ZVRocmVlLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIHZhciBkcm9wTGFzdFdoaWxlID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdkcm9wTGFzdFdoaWxlJywgX3hkcm9wTGFzdFdoaWxlLCBfZHJvcExhc3RXaGlsZSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgZXF1aXZhbGVudCwgYGZhbHNlYCBvdGhlcndpc2UuIEhhbmRsZXNcbiAgICAgKiBjeWNsaWNhbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHN5bW1ldHJpY2FsbHkgdG8gdGhlIGBlcXVhbHNgIG1ldGhvZHMgb2YgYm90aCBhcmd1bWVudHMsIGlmXG4gICAgICogcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTUuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgYSAtPiBiIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZXF1YWxzKDEsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZXF1YWxzKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZXF1YWxzKFsxLCAyLCAzXSwgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhID0ge307IGEudiA9IGE7XG4gICAgICogICAgICB2YXIgYiA9IHt9OyBiLnYgPSBiO1xuICAgICAqICAgICAgUi5lcXVhbHMoYSwgYik7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBlcXVhbHMgPSBfY3VycnkyKGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBfZXF1YWxzKGEsIGIsIFtdLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBcImZpbHRlcmFibGVcIiwgYW5kIHJldHVybnMgYSBuZXcgZmlsdGVyYWJsZSBvZiB0aGVcbiAgICAgKiBzYW1lIHR5cGUgY29udGFpbmluZyB0aGUgbWVtYmVycyBvZiB0aGUgZ2l2ZW4gZmlsdGVyYWJsZSB3aGljaCBzYXRpc2Z5IHRoZVxuICAgICAqIGdpdmVuIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaWx0ZXJgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBzZWUgUi5yZWplY3QsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzRXZlbiA9IG4gPT4gbiAlIDIgPT09IDA7XG4gICAgICpcbiAgICAgKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAgICAgKlxuICAgICAqICAgICAgUi5maWx0ZXIoaXNFdmVuLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBkOiA0fVxuICAgICAqL1xuICAgIC8vIGVsc2VcbiAgICB2YXIgZmlsdGVyID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaWx0ZXInLCBfeGZpbHRlciwgZnVuY3Rpb24gKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9pc09iamVjdChmaWx0ZXJhYmxlKSA/IF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICBpZiAocHJlZChmaWx0ZXJhYmxlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBmaWx0ZXJhYmxlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSwga2V5cyhmaWx0ZXJhYmxlKSkgOiAvLyBlbHNlXG4gICAgICAgIF9maWx0ZXIocHJlZCwgZmlsdGVyYWJsZSk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGJ5IHB1bGxpbmcgZXZlcnkgaXRlbSBvdXQgb2YgaXQgKGFuZCBhbGwgaXRzIHN1Yi1hcnJheXMpXG4gICAgICogYW5kIHB1dHRpbmcgdGhlbSBpbiBhIG5ldyBhcnJheSwgZGVwdGgtZmlyc3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2JdXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBmbGF0dGVuZWQgbGlzdC5cbiAgICAgKiBAc2VlIFIudW5uZXN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5mbGF0dGVuKFsxLCAyLCBbMywgNF0sIDUsIFs2LCBbNywgOCwgWzksIFsxMCwgMTFdLCAxMl1dXV0pO1xuICAgICAqICAgICAgLy89PiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiAgICAgKi9cbiAgICB2YXIgZmxhdHRlbiA9IF9jdXJyeTEoX21ha2VGbGF0KHRydWUpKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gbXVjaCBsaWtlIHRoZSBzdXBwbGllZCBvbmUsIGV4Y2VwdCB0aGF0IHRoZSBmaXJzdCB0d29cbiAgICAgKiBhcmd1bWVudHMnIG9yZGVyIGlzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIChhIC0+IGIgLT4gYyAtPiAuLi4gLT4geikgLT4gKGIgLT4gYSAtPiBjIC0+IC4uLiAtPiB6KVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMgcmV2ZXJzZWQuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiBpbnZva2luZyBgZm5gIHdpdGggaXRzIGZpcnN0IHR3byBwYXJhbWV0ZXJzJyBvcmRlciByZXZlcnNlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWVyZ2VUaHJlZSA9IChhLCBiLCBjKSA9PiBbXS5jb25jYXQoYSwgYiwgYyk7XG4gICAgICpcbiAgICAgKiAgICAgIG1lcmdlVGhyZWUoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAgICAgIFIuZmxpcChtZXJnZVRocmVlKSgxLCAyLCAzKTsgLy89PiBbMiwgMSwgM11cbiAgICAgKi9cbiAgICB2YXIgZmxpcCA9IF9jdXJyeTEoZnVuY3Rpb24gZmxpcChmbikge1xuICAgICAgICByZXR1cm4gY3VycnkoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gX3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzWzBdID0gYjtcbiAgICAgICAgICAgIGFyZ3NbMV0gPSBhO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLiBJbiBzb21lIGxpYnJhcmllc1xuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi50YWlsLCBSLmluaXQsIFIubGFzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaGVhZChbJ2ZpJywgJ2ZvJywgJ2Z1bSddKTsgLy89PiAnZmknXG4gICAgICogICAgICBSLmhlYWQoW10pOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogICAgICBSLmhlYWQoJ2FiYycpOyAvLz0+ICdhJ1xuICAgICAqICAgICAgUi5oZWFkKCcnKTsgLy89PiAnJ1xuICAgICAqL1xuICAgIHZhciBoZWFkID0gbnRoKDApO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW2FdIC0+IFthXVxuICAgICAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gbGlzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLmxhc3QsIFIuaGVhZCwgUi50YWlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pbml0KFsxLCAyLCAzXSk7ICAvLz0+IFsxLCAyXVxuICAgICAqICAgICAgUi5pbml0KFsxLCAyXSk7ICAgICAvLz0+IFsxXVxuICAgICAqICAgICAgUi5pbml0KFsxXSk7ICAgICAgICAvLz0+IFtdXG4gICAgICogICAgICBSLmluaXQoW10pOyAgICAgICAgIC8vPT4gW11cbiAgICAgKlxuICAgICAqICAgICAgUi5pbml0KCdhYmMnKTsgIC8vPT4gJ2FiJ1xuICAgICAqICAgICAgUi5pbml0KCdhYicpOyAgIC8vPT4gJ2EnXG4gICAgICogICAgICBSLmluaXQoJ2EnKTsgICAgLy89PiAnJ1xuICAgICAqICAgICAgUi5pbml0KCcnKTsgICAgIC8vPT4gJydcbiAgICAgKi9cbiAgICB2YXIgaW5pdCA9IHNsaWNlKDAsIC0xKTtcblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRob3NlXG4gICAgICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuIER1cGxpY2F0aW9uIGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgKGEgLT4gYSAtPiBCb29sZWFuKSAtPiBbKl0gLT4gWypdIC0+IFsqXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICAgKiAgICAgICAgdGhlIHR3byBzdXBwbGllZCBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgT25lIGxpc3Qgb2YgaXRlbXMgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIEEgc2Vjb25kIGxpc3Qgb2YgaXRlbXMgdG8gY29tcGFyZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhvc2UgZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gICAgICogQHNlZSBSLmludGVyc2VjdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBidWZmYWxvU3ByaW5nZmllbGQgPSBbXG4gICAgICogICAgICAgIHtpZDogODI0LCBuYW1lOiAnUmljaGllIEZ1cmF5J30sXG4gICAgICogICAgICAgIHtpZDogOTU2LCBuYW1lOiAnRGV3ZXkgTWFydGluJ30sXG4gICAgICogICAgICAgIHtpZDogMzEzLCBuYW1lOiAnQnJ1Y2UgUGFsbWVyJ30sXG4gICAgICogICAgICAgIHtpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSxcbiAgICAgKiAgICAgICAge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31cbiAgICAgKiAgICAgIF07XG4gICAgICogICAgICB2YXIgY3NueSA9IFtcbiAgICAgKiAgICAgICAge2lkOiAyMDQsIG5hbWU6ICdEYXZpZCBDcm9zYnknfSxcbiAgICAgKiAgICAgICAge2lkOiA0NTYsIG5hbWU6ICdTdGVwaGVuIFN0aWxscyd9LFxuICAgICAqICAgICAgICB7aWQ6IDUzOSwgbmFtZTogJ0dyYWhhbSBOYXNoJ30sXG4gICAgICogICAgICAgIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XG4gICAgICogICAgICBdO1xuICAgICAqXG4gICAgICogICAgICBSLmludGVyc2VjdGlvbldpdGgoUi5lcUJ5KFIucHJvcCgnaWQnKSksIGJ1ZmZhbG9TcHJpbmdmaWVsZCwgY3NueSk7XG4gICAgICogICAgICAvLz0+IFt7aWQ6IDQ1NiwgbmFtZTogJ1N0ZXBoZW4gU3RpbGxzJ30sIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gX2N1cnJ5MyhmdW5jdGlvbiBpbnRlcnNlY3Rpb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICAgICAgICB2YXIgbG9va3VwTGlzdCwgZmlsdGVyZWRMaXN0O1xuICAgICAgICBpZiAobGlzdDEubGVuZ3RoID4gbGlzdDIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb29rdXBMaXN0ID0gbGlzdDE7XG4gICAgICAgICAgICBmaWx0ZXJlZExpc3QgPSBsaXN0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb2t1cExpc3QgPSBsaXN0MjtcbiAgICAgICAgICAgIGZpbHRlcmVkTGlzdCA9IGxpc3QxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgZmlsdGVyZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKF9jb250YWluc1dpdGgocHJlZCwgZmlsdGVyZWRMaXN0W2lkeF0sIGxvb2t1cExpc3QpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBmaWx0ZXJlZExpc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlxV2l0aChwcmVkLCByZXN1bHRzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGl0ZW1zIG9mIHRoZSBsaXN0IHdpdGggdGhlIHRyYW5zZHVjZXIgYW5kIGFwcGVuZHMgdGhlXG4gICAgICogdHJhbnNmb3JtZWQgaXRlbXMgdG8gdGhlIGFjY3VtdWxhdG9yIHVzaW5nIGFuIGFwcHJvcHJpYXRlIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gICAgICogYmFzZWQgb24gdGhlIGFjY3VtdWxhdG9yIHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGUgYWNjdW11bGF0b3IgY2FuIGJlIGFuIGFycmF5LCBzdHJpbmcsIG9iamVjdCBvciBhIHRyYW5zZm9ybWVyLiBJdGVyYXRlZFxuICAgICAqIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gYXJyYXlzIGFuZCBjb25jYXRlbmF0ZWQgdG8gc3RyaW5ncy4gT2JqZWN0cyB3aWxsXG4gICAgICogYmUgbWVyZ2VkIGRpcmVjdGx5IG9yIDItaXRlbSBhcnJheXMgd2lsbCBiZSBtZXJnZWQgYXMga2V5LCB2YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIFRoZSBhY2N1bXVsYXRvciBjYW4gYWxzbyBiZSBhIHRyYW5zZm9ybWVyIG9iamVjdCB0aGF0IHByb3ZpZGVzIGEgMi1hcml0eVxuICAgICAqIHJlZHVjaW5nIGl0ZXJhdG9yIGZ1bmN0aW9uLCBzdGVwLCAwLWFyaXR5IGluaXRpYWwgdmFsdWUgZnVuY3Rpb24sIGluaXQsIGFuZFxuICAgICAqIDEtYXJpdHkgcmVzdWx0IGV4dHJhY3Rpb24gZnVuY3Rpb24gcmVzdWx0LiBUaGUgc3RlcCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZVxuICAgICAqIGl0ZXJhdG9yIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlXG4gICAgICogZmluYWwgYWNjdW11bGF0b3IgaW50byB0aGUgcmV0dXJuIHR5cGUgYW5kIGluIG1vc3QgY2FzZXMgaXMgUi5pZGVudGl0eS4gVGhlXG4gICAgICogaW5pdCBmdW5jdGlvbiBpcyB1c2VkIHRvIHByb3ZpZGUgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0aW9uIGlzIHBlcmZvcm1lZCB3aXRoIFIucmVkdWNlIGFmdGVyIGluaXRpYWxpemluZyB0aGUgdHJhbnNkdWNlci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IChiIC0+IGIpIC0+IFtjXSAtPiBhXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0geGYgVGhlIHRyYW5zZHVjZXIgZnVuY3Rpb24uIFJlY2VpdmVzIGEgdHJhbnNmb3JtZXIgYW5kIHJldHVybnMgYSB0cmFuc2Zvcm1lci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBudW1iZXJzID0gWzEsIDIsIDMsIDRdO1xuICAgICAqICAgICAgdmFyIHRyYW5zZHVjZXIgPSBSLmNvbXBvc2UoUi5tYXAoUi5hZGQoMSkpLCBSLnRha2UoMikpO1xuICAgICAqXG4gICAgICogICAgICBSLmludG8oW10sIHRyYW5zZHVjZXIsIG51bWJlcnMpOyAvLz0+IFsyLCAzXVxuICAgICAqXG4gICAgICogICAgICB2YXIgaW50b0FycmF5ID0gUi5pbnRvKFtdKTtcbiAgICAgKiAgICAgIGludG9BcnJheSh0cmFuc2R1Y2VyLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW50byA9IF9jdXJyeTMoZnVuY3Rpb24gaW50byhhY2MsIHhmLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfaXNUcmFuc2Zvcm1lcihhY2MpID8gX3JlZHVjZSh4ZihhY2MpLCBhY2NbJ0BAdHJhbnNkdWNlci9pbml0J10oKSwgbGlzdCkgOiBfcmVkdWNlKHhmKF9zdGVwQ2F0KGFjYykpLCBfY2xvbmUoYWNjLCBbXSwgW10sIGZhbHNlKSwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIFIuaW52ZXJ0T2JqLCBob3dldmVyIHRoaXMgYWNjb3VudHMgZm9yIG9iamVjdHMgd2l0aCBkdXBsaWNhdGUgdmFsdWVzXG4gICAgICogYnkgcHV0dGluZyB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtzOiB4fSAtPiB7eDogWyBzLCAuLi4gXX1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaW52ZXJ0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvdXQgQSBuZXcgb2JqZWN0IHdpdGgga2V5c1xuICAgICAqIGluIGFuIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciByYWNlUmVzdWx0c0J5Rmlyc3ROYW1lID0ge1xuICAgICAqICAgICAgICBmaXJzdDogJ2FsaWNlJyxcbiAgICAgKiAgICAgICAgc2Vjb25kOiAnamFrZScsXG4gICAgICogICAgICAgIHRoaXJkOiAnYWxpY2UnLFxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIFIuaW52ZXJ0KHJhY2VSZXN1bHRzQnlGaXJzdE5hbWUpO1xuICAgICAqICAgICAgLy89PiB7ICdhbGljZSc6IFsnZmlyc3QnLCAndGhpcmQnXSwgJ2pha2UnOlsnc2Vjb25kJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBfY3VycnkxKGZ1bmN0aW9uIGludmVydChvYmopIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICAgICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaWR4XTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gX2hhcyh2YWwsIG91dCkgPyBvdXRbdmFsXSA6IG91dFt2YWxdID0gW107XG4gICAgICAgICAgICBsaXN0W2xpc3QubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3QgYXMgdmFsdWVzLCBhbmQgdGhlXG4gICAgICogdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsIHdoaWNoIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MsIGFzIGtleXMuIE5vdGVcbiAgICAgKiB0aGF0IHRoZSBsYXN0IGtleSBmb3VuZCBpcyBwcmVmZXJyZWQgd2hlbiBoYW5kbGluZyB0aGUgc2FtZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge3M6IHh9IC0+IHt4OiBzfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byBpbnZlcnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG91dCBBIG5ldyBvYmplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcmFjZVJlc3VsdHMgPSB7XG4gICAgICogICAgICAgIGZpcnN0OiAnYWxpY2UnLFxuICAgICAqICAgICAgICBzZWNvbmQ6ICdqYWtlJ1xuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIFIuaW52ZXJ0T2JqKHJhY2VSZXN1bHRzKTtcbiAgICAgKiAgICAgIC8vPT4geyAnYWxpY2UnOiAnZmlyc3QnLCAnamFrZSc6J3NlY29uZCcgfVxuICAgICAqXG4gICAgICogICAgICAvLyBBbHRlcm5hdGl2ZWx5OlxuICAgICAqICAgICAgdmFyIHJhY2VSZXN1bHRzID0gWydhbGljZScsICdqYWtlJ107XG4gICAgICogICAgICBSLmludmVydE9iaihyYWNlUmVzdWx0cyk7XG4gICAgICogICAgICAvLz0+IHsgJ2FsaWNlJzogJzAnLCAnamFrZSc6JzEnIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0T2JqID0gX2N1cnJ5MShmdW5jdGlvbiBpbnZlcnRPYmoob2JqKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2lkeF07XG4gICAgICAgICAgICBvdXRbb2JqW2tleV1dID0ga2V5O1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBpdHMgdHlwZSdzIGVtcHR5IHZhbHVlOyBgZmFsc2VgXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnIGEgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmVtcHR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pc0VtcHR5KFsxLCAyLCAzXSk7ICAgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pc0VtcHR5KFtdKTsgICAgICAgICAgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzRW1wdHkoJycpOyAgICAgICAgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXNFbXB0eShudWxsKTsgICAgICAgIC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNFbXB0eSh7fSk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pc0VtcHR5KHtsZW5ndGg6IDB9KTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0VtcHR5ID0gX2N1cnJ5MShmdW5jdGlvbiBpc0VtcHR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiBlcXVhbHMoeCwgZW1wdHkoeCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS40XG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIuaW5pdCwgUi5oZWFkLCBSLnRhaWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmxhc3QoWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gJ2Z1bSdcbiAgICAgKiAgICAgIFIubGFzdChbXSk7IC8vPT4gdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiAgICAgIFIubGFzdCgnYWJjJyk7IC8vPT4gJ2MnXG4gICAgICogICAgICBSLmxhc3QoJycpOyAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIGxhc3QgPSBudGgoLTEpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZlxuICAgICAqIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuIGBSLmVxdWFsc2AgaXMgdXNlZCB0byBkZXRlcm1pbmVcbiAgICAgKiBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gW2FdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LCBvciAtMSBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAc2VlIFIuaW5kZXhPZlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubGFzdEluZGV4T2YoMywgWy0xLDMsMywwLDEsMiwzLDRdKTsgLy89PiA2XG4gICAgICogICAgICBSLmxhc3RJbmRleE9mKDEwLCBbMSwyLDMsNF0pOyAvLz0+IC0xXG4gICAgICovXG4gICAgdmFyIGxhc3RJbmRleE9mID0gX2N1cnJ5MihmdW5jdGlvbiBsYXN0SW5kZXhPZih0YXJnZXQsIHhzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeHMubGFzdEluZGV4T2YgPT09ICdmdW5jdGlvbicgJiYgIV9pc0FycmF5KHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHhzLmxhc3RJbmRleE9mKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0geHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbHMoeHNbaWR4XSwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBmdW5jdGlvbiBhbmRcbiAgICAgKiBhIFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpLFxuICAgICAqIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggb2YgdGhlIGZ1bmN0b3IncyB2YWx1ZXMsIGFuZCByZXR1cm5zXG4gICAgICogYSBmdW5jdG9yIG9mIHRoZSBzYW1lIHNoYXBlLlxuICAgICAqXG4gICAgICogUmFtZGEgcHJvdmlkZXMgc3VpdGFibGUgYG1hcGAgaW1wbGVtZW50YXRpb25zIGZvciBgQXJyYXlgIGFuZCBgT2JqZWN0YCxcbiAgICAgKiBzbyB0aGlzIGZ1bmN0aW9uIG1heSBiZSBhcHBsaWVkIHRvIGBbMSwgMiwgM11gIG9yIGB7eDogMSwgeTogMiwgejogM31gLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYG1hcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBBbHNvIHRyZWF0cyBmdW5jdGlvbnMgYXMgZnVuY3RvcnMgYW5kIHdpbGwgY29tcG9zZSB0aGVtIHRvZ2V0aGVyLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRvdWJsZSA9IHggPT4geCAqIDI7XG4gICAgICpcbiAgICAgKiAgICAgIFIubWFwKGRvdWJsZSwgWzEsIDIsIDNdKTsgLy89PiBbMiwgNCwgNl1cbiAgICAgKlxuICAgICAqICAgICAgUi5tYXAoZG91YmxlLCB7eDogMSwgeTogMiwgejogM30pOyAvLz0+IHt4OiAyLCB5OiA0LCB6OiA2fVxuICAgICAqL1xuICAgIHZhciBtYXAgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ21hcCcsIF94bWFwLCBmdW5jdGlvbiBtYXAoZm4sIGZ1bmN0b3IpIHtcbiAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZnVuY3RvcikpIHtcbiAgICAgICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJ5TihmdW5jdG9yLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGZ1bmN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzpcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZm4oZnVuY3RvcltrZXldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30sIGtleXMoZnVuY3RvcikpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIF9tYXAoZm4sIGZ1bmN0b3IpO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogQW4gT2JqZWN0LXNwZWNpZmljIHZlcnNpb24gb2YgYG1hcGAuIFRoZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAqKHZhbHVlLCBrZXksIG9iaikqLiBJZiBvbmx5IHRoZSB2YWx1ZSBpcyBzaWduaWZpY2FudCwgdXNlXG4gICAgICogYG1hcGAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgKCgqLCBTdHJpbmcsIE9iamVjdCkgLT4gKikgLT4gT2JqZWN0IC0+IE9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2VlIFIubWFwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHZhbHVlcyA9IHsgeDogMSwgeTogMiwgejogMyB9O1xuICAgICAqICAgICAgdmFyIHByZXBlbmRLZXlBbmREb3VibGUgPSAobnVtLCBrZXksIG9iaikgPT4ga2V5ICsgKG51bSAqIDIpO1xuICAgICAqXG4gICAgICogICAgICBSLm1hcE9iakluZGV4ZWQocHJlcGVuZEtleUFuZERvdWJsZSwgdmFsdWVzKTsgLy89PiB7IHg6ICd4MicsIHk6ICd5NCcsIHo6ICd6NicgfVxuICAgICAqL1xuICAgIHZhciBtYXBPYmpJbmRleGVkID0gX2N1cnJ5MihmdW5jdGlvbiBtYXBPYmpJbmRleGVkKGZuLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZuKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSwga2V5cyhvYmopKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy4gSWZcbiAgICAgKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUgdmFsdWVzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gZWFjaCBvYmplY3QsIHdpdGggdGhlIHJlc3VsdCBiZWluZyB1c2VkIGFzIHRoZVxuICAgICAqIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIHRoZSByZXR1cm5lZCBvYmplY3QuIFRoZSBrZXkgd2lsbCBiZVxuICAgICAqIGV4Y2x1ZGVkIGZyb20gdGhlIHJldHVybmVkIG9iamVjdCBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgKGEgLT4gYSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2VlIFIubWVyZ2UsIFIubWVyZ2VXaXRoS2V5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZXJnZVdpdGgoUi5jb25jYXQsXG4gICAgICogICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHZhbHVlczogWzEwLCAyMF0gfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgdmFsdWVzOiBbMTUsIDM1XSB9KTtcbiAgICAgKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBfY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aChmbiwgbCwgcikge1xuICAgICAgICByZXR1cm4gbWVyZ2VXaXRoS2V5KGZ1bmN0aW9uIChfLCBfbCwgX3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmbihfbCwgX3IpO1xuICAgICAgICB9LCBsLCByKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYC5cbiAgICAgKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAgICAgKiBwcm92aWRlZCBpbml0aWFsbHkgZm9sbG93ZWQgYnkgdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byBgZ2AuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoYSwgYiwgYywgLi4uLCBuKSAtPiB4KSAtPiBbYSwgYiwgYywgLi4uXSAtPiAoKGQsIGUsIGYsIC4uLiwgbikgLT4geClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5wYXJ0aWFsUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbXVsdGlwbHkgPSAoYSwgYikgPT4gYSAqIGI7XG4gICAgICogICAgICB2YXIgZG91YmxlID0gUi5wYXJ0aWFsKG11bHRpcGx5LCBbMl0pO1xuICAgICAqICAgICAgZG91YmxlKDIpOyAvLz0+IDRcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGdyZWV0ID0gKHNhbHV0YXRpb24sIHRpdGxlLCBmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PlxuICAgICAqICAgICAgICBzYWx1dGF0aW9uICsgJywgJyArIHRpdGxlICsgJyAnICsgZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWUgKyAnISc7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzYXlIZWxsbyA9IFIucGFydGlhbChncmVldCwgWydIZWxsbyddKTtcbiAgICAgKiAgICAgIHZhciBzYXlIZWxsb1RvTXMgPSBSLnBhcnRpYWwoc2F5SGVsbG8sIFsnTXMuJ10pO1xuICAgICAqICAgICAgc2F5SGVsbG9Ub01zKCdKYW5lJywgJ0pvbmVzJyk7IC8vPT4gJ0hlbGxvLCBNcy4gSmFuZSBKb25lcyEnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoX2NvbmNhdCk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2AuXG4gICAgICogV2hlbiBhcHBsaWVkLCBgZ2AgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBmYCB0byB0aGUgYXJndW1lbnRzXG4gICAgICogcHJvdmlkZWQgdG8gYGdgIGZvbGxvd2VkIGJ5IHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgaW5pdGlhbGx5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKGEsIGIsIGMsIC4uLiwgbikgLT4geCkgLT4gW2QsIGUsIGYsIC4uLiwgbl0gLT4gKChhLCBiLCBjLCAuLi4pIC0+IHgpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIucGFydGlhbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBncmVldCA9IChzYWx1dGF0aW9uLCB0aXRsZSwgZmlyc3ROYW1lLCBsYXN0TmFtZSkgPT5cbiAgICAgKiAgICAgICAgc2FsdXRhdGlvbiArICcsICcgKyB0aXRsZSArICcgJyArIGZpcnN0TmFtZSArICcgJyArIGxhc3ROYW1lICsgJyEnO1xuICAgICAqXG4gICAgICogICAgICB2YXIgZ3JlZXRNc0phbmVKb25lcyA9IFIucGFydGlhbFJpZ2h0KGdyZWV0LCBbJ01zLicsICdKYW5lJywgJ0pvbmVzJ10pO1xuICAgICAqXG4gICAgICogICAgICBncmVldE1zSmFuZUpvbmVzKCdIZWxsbycpOyAvLz0+ICdIZWxsbywgTXMuIEphbmUgSm9uZXMhJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoZmxpcChfY29uY2F0KSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBuZXN0ZWQgcGF0aCBvbiBhbiBvYmplY3QgaGFzIGEgc3BlY2lmaWMgdmFsdWUsIGluXG4gICAgICogYFIuZXF1YWxzYCB0ZXJtcy4gTW9zdCBsaWtlbHkgdXNlZCB0byBmaWx0ZXIgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+ICogLT4ge1N0cmluZzogKn0gLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIG5lc3RlZCBwcm9wZXJ0eSB0byB1c2VcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gY29tcGFyZSB0aGUgbmVzdGVkIHByb3BlcnR5IHdpdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgdGhlIG5lc3RlZCBwcm9wZXJ0eSBpblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgZXF1YWxzIHRoZSBuZXN0ZWQgb2JqZWN0IHByb3BlcnR5LFxuICAgICAqICAgICAgICAgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHVzZXIxID0geyBhZGRyZXNzOiB7IHppcENvZGU6IDkwMjEwIH0gfTtcbiAgICAgKiAgICAgIHZhciB1c2VyMiA9IHsgYWRkcmVzczogeyB6aXBDb2RlOiA1NTU1NSB9IH07XG4gICAgICogICAgICB2YXIgdXNlcjMgPSB7IG5hbWU6ICdCb2InIH07XG4gICAgICogICAgICB2YXIgdXNlcnMgPSBbIHVzZXIxLCB1c2VyMiwgdXNlcjMgXTtcbiAgICAgKiAgICAgIHZhciBpc0ZhbW91cyA9IFIucGF0aEVxKFsnYWRkcmVzcycsICd6aXBDb2RlJ10sIDkwMjEwKTtcbiAgICAgKiAgICAgIFIuZmlsdGVyKGlzRmFtb3VzLCB1c2Vycyk7IC8vPT4gWyB1c2VyMSBdXG4gICAgICovXG4gICAgdmFyIHBhdGhFcSA9IF9jdXJyeTMoZnVuY3Rpb24gcGF0aEVxKF9wYXRoLCB2YWwsIG9iaikge1xuICAgICAgICByZXR1cm4gZXF1YWxzKHBhdGgoX3BhdGgsIG9iaiksIHZhbCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgYnkgcGx1Y2tpbmcgdGhlIHNhbWUgbmFtZWQgcHJvcGVydHkgb2ZmIGFsbCBvYmplY3RzIGluXG4gICAgICogdGhlIGxpc3Qgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBrIC0+IFt7azogdn1dIC0+IFt2XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IFRoZSBrZXkgbmFtZSB0byBwbHVjayBvZmYgb2YgZWFjaCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICAgKiBAc2VlIFIucHJvcHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnBsdWNrKCdhJykoW3thOiAxfSwge2E6IDJ9XSk7IC8vPT4gWzEsIDJdXG4gICAgICogICAgICBSLnBsdWNrKDApKFtbMSwgMl0sIFszLCA0XV0pOyAgIC8vPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gX2N1cnJ5MihmdW5jdGlvbiBwbHVjayhwLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBtYXAocHJvcChwKSwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWFzb25hYmxlIGFuYWxvZyB0byBTUUwgYHNlbGVjdGAgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBba10gLT4gW3trOiB2fV0gLT4gW3trOiB2fV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gcHJvamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ianMgVGhlIG9iamVjdHMgdG8gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGp1c3QgdGhlIGBwcm9wc2AgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWJieSA9IHtuYW1lOiAnQWJieScsIGFnZTogNywgaGFpcjogJ2Jsb25kJywgZ3JhZGU6IDJ9O1xuICAgICAqICAgICAgdmFyIGZyZWQgPSB7bmFtZTogJ0ZyZWQnLCBhZ2U6IDEyLCBoYWlyOiAnYnJvd24nLCBncmFkZTogN307XG4gICAgICogICAgICB2YXIga2lkcyA9IFthYmJ5LCBmcmVkXTtcbiAgICAgKiAgICAgIFIucHJvamVjdChbJ25hbWUnLCAnZ3JhZGUnXSwga2lkcyk7IC8vPT4gW3tuYW1lOiAnQWJieScsIGdyYWRlOiAyfSwge25hbWU6ICdGcmVkJywgZ3JhZGU6IDd9XVxuICAgICAqL1xuICAgIC8vIHBhc3NpbmcgYGlkZW50aXR5YCBnaXZlcyBjb3JyZWN0IGFyaXR5XG4gICAgdmFyIHByb2plY3QgPSB1c2VXaXRoKF9tYXAsIFtcbiAgICAgICAgcGlja0FsbCxcbiAgICAgICAgaWRlbnRpdHlcbiAgICBdKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGlzIGVxdWFsLCBpbiBgUi5lcXVhbHNgXG4gICAgICogdGVybXMsIHRvIHRoZSBnaXZlbiB2YWx1ZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgU3RyaW5nIC0+IGEgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHBhcmFtIHsqfSBvYmpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5lcXVhbHMsIFIucHJvcFNhdGlzZmllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhYmJ5ID0ge25hbWU6ICdBYmJ5JywgYWdlOiA3LCBoYWlyOiAnYmxvbmQnfTtcbiAgICAgKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJ307XG4gICAgICogICAgICB2YXIgcnVzdHkgPSB7bmFtZTogJ1J1c3R5JywgYWdlOiAxMCwgaGFpcjogJ2Jyb3duJ307XG4gICAgICogICAgICB2YXIgYWxvaXMgPSB7bmFtZTogJ0Fsb2lzJywgYWdlOiAxNSwgZGlzcG9zaXRpb246ICdzdXJseSd9O1xuICAgICAqICAgICAgdmFyIGtpZHMgPSBbYWJieSwgZnJlZCwgcnVzdHksIGFsb2lzXTtcbiAgICAgKiAgICAgIHZhciBoYXNCcm93bkhhaXIgPSBSLnByb3BFcSgnaGFpcicsICdicm93bicpO1xuICAgICAqICAgICAgUi5maWx0ZXIoaGFzQnJvd25IYWlyLCBraWRzKTsgLy89PiBbZnJlZCwgcnVzdHldXG4gICAgICovXG4gICAgdmFyIHByb3BFcSA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcEVxKG5hbWUsIHZhbCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wU2F0aXNmaWVzKGVxdWFscyh2YWwpLCBuYW1lLCBvYmopO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgb2YgdGhlIGdpdmVuIHR5cGU7XG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgVHlwZVxuICAgICAqIEBzaWcgVHlwZSAtPiBTdHJpbmcgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmlzLCBSLnByb3BTYXRpc2ZpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6IDEsIHk6IDJ9KTsgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt4OiAnZm9vJ30pOyAgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge30pOyAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgcHJvcElzID0gX2N1cnJ5MyhmdW5jdGlvbiBwcm9wSXModHlwZSwgbmFtZSwgb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wU2F0aXNmaWVzKGlzKHR5cGUpLCBuYW1lLCBvYmopO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICAgICAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IG1heSB1c2VcbiAgICAgKiBgUi5yZWR1Y2VkYCB0byBzaG9ydGN1dCB0aGUgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogTm90ZTogYFIucmVkdWNlYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAgICAgKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kLiBGb3IgbW9yZSBkZXRhaWxzXG4gICAgICogb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSNEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYHJlZHVjZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAgICAgKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5yZWR1Y2VkLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgM107XG4gICAgICogICAgICB2YXIgYWRkID0gKGEsIGIpID0+IGEgKyBiO1xuICAgICAqXG4gICAgICogICAgICBSLnJlZHVjZShhZGQsIDEwLCBudW1iZXJzKTsgLy89PiAxNlxuICAgICAqL1xuICAgIHZhciByZWR1Y2UgPSBfY3VycnkzKF9yZWR1Y2UpO1xuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIHRoZSBlbGVtZW50cyBvZiB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gICAgICogdGhlIFN0cmluZy1yZXR1cm5pbmcgZnVuY3Rpb24gYGtleUZuYCBvbiBlYWNoIGVsZW1lbnQgYW5kIHJlZHVjZXMgdGhlIGVsZW1lbnRzXG4gICAgICogb2YgZWFjaCBncm91cCB0byBhIHNpbmdsZSB2YWx1ZSB2aWEgdGhlIHJlZHVjZXIgZnVuY3Rpb24gYHZhbHVlRm5gLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBiYXNpY2FsbHkgYSBtb3JlIGdlbmVyYWwgYGdyb3VwQnlgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiAoYiAtPiBTdHJpbmcpIC0+IFtiXSAtPiB7U3RyaW5nOiBhfVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHZhbHVlRm4gVGhlIGZ1bmN0aW9uIHRoYXQgcmVkdWNlcyB0aGUgZWxlbWVudHMgb2YgZWFjaCBncm91cCB0byBhIHNpbmdsZVxuICAgICAqICAgICAgICB2YWx1ZS4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgYWNjdW11bGF0b3IgZm9yIGEgcGFydGljdWxhciBncm91cCBhbmQgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgKGluaXRpYWwpIGFjY3VtdWxhdG9yIHZhbHVlIGZvciBlYWNoIGdyb3VwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleUZuIFRoZSBmdW5jdGlvbiB0aGF0IG1hcHMgdGhlIGxpc3QncyBlbGVtZW50IGludG8gYSBrZXkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gZ3JvdXAuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBrZXlGbmAgZm9yIGtleXMsIG1hcHBlZCB0byB0aGUgb3V0cHV0IG9mXG4gICAgICogICAgICAgICBgdmFsdWVGbmAgZm9yIGVsZW1lbnRzIHdoaWNoIHByb2R1Y2VkIHRoYXQga2V5IHdoZW4gcGFzc2VkIHRvIGBrZXlGbmAuXG4gICAgICogQHNlZSBSLmdyb3VwQnksIFIucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHJlZHVjZVRvTmFtZXNCeSA9IFIucmVkdWNlQnkoKGFjYywgc3R1ZGVudCkgPT4gYWNjLmNvbmNhdChzdHVkZW50Lm5hbWUpLCBbXSk7XG4gICAgICogICAgICB2YXIgbmFtZXNCeUdyYWRlID0gcmVkdWNlVG9OYW1lc0J5KGZ1bmN0aW9uKHN0dWRlbnQpIHtcbiAgICAgKiAgICAgICAgdmFyIHNjb3JlID0gc3R1ZGVudC5zY29yZTtcbiAgICAgKiAgICAgICAgcmV0dXJuIHNjb3JlIDwgNjUgPyAnRicgOlxuICAgICAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gICAgICogICAgICAgICAgICAgICBzY29yZSA8IDgwID8gJ0MnIDpcbiAgICAgKiAgICAgICAgICAgICAgIHNjb3JlIDwgOTAgPyAnQicgOiAnQSc7XG4gICAgICogICAgICB9KTtcbiAgICAgKiAgICAgIHZhciBzdHVkZW50cyA9IFt7bmFtZTogJ0x1Y3knLCBzY29yZTogOTJ9LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnRHJldycsIHNjb3JlOiA4NX0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgLy8gLi4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdCYXJ0Jywgc2NvcmU6IDYyfV07XG4gICAgICogICAgICBuYW1lc0J5R3JhZGUoc3R1ZGVudHMpO1xuICAgICAqICAgICAgLy8ge1xuICAgICAqICAgICAgLy8gICAnQSc6IFsnTHVjeSddLFxuICAgICAqICAgICAgLy8gICAnQic6IFsnRHJldyddXG4gICAgICogICAgICAvLyAgIC8vIC4uLixcbiAgICAgKiAgICAgIC8vICAgJ0YnOiBbJ0JhcnQnXVxuICAgICAqICAgICAgLy8gfVxuICAgICAqL1xuICAgIHZhciByZWR1Y2VCeSA9IF9jdXJyeU4oNCwgW10sIGZ1bmN0aW9uIHJlZHVjZUJ5KHZhbHVlRm4sIHZhbHVlQWNjLCBrZXlGbiwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBlbHQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlGbihlbHQpO1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUZuKF9oYXMoa2V5LCBhY2MpID8gYWNjW2tleV0gOiB2YWx1ZUFjYywgZWx0KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9LCBsaXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGVtZW50IG9mIGBmaWx0ZXJgLlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBzZWUgUi5maWx0ZXIsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzT2RkID0gKG4pID0+IG4gJSAyID09PSAxO1xuICAgICAqXG4gICAgICogICAgICBSLnJlamVjdChpc09kZCwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAgICAgKlxuICAgICAqICAgICAgUi5yZWplY3QoaXNPZGQsIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGQ6IDR9XG4gICAgICovXG4gICAgdmFyIHJlamVjdCA9IF9jdXJyeTIoZnVuY3Rpb24gcmVqZWN0KHByZWQsIGZpbHRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihfY29tcGxlbWVudChwcmVkKSwgZmlsdGVyYWJsZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZml4ZWQgbGlzdCBvZiBzaXplIGBuYCBjb250YWluaW5nIGEgc3BlY2lmaWVkIGlkZW50aWNhbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gbiAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYG5gIGB2YWx1ZWBzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVwZWF0KCdoaScsIDUpOyAvLz0+IFsnaGknLCAnaGknLCAnaGknLCAnaGknLCAnaGknXVxuICAgICAqXG4gICAgICogICAgICB2YXIgb2JqID0ge307XG4gICAgICogICAgICB2YXIgcmVwZWF0ZWRPYmpzID0gUi5yZXBlYXQob2JqLCA1KTsgLy89PiBbe30sIHt9LCB7fSwge30sIHt9XVxuICAgICAqICAgICAgcmVwZWF0ZWRPYmpzWzBdID09PSByZXBlYXRlZE9ianNbMV07IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciByZXBlYXQgPSBfY3VycnkyKGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSwgbikge1xuICAgICAgICByZXR1cm4gdGltZXMoYWx3YXlzKHZhbHVlKSwgbik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRvZ2V0aGVyIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3VtIG9mIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgbGlzdC5cbiAgICAgKiBAc2VlIFIucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zdW0oWzIsNCw2LDgsMTAwLDFdKTsgLy89PiAxMjFcbiAgICAgKi9cbiAgICB2YXIgc3VtID0gcmVkdWNlKGFkZCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QuXG4gICAgICogSWYgYG4gPiBsaXN0Lmxlbmd0aGAsIHJldHVybnMgYSBsaXN0IG9mIGBsaXN0Lmxlbmd0aGAgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHNlZSBSLmRyb3BMYXN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50YWtlTGFzdCgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnYmF6J11cbiAgICAgKiAgICAgIFIudGFrZUxhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdtZGEnXG4gICAgICovXG4gICAgdmFyIHRha2VMYXN0ID0gX2N1cnJ5MihmdW5jdGlvbiB0YWtlTGFzdChuLCB4cykge1xuICAgICAgICByZXR1cm4gZHJvcChuID49IDAgPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSB0cmFuc2R1Y2VyIHVzaW5nIHN1cHBsaWVkIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZXR1cm5zIGEgc2luZ2xlXG4gICAgICogaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmcgdGhlIHRyYW5zZm9ybWVkXG4gICAgICogaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICogZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqLiBJdCB3aWxsIGJlXG4gICAgICogd3JhcHBlZCBhcyBhIHRyYW5zZm9ybWVyIHRvIGluaXRpYWxpemUgdGhlIHRyYW5zZHVjZXIuIEEgdHJhbnNmb3JtZXIgY2FuIGJlXG4gICAgICogcGFzc2VkIGRpcmVjdGx5IGluIHBsYWNlIG9mIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLiBJbiBib3RoIGNhc2VzLCBpdGVyYXRpb25cbiAgICAgKiBtYXkgYmUgc3RvcHBlZCBlYXJseSB3aXRoIHRoZSBgUi5yZWR1Y2VkYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEEgdHJhbnNkdWNlciBpcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGFcbiAgICAgKiB0cmFuc2Zvcm1lciBhbmQgY2FuIGJlIGNvbXBvc2VkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogQSB0cmFuc2Zvcm1lciBpcyBhbiBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhIDItYXJpdHkgcmVkdWNpbmcgaXRlcmF0b3JcbiAgICAgKiBmdW5jdGlvbiwgc3RlcCwgMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmQgMS1hcml0eSByZXN1bHRcbiAgICAgKiBleHRyYWN0aW9uIGZ1bmN0aW9uLCByZXN1bHQuIFRoZSBzdGVwIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGl0ZXJhdG9yXG4gICAgICogZnVuY3Rpb24gaW4gcmVkdWNlLiBUaGUgcmVzdWx0IGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmVydCB0aGUgZmluYWxcbiAgICAgKiBhY2N1bXVsYXRvciBpbnRvIHRoZSByZXR1cm4gdHlwZSBhbmQgaW4gbW9zdCBjYXNlcyBpcyBSLmlkZW50aXR5LiBUaGUgaW5pdFxuICAgICAqIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBhY2N1bXVsYXRvciwgYnV0IGlzIGlnbm9yZWQgYnlcbiAgICAgKiB0cmFuc2R1Y2UuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0aW9uIGlzIHBlcmZvcm1lZCB3aXRoIFIucmVkdWNlIGFmdGVyIGluaXRpYWxpemluZyB0aGUgdHJhbnNkdWNlci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYyAtPiBjKSAtPiAoYSxiIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiBUaGUgdHJhbnNkdWNlciBmdW5jdGlvbi4gUmVjZWl2ZXMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhIHRyYW5zZm9ybWVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAgICAgKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LiBXcmFwcGVkIGFzIHRyYW5zZm9ybWVyLCBpZiBuZWNlc3NhcnksIGFuZCB1c2VkIHRvXG4gICAgICogICAgICAgIGluaXRpYWxpemUgdGhlIHRyYW5zZHVjZXJcbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5yZWR1Y2UsIFIucmVkdWNlZCwgUi5pbnRvXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gICAgICogICAgICB2YXIgdHJhbnNkdWNlciA9IFIuY29tcG9zZShSLm1hcChSLmFkZCgxKSksIFIudGFrZSgyKSk7XG4gICAgICpcbiAgICAgKiAgICAgIFIudHJhbnNkdWNlKHRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgdHJhbnNkdWNlID0gY3VycnlOKDQsIGZ1bmN0aW9uIHRyYW5zZHVjZSh4ZiwgZm4sIGFjYywgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3JlZHVjZSh4Zih0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBfeHdyYXAoZm4pIDogZm4pLCBhY2MsIGxpc3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhlIGVsZW1lbnRzXG4gICAgICogb2YgZWFjaCBsaXN0LiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGUgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgKiBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIChhIC0+IGEgLT4gQm9vbGVhbikgLT4gWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmlyc3QgYW5kIHNlY29uZCBsaXN0cyBjb25jYXRlbmF0ZWQsIHdpdGhcbiAgICAgKiAgICAgICAgIGR1cGxpY2F0ZXMgcmVtb3ZlZC5cbiAgICAgKiBAc2VlIFIudW5pb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn1dO1xuICAgICAqICAgICAgdmFyIGwyID0gW3thOiAxfSwge2E6IDR9XTtcbiAgICAgKiAgICAgIFIudW5pb25XaXRoKFIuZXFCeShSLnByb3AoJ2EnKSksIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9LCB7YTogNH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IF9jdXJyeTMoZnVuY3Rpb24gdW5pb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICAgICAgICByZXR1cm4gdW5pcVdpdGgocHJlZCwgX2NvbmNhdChsaXN0MSwgbGlzdDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgc3BlYyBvYmplY3QgYW5kIGEgdGVzdCBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiB0aGUgdGVzdCBzYXRpc2ZpZXNcbiAgICAgKiB0aGUgc3BlYywgZmFsc2Ugb3RoZXJ3aXNlLiBBbiBvYmplY3Qgc2F0aXNmaWVzIHRoZSBzcGVjIGlmLCBmb3IgZWFjaCBvZiB0aGVcbiAgICAgKiBzcGVjJ3Mgb3duIHByb3BlcnRpZXMsIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZSBvYmplY3QgZ2l2ZXMgdGhlIHNhbWVcbiAgICAgKiB2YWx1ZSAoaW4gYFIuZXF1YWxzYCB0ZXJtcykgYXMgYWNjZXNzaW5nIHRoYXQgcHJvcGVydHkgb2YgdGhlIHNwZWMuXG4gICAgICpcbiAgICAgKiBgd2hlcmVFcWAgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBbYHdoZXJlYF0oI3doZXJlKS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIud2hlcmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gICAgICogICAgICB2YXIgcHJlZCA9IFIud2hlcmVFcSh7YTogMSwgYjogMn0pO1xuICAgICAqXG4gICAgICogICAgICBwcmVkKHthOiAxfSk7ICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBwcmVkKHthOiAxLCBiOiAyfSk7ICAgICAgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIHByZWQoe2E6IDEsIGI6IDIsIGM6IDN9KTsgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgcHJlZCh7YTogMSwgYjogMX0pOyAgICAgICAgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciB3aGVyZUVxID0gX2N1cnJ5MihmdW5jdGlvbiB3aGVyZUVxKHNwZWMsIHRlc3RPYmopIHtcbiAgICAgICAgcmV0dXJuIHdoZXJlKG1hcChlcXVhbHMsIHNwZWMpLCB0ZXN0T2JqKTtcbiAgICB9KTtcblxuICAgIHZhciBfZmxhdENhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXNlcnZpbmdSZWR1Y2VkID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IF9mb3JjZVJlZHVjZWQocmV0KSA6IHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gX3hjYXQoeGYpIHtcbiAgICAgICAgICAgIHZhciByeGYgPSBwcmVzZXJ2aW5nUmVkdWNlZCh4Zik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzQXJyYXlMaWtlKGlucHV0KSA/IF9yZWR1Y2UocnhmLCByZXN1bHQsIFtpbnB1dF0pIDogX3JlZHVjZShyeGYsIHJlc3VsdCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgLy8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgZG9lc24ndCBleGlzdCBiZWxvdyBJRTlcbiAgICAvLyBtYW51YWxseSBjcmF3bCB0aGUgbGlzdCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgIC8vIE5hTlxuICAgIC8vIG5vbi16ZXJvIG51bWJlcnMgY2FuIHV0aWxpc2UgU2V0XG4gICAgLy8gYWxsIHRoZXNlIHR5cGVzIGNhbiB1dGlsaXNlIFNldFxuICAgIC8vIG51bGwgY2FuIHV0aWxpc2UgU2V0XG4gICAgLy8gYW55dGhpbmcgZWxzZSBub3QgY292ZXJlZCBhYm92ZSwgZGVmZXIgdG8gUi5lcXVhbHNcbiAgICB2YXIgX2luZGV4T2YgPSBmdW5jdGlvbiBfaW5kZXhPZihsaXN0LCBhLCBpZHgpIHtcbiAgICAgICAgdmFyIGluZiwgaXRlbTtcbiAgICAgICAgLy8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgZG9lc24ndCBleGlzdCBiZWxvdyBJRTlcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0LmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgY3Jhd2wgdGhlIGxpc3QgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiArMCBhbmQgLTBcbiAgICAgICAgICAgICAgICAgICAgaW5mID0gMSAvIGE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSAwICYmIDEgLyBpdGVtID09PSBpbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYSAhPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYU5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyAmJiBpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm9uLXplcm8gbnVtYmVycyBjYW4gdXRpbGlzZSBTZXRcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG4gICAgICAgICAgICAvLyBhbGwgdGhlc2UgdHlwZXMgY2FuIHV0aWxpc2UgU2V0XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBjYW4gdXRpbGlzZSBTZXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbnl0aGluZyBlbHNlIG5vdCBjb3ZlcmVkIGFib3ZlLCBkZWZlciB0byBSLmVxdWFsc1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbHMobGlzdFtpZHhdLCBhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIHZhciBfeGNoYWluID0gX2N1cnJ5MihmdW5jdGlvbiBfeGNoYWluKGYsIHhmKSB7XG4gICAgICAgIHJldHVybiBtYXAoZiwgX2ZsYXRDYXQoeGYpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvciBhXG4gICAgICogZ2l2ZW4gbGlzdCBvZiBhcmd1bWVudHMgaWYgZXZlcnkgb25lIG9mIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVzIGlzIHNhdGlzZmllZFxuICAgICAqIGJ5IHRob3NlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5lZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gd2hvc2UgYXJpdHkgbWF0Y2hlcyB0aGF0IG9mIHRoZVxuICAgICAqIGhpZ2hlc3QtYXJpdHkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnIFsoKi4uLiAtPiBCb29sZWFuKV0gLT4gKCouLi4gLT4gQm9vbGVhbilcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcmVkc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5hbnlQYXNzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzUXVlZW4gPSBSLnByb3BFcSgncmFuaycsICdRJyk7XG4gICAgICogICAgICB2YXIgaXNTcGFkZSA9IFIucHJvcEVxKCdzdWl0JywgJ+KZoO+4jicpO1xuICAgICAqICAgICAgdmFyIGlzUXVlZW5PZlNwYWRlcyA9IFIuYWxsUGFzcyhbaXNRdWVlbiwgaXNTcGFkZV0pO1xuICAgICAqXG4gICAgICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZo++4jid9KTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgaXNRdWVlbk9mU3BhZGVzKHtyYW5rOiAnUScsIHN1aXQ6ICfimaDvuI4nfSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBhbGxQYXNzID0gX2N1cnJ5MShmdW5jdGlvbiBhbGxQYXNzKHByZWRzKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZWRzW2lkeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIGFyZSB1bmlxdWUsIGluIGBSLmVxdWFsc2AgdGVybXMsIG90aGVyd2lzZVxuICAgICAqIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW2FdIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIGFyZSB1bmlxdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2MC4yMC4wXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hbGxVbmlxKFsnMScsIDFdKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmFsbFVuaXEoWzEsIDFdKTsgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmFsbFVuaXEoW1s0Ml0sIFs0Ml1dKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBhbGxVbmlxID0gX2N1cnJ5MShmdW5jdGlvbiBhbGxVbmlxKGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKF9pbmRleE9mKGxpc3QsIGxpc3RbaWR4XSwgaWR4ICsgMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBsaXN0IG9mIHByZWRpY2F0ZXMgYW5kIHJldHVybnMgYSBwcmVkaWNhdGUgdGhhdCByZXR1cm5zIHRydWUgZm9yIGFcbiAgICAgKiBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXMgaXNcbiAgICAgKiBzYXRpc2ZpZWQgYnkgdGhvc2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gICAgICogaGlnaGVzdC1hcml0eSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgWygqLi4uIC0+IEJvb2xlYW4pXSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByZWRzXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmFsbFBhc3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZ3RlID0gUi5hbnlQYXNzKFtSLmd0LCBSLmVxdWFsc10pO1xuICAgICAqXG4gICAgICogICAgICBndGUoMywgMik7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgZ3RlKDIsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIGd0ZSgyLCAzKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBhbnlQYXNzID0gX2N1cnJ5MShmdW5jdGlvbiBhbnlQYXNzKHByZWRzKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZHNbaWR4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBhcCBhcHBsaWVzIGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYSBsaXN0IG9mIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuIEFsc29cbiAgICAgKiB0cmVhdHMgZnVuY3Rpb25zIGFzIGFwcGxpY2F0aXZlcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMy4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBbZl0gLT4gW2FdIC0+IFtmIGFdXG4gICAgICogQHBhcmFtIHtBcnJheX0gZm5zIEFuIGFycmF5IG9mIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZzIEFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiByZXN1bHRzIG9mIGFwcGx5aW5nIGVhY2ggb2YgYGZuc2AgdG8gYWxsIG9mIGB2c2AgaW4gdHVybi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFwKFtSLm11bHRpcGx5KDIpLCBSLmFkZCgzKV0sIFsxLDIsM10pOyAvLz0+IFsyLCA0LCA2LCA0LCA1LCA2XVxuICAgICAqL1xuICAgIC8vIGVsc2VcbiAgICB2YXIgYXAgPSBfY3VycnkyKGZ1bmN0aW9uIGFwKGFwcGxpY2F0aXZlLCBmbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGFwcGxpY2F0aXZlLmFwID09PSAnZnVuY3Rpb24nID8gYXBwbGljYXRpdmUuYXAoZm4pIDogdHlwZW9mIGFwcGxpY2F0aXZlID09PSAnZnVuY3Rpb24nID8gY3VycnlOKE1hdGgubWF4KGFwcGxpY2F0aXZlLmxlbmd0aCwgZm4ubGVuZ3RoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGxpY2F0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH0pIDogLy8gZWxzZVxuICAgICAgICBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGYpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29uY2F0KGFjYywgbWFwKGYsIGZuKSk7XG4gICAgICAgIH0sIFtdLCBhcHBsaWNhdGl2ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNwZWMgb2JqZWN0IHJlY3Vyc2l2ZWx5IG1hcHBpbmcgcHJvcGVydGllcyB0byBmdW5jdGlvbnMsIGNyZWF0ZXMgYVxuICAgICAqIGZ1bmN0aW9uIHByb2R1Y2luZyBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc3RydWN0dXJlLCBieSBtYXBwaW5nIGVhY2ggcHJvcGVydHlcbiAgICAgKiB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGFzc29jaWF0ZWQgZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyB7azogKChhLCBiLCAuLi4sIG0pIC0+IHYpfSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4ge2s6IHZ9KVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIGFuIG9iamVjdCByZWN1cnNpdmVseSBtYXBwaW5nIHByb3BlcnRpZXMgdG8gZnVuY3Rpb25zIGZvclxuICAgICAqICAgICAgICBwcm9kdWNpbmcgdGhlIHZhbHVlcyBmb3IgdGhlc2UgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHN0cnVjdHVyZVxuICAgICAqIGFzIGBzcGVjJywgd2l0aCBlYWNoIHByb3BlcnR5IHNldCB0byB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgY2FsbGluZyBpdHNcbiAgICAgKiBhc3NvY2lhdGVkIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBAc2VlIFIuanV4dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBnZXRNZXRyaWNzID0gUi5hcHBseVNwZWMoe1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW06IFIuYWRkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWQ6IHsgbXVsOiBSLm11bHRpcGx5IH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICogICAgICBnZXRNZXRyaWNzKDIsIDQpOyAvLyA9PiB7IHN1bTogNiwgbmVzdGVkOiB7IG11bDogOCB9IH1cbiAgICAgKi9cbiAgICB2YXIgYXBwbHlTcGVjID0gX2N1cnJ5MShmdW5jdGlvbiBhcHBseVNwZWMoc3BlYykge1xuICAgICAgICBzcGVjID0gbWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJyA/IHYgOiBhcHBseVNwZWModik7XG4gICAgICAgIH0sIHNwZWMpO1xuICAgICAgICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCB2YWx1ZXMoc3BlYykpKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gbWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGYsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgc3BlYyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGZpcnN0IGFyZ3VtZW50IHdpdGggdGhlIHJlbWFpbmluZ1xuICAgICAqIGFyZ3VtZW50cy4gVGhpcyBpcyBvY2Nhc2lvbmFsbHkgdXNlZnVsIGFzIGEgY29udmVyZ2luZyBmdW5jdGlvbiBmb3JcbiAgICAgKiBgUi5jb252ZXJnZWA6IHRoZSBsZWZ0IGJyYW5jaCBjYW4gcHJvZHVjZSBhIGZ1bmN0aW9uIHdoaWxlIHRoZSByaWdodCBicmFuY2hcbiAgICAgKiBwcm9kdWNlcyBhIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqLi4uIC0+IGEpLCouLi4gLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5hcHBseVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpbmRlbnROID0gUi5waXBlKFIudGltZXMoUi5hbHdheXMoJyAnKSksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBSLmpvaW4oJycpLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5yZXBsYWNlKC9eKD8hJCkvZ20pKTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGZvcm1hdCA9IFIuY29udmVyZ2UoUi5jYWxsLCBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5waXBlKFIucHJvcCgnaW5kZW50JyksIGluZGVudE4pLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucHJvcCgndmFsdWUnKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgIGZvcm1hdCh7aW5kZW50OiAyLCB2YWx1ZTogJ2Zvb1xcbmJhclxcbmJhelxcbid9KTsgLy89PiAnICBmb29cXG4gIGJhclxcbiAgYmF6XFxuJ1xuICAgICAqL1xuICAgIHZhciBjYWxsID0gY3VycnkoZnVuY3Rpb24gY2FsbChmbikge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgX3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogYGNoYWluYCBtYXBzIGEgZnVuY3Rpb24gb3ZlciBhIGxpc3QgYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0cy4gYGNoYWluYFxuICAgICAqIGlzIGFsc28ga25vd24gYXMgYGZsYXRNYXBgIGluIHNvbWUgbGlicmFyaWVzXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgY2hhaW5gIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gW2JdKSAtPiBbYV0gLT4gW2JdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGR1cGxpY2F0ZSA9IG4gPT4gW24sIG5dO1xuICAgICAqICAgICAgUi5jaGFpbihkdXBsaWNhdGUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDEsIDIsIDIsIDMsIDNdXG4gICAgICovXG4gICAgdmFyIGNoYWluID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdjaGFpbicsIF94Y2hhaW4sIGZ1bmN0aW9uIGNoYWluKGZuLCBtb25hZCkge1xuICAgICAgICBpZiAodHlwZW9mIG1vbmFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb25hZC5jYWxsKHRoaXMsIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbWFrZUZsYXQoZmFsc2UpKG1hcChmbiwgbW9uYWQpKTtcbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24sIGBmbmAsIHdoaWNoIGVuY2Fwc3VsYXRlcyBpZi9lbHNlLWlmL2Vsc2UgbG9naWMuXG4gICAgICogYFIuY29uZGAgdGFrZXMgYSBsaXN0IG9mIFtwcmVkaWNhdGUsIHRyYW5zZm9ybV0gcGFpcnMuIEFsbCBvZiB0aGUgYXJndW1lbnRzXG4gICAgICogdG8gYGZuYCBhcmUgYXBwbGllZCB0byBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm4gdW50aWwgb25lIHJldHVybnMgYVxuICAgICAqIFwidHJ1dGh5XCIgdmFsdWUsIGF0IHdoaWNoIHBvaW50IGBmbmAgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGl0c1xuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0cmFuc2Zvcm1lci4gSWYgbm9uZSBvZiB0aGUgcHJlZGljYXRlc1xuICAgICAqIG1hdGNoZXMsIGBmbmAgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgW1soKi4uLiAtPiBCb29sZWFuKSwoKi4uLiAtPiAqKV1dIC0+ICgqLi4uIC0+ICopXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZm4gPSBSLmNvbmQoW1xuICAgICAqICAgICAgICBbUi5lcXVhbHMoMCksICAgUi5hbHdheXMoJ3dhdGVyIGZyZWV6ZXMgYXQgMMKwQycpXSxcbiAgICAgKiAgICAgICAgW1IuZXF1YWxzKDEwMCksIFIuYWx3YXlzKCd3YXRlciBib2lscyBhdCAxMDDCsEMnKV0sXG4gICAgICogICAgICAgIFtSLlQsICAgICAgICAgICB0ZW1wID0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCAnICsgdGVtcCArICfCsEMnXVxuICAgICAqICAgICAgXSk7XG4gICAgICogICAgICBmbigwKTsgLy89PiAnd2F0ZXIgZnJlZXplcyBhdCAwwrBDJ1xuICAgICAqICAgICAgZm4oNTApOyAvLz0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCA1MMKwQydcbiAgICAgKiAgICAgIGZuKDEwMCk7IC8vPT4gJ3dhdGVyIGJvaWxzIGF0IDEwMMKwQydcbiAgICAgKi9cbiAgICB2YXIgY29uZCA9IF9jdXJyeTEoZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgICB2YXIgYXJpdHkgPSByZWR1Y2UobWF4LCAwLCBtYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWlyWzBdLmxlbmd0aDtcbiAgICAgICAgfSwgcGFpcnMpKTtcbiAgICAgICAgcmV0dXJuIF9hcml0eShhcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhaXJzW2lkeF1bMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcnNbaWR4XVsxXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGluc2lkZSBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkXG4gICAgICogd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYW5kIHJldHVybnMgdGhlIHNhbWUgdHlwZS4gVGhlIGFyaXR5IG9mIHRoZSBmdW5jdGlvblxuICAgICAqIHJldHVybmVkIGlzIHNwZWNpZmllZCB0byBhbGxvdyB1c2luZyB2YXJpYWRpYyBjb25zdHJ1Y3RvciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBhcml0eSBvZiB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gRm4gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgd3JhcHBlZCwgY3VycmllZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBWYXJpYWRpYyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgICAqICAgICAgdmFyIFdpZGdldCA9ICgpID0+IHtcbiAgICAgKiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIFdpZGdldC5wcm90b3R5cGUgPSB7XG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBhbGxDb25maWdzID0gW1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIF07XG4gICAgICogICAgICBSLm1hcChSLmNvbnN0cnVjdE4oMSwgV2lkZ2V0KSwgYWxsQ29uZmlncyk7IC8vIGEgbGlzdCBvZiBXaWRnZXRzXG4gICAgICovXG4gICAgdmFyIGNvbnN0cnVjdE4gPSBfY3VycnkyKGZ1bmN0aW9uIGNvbnN0cnVjdE4obiwgRm4pIHtcbiAgICAgICAgaWYgKG4gPiAxMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RvciB3aXRoIGdyZWF0ZXIgdGhhbiB0ZW4gYXJndW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycnkobkFyeShuLCBmdW5jdGlvbiAoJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCwgJDkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDApO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0KTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgsICQ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIGNvbnZlcmdpbmcgZnVuY3Rpb24gYW5kIGEgbGlzdCBvZiBicmFuY2hpbmcgZnVuY3Rpb25zIGFuZCByZXR1cm5zXG4gICAgICogYSBuZXcgZnVuY3Rpb24uIFdoZW4gaW52b2tlZCwgdGhpcyBuZXcgZnVuY3Rpb24gaXMgYXBwbGllZCB0byBzb21lXG4gICAgICogYXJndW1lbnRzLCBlYWNoIGJyYW5jaGluZyBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRob3NlIHNhbWUgYXJndW1lbnRzLiBUaGVcbiAgICAgKiByZXN1bHRzIG9mIGVhY2ggYnJhbmNoaW5nIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIHRoZSBjb252ZXJnaW5nXG4gICAgICogZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICh4MSAtPiB4MiAtPiAuLi4gLT4geikgLT4gWyhhIC0+IGIgLT4gLi4uIC0+IHgxKSwgKGEgLT4gYiAtPiAuLi4gLT4geDIpLCAuLi5dIC0+IChhIC0+IGIgLT4gLi4uIC0+IHopXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWZ0ZXIgQSBmdW5jdGlvbi4gYGFmdGVyYCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlcyBvZlxuICAgICAqICAgICAgICBgZm4xYCBhbmQgYGZuMmAgYXMgaXRzIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmdW5jdGlvbnMgQSBsaXN0IG9mIGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZCA9IChhLCBiKSA9PiBhICsgYjtcbiAgICAgKiAgICAgIHZhciBtdWx0aXBseSA9IChhLCBiKSA9PiBhICogYjtcbiAgICAgKiAgICAgIHZhciBzdWJ0cmFjdCA9IChhLCBiKSA9PiBhIC0gYjtcbiAgICAgKlxuICAgICAqICAgICAgLy/iiYUgbXVsdGlwbHkoIGFkZCgxLCAyKSwgc3VidHJhY3QoMSwgMikgKTtcbiAgICAgKiAgICAgIFIuY29udmVyZ2UobXVsdGlwbHksIFthZGQsIHN1YnRyYWN0XSkoMSwgMik7IC8vPT4gLTNcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZDMgPSAoYSwgYiwgYykgPT4gYSArIGIgKyBjO1xuICAgICAqICAgICAgUi5jb252ZXJnZShhZGQzLCBbbXVsdGlwbHksIGFkZCwgc3VidHJhY3RdKSgxLCAyKTsgLy89PiA0XG4gICAgICovXG4gICAgdmFyIGNvbnZlcmdlID0gX2N1cnJ5MihmdW5jdGlvbiBjb252ZXJnZShhZnRlciwgZm5zKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIGZucykpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBhZnRlci5hcHBseShjb250ZXh0LCBfbWFwKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIGZucykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgZWxlbWVudHMgb2YgYSBsaXN0IGFjY29yZGluZyB0byBob3cgbWFueSBtYXRjaCBlYWNoIHZhbHVlIG9mIGFcbiAgICAgKiBrZXkgZ2VuZXJhdGVkIGJ5IHRoZSBzdXBwbGllZCBmdW5jdGlvbi4gUmV0dXJucyBhbiBvYmplY3QgbWFwcGluZyB0aGUga2V5c1xuICAgICAqIHByb2R1Y2VkIGJ5IGBmbmAgdG8gdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBpbiB0aGUgbGlzdC4gTm90ZSB0aGF0IGFsbFxuICAgICAqIGtleXMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBiZWNhdXNlIG9mIGhvdyBKYXZhU2NyaXB0IG9iamVjdHMgd29yay5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSAtPiBTdHJpbmcpIC0+IFthXSAtPiB7Kn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBtYXAgdmFsdWVzIHRvIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBjb3VudCBlbGVtZW50cyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IG1hcHBpbmcga2V5cyB0byBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgaW4gdGhlIGxpc3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMS4wLCAxLjEsIDEuMiwgMi4wLCAzLjAsIDIuMl07XG4gICAgICogICAgICB2YXIgbGV0dGVycyA9IFIuc3BsaXQoJycsICdhYmNBQkNhYWFCQmMnKTtcbiAgICAgKiAgICAgIFIuY291bnRCeShNYXRoLmZsb29yKShudW1iZXJzKTsgICAgLy89PiB7JzEnOiAzLCAnMic6IDIsICczJzogMX1cbiAgICAgKiAgICAgIFIuY291bnRCeShSLnRvTG93ZXIpKGxldHRlcnMpOyAgIC8vPT4geydhJzogNSwgJ2InOiA0LCAnYyc6IDN9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSByZWR1Y2VCeShmdW5jdGlvbiAoYWNjLCBlbGVtKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyAxO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgYW55IGNvbnNlY3V0aXZlbHkgcmVwZWF0aW5nIGVsZW1lbnRzLiBFcXVhbGl0eSBpc1xuICAgICAqIGRldGVybWluZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0d28gY29uc2VjdXRpdmUgZWxlbWVudHMuIFRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnQgaW4gYSBzZXJpZXMgb2YgZXF1YWwgZWxlbWVudCBpcyB0aGUgb25lIGJlaW5nIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wUmVwZWF0c1dpdGhgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhLCBhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IGBsaXN0YCB3aXRob3V0IHJlcGVhdGluZyBlbGVtZW50cy5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGwgPSBbMSwgLTEsIDEsIDMsIDQsIC00LCAtNCwgLTUsIDUsIDMsIDNdO1xuICAgICAqICAgICAgUi5kcm9wUmVwZWF0c1dpdGgoUi5lcUJ5KE1hdGguYWJzKSwgbCk7IC8vPT4gWzEsIDMsIDQsIC01LCAzXVxuICAgICAqL1xuICAgIHZhciBkcm9wUmVwZWF0c1dpdGggPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2Ryb3BSZXBlYXRzV2l0aCcsIF94ZHJvcFJlcGVhdHNXaXRoLCBmdW5jdGlvbiBkcm9wUmVwZWF0c1dpdGgocHJlZCwgbGlzdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAxO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IGxpc3RbMF07XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVkKGxhc3QocmVzdWx0KSwgbGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBmdW5jdGlvbiBhbmQgdHdvIHZhbHVlcyBpbiBpdHMgZG9tYWluIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVcbiAgICAgKiB2YWx1ZXMgbWFwIHRvIHRoZSBzYW1lIHZhbHVlIGluIHRoZSBjb2RvbWFpbjsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIChhIC0+IGIpIC0+IGEgLT4gYSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEBwYXJhbSB7Kn0geVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5lcUJ5KE1hdGguYWJzLCA1LCAtNSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBlcUJ5ID0gX2N1cnJ5MyhmdW5jdGlvbiBlcUJ5KGYsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFscyhmKHgpLCBmKHkpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0d28gb2JqZWN0cyBoYXZlIHRoZSBzYW1lIHZhbHVlLCBpbiBgUi5lcXVhbHNgIHRlcm1zLCBmb3JcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBVc2VmdWwgYXMgYSBjdXJyaWVkIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgayAtPiB7azogdn0gLT4ge2s6IHZ9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG8xID0geyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0IH07XG4gICAgICogICAgICB2YXIgbzIgPSB7IGE6IDEwLCBiOiAyMCwgYzogMywgZDogNDAgfTtcbiAgICAgKiAgICAgIFIuZXFQcm9wcygnYScsIG8xLCBvMik7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZXFQcm9wcygnYycsIG8xLCBvMik7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBlcVByb3BzID0gX2N1cnJ5MyhmdW5jdGlvbiBlcVByb3BzKHByb3AsIG9iajEsIG9iajIpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFscyhvYmoxW3Byb3BdLCBvYmoyW3Byb3BdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIGxpc3QgaW50byBzdWItbGlzdHMgc3RvcmVkIGluIGFuIG9iamVjdCwgYmFzZWQgb24gdGhlIHJlc3VsdCBvZlxuICAgICAqIGNhbGxpbmcgYSBTdHJpbmctcmV0dXJuaW5nIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCwgYW5kIGdyb3VwaW5nIHRoZVxuICAgICAqIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHZhbHVlcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBncm91cEJ5YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW2FdIC0+IHtTdHJpbmc6IFthXX1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiA6OiBhIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBmbmAgZm9yIGtleXMsIG1hcHBlZCB0byBhcnJheXMgb2YgZWxlbWVudHNcbiAgICAgKiAgICAgICAgIHRoYXQgcHJvZHVjZWQgdGhhdCBrZXkgd2hlbiBwYXNzZWQgdG8gYGZuYC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGJ5R3JhZGUgPSBSLmdyb3VwQnkoZnVuY3Rpb24oc3R1ZGVudCkge1xuICAgICAqICAgICAgICB2YXIgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICAgICAqICAgICAgICByZXR1cm4gc2NvcmUgPCA2NSA/ICdGJyA6XG4gICAgICogICAgICAgICAgICAgICBzY29yZSA8IDcwID8gJ0QnIDpcbiAgICAgKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICAgICAqICAgICAgICAgICAgICAgc2NvcmUgPCA5MCA/ICdCJyA6ICdBJztcbiAgICAgKiAgICAgIH0pO1xuICAgICAqICAgICAgdmFyIHN0dWRlbnRzID0gW3tuYW1lOiAnQWJieScsIHNjb3JlOiA4NH0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdFZGR5Jywgc2NvcmU6IDU4fSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0phY2snLCBzY29yZTogNjl9XTtcbiAgICAgKiAgICAgIGJ5R3JhZGUoc3R1ZGVudHMpO1xuICAgICAqICAgICAgLy8ge1xuICAgICAqICAgICAgLy8gICAnQSc6IFt7bmFtZTogJ0RpYW5uZScsIHNjb3JlOiA5OX1dLFxuICAgICAqICAgICAgLy8gICAnQic6IFt7bmFtZTogJ0FiYnknLCBzY29yZTogODR9XVxuICAgICAqICAgICAgLy8gICAvLyAuLi4sXG4gICAgICogICAgICAvLyAgICdGJzogW3tuYW1lOiAnRWRkeScsIHNjb3JlOiA1OH1dXG4gICAgICogICAgICAvLyB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2dyb3VwQnknLCBfeGdyb3VwQnksIHJlZHVjZUJ5KGZ1bmN0aW9uIChhY2MsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGFjYyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhY2MucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBudWxsKSkpO1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIGtleSwgdHVybnMgYSBsaXN0IG9mIG9iamVjdHMgaW50byBhblxuICAgICAqIG9iamVjdCBpbmRleGluZyB0aGUgb2JqZWN0cyBieSB0aGUgZ2l2ZW4ga2V5LiBOb3RlIHRoYXQgaWYgbXVsdGlwbGVcbiAgICAgKiBvYmplY3RzIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlIGZvciB0aGUgaW5kZXhpbmcga2V5IG9ubHkgdGhlIGxhc3QgdmFsdWVcbiAgICAgKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW3trOiB2fV0gLT4ge2s6IHtrOiB2fX1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiA6OiBhIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBvYmplY3RzIHRvIGluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgaW5kZXhpbmcgZWFjaCBhcnJheSBlbGVtZW50IGJ5IHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbGlzdCA9IFt7aWQ6ICd4eXonLCB0aXRsZTogJ0EnfSwge2lkOiAnYWJjJywgdGl0bGU6ICdCJ31dO1xuICAgICAqICAgICAgUi5pbmRleEJ5KFIucHJvcCgnaWQnKSwgbGlzdCk7XG4gICAgICogICAgICAvLz0+IHthYmM6IHtpZDogJ2FiYycsIHRpdGxlOiAnQid9LCB4eXo6IHtpZDogJ3h5eicsIHRpdGxlOiAnQSd9fVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gcmVkdWNlQnkoZnVuY3Rpb24gKGFjYywgZWxlbSkge1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9LCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xXG4gICAgICogaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gYFIuZXF1YWxzYCBpcyB1c2VkIHRvIGRldGVybWluZVxuICAgICAqIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIGl0ZW0gdG8gZmluZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGluZGV4IG9mIHRoZSB0YXJnZXQsIG9yIC0xIGlmIHRoZSB0YXJnZXQgaXMgbm90IGZvdW5kLlxuICAgICAqIEBzZWUgUi5sYXN0SW5kZXhPZlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW5kZXhPZigzLCBbMSwyLDMsNF0pOyAvLz0+IDJcbiAgICAgKiAgICAgIFIuaW5kZXhPZigxMCwgWzEsMiwzLDRdKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBpbmRleE9mID0gX2N1cnJ5MihmdW5jdGlvbiBpbmRleE9mKHRhcmdldCwgeHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4cy5pbmRleE9mID09PSAnZnVuY3Rpb24nICYmICFfaXNBcnJheSh4cykgPyB4cy5pbmRleE9mKHRhcmdldCkgOiBfaW5kZXhPZih4cywgdGFyZ2V0LCAwKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIGp1eHQgYXBwbGllcyBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGEgbGlzdCBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIFsoYSwgYiwgLi4uLCBtKSAtPiBuXSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4gW25dKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZucyBBbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXN0IG9mIHZhbHVlcyBhZnRlciBhcHBseWluZyBlYWNoIG9mIHRoZSBvcmlnaW5hbCBgZm5zYCB0byBpdHMgcGFyYW1ldGVycy5cbiAgICAgKiBAc2VlIFIuYXBwbHlTcGVjXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHJhbmdlID0gUi5qdXh0KFtNYXRoLm1pbiwgTWF0aC5tYXhdKTtcbiAgICAgKiAgICAgIHJhbmdlKDMsIDQsIDksIC0zKTsgLy89PiBbLTMsIDldXG4gICAgICovXG4gICAgdmFyIGp1eHQgPSBfY3VycnkxKGZ1bmN0aW9uIGp1eHQoZm5zKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJnZShfYXJyYXlPZiwgZm5zKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsZW5zIGZvciB0aGUgZ2l2ZW4gZ2V0dGVyIGFuZCBzZXR0ZXIgZnVuY3Rpb25zLiBUaGUgZ2V0dGVyIFwiZ2V0c1wiXG4gICAgICogdGhlIHZhbHVlIG9mIHRoZSBmb2N1czsgdGhlIHNldHRlciBcInNldHNcIiB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzLiBUaGUgc2V0dGVyXG4gICAgICogc2hvdWxkIG5vdCBtdXRhdGUgdGhlIGRhdGEgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIChzIC0+IGEpIC0+ICgoYSwgcykgLT4gcykgLT4gTGVucyBzIGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKiBAcmV0dXJuIHtMZW5zfVxuICAgICAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4TGVucyA9IFIubGVucyhSLnByb3AoJ3gnKSwgUi5hc3NvYygneCcpKTtcbiAgICAgKlxuICAgICAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgICAgICAgICAgIC8vPT4gMVxuICAgICAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gICAgICogICAgICBSLm92ZXIoeExlbnMsIFIubmVnYXRlLCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogLTEsIHk6IDJ9XG4gICAgICovXG4gICAgdmFyIGxlbnMgPSBfY3VycnkyKGZ1bmN0aW9uIGxlbnMoZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b0Z1bmN0b3JGbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwKGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGVyKGZvY3VzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0sIHRvRnVuY3RvckZuKGdldHRlcih0YXJnZXQpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICAgICAqIEBzaWcgTnVtYmVyIC0+IExlbnMgcyBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgKiBAcmV0dXJuIHtMZW5zfVxuICAgICAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGhlYWRMZW5zID0gUi5sZW5zSW5kZXgoMCk7XG4gICAgICpcbiAgICAgKiAgICAgIFIudmlldyhoZWFkTGVucywgWydhJywgJ2InLCAnYyddKTsgICAgICAgICAgICAvLz0+ICdhJ1xuICAgICAqICAgICAgUi5zZXQoaGVhZExlbnMsICd4JywgWydhJywgJ2InLCAnYyddKTsgICAgICAgIC8vPT4gWyd4JywgJ2InLCAnYyddXG4gICAgICogICAgICBSLm92ZXIoaGVhZExlbnMsIFIudG9VcHBlciwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbJ0EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgbGVuc0luZGV4ID0gX2N1cnJ5MShmdW5jdGlvbiBsZW5zSW5kZXgobikge1xuICAgICAgICByZXR1cm4gbGVucyhudGgobiksIHVwZGF0ZShuKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IExlbnMgcyBhXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB1c2UuXG4gICAgICogQHJldHVybiB7TGVuc31cbiAgICAgKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4eUxlbnMgPSBSLmxlbnNQYXRoKFsneCcsICd5J10pO1xuICAgICAqXG4gICAgICogICAgICBSLnZpZXcoeHlMZW5zLCB7eDoge3k6IDIsIHo6IDN9fSk7ICAgICAgICAgICAgLy89PiAyXG4gICAgICogICAgICBSLnNldCh4eUxlbnMsIDQsIHt4OiB7eTogMiwgejogM319KTsgICAgICAgICAgLy89PiB7eDoge3k6IDQsIHo6IDN9fVxuICAgICAqICAgICAgUi5vdmVyKHh5TGVucywgUi5uZWdhdGUsIHt4OiB7eTogMiwgejogM319KTsgIC8vPT4ge3g6IHt5OiAtMiwgejogM319XG4gICAgICovXG4gICAgdmFyIGxlbnNQYXRoID0gX2N1cnJ5MShmdW5jdGlvbiBsZW5zUGF0aChwKSB7XG4gICAgICAgIHJldHVybiBsZW5zKHBhdGgocCksIGFzc29jUGF0aChwKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gICAgICogQHNpZyBTdHJpbmcgLT4gTGVucyBzIGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga1xuICAgICAqIEByZXR1cm4ge0xlbnN9XG4gICAgICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gICAgICpcbiAgICAgKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgICAvLz0+IDFcbiAgICAgKiAgICAgIFIuc2V0KHhMZW5zLCA0LCB7eDogMSwgeTogMn0pOyAgICAgICAgICAvLz0+IHt4OiA0LCB5OiAyfVxuICAgICAqICAgICAgUi5vdmVyKHhMZW5zLCBSLm5lZ2F0ZSwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IC0xLCB5OiAyfVxuICAgICAqL1xuICAgIHZhciBsZW5zUHJvcCA9IF9jdXJyeTEoZnVuY3Rpb24gbGVuc1Byb3Aoaykge1xuICAgICAgICByZXR1cm4gbGVucyhwcm9wKGspLCBhc3NvYyhrKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBcImxpZnRzXCIgYSBmdW5jdGlvbiB0byBiZSB0aGUgc3BlY2lmaWVkIGFyaXR5LCBzbyB0aGF0IGl0IG1heSBcIm1hcCBvdmVyXCIgdGhhdFxuICAgICAqIG1hbnkgbGlzdHMsIEZ1bmN0aW9ucyBvciBvdGhlciBvYmplY3RzIHRoYXQgc2F0aXNmeSB0aGUgW0ZhbnRhc3lMYW5kIEFwcGx5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHkpLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIE51bWJlciAtPiAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBsaWZ0ZWQgZnVuY3Rpb24uXG4gICAgICogQHNlZSBSLmxpZnQsIFIuYXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWFkZDMgPSBSLmxpZnROKDMsIFIuY3VycnlOKDMsICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKSkpO1xuICAgICAqICAgICAgbWFkZDMoWzEsMiwzXSwgWzEsMiwzXSwgWzFdKTsgLy89PiBbMywgNCwgNSwgNCwgNSwgNiwgNSwgNiwgN11cbiAgICAgKi9cbiAgICB2YXIgbGlmdE4gPSBfY3VycnkyKGZ1bmN0aW9uIGxpZnROKGFyaXR5LCBmbikge1xuICAgICAgICB2YXIgbGlmdGVkID0gY3VycnlOKGFyaXR5LCBmbik7XG4gICAgICAgIHJldHVybiBjdXJyeU4oYXJpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKGFwLCBtYXAobGlmdGVkLCBhcmd1bWVudHNbMF0pLCBfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiBvZiB0aGUgZ2l2ZW4gbGlzdCBvZiBudW1iZXJzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZWFuKFsyLCA3LCA5XSk7IC8vPT4gNlxuICAgICAqICAgICAgUi5tZWFuKFtdKTsgLy89PiBOYU5cbiAgICAgKi9cbiAgICB2YXIgbWVhbiA9IF9jdXJyeTEoZnVuY3Rpb24gbWVhbihsaXN0KSB7XG4gICAgICAgIHJldHVybiBzdW0obGlzdCkgLyBsaXN0Lmxlbmd0aDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lZGlhbiBvZiB0aGUgZ2l2ZW4gbGlzdCBvZiBudW1iZXJzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZWRpYW4oWzIsIDksIDddKTsgLy89PiA3XG4gICAgICogICAgICBSLm1lZGlhbihbNywgMiwgMTAsIDldKTsgLy89PiA4XG4gICAgICogICAgICBSLm1lZGlhbihbXSk7IC8vPT4gTmFOXG4gICAgICovXG4gICAgdmFyIG1lZGlhbiA9IF9jdXJyeTEoZnVuY3Rpb24gbWVkaWFuKGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IDIgLSBsZW4gJSAyO1xuICAgICAgICB2YXIgaWR4ID0gKGxlbiAtIHdpZHRoKSAvIDI7XG4gICAgICAgIHJldHVybiBtZWFuKF9zbGljZShsaXN0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgIH0pLnNsaWNlKGlkeCwgaWR4ICsgd2lkdGgpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIGxpc3Qgb3Igb3RoZXIgXCJmaWx0ZXJhYmxlXCIgb2JqZWN0IGFuZCByZXR1cm5zIHRoZVxuICAgICAqIHBhaXIgb2YgZmlsdGVyYWJsZSBvYmplY3RzIG9mIHRoZSBzYW1lIHR5cGUgb2YgZWxlbWVudHMgd2hpY2ggZG8gYW5kIGRvIG5vdFxuICAgICAqIHNhdGlzZnksIHRoZSBwcmVkaWNhdGUsIHJlc3BlY3RpdmVseS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS40XG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gW2YgYSwgZiBhXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpZGUgdGhlIGVsZW1lbnQgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlIHRoZSBsaXN0IChvciBvdGhlciBmaWx0ZXJhYmxlKSB0byBwYXJ0aXRpb24uXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5LCBjb250YWluaW5nIGZpcnN0IHRoZSBzdWJzZXQgb2YgZWxlbWVudHMgdGhhdCBzYXRpc2Z5IHRoZVxuICAgICAqICAgICAgICAgcHJlZGljYXRlLCBhbmQgc2Vjb25kIHRoZSBzdWJzZXQgb2YgZWxlbWVudHMgdGhhdCBkbyBub3Qgc2F0aXNmeS5cbiAgICAgKiBAc2VlIFIuZmlsdGVyLCBSLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGFydGl0aW9uKFIuY29udGFpbnMoJ3MnKSwgWydzc3MnLCAndHR0JywgJ2ZvbycsICdiYXJzJ10pO1xuICAgICAqICAgICAgLy8gPT4gWyBbICdzc3MnLCAnYmFycycgXSwgIFsgJ3R0dCcsICdmb28nIF0gXVxuICAgICAqXG4gICAgICogICAgICBSLnBhcnRpdGlvbihSLmNvbnRhaW5zKCdzJyksIHsgYTogJ3NzcycsIGI6ICd0dHQnLCBmb286ICdiYXJzJyB9KTtcbiAgICAgKiAgICAgIC8vID0+IFsgeyBhOiAnc3NzJywgZm9vOiAnYmFycycgfSwgeyBiOiAndHR0JyB9ICBdXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGp1eHQoW1xuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHJlamVjdFxuICAgIF0pO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGVmdC10by1yaWdodCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIGxlZnRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlXG4gICAgICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGZ1bmN0aW9ucyBtdXN0IGJlIHVuYXJ5LlxuICAgICAqXG4gICAgICogSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgc2VxdWVuY2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgcGlwZSBpcyBub3QgYXV0b21hdGljYWxseSBjdXJyaWVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoKGEsIGIsIC4uLiwgbikgLT4gbyksIChvIC0+IHApLCAuLi4sICh4IC0+IHkpLCAoeSAtPiB6KSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmNvbXBvc2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZiA9IFIucGlwZShNYXRoLnBvdywgUi5uZWdhdGUsIFIuaW5jKTtcbiAgICAgKlxuICAgICAqICAgICAgZigzLCA0KTsgLy8gLSgzXjQpICsgMVxuICAgICAqL1xuICAgIHZhciBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsIHJlZHVjZShfcGlwZSwgYXJndW1lbnRzWzBdLCB0YWlsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGVmdC10by1yaWdodCBjb21wb3NpdGlvbiBvZiBvbmUgb3IgbW9yZSBQcm9taXNlLXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9ucy4gVGhlIGxlZnRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnNcbiAgICAgKiBtdXN0IGJlIHVuYXJ5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKGEgLT4gUHJvbWlzZSBiKSwgKGIgLT4gUHJvbWlzZSBjKSwgLi4uLCAoeSAtPiBQcm9taXNlIHopKSAtPiAoYSAtPiBQcm9taXNlIHopXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmNvbXBvc2VQXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gIGZvbGxvd2Vyc0ZvclVzZXIgOjogU3RyaW5nIC0+IFByb21pc2UgW1VzZXJdXG4gICAgICogICAgICB2YXIgZm9sbG93ZXJzRm9yVXNlciA9IFIucGlwZVAoZGIuZ2V0VXNlckJ5SWQsIGRiLmdldEZvbGxvd2Vycyk7XG4gICAgICovXG4gICAgdmFyIHBpcGVQID0gZnVuY3Rpb24gcGlwZVAoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVQIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCwgcmVkdWNlKF9waXBlUCwgYXJndW1lbnRzWzBdLCB0YWlsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0b2dldGhlciBhbGwgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2YgbnVtYmVyc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHByb2R1Y3Qgb2YgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBsaXN0LlxuICAgICAqIEBzZWUgUi5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb2R1Y3QoWzIsNCw2LDgsMTAwLDFdKTsgLy89PiAzODQwMFxuICAgICAqL1xuICAgIHZhciBwcm9kdWN0ID0gcmVkdWNlKG11bHRpcGx5LCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBbVHJhdmVyc2FibGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2FibGUpXG4gICAgICogb2YgW0FwcGxpY2F0aXZlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGxpY2F0aXZlKSBpbnRvIGFuXG4gICAgICogQXBwbGljYXRpdmUgb2YgVHJhdmVyc2FibGUuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2VxdWVuY2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChBcHBsaWNhdGl2ZSBmLCBUcmF2ZXJzYWJsZSB0KSA9PiAoYSAtPiBmIGEpIC0+IHQgKGYgYSkgLT4gZiAodCBhKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9mXG4gICAgICogQHBhcmFtIHsqfSB0cmF2ZXJzYWJsZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnRyYXZlcnNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldKTsgICAvLz0+IEp1c3QoWzEsIDIsIDNdKVxuICAgICAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIE5vdGhpbmcoKV0pOyAvLz0+IE5vdGhpbmcoKVxuICAgICAqXG4gICAgICogICAgICBSLnNlcXVlbmNlKFIub2YsIEp1c3QoWzEsIDIsIDNdKSk7IC8vPT4gW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldXG4gICAgICogICAgICBSLnNlcXVlbmNlKFIub2YsIE5vdGhpbmcoKSk7ICAgICAgIC8vPT4gW05vdGhpbmcoKV1cbiAgICAgKi9cbiAgICB2YXIgc2VxdWVuY2UgPSBfY3VycnkyKGZ1bmN0aW9uIHNlcXVlbmNlKG9mLCB0cmF2ZXJzYWJsZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRyYXZlcnNhYmxlLnNlcXVlbmNlID09PSAnZnVuY3Rpb24nID8gdHJhdmVyc2FibGUuc2VxdWVuY2Uob2YpIDogcmVkdWNlUmlnaHQoZnVuY3Rpb24gKGFjYywgeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwKG1hcChwcmVwZW5kLCB4KSwgYWNjKTtcbiAgICAgICAgfSwgb2YoW10pLCB0cmF2ZXJzYWJsZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSktcmV0dXJuaW5nXG4gICAgICogZnVuY3Rpb24gb3ZlciBhIFtUcmF2ZXJzYWJsZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0cmF2ZXJzYWJsZSksXG4gICAgICogdGhlbiB1c2VzIFtgc2VxdWVuY2VgXSgjc2VxdWVuY2UpIHRvIHRyYW5zZm9ybSB0aGUgcmVzdWx0aW5nIFRyYXZlcnNhYmxlIG9mIEFwcGxpY2F0aXZlXG4gICAgICogaW50byBhbiBBcHBsaWNhdGl2ZSBvZiBUcmF2ZXJzYWJsZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBzZXF1ZW5jZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKGEgLT4gZiBhKSAtPiAoYSAtPiBmIGIpIC0+IHQgYSAtPiBmICh0IGIpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2ZcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHBhcmFtIHsqfSB0cmF2ZXJzYWJsZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnNlcXVlbmNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gUmV0dXJucyBgTm90aGluZ2AgaWYgdGhlIGdpdmVuIGRpdmlzb3IgaXMgYDBgXG4gICAgICogICAgICBzYWZlRGl2ID0gbiA9PiBkID0+IGQgPT09IDAgPyBOb3RoaW5nKCkgOiBKdXN0KG4gLyBkKVxuICAgICAqXG4gICAgICogICAgICBSLnRyYXZlcnNlKE1heWJlLm9mLCBzYWZlRGl2KDEwKSwgWzIsIDQsIDVdKTsgLy89PiBKdXN0KFs1LCAyLjUsIDJdKVxuICAgICAqICAgICAgUi50cmF2ZXJzZShNYXliZS5vZiwgc2FmZURpdigxMCksIFsyLCAwLCA1XSk7IC8vPT4gTm90aGluZ1xuICAgICAqL1xuICAgIHZhciB0cmF2ZXJzZSA9IF9jdXJyeTMoZnVuY3Rpb24gdHJhdmVyc2Uob2YsIGYsIHRyYXZlcnNhYmxlKSB7XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZShvZiwgbWFwKGYsIHRyYXZlcnNhYmxlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGhhbmQgZm9yIGBSLmNoYWluKFIuaWRlbnRpdHkpYCwgd2hpY2ggcmVtb3ZlcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyBmcm9tXG4gICAgICogYW55IFtDaGFpbl0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbikuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBDaGFpbiBjID0+IGMgKGMgYSkgLT4gYyBhXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIuZmxhdHRlbiwgUi5jaGFpblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5uZXN0KFsxLCBbMl0sIFtbM11dXSk7IC8vPT4gWzEsIDIsIFszXV1cbiAgICAgKiAgICAgIFIudW5uZXN0KFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdXSk7IC8vPT4gWzEsIDIsIDMsIDQsIDUsIDZdXG4gICAgICovXG4gICAgdmFyIHVubmVzdCA9IGNoYWluKF9pZGVudGl0eSk7XG5cbiAgICB2YXIgX2NvbnRhaW5zID0gZnVuY3Rpb24gX2NvbnRhaW5zKGEsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9pbmRleE9mKGxpc3QsIGEsIDApID49IDA7XG4gICAgfTtcblxuICAgIC8vICBtYXBQYWlycyA6OiAoT2JqZWN0LCBbU3RyaW5nXSkgLT4gW1N0cmluZ11cbiAgICB2YXIgX3RvU3RyaW5nID0gZnVuY3Rpb24gX3RvU3RyaW5nKHgsIHNlZW4pIHtcbiAgICAgICAgdmFyIHJlY3VyID0gZnVuY3Rpb24gcmVjdXIoeSkge1xuICAgICAgICAgICAgdmFyIHhzID0gc2Vlbi5jb25jYXQoW3hdKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGFpbnMoeSwgeHMpID8gJzxDaXJjdWxhcj4nIDogX3RvU3RyaW5nKHksIHhzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gIG1hcFBhaXJzIDo6IChPYmplY3QsIFtTdHJpbmddKSAtPiBbU3RyaW5nXVxuICAgICAgICB2YXIgbWFwUGFpcnMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX21hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcXVvdGUoaykgKyAnOiAnICsgcmVjdXIob2JqW2tdKTtcbiAgICAgICAgICAgIH0sIGtleXMuc2xpY2UoKS5zb3J0KCkpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSkge1xuICAgICAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOlxuICAgICAgICAgICAgcmV0dXJuICcoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oJyArIF9tYXAocmVjdXIsIHgpLmpvaW4oJywgJykgKyAnKSknO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgX21hcChyZWN1ciwgeCkuY29uY2F0KG1hcFBhaXJzKHgsIHJlamVjdChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXlxcZCskLy50ZXN0KGspO1xuICAgICAgICAgICAgfSwga2V5cyh4KSkpKS5qb2luKCcsICcpICsgJ10nO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IEJvb2xlYW4oJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IHgudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICAgICAgICByZXR1cm4gJ25ldyBEYXRlKCcgKyAoaXNOYU4oeC52YWx1ZU9mKCkpID8gcmVjdXIoTmFOKSA6IF9xdW90ZShfdG9JU09TdHJpbmcoeCkpKSArICcpJztcbiAgICAgICAgY2FzZSAnW29iamVjdCBOdWxsXSc6XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgTnVtYmVyKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiAxIC8geCA9PT0gLUluZmluaXR5ID8gJy0wJyA6IHgudG9TdHJpbmcoMTApO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgU3RyaW5nKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiBfcXVvdGUoeCk7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVW5kZWZpbmVkXSc6XG4gICAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHgudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwciA9IHgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwciAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICd7JyArIG1hcFBhaXJzKHgsIGtleXMoeCkpLmpvaW4oJywgJykgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIHJpZ2h0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZVxuICAgICAqIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIGNvbXBvc2UgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKHkgLT4geiksICh4IC0+IHkpLCAuLi4sIChvIC0+IHApLCAoKGEsIGIsIC4uLiwgbikgLT4gbykpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9uc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5waXBlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGYgPSBSLmNvbXBvc2UoUi5pbmMsIFIubmVnYXRlLCBNYXRoLnBvdyk7XG4gICAgICpcbiAgICAgKiAgICAgIGYoMywgNCk7IC8vIC0oM140KSArIDFcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZSA9IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvc2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGUuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlnaHQtdG8tbGVmdCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogZWFjaCBvZiB3aGljaCBtdXN0IHJldHVybiBhIHZhbHVlIG9mIGEgdHlwZSBzdXBwb3J0ZWQgYnkgW2BjaGFpbmBdKCNjaGFpbikuXG4gICAgICpcbiAgICAgKiBgUi5jb21wb3NlSyhoLCBnLCBmKWAgaXMgZXF1aXZhbGVudCB0byBgUi5jb21wb3NlKFIuY2hhaW4oaCksIFIuY2hhaW4oZyksIFIuY2hhaW4oZikpYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgQ2hhaW4gbSA9PiAoKHkgLT4gbSB6KSwgKHggLT4gbSB5KSwgLi4uLCAoYSAtPiBtIGIpKSAtPiAobSBhIC0+IG0geilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5waXBlS1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIC8vICBwYXJzZUpzb24gOjogU3RyaW5nIC0+IE1heWJlICpcbiAgICAgKiAgICAgIC8vICBnZXQgOjogU3RyaW5nIC0+IE9iamVjdCAtPiBNYXliZSAqXG4gICAgICpcbiAgICAgKiAgICAgIC8vICBnZXRTdGF0ZUNvZGUgOjogTWF5YmUgU3RyaW5nIC0+IE1heWJlIFN0cmluZ1xuICAgICAqICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIuY29tcG9zZUsoXG4gICAgICogICAgICAgIFIuY29tcG9zZShNYXliZS5vZiwgUi50b1VwcGVyKSxcbiAgICAgKiAgICAgICAgZ2V0KCdzdGF0ZScpLFxuICAgICAqICAgICAgICBnZXQoJ2FkZHJlc3MnKSxcbiAgICAgKiAgICAgICAgZ2V0KCd1c2VyJyksXG4gICAgICogICAgICAgIHBhcnNlSnNvblxuICAgICAqICAgICAgKTtcbiAgICAgKlxuICAgICAqICAgICAgZ2V0U3RhdGVDb2RlKE1heWJlLm9mKCd7XCJ1c2VyXCI6e1wiYWRkcmVzc1wiOntcInN0YXRlXCI6XCJueVwifX19JykpO1xuICAgICAqICAgICAgLy89PiBKdXN0KCdOWScpXG4gICAgICogICAgICBnZXRTdGF0ZUNvZGUoTWF5YmUub2YoJ1tJbnZhbGlkIEpTT05dJykpO1xuICAgICAqICAgICAgLy89PiBOb3RoaW5nKClcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZUsgPSBmdW5jdGlvbiBjb21wb3NlSygpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkodGhpcywgcHJlcGVuZChpZGVudGl0eSwgbWFwKGNoYWluLCBhcmd1bWVudHMpKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHJpZ2h0LXRvLWxlZnQgY29tcG9zaXRpb24gb2Ygb25lIG9yIG1vcmUgUHJvbWlzZS1yZXR1cm5pbmdcbiAgICAgKiBmdW5jdGlvbnMuIFRoZSByaWdodG1vc3QgZnVuY3Rpb24gbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nXG4gICAgICogZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoeSAtPiBQcm9taXNlIHopLCAoeCAtPiBQcm9taXNlIHkpLCAuLi4sIChhIC0+IFByb21pc2UgYikpIC0+IChhIC0+IFByb21pc2UgeilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIucGlwZVBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcl1cbiAgICAgKiAgICAgIHZhciBmb2xsb3dlcnNGb3JVc2VyID0gUi5jb21wb3NlUChkYi5nZXRGb2xsb3dlcnMsIGRiLmdldFVzZXJCeUlkKTtcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZVAgPSBmdW5jdGlvbiBjb21wb3NlUCgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZVAgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVQLmFwcGx5KHRoaXMsIHJldmVyc2UoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAgICAgKiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgc2FtZSB0eXBlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEZuIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIHdyYXBwZWQsIGN1cnJpZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICAgKiAgICAgIHZhciBXaWRnZXQgPSBjb25maWcgPT4ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBXaWRnZXQucHJvdG90eXBlID0ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICB2YXIgYWxsQ29uZmlncyA9IFtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICBdO1xuICAgICAqICAgICAgUi5tYXAoUi5jb25zdHJ1Y3QoV2lkZ2V0KSwgYWxsQ29uZmlncyk7IC8vIGEgbGlzdCBvZiBXaWRnZXRzXG4gICAgICovXG4gICAgdmFyIGNvbnN0cnVjdCA9IF9jdXJyeTEoZnVuY3Rpb24gY29uc3RydWN0KEZuKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3ROKEZuLmxlbmd0aCwgRm4pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBlcXVhbCwgaW4gYFIuZXF1YWxzYCB0ZXJtcywgdG8gYXRcbiAgICAgKiBsZWFzdCBvbmUgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIGl0ZW0gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaXRlbSBpcyBpbiB0aGUgbGlzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogQHNlZSBSLmFueVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuY29udGFpbnMoMywgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmNvbnRhaW5zKDQsIFsxLCAyLCAzXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuY29udGFpbnMoWzQyXSwgW1s0Ml1dKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGNvbnRhaW5zID0gX2N1cnJ5MihfY29udGFpbnMpO1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gICAgICogY29udGFpbmVkIGluIHRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgdGhhdCBhcmUgbm90IGluIGBsaXN0MmAuXG4gICAgICogQHNlZSBSLmRpZmZlcmVuY2VXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5kaWZmZXJlbmNlKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFsxLDJdXG4gICAgICogICAgICBSLmRpZmZlcmVuY2UoWzcsNiw1LDQsM10sIFsxLDIsMyw0XSk7IC8vPT4gWzcsNiw1XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gX2N1cnJ5MihmdW5jdGlvbiBkaWZmZXJlbmNlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGZpcnN0TGVuID0gZmlyc3QubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgZmlyc3RMZW4pIHtcbiAgICAgICAgICAgIGlmICghX2NvbnRhaW5zKGZpcnN0W2lkeF0sIHNlY29uZCkgJiYgIV9jb250YWlucyhmaXJzdFtpZHhdLCBvdXQpKSB7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gZmlyc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aG91dCBhbnkgY29uc2VjdXRpdmVseSByZXBlYXRpbmcgZWxlbWVudHMuIGBSLmVxdWFsc2BcbiAgICAgKiBpcyB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wUmVwZWF0c2AgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IGBsaXN0YCB3aXRob3V0IHJlcGVhdGluZyBlbGVtZW50cy5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBSLmRyb3BSZXBlYXRzKFsxLCAxLCAxLCAyLCAzLCA0LCA0LCAyLCAyXSk7IC8vPT4gWzEsIDIsIDMsIDQsIDJdXG4gICAgICovXG4gICAgdmFyIGRyb3BSZXBlYXRzID0gX2N1cnJ5MShfZGlzcGF0Y2hhYmxlKCdkcm9wUmVwZWF0cycsIF94ZHJvcFJlcGVhdHNXaXRoKGVxdWFscyksIGRyb3BSZXBlYXRzV2l0aChlcXVhbHMpKSk7XG5cbiAgICAvKipcbiAgICAgKiBcImxpZnRzXCIgYSBmdW5jdGlvbiBvZiBhcml0eSA+IDEgc28gdGhhdCBpdCBtYXkgXCJtYXAgb3ZlclwiIGEgbGlzdCwgRnVuY3Rpb24gb3Igb3RoZXJcbiAgICAgKiBvYmplY3QgdGhhdCBzYXRpc2ZpZXMgdGhlIFtGYW50YXN5TGFuZCBBcHBseSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5KS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBsaWZ0ZWQgZnVuY3Rpb24uXG4gICAgICogQHNlZSBSLmxpZnROXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hZGQzID0gUi5saWZ0KFIuY3VycnkoKGEsIGIsIGMpID0+IGEgKyBiICsgYykpO1xuICAgICAqXG4gICAgICogICAgICBtYWRkMyhbMSwyLDNdLCBbMSwyLDNdLCBbMV0pOyAvLz0+IFszLCA0LCA1LCA0LCA1LCA2LCA1LCA2LCA3XVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWFkZDUgPSBSLmxpZnQoUi5jdXJyeSgoYSwgYiwgYywgZCwgZSkgPT4gYSArIGIgKyBjICsgZCArIGUpKTtcbiAgICAgKlxuICAgICAqICAgICAgbWFkZDUoWzEsMl0sIFszXSwgWzQsIDVdLCBbNl0sIFs3LCA4XSk7IC8vPT4gWzIxLCAyMiwgMjIsIDIzLCAyMiwgMjMsIDIzLCAyNF1cbiAgICAgKi9cbiAgICB2YXIgbGlmdCA9IF9jdXJyeTEoZnVuY3Rpb24gbGlmdChmbikge1xuICAgICAgICByZXR1cm4gbGlmdE4oZm4ubGVuZ3RoLCBmbik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBvbWl0dGluZyB0aGUga2V5cyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9XG4gICAgICogQHBhcmFtIHtBcnJheX0gbmFtZXMgYW4gYXJyYXkgb2YgU3RyaW5nIHByb3BlcnR5IG5hbWVzIHRvIG9taXQgZnJvbSB0aGUgbmV3IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG5vdCBvbiBpdC5cbiAgICAgKiBAc2VlIFIucGlja1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIub21pdChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBjOiAzfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gX2N1cnJ5MihmdW5jdGlvbiBvbWl0KG5hbWVzLCBvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKCFfY29udGFpbnMocHJvcCwgbmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZWZ0LXRvLXJpZ2h0IEtsZWlzbGkgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAgICAgKlxuICAgICAqIGBSLnBpcGVLKGYsIGcsIGgpYCBpcyBlcXVpdmFsZW50IHRvIGBSLnBpcGUoUi5jaGFpbihmKSwgUi5jaGFpbihnKSwgUi5jaGFpbihoKSlgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBDaGFpbiBtID0+ICgoYSAtPiBtIGIpLCAoYiAtPiBtIGMpLCAuLi4sICh5IC0+IG0geikpIC0+IChtIGEgLT4gbSB6KVxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmNvbXBvc2VLXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gIHBhcnNlSnNvbiA6OiBTdHJpbmcgLT4gTWF5YmUgKlxuICAgICAqICAgICAgLy8gIGdldCA6OiBTdHJpbmcgLT4gT2JqZWN0IC0+IE1heWJlICpcbiAgICAgKlxuICAgICAqICAgICAgLy8gIGdldFN0YXRlQ29kZSA6OiBNYXliZSBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gICAgICogICAgICB2YXIgZ2V0U3RhdGVDb2RlID0gUi5waXBlSyhcbiAgICAgKiAgICAgICAgcGFyc2VKc29uLFxuICAgICAqICAgICAgICBnZXQoJ3VzZXInKSxcbiAgICAgKiAgICAgICAgZ2V0KCdhZGRyZXNzJyksXG4gICAgICogICAgICAgIGdldCgnc3RhdGUnKSxcbiAgICAgKiAgICAgICAgUi5jb21wb3NlKE1heWJlLm9mLCBSLnRvVXBwZXIpXG4gICAgICogICAgICApO1xuICAgICAqXG4gICAgICogICAgICBnZXRTdGF0ZUNvZGUoTWF5YmUub2YoJ3tcInVzZXJcIjp7XCJhZGRyZXNzXCI6e1wic3RhdGVcIjpcIm55XCJ9fX0nKSk7XG4gICAgICogICAgICAvLz0+IEp1c3QoJ05ZJylcbiAgICAgKiAgICAgIGdldFN0YXRlQ29kZShNYXliZS5vZignW0ludmFsaWQgSlNPTl0nKSk7XG4gICAgICogICAgICAvLz0+IE5vdGhpbmcoKVxuICAgICAqL1xuICAgIHZhciBwaXBlSyA9IGZ1bmN0aW9uIHBpcGVLKCkge1xuICAgICAgICByZXR1cm4gY29tcG9zZUsuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS4gYGV2YWxgJ2luZyB0aGUgb3V0cHV0XG4gICAgICogc2hvdWxkIHJlc3VsdCBpbiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHZhbHVlLiBNYW55IG9mIHRoZSBidWlsdC1pblxuICAgICAqIGB0b1N0cmluZ2AgbWV0aG9kcyBkbyBub3Qgc2F0aXNmeSB0aGlzIHJlcXVpcmVtZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGBbb2JqZWN0IE9iamVjdF1gIHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBvdGhlclxuICAgICAqIHRoYW4gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLCB0aGlzIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggbm8gYXJndW1lbnRzXG4gICAgICogdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLiBUaGlzIG1lYW5zIHVzZXItZGVmaW5lZCBjb25zdHJ1Y3RvciBmdW5jdGlvbnNcbiAgICAgKiBjYW4gcHJvdmlkZSBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgICogICAgICAgdGhpcy54ID0geDtcbiAgICAgKiAgICAgICB0aGlzLnkgPSB5O1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgcmV0dXJuICduZXcgUG9pbnQoJyArIHRoaXMueCArICcsICcgKyB0aGlzLnkgKyAnKSc7XG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiAgICAgUi50b1N0cmluZyhuZXcgUG9pbnQoMSwgMikpOyAvLz0+ICduZXcgUG9pbnQoMSwgMiknXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyAqIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudG9TdHJpbmcoNDIpOyAvLz0+ICc0MidcbiAgICAgKiAgICAgIFIudG9TdHJpbmcoJ2FiYycpOyAvLz0+ICdcImFiY1wiJ1xuICAgICAqICAgICAgUi50b1N0cmluZyhbMSwgMiwgM10pOyAvLz0+ICdbMSwgMiwgM10nXG4gICAgICogICAgICBSLnRvU3RyaW5nKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSk7IC8vPT4gJ3tcImJhclwiOiAyLCBcImJhelwiOiAzLCBcImZvb1wiOiAxfSdcbiAgICAgKiAgICAgIFIudG9TdHJpbmcobmV3IERhdGUoJzIwMDEtMDItMDNUMDQ6MDU6MDZaJykpOyAvLz0+ICduZXcgRGF0ZShcIjIwMDEtMDItMDNUMDQ6MDU6MDYuMDAwWlwiKSdcbiAgICAgKi9cbiAgICB2YXIgdG9TdHJpbmcgPSBfY3VycnkxKGZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nKHZhbCwgW10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgdmFsdWVzIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiBgUi5lcXVhbHNgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIHZhbHVlcyB0byBiZSByZW1vdmVkIGZyb20gYGxpc3QyYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgYXJyYXkgdG8gcmVtb3ZlIHZhbHVlcyBmcm9tLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGFycmF5IHdpdGhvdXQgdmFsdWVzIGluIGBsaXN0MWAuXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIud2l0aG91dChbMSwgMl0sIFsxLCAyLCAxLCAzLCA0XSk7IC8vPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBfY3VycnkyKGZ1bmN0aW9uICh4cywgbGlzdCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGZsaXAoX2NvbnRhaW5zKSh4cyksIGxpc3QpO1xuICAgIH0pO1xuXG4gICAgLy8gQSBzaW1wbGUgU2V0IHR5cGUgdGhhdCBob25vdXJzIFIuZXF1YWxzIHNlbWFudGljc1xuICAgIC8qIGdsb2JhbHMgU2V0ICovXG4gICAgLyoqXG4gICAgICAgKiBDb21iaW5lcyB0aGUgbG9naWMgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gaXRlbSBpcyBhIG1lbWJlciBvZiB0aGUgc2V0IGFuZFxuICAgICAgICogZm9yIGFkZGluZyBhIG5ldyBpdGVtIHRvIHRoZSBzZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGl0ZW0gICAgICAgVGhlIGl0ZW0gdG8gY2hlY2sgb3IgYWRkIHRvIHRoZSBTZXQgaW5zdGFuY2UuXG4gICAgICAgKiBAcGFyYW0gc2hvdWxkQWRkICBJZiB0cnVlLCB0aGUgaXRlbSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzZXQgaWYgaXQgZG9lc24ndFxuICAgICAgICogICAgICAgICAgICAgICAgICAgYWxyZWFkeSBleGlzdC5cbiAgICAgICAqIEBwYXJhbSBzZXQgICAgICAgIFRoZSBzZXQgaW5zdGFuY2UgdG8gY2hlY2sgb3IgYWRkIHRvLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hlbiBzaG91bGRBZGQgaXMgdHJ1ZSwgdGhpcyB3aWxsIHJldHVybiB0cnVlIHdoZW4gYSBuZXdcbiAgICAgICAqICAgICAgICAgICAgICAgICAgIGl0ZW0gd2FzIGFkZGVkIG90aGVyd2lzZSBmYWxzZS4gV2hlbiBzaG91bGRBZGQgaXMgZmFsc2UsXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICB0aGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGl0ZW0gYWxyZWFkeSBleGlzdHMsIG90aGVyd2lzZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgZmFsc2UuXG4gICAgICAgKi9cbiAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgIC8vIHRoZXNlIHR5cGVzIGNhbiBhbGwgdXRpbGlzZSBTZXRcbiAgICAvLyBzZXQuX2l0ZW1zWydib29sZWFuJ10gaG9sZHMgYSB0d28gZWxlbWVudCBhcnJheVxuICAgIC8vIHJlcHJlc2VudGluZyBbIGZhbHNlRXhpc3RzLCB0cnVlRXhpc3RzIF1cbiAgICAvLyBjb21wYXJlIGZ1bmN0aW9ucyBmb3IgcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAvLyBmb3IgZWFjaCB0eXBlLlxuICAgIC8vIHNjYW4gdGhyb3VnaCBhbGwgcHJldmlvdXNseSBhcHBsaWVkIGl0ZW1zXG4gICAgdmFyIF9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9TZXQoKSB7XG4gICAgICAgICAgICAvKiBnbG9iYWxzIFNldCAqL1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBTZXQoKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIF9TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3JBZGQoaXRlbSwgdHJ1ZSwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3JBZGQoaXRlbSwgZmFsc2UsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAqIENvbWJpbmVzIHRoZSBsb2dpYyBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBpdGVtIGlzIGEgbWVtYmVyIG9mIHRoZSBzZXQgYW5kXG4gICAgICAgKiBmb3IgYWRkaW5nIGEgbmV3IGl0ZW0gdG8gdGhlIHNldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gaXRlbSAgICAgICBUaGUgaXRlbSB0byBjaGVjayBvciBhZGQgdG8gdGhlIFNldCBpbnN0YW5jZS5cbiAgICAgICAqIEBwYXJhbSBzaG91bGRBZGQgIElmIHRydWUsIHRoZSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNldCBpZiBpdCBkb2Vzbid0XG4gICAgICAgKiAgICAgICAgICAgICAgICAgICBhbHJlYWR5IGV4aXN0LlxuICAgICAgICogQHBhcmFtIHNldCAgICAgICAgVGhlIHNldCBpbnN0YW5jZSB0byBjaGVjayBvciBhZGQgdG8uXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGVuIHNob3VsZEFkZCBpcyB0cnVlLCB0aGlzIHdpbGwgcmV0dXJuIHRydWUgd2hlbiBhIG5ld1xuICAgICAgICogICAgICAgICAgICAgICAgICAgaXRlbSB3YXMgYWRkZWQgb3RoZXJ3aXNlIGZhbHNlLiBXaGVuIHNob3VsZEFkZCBpcyBmYWxzZSxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgIHRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgaXRlbSBhbHJlYWR5IGV4aXN0cywgb3RoZXJ3aXNlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICBmYWxzZS5cbiAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYXNPckFkZChpdGVtLCBzaG91bGRBZGQsIHNldCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgICAgIHZhciBwcmV2U2l6ZSwgbmV3U2l6ZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiArMCBhbmQgLTBcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gMCAmJiAhc2V0Ll9pdGVtc1snLTAnXSAmJiAxIC8gaXRlbSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5faXRlbXNbJy0wJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHR5cGVzIGNhbiBhbGwgdXRpbGlzZSBTZXRcbiAgICAgICAgICAgICAgICBpZiAoc2V0Ll9uYXRpdmVTZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlNpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9uYXRpdmVTZXQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2l6ZSA9IHNldC5fbmF0aXZlU2V0LnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2l6ZSA+IHByZXZTaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldC5fbmF0aXZlU2V0LmhhcyhpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGUgaW4gc2V0Ll9pdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtpdGVtXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW4gc2V0Ll9pdGVtc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtpdGVtXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgLy8gc2V0Ll9pdGVtc1snYm9vbGVhbiddIGhvbGRzIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICAgICAgICAgICAgICAvLyByZXByZXNlbnRpbmcgWyBmYWxzZUV4aXN0cywgdHJ1ZUV4aXN0cyBdXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgaW4gc2V0Ll9pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYklkeCA9IGl0ZW0gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV1bYklkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1bYklkeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBpdGVtID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlIGZ1bmN0aW9ucyBmb3IgcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgICAgICAgICAgICAgaWYgKHNldC5fbmF0aXZlU2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5fbmF0aXZlU2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NpemUgPiBwcmV2U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXQuX25hdGl2ZVNldC5oYXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXSA9IFtpdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29udGFpbnMoaXRlbSwgc2V0Ll9pdGVtc1t0eXBlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhc2hvdWxkQWRkO1xuICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICBpZiAoc2V0Ll9pdGVtc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQuX2l0ZW1zWydudWxsJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zWydudWxsJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCB0eXBlLlxuICAgICAgICAgICAgICAgIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gW2l0ZW1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNjYW4gdGhyb3VnaCBhbGwgcHJldmlvdXNseSBhcHBsaWVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgaWYgKCFfY29udGFpbnMoaXRlbSwgc2V0Ll9pdGVtc1t0eXBlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhc2hvdWxkQWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfU2V0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd3JhcHBpbmcgY2FsbHMgdG8gdGhlIHR3byBmdW5jdGlvbnMgaW4gYW4gYCYmYCBvcGVyYXRpb24sXG4gICAgICogcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0IGZ1bmN0aW9uIGlmIGl0IGlzIGZhbHNlLXkgYW5kIHRoZSByZXN1bHRcbiAgICAgKiBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIG90aGVyd2lzZS4gTm90ZSB0aGF0IHRoaXMgaXMgc2hvcnQtY2lyY3VpdGVkLFxuICAgICAqIG1lYW5pbmcgdGhhdCB0aGUgc2Vjb25kIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgdGhlIGZpcnN0IHJldHVybnMgYVxuICAgICAqIGZhbHNlLXkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBmdW5jdGlvbnMsIGBSLmJvdGhgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAgICAgKiBhcHBsaWNhdGl2ZSBmdW5jdG9yLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgYSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIGFub3RoZXIgcHJlZGljYXRlXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGl0cyBhcmd1bWVudHMgdG8gYGZgIGFuZCBgZ2AgYW5kIGAmJmBzIHRoZWlyIG91dHB1dHMgdG9nZXRoZXIuXG4gICAgICogQHNlZSBSLmFuZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBndDEwID0geCA9PiB4ID4gMTA7XG4gICAgICogICAgICB2YXIgZXZlbiA9IHggPT4geCAlIDIgPT09IDA7XG4gICAgICogICAgICB2YXIgZiA9IFIuYm90aChndDEwLCBldmVuKTtcbiAgICAgKiAgICAgIGYoMTAwKTsgLy89PiB0cnVlXG4gICAgICogICAgICBmKDEwMSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgYm90aCA9IF9jdXJyeTIoZnVuY3Rpb24gYm90aChmLCBnKSB7XG4gICAgICAgIHJldHVybiBfaXNGdW5jdGlvbihmKSA/IGZ1bmN0aW9uIF9ib3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gOiBsaWZ0KGFuZCkoZiwgZyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYCBzdWNoIHRoYXQ6XG4gICAgICpcbiAgICAgKiAgIC0gYXBwbHlpbmcgYGdgIHRvIHplcm8gb3IgbW9yZSBhcmd1bWVudHMgd2lsbCBnaXZlIF9fdHJ1ZV9fIGlmIGFwcGx5aW5nXG4gICAgICogICAgIHRoZSBzYW1lIGFyZ3VtZW50cyB0byBgZmAgZ2l2ZXMgYSBsb2dpY2FsIF9fZmFsc2VfXyB2YWx1ZTsgYW5kXG4gICAgICpcbiAgICAgKiAgIC0gYXBwbHlpbmcgYGdgIHRvIHplcm8gb3IgbW9yZSBhcmd1bWVudHMgd2lsbCBnaXZlIF9fZmFsc2VfXyBpZiBhcHBseWluZ1xuICAgICAqICAgICB0aGUgc2FtZSBhcmd1bWVudHMgdG8gYGZgIGdpdmVzIGEgbG9naWNhbCBfX3RydWVfXyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIGBSLmNvbXBsZW1lbnRgIHdpbGwgd29yayBvbiBhbGwgb3RoZXIgZnVuY3RvcnMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKCouLi4gLT4gKikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLm5vdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICAgICAqICAgICAgdmFyIGlzT2RkID0gUi5jb21wbGVtZW50KGlzRXZlbik7XG4gICAgICogICAgICBpc09kZCgyMSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgaXNPZGQoNDIpOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGNvbXBsZW1lbnQgPSBsaWZ0KG5vdCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdyYXBwaW5nIGNhbGxzIHRvIHRoZSB0d28gZnVuY3Rpb25zIGluIGFuIGB8fGAgb3BlcmF0aW9uLFxuICAgICAqIHJldHVybmluZyB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBmdW5jdGlvbiBpZiBpdCBpcyB0cnV0aC15IGFuZCB0aGUgcmVzdWx0XG4gICAgICogb2YgdGhlIHNlY29uZCBmdW5jdGlvbiBvdGhlcndpc2UuIE5vdGUgdGhhdCB0aGlzIGlzIHNob3J0LWNpcmN1aXRlZCxcbiAgICAgKiBtZWFuaW5nIHRoYXQgdGhlIHNlY29uZCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBpbnZva2VkIGlmIHRoZSBmaXJzdCByZXR1cm5zIGFcbiAgICAgKiB0cnV0aC15IHZhbHVlLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gZnVuY3Rpb25zLCBgUi5laXRoZXJgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAgICAgKiBhcHBsaWNhdGl2ZSBmdW5jdG9yLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgYSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIGFub3RoZXIgcHJlZGljYXRlXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGl0cyBhcmd1bWVudHMgdG8gYGZgIGFuZCBgZ2AgYW5kIGB8fGBzIHRoZWlyIG91dHB1dHMgdG9nZXRoZXIuXG4gICAgICogQHNlZSBSLm9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGd0MTAgPSB4ID0+IHggPiAxMDtcbiAgICAgKiAgICAgIHZhciBldmVuID0geCA9PiB4ICUgMiA9PT0gMDtcbiAgICAgKiAgICAgIHZhciBmID0gUi5laXRoZXIoZ3QxMCwgZXZlbik7XG4gICAgICogICAgICBmKDEwMSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgZig4KTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGVpdGhlciA9IF9jdXJyeTIoZnVuY3Rpb24gZWl0aGVyKGYsIGcpIHtcbiAgICAgICAgcmV0dXJuIF9pc0Z1bmN0aW9uKGYpID8gZnVuY3Rpb24gX2VpdGhlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IDogbGlmdChvcikoZiwgZyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBhIG5hbWVkIG1ldGhvZCB3aXRoIGEgc3BlY2lmaWVkIGFyaXR5IGludG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICAgICAqIGNhbGxlZCBkaXJlY3RseSBzdXBwbGllZCB3aXRoIGFyZ3VtZW50cyBhbmQgYSB0YXJnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIGN1cnJpZWQgYW5kIGFjY2VwdHMgYGFyaXR5ICsgMWAgcGFyYW1ldGVycyB3aGVyZVxuICAgICAqIHRoZSBmaW5hbCBwYXJhbWV0ZXIgaXMgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiAoYSAtPiBiIC0+IC4uLiAtPiBuIC0+IE9iamVjdCAtPiAqKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcml0eSBOdW1iZXIgb2YgYXJndW1lbnRzIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBzaG91bGQgdGFrZVxuICAgICAqICAgICAgICBiZWZvcmUgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBOYW1lIG9mIHRoZSBtZXRob2QgdG8gY2FsbC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgc2xpY2VGcm9tID0gUi5pbnZva2VyKDEsICdzbGljZScpO1xuICAgICAqICAgICAgc2xpY2VGcm9tKDYsICdhYmNkZWZnaGlqa2xtJyk7IC8vPT4gJ2doaWprbG0nXG4gICAgICogICAgICB2YXIgc2xpY2VGcm9tNiA9IFIuaW52b2tlcigyLCAnc2xpY2UnKSg2KTtcbiAgICAgKiAgICAgIHNsaWNlRnJvbTYoOCwgJ2FiY2RlZmdoaWprbG0nKTsgLy89PiAnZ2gnXG4gICAgICovXG4gICAgdmFyIGludm9rZXIgPSBfY3VycnkyKGZ1bmN0aW9uIGludm9rZXIoYXJpdHksIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gY3VycnlOKGFyaXR5ICsgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1thcml0eV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgaXMoRnVuY3Rpb24sIHRhcmdldFttZXRob2RdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbbWV0aG9kXS5hcHBseSh0YXJnZXQsIF9zbGljZShhcmd1bWVudHMsIDAsIGFyaXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKHRhcmdldCkgKyAnIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBtYWRlIGJ5IGluc2VydGluZyB0aGUgYHNlcGFyYXRvcmAgYmV0d2VlbiBlYWNoIGVsZW1lbnQgYW5kXG4gICAgICogY29uY2F0ZW5hdGluZyBhbGwgdGhlIGVsZW1lbnRzIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgU3RyaW5nIC0+IFthXSAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHNlcGFyYXRvciBUaGUgc3RyaW5nIHVzZWQgdG8gc2VwYXJhdGUgdGhlIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBlbGVtZW50cyB0byBqb2luIGludG8gYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyBtYWRlIGJ5IGNvbmNhdGVuYXRpbmcgYHhzYCB3aXRoIGBzZXBhcmF0b3JgLlxuICAgICAqIEBzZWUgUi5zcGxpdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzcGFjZXIgPSBSLmpvaW4oJyAnKTtcbiAgICAgKiAgICAgIHNwYWNlcihbJ2EnLCAyLCAzLjRdKTsgICAvLz0+ICdhIDIgMy40J1xuICAgICAqICAgICAgUi5qb2luKCd8JywgWzEsIDIsIDNdKTsgICAgLy89PiAnMXwyfDMnXG4gICAgICovXG4gICAgdmFyIGpvaW4gPSBpbnZva2VyKDEsICdqb2luJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgY2FjaGVzIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZm5gXG4gICAgICogZm9yIGEgZ2l2ZW4gYXJndW1lbnQgc2V0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlXG4gICAgICogbWVtb2l6ZWQgYGZuYCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50IHNldCB3aWxsIG5vdCByZXN1bHQgaW4gYW4gYWRkaXRpb25hbFxuICAgICAqIGNhbGwgdG8gYGZuYDsgaW5zdGVhZCwgdGhlIGNhY2hlZCByZXN1bHQgZm9yIHRoYXQgc2V0IG9mIGFyZ3VtZW50cyB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCouLi4gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWVtb2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gTWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICogICAgICB2YXIgZmFjdG9yaWFsID0gUi5tZW1vaXplKG4gPT4ge1xuICAgICAqICAgICAgICBjb3VudCArPSAxO1xuICAgICAqICAgICAgICByZXR1cm4gUi5wcm9kdWN0KFIucmFuZ2UoMSwgbiArIDEpKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICAgICAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICAgICAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICAgICAqICAgICAgY291bnQ7IC8vPT4gMVxuICAgICAqL1xuICAgIHZhciBtZW1vaXplID0gX2N1cnJ5MShmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRvU3RyaW5nKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIV9oYXMoa2V5LCBjYWNoZSkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtrZXldID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgYmFzZWQgb24gdGhlIGdpdmVuXG4gICAgICogc2VwYXJhdG9yLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyAoU3RyaW5nIHwgUmVnRXhwKSAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHNlcCBUaGUgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VwYXJhdGUgaW50byBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHN0cmluZ3MgZnJvbSBgc3RyYCBzZXBhcmF0ZWQgYnkgYHN0cmAuXG4gICAgICogQHNlZSBSLmpvaW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcGF0aENvbXBvbmVudHMgPSBSLnNwbGl0KCcvJyk7XG4gICAgICogICAgICBSLnRhaWwocGF0aENvbXBvbmVudHMoJy91c3IvbG9jYWwvYmluL25vZGUnKSk7IC8vPT4gWyd1c3InLCAnbG9jYWwnLCAnYmluJywgJ25vZGUnXVxuICAgICAqXG4gICAgICogICAgICBSLnNwbGl0KCcuJywgJ2EuYi5jLnh5ei5kJyk7IC8vPT4gWydhJywgJ2InLCAnYycsICd4eXonLCAnZCddXG4gICAgICovXG4gICAgdmFyIHNwbGl0ID0gaW52b2tlcigxLCAnc3BsaXQnKTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIHN0cmluZyBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIubWF0Y2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRlc3QoL154LywgJ3h5eicpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIudGVzdCgvXnkvLCAneHl6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgdGVzdCA9IF9jdXJyeTIoZnVuY3Rpb24gdGVzdChwYXR0ZXJuLCBzdHIpIHtcbiAgICAgICAgaWYgKCFfaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcdTIwMTh0ZXN0XFx1MjAxOSByZXF1aXJlcyBhIHZhbHVlIG9mIHR5cGUgUmVnRXhwIGFzIGl0cyBmaXJzdCBhcmd1bWVudDsgcmVjZWl2ZWQgJyArIHRvU3RyaW5nKHBhdHRlcm4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKHBhdHRlcm4pLnRlc3Qoc3RyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYHN0cmAuXG4gICAgICogQHNlZSBSLnRvVXBwZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRvTG93ZXIoJ1hZWicpOyAvLz0+ICd4eXonXG4gICAgICovXG4gICAgdmFyIHRvTG93ZXIgPSBpbnZva2VyKDAsICd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1cHBlciBjYXNlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBgc3RyYC5cbiAgICAgKiBAc2VlIFIudG9Mb3dlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudG9VcHBlcignYWJjJyk7IC8vPT4gJ0FCQydcbiAgICAgKi9cbiAgICB2YXIgdG9VcHBlciA9IGludm9rZXIoMCwgJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgKiBsaXN0LCBiYXNlZCB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gdG9cbiAgICAgKiBlYWNoIGxpc3QgZWxlbWVudC4gUHJlZmVycyB0aGUgZmlyc3QgaXRlbSBpZiB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcHJvZHVjZXNcbiAgICAgKiB0aGUgc2FtZSB2YWx1ZSBvbiB0d28gaXRlbXMuIGBSLmVxdWFsc2AgaXMgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB1c2VkIHRvIHByb2R1Y2UgYSB2YWx1ZSB0byB1c2UgZHVyaW5nIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi51bmlxQnkoTWF0aC5hYnMsIFstMSwgLTUsIDIsIDEwLCAxLCAyXSk7IC8vPT4gWy0xLCAtNSwgMiwgMTBdXG4gICAgICovXG4gICAgdmFyIHVuaXFCeSA9IF9jdXJyeTIoZnVuY3Rpb24gdW5pcUJ5KGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBzZXQgPSBuZXcgX1NldCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgYXBwbGllZEl0ZW0sIGl0ZW07XG4gICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGFwcGxpZWRJdGVtID0gZm4oaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2V0LmFkZChhcHBsaWVkSXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbGlzdHMgb3Igc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBjb25jYXRgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBiXG4gICAgICogQHJldHVybiB7QXJyYXl8U3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5jb25jYXQoW10sIFtdKTsgLy89PiBbXVxuICAgICAqICAgICAgUi5jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICAgICAqICAgICAgUi5jb25jYXQoJ0FCQycsICdERUYnKTsgLy8gJ0FCQ0RFRidcbiAgICAgKi9cbiAgICB2YXIgY29uY2F0ID0gZmxpcChpbnZva2VyKDEsICdjb25jYXQnKSk7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIGZpcnN0IG9yXG4gICAgICogc2Vjb25kIGxpc3QsIGJ1dCBub3QgYm90aC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIG9yIGBsaXN0MmAsIGJ1dCBub3QgYm90aC5cbiAgICAgKiBAc2VlIFIuc3ltbWV0cmljRGlmZmVyZW5jZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2UoWzEsMiwzLDRdLCBbNyw2LDUsNCwzXSk7IC8vPT4gWzEsMiw3LDYsNV1cbiAgICAgKiAgICAgIFIuc3ltbWV0cmljRGlmZmVyZW5jZShbNyw2LDUsNCwzXSwgWzEsMiwzLDRdKTsgLy89PiBbNyw2LDUsMSwyXVxuICAgICAqL1xuICAgIHZhciBzeW1tZXRyaWNEaWZmZXJlbmNlID0gX2N1cnJ5MihmdW5jdGlvbiBzeW1tZXRyaWNEaWZmZXJlbmNlKGxpc3QxLCBsaXN0Mikge1xuICAgICAgICByZXR1cm4gY29uY2F0KGRpZmZlcmVuY2UobGlzdDEsIGxpc3QyKSwgZGlmZmVyZW5jZShsaXN0MiwgbGlzdDEpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3Qgb3JcbiAgICAgKiBzZWNvbmQgbGlzdCwgYnV0IG5vdCBib3RoLiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGUgdmFsdWVcbiAgICAgKiByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSAtPiBhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgb3IgYGxpc3QyYCwgYnV0IG5vdCBib3RoLlxuICAgICAqIEBzZWUgUi5zeW1tZXRyaWNEaWZmZXJlbmNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGVxQSA9IFIuZXFCeShSLnByb3AoJ2EnKSk7XG4gICAgICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XTtcbiAgICAgKiAgICAgIHZhciBsMiA9IFt7YTogM30sIHthOiA0fSwge2E6IDV9LCB7YTogNn1dO1xuICAgICAqICAgICAgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aChlcUEsIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9LCB7YTogNX0sIHthOiA2fV1cbiAgICAgKi9cbiAgICB2YXIgc3ltbWV0cmljRGlmZmVyZW5jZVdpdGggPSBfY3VycnkzKGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICAgICAgICByZXR1cm4gY29uY2F0KGRpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QxLCBsaXN0MiksIGRpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QyLCBsaXN0MSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgb25seSBvbmUgY29weSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICogbGlzdC4gYFIuZXF1YWxzYCBpcyB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5pcShbMSwgMSwgMiwgMV0pOyAvLz0+IFsxLCAyXVxuICAgICAqICAgICAgUi51bmlxKFsxLCAnMSddKTsgICAgIC8vPT4gWzEsICcxJ11cbiAgICAgKiAgICAgIFIudW5pcShbWzQyXSwgWzQyXV0pOyAvLz0+IFtbNDJdXVxuICAgICAqL1xuICAgIHZhciB1bmlxID0gdW5pcUJ5KGlkZW50aXR5KTtcblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRob3NlXG4gICAgICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGVsZW1lbnRzIGZvdW5kIGluIGJvdGggYGxpc3QxYCBhbmQgYGxpc3QyYC5cbiAgICAgKiBAc2VlIFIuaW50ZXJzZWN0aW9uV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW50ZXJzZWN0aW9uKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFs0LCAzXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBfY3VycnkyKGZ1bmN0aW9uIGludGVyc2VjdGlvbihsaXN0MSwgbGlzdDIpIHtcbiAgICAgICAgdmFyIGxvb2t1cExpc3QsIGZpbHRlcmVkTGlzdDtcbiAgICAgICAgaWYgKGxpc3QxLmxlbmd0aCA+IGxpc3QyLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9va3VwTGlzdCA9IGxpc3QxO1xuICAgICAgICAgICAgZmlsdGVyZWRMaXN0ID0gbGlzdDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb29rdXBMaXN0ID0gbGlzdDI7XG4gICAgICAgICAgICBmaWx0ZXJlZExpc3QgPSBsaXN0MTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pcShfZmlsdGVyKGZsaXAoX2NvbnRhaW5zKShsb29rdXBMaXN0KSwgZmlsdGVyZWRMaXN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAgICAgKiBvZiBlYWNoIGxpc3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcyBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBicyBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICAgICAqICAgICAgICAgZHVwbGljYXRlcyByZW1vdmVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5pb24oWzEsIDIsIDNdLCBbMiwgMywgNF0pOyAvLz0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IF9jdXJyeTIoY29tcG9zZSh1bmlxLCBfY29uY2F0KSk7XG5cbiAgICB2YXIgUiA9IHtcbiAgICAgICAgRjogRixcbiAgICAgICAgVDogVCxcbiAgICAgICAgX186IF9fLFxuICAgICAgICBhZGQ6IGFkZCxcbiAgICAgICAgYWRkSW5kZXg6IGFkZEluZGV4LFxuICAgICAgICBhZGp1c3Q6IGFkanVzdCxcbiAgICAgICAgYWxsOiBhbGwsXG4gICAgICAgIGFsbFBhc3M6IGFsbFBhc3MsXG4gICAgICAgIGFsbFVuaXE6IGFsbFVuaXEsXG4gICAgICAgIGFsd2F5czogYWx3YXlzLFxuICAgICAgICBhbmQ6IGFuZCxcbiAgICAgICAgYW55OiBhbnksXG4gICAgICAgIGFueVBhc3M6IGFueVBhc3MsXG4gICAgICAgIGFwOiBhcCxcbiAgICAgICAgYXBlcnR1cmU6IGFwZXJ0dXJlLFxuICAgICAgICBhcHBlbmQ6IGFwcGVuZCxcbiAgICAgICAgYXBwbHk6IGFwcGx5LFxuICAgICAgICBhcHBseVNwZWM6IGFwcGx5U3BlYyxcbiAgICAgICAgYXNzb2M6IGFzc29jLFxuICAgICAgICBhc3NvY1BhdGg6IGFzc29jUGF0aCxcbiAgICAgICAgYmluYXJ5OiBiaW5hcnksXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIGJvdGg6IGJvdGgsXG4gICAgICAgIGNhbGw6IGNhbGwsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIGNvbXBhcmF0b3I6IGNvbXBhcmF0b3IsXG4gICAgICAgIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsXG4gICAgICAgIGNvbXBvc2U6IGNvbXBvc2UsXG4gICAgICAgIGNvbXBvc2VLOiBjb21wb3NlSyxcbiAgICAgICAgY29tcG9zZVA6IGNvbXBvc2VQLFxuICAgICAgICBjb25jYXQ6IGNvbmNhdCxcbiAgICAgICAgY29uZDogY29uZCxcbiAgICAgICAgY29uc3RydWN0OiBjb25zdHJ1Y3QsXG4gICAgICAgIGNvbnN0cnVjdE46IGNvbnN0cnVjdE4sXG4gICAgICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICAgICAgY29udmVyZ2U6IGNvbnZlcmdlLFxuICAgICAgICBjb3VudEJ5OiBjb3VudEJ5LFxuICAgICAgICBjdXJyeTogY3VycnksXG4gICAgICAgIGN1cnJ5TjogY3VycnlOLFxuICAgICAgICBkZWM6IGRlYyxcbiAgICAgICAgZGVmYXVsdFRvOiBkZWZhdWx0VG8sXG4gICAgICAgIGRpZmZlcmVuY2U6IGRpZmZlcmVuY2UsXG4gICAgICAgIGRpZmZlcmVuY2VXaXRoOiBkaWZmZXJlbmNlV2l0aCxcbiAgICAgICAgZGlzc29jOiBkaXNzb2MsXG4gICAgICAgIGRpc3NvY1BhdGg6IGRpc3NvY1BhdGgsXG4gICAgICAgIGRpdmlkZTogZGl2aWRlLFxuICAgICAgICBkcm9wOiBkcm9wLFxuICAgICAgICBkcm9wTGFzdDogZHJvcExhc3QsXG4gICAgICAgIGRyb3BMYXN0V2hpbGU6IGRyb3BMYXN0V2hpbGUsXG4gICAgICAgIGRyb3BSZXBlYXRzOiBkcm9wUmVwZWF0cyxcbiAgICAgICAgZHJvcFJlcGVhdHNXaXRoOiBkcm9wUmVwZWF0c1dpdGgsXG4gICAgICAgIGRyb3BXaGlsZTogZHJvcFdoaWxlLFxuICAgICAgICBlaXRoZXI6IGVpdGhlcixcbiAgICAgICAgZW1wdHk6IGVtcHR5LFxuICAgICAgICBlcUJ5OiBlcUJ5LFxuICAgICAgICBlcVByb3BzOiBlcVByb3BzLFxuICAgICAgICBlcXVhbHM6IGVxdWFscyxcbiAgICAgICAgZXZvbHZlOiBldm9sdmUsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBmaW5kSW5kZXg6IGZpbmRJbmRleCxcbiAgICAgICAgZmluZExhc3Q6IGZpbmRMYXN0LFxuICAgICAgICBmaW5kTGFzdEluZGV4OiBmaW5kTGFzdEluZGV4LFxuICAgICAgICBmbGF0dGVuOiBmbGF0dGVuLFxuICAgICAgICBmbGlwOiBmbGlwLFxuICAgICAgICBmb3JFYWNoOiBmb3JFYWNoLFxuICAgICAgICBmcm9tUGFpcnM6IGZyb21QYWlycyxcbiAgICAgICAgZ3JvdXBCeTogZ3JvdXBCeSxcbiAgICAgICAgZ3JvdXBXaXRoOiBncm91cFdpdGgsXG4gICAgICAgIGd0OiBndCxcbiAgICAgICAgZ3RlOiBndGUsXG4gICAgICAgIGhhczogaGFzLFxuICAgICAgICBoYXNJbjogaGFzSW4sXG4gICAgICAgIGhlYWQ6IGhlYWQsXG4gICAgICAgIGlkZW50aWNhbDogaWRlbnRpY2FsLFxuICAgICAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgICAgIGlmRWxzZTogaWZFbHNlLFxuICAgICAgICBpbmM6IGluYyxcbiAgICAgICAgaW5kZXhCeTogaW5kZXhCeSxcbiAgICAgICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgaW5zZXJ0OiBpbnNlcnQsXG4gICAgICAgIGluc2VydEFsbDogaW5zZXJ0QWxsLFxuICAgICAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvbixcbiAgICAgICAgaW50ZXJzZWN0aW9uV2l0aDogaW50ZXJzZWN0aW9uV2l0aCxcbiAgICAgICAgaW50ZXJzcGVyc2U6IGludGVyc3BlcnNlLFxuICAgICAgICBpbnRvOiBpbnRvLFxuICAgICAgICBpbnZlcnQ6IGludmVydCxcbiAgICAgICAgaW52ZXJ0T2JqOiBpbnZlcnRPYmosXG4gICAgICAgIGludm9rZXI6IGludm9rZXIsXG4gICAgICAgIGlzOiBpcyxcbiAgICAgICAgaXNBcnJheUxpa2U6IGlzQXJyYXlMaWtlLFxuICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICBpc05pbDogaXNOaWwsXG4gICAgICAgIGpvaW46IGpvaW4sXG4gICAgICAgIGp1eHQ6IGp1eHQsXG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIGtleXNJbjoga2V5c0luLFxuICAgICAgICBsYXN0OiBsYXN0LFxuICAgICAgICBsYXN0SW5kZXhPZjogbGFzdEluZGV4T2YsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBsZW5zOiBsZW5zLFxuICAgICAgICBsZW5zSW5kZXg6IGxlbnNJbmRleCxcbiAgICAgICAgbGVuc1BhdGg6IGxlbnNQYXRoLFxuICAgICAgICBsZW5zUHJvcDogbGVuc1Byb3AsXG4gICAgICAgIGxpZnQ6IGxpZnQsXG4gICAgICAgIGxpZnROOiBsaWZ0TixcbiAgICAgICAgbHQ6IGx0LFxuICAgICAgICBsdGU6IGx0ZSxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIG1hcEFjY3VtOiBtYXBBY2N1bSxcbiAgICAgICAgbWFwQWNjdW1SaWdodDogbWFwQWNjdW1SaWdodCxcbiAgICAgICAgbWFwT2JqSW5kZXhlZDogbWFwT2JqSW5kZXhlZCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtYXRoTW9kOiBtYXRoTW9kLFxuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgbWF4Qnk6IG1heEJ5LFxuICAgICAgICBtZWFuOiBtZWFuLFxuICAgICAgICBtZWRpYW46IG1lZGlhbixcbiAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZSxcbiAgICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgICBtZXJnZUFsbDogbWVyZ2VBbGwsXG4gICAgICAgIG1lcmdlV2l0aDogbWVyZ2VXaXRoLFxuICAgICAgICBtZXJnZVdpdGhLZXk6IG1lcmdlV2l0aEtleSxcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1pbkJ5OiBtaW5CeSxcbiAgICAgICAgbW9kdWxvOiBtb2R1bG8sXG4gICAgICAgIG11bHRpcGx5OiBtdWx0aXBseSxcbiAgICAgICAgbkFyeTogbkFyeSxcbiAgICAgICAgbmVnYXRlOiBuZWdhdGUsXG4gICAgICAgIG5vbmU6IG5vbmUsXG4gICAgICAgIG5vdDogbm90LFxuICAgICAgICBudGg6IG50aCxcbiAgICAgICAgbnRoQXJnOiBudGhBcmcsXG4gICAgICAgIG9iak9mOiBvYmpPZixcbiAgICAgICAgb2Y6IG9mLFxuICAgICAgICBvbWl0OiBvbWl0LFxuICAgICAgICBvbmNlOiBvbmNlLFxuICAgICAgICBvcjogb3IsXG4gICAgICAgIG92ZXI6IG92ZXIsXG4gICAgICAgIHBhaXI6IHBhaXIsXG4gICAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICAgIHBhcnRpYWxSaWdodDogcGFydGlhbFJpZ2h0LFxuICAgICAgICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgcGF0aEVxOiBwYXRoRXEsXG4gICAgICAgIHBhdGhPcjogcGF0aE9yLFxuICAgICAgICBwYXRoU2F0aXNmaWVzOiBwYXRoU2F0aXNmaWVzLFxuICAgICAgICBwaWNrOiBwaWNrLFxuICAgICAgICBwaWNrQWxsOiBwaWNrQWxsLFxuICAgICAgICBwaWNrQnk6IHBpY2tCeSxcbiAgICAgICAgcGlwZTogcGlwZSxcbiAgICAgICAgcGlwZUs6IHBpcGVLLFxuICAgICAgICBwaXBlUDogcGlwZVAsXG4gICAgICAgIHBsdWNrOiBwbHVjayxcbiAgICAgICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgcHJvamVjdDogcHJvamVjdCxcbiAgICAgICAgcHJvcDogcHJvcCxcbiAgICAgICAgcHJvcEVxOiBwcm9wRXEsXG4gICAgICAgIHByb3BJczogcHJvcElzLFxuICAgICAgICBwcm9wT3I6IHByb3BPcixcbiAgICAgICAgcHJvcFNhdGlzZmllczogcHJvcFNhdGlzZmllcyxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgICByZWR1Y2VCeTogcmVkdWNlQnksXG4gICAgICAgIHJlZHVjZVJpZ2h0OiByZWR1Y2VSaWdodCxcbiAgICAgICAgcmVkdWNlZDogcmVkdWNlZCxcbiAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgICAgc2Nhbjogc2NhbixcbiAgICAgICAgc2VxdWVuY2U6IHNlcXVlbmNlLFxuICAgICAgICBzZXQ6IHNldCxcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBzb3J0OiBzb3J0LFxuICAgICAgICBzb3J0Qnk6IHNvcnRCeSxcbiAgICAgICAgc3BsaXQ6IHNwbGl0LFxuICAgICAgICBzcGxpdEF0OiBzcGxpdEF0LFxuICAgICAgICBzcGxpdEV2ZXJ5OiBzcGxpdEV2ZXJ5LFxuICAgICAgICBzcGxpdFdoZW46IHNwbGl0V2hlbixcbiAgICAgICAgc3VidHJhY3Q6IHN1YnRyYWN0LFxuICAgICAgICBzdW06IHN1bSxcbiAgICAgICAgc3ltbWV0cmljRGlmZmVyZW5jZTogc3ltbWV0cmljRGlmZmVyZW5jZSxcbiAgICAgICAgc3ltbWV0cmljRGlmZmVyZW5jZVdpdGg6IHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoLFxuICAgICAgICB0YWlsOiB0YWlsLFxuICAgICAgICB0YWtlOiB0YWtlLFxuICAgICAgICB0YWtlTGFzdDogdGFrZUxhc3QsXG4gICAgICAgIHRha2VMYXN0V2hpbGU6IHRha2VMYXN0V2hpbGUsXG4gICAgICAgIHRha2VXaGlsZTogdGFrZVdoaWxlLFxuICAgICAgICB0YXA6IHRhcCxcbiAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgdGltZXM6IHRpbWVzLFxuICAgICAgICB0b0xvd2VyOiB0b0xvd2VyLFxuICAgICAgICB0b1BhaXJzOiB0b1BhaXJzLFxuICAgICAgICB0b1BhaXJzSW46IHRvUGFpcnNJbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICB0b1VwcGVyOiB0b1VwcGVyLFxuICAgICAgICB0cmFuc2R1Y2U6IHRyYW5zZHVjZSxcbiAgICAgICAgdHJhbnNwb3NlOiB0cmFuc3Bvc2UsXG4gICAgICAgIHRyYXZlcnNlOiB0cmF2ZXJzZSxcbiAgICAgICAgdHJpbTogdHJpbSxcbiAgICAgICAgdHJ5Q2F0Y2g6IHRyeUNhdGNoLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB1bmFwcGx5OiB1bmFwcGx5LFxuICAgICAgICB1bmFyeTogdW5hcnksXG4gICAgICAgIHVuY3VycnlOOiB1bmN1cnJ5TixcbiAgICAgICAgdW5mb2xkOiB1bmZvbGQsXG4gICAgICAgIHVuaW9uOiB1bmlvbixcbiAgICAgICAgdW5pb25XaXRoOiB1bmlvbldpdGgsXG4gICAgICAgIHVuaXE6IHVuaXEsXG4gICAgICAgIHVuaXFCeTogdW5pcUJ5LFxuICAgICAgICB1bmlxV2l0aDogdW5pcVdpdGgsXG4gICAgICAgIHVubGVzczogdW5sZXNzLFxuICAgICAgICB1bm5lc3Q6IHVubmVzdCxcbiAgICAgICAgdW50aWw6IHVudGlsLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgdXNlV2l0aDogdXNlV2l0aCxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHZhbHVlc0luOiB2YWx1ZXNJbixcbiAgICAgICAgdmlldzogdmlldyxcbiAgICAgICAgd2hlbjogd2hlbixcbiAgICAgICAgd2hlcmU6IHdoZXJlLFxuICAgICAgICB3aGVyZUVxOiB3aGVyZUVxLFxuICAgICAgICB3aXRob3V0OiB3aXRob3V0LFxuICAgICAgICB3cmFwOiB3cmFwLFxuICAgICAgICB4cHJvZDogeHByb2QsXG4gICAgICAgIHppcDogemlwLFxuICAgICAgICB6aXBPYmo6IHppcE9iaixcbiAgICAgICAgemlwV2l0aDogemlwV2l0aFxuICAgIH07XG4gIC8qIGVzbGludC1lbnYgYW1kICovXG5cbiAgLyogVEVTVF9FTlRSWV9QT0lOVCAqL1xuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gUjsgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5SID0gUjtcbiAgfVxuXG59LmNhbGwodGhpcykpO1xuIl19
